<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How to write type annotations - Apalache Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorials/entry-tutorial.html"><strong aria-hidden="true">2.</strong> Entry-level Model Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">3.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/pluscal-tutorial.html"><strong aria-hidden="true">4.</strong> Checking Pluscal specifications</a></li><li class="chapter-item expanded "><a href="../tutorials/trail-tips.html"><strong aria-hidden="true">5.</strong> Apalache trail tips: how to check your specs faster</a></li><li class="chapter-item expanded "><a href="../tutorials/symbmc.html"><strong aria-hidden="true">6.</strong> Symbolic Model Checking</a></li><li class="chapter-item expanded "><a href="../tutorials/temporal-properties.html"><strong aria-hidden="true">7.</strong> Specifying temporal properties and understanding counterexamples</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="../HOWTOs/index.html"><strong aria-hidden="true">8.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../HOWTOs/howto-write-type-annotations.html" class="active"><strong aria-hidden="true">9.</strong> How to write type annotations</a></li><li class="chapter-item expanded "><a href="../HOWTOs/uninterpretedTypes.html"><strong aria-hidden="true">10.</strong> How to use uninterpreted types</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="../apalache/index.html"><strong aria-hidden="true">11.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/index.html"><strong aria-hidden="true">11.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/jvm.html"><strong aria-hidden="true">11.1.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="../apalache/installation/docker.html"><strong aria-hidden="true">11.1.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../apalache/installation/source.html"><strong aria-hidden="true">11.1.3.</strong> Build from Source</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/running.html"><strong aria-hidden="true">11.2.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="../apalache/example.html"><strong aria-hidden="true">11.3.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="../apalache/parameters.html"><strong aria-hidden="true">11.4.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="../apalache/principles/index.html"><strong aria-hidden="true">11.5.</strong> Symbolic Model Checking with Apalache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/principles/assignments.html"><strong aria-hidden="true">11.5.1.</strong> Assignments and symbolic transitions</a></li><li class="chapter-item expanded "><a href="../apalache/principles/folds.html"><strong aria-hidden="true">11.5.2.</strong> Folding sets and sequences</a></li><li class="chapter-item expanded "><a href="../apalache/principles/invariants.html"><strong aria-hidden="true">11.5.3.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="../apalache/principles/enumeration.html"><strong aria-hidden="true">11.5.4.</strong> Enumeration of counterexamples</a></li><li class="chapter-item expanded "><a href="../apalache/principles/apalache-mod.html"><strong aria-hidden="true">11.5.5.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="../apalache/principles/naturals.html"><strong aria-hidden="true">11.5.6.</strong> Naturals</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/config.html"><strong aria-hidden="true">11.6.</strong> Apalache global configuration file</a></li><li class="chapter-item expanded "><a href="../apalache/statistics.html"><strong aria-hidden="true">11.7.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="../apalache/profiling.html"><strong aria-hidden="true">11.8.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="../apalache/theory.html"><strong aria-hidden="true">11.9.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/tlc-config.html"><strong aria-hidden="true">12.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="../apalache/typechecker-snowcat.html"><strong aria-hidden="true">13.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="../apalache/features.html"><strong aria-hidden="true">14.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../apalache/principles/recursive.html"><strong aria-hidden="true">15.</strong> Obsolete: Recursive operators and functions</a></li><li class="chapter-item expanded "><a href="../apalache/known-issues.html"><strong aria-hidden="true">16.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="../apalache/antipatterns.html"><strong aria-hidden="true">17.</strong> Antipatterns</a></li><li class="chapter-item expanded "><a href="../apalache/preprocessing.html"><strong aria-hidden="true">18.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="../apalache/tuning.html"><strong aria-hidden="true">19.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="../apalache/assignments-in-depth.html"><strong aria-hidden="true">20.</strong> Assignments and Symbolic Transitions in Depth</a></li><li class="chapter-item expanded "><a href="../apalache/kera.html"><strong aria-hidden="true">21.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="../lang/index.html"><strong aria-hidden="true">22.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../lang/standard-operators.html"><strong aria-hidden="true">23.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/booleans.html"><strong aria-hidden="true">23.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../lang/control-and-nondeterminism.html"><strong aria-hidden="true">23.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="../lang/conditionals.html"><strong aria-hidden="true">23.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../lang/integers.html"><strong aria-hidden="true">23.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../lang/sets.html"><strong aria-hidden="true">23.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="../lang/logic.html"><strong aria-hidden="true">23.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="../lang/functions.html"><strong aria-hidden="true">23.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../lang/records.html"><strong aria-hidden="true">23.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="../lang/tuples.html"><strong aria-hidden="true">23.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../lang/sequences.html"><strong aria-hidden="true">23.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="../lang/apalache-extensions.html"><strong aria-hidden="true">24.</strong> Apalache extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/apalache-operators.html"><strong aria-hidden="true">24.1.</strong> Apalache module</a></li><li class="chapter-item expanded "><a href="../lang/variants.html"><strong aria-hidden="true">24.2.</strong> Variants</a></li><li class="chapter-item expanded "><a href="../lang/option-types.html"><strong aria-hidden="true">24.3.</strong> Option types</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/user-operators.html"><strong aria-hidden="true">25.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/user/top-level-operators.html"><strong aria-hidden="true">25.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/let-in.html"><strong aria-hidden="true">25.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/higher-order-operators.html"><strong aria-hidden="true">25.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/lambdas.html"><strong aria-hidden="true">25.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/local-operators.html"><strong aria-hidden="true">25.5.</strong> Local operator definitions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="../idiomatic/index.html"><strong aria-hidden="true">27.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">28.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="../idiomatic/001assignments.html"><strong aria-hidden="true">29.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="../idiomatic/002primes.html"><strong aria-hidden="true">30.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded "><a href="../idiomatic/007if-then-else.html"><strong aria-hidden="true">31.</strong> Use Boolean operators in actions, not IF-THEN-ELSE</a></li><li class="chapter-item expanded "><a href="../idiomatic/003record-sets.html"><strong aria-hidden="true">32.</strong> Avoid sets of mixed records</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="../adr/001rfc-types.html"><strong aria-hidden="true">33.</strong> RFC 001: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/002adr-types.html"><strong aria-hidden="true">34.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/003adr-trex.html"><strong aria-hidden="true">35.</strong> ADR-003: transition executor (TRex)</a></li><li class="chapter-item expanded "><a href="../adr/004adr-annotations.html"><strong aria-hidden="true">36.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="../adr/005adr-json.html"><strong aria-hidden="true">37.</strong> ADR-005: JSON Serialization Format</a></li><li class="chapter-item expanded "><a href="../adr/006rfc-unit-testing.html"><strong aria-hidden="true">38.</strong> RFC-006: unit tests and property-based tests</a></li><li class="chapter-item expanded "><a href="../adr/007adr-restructuring.html"><strong aria-hidden="true">39.</strong> ADR-007: restructuring</a></li><li class="chapter-item expanded "><a href="../adr/008adr-exceptions.html"><strong aria-hidden="true">40.</strong> ADR-008: exceptions</a></li><li class="chapter-item expanded "><a href="../adr/009adr-outputs.html"><strong aria-hidden="true">41.</strong> ADR-009: outputs</a></li><li class="chapter-item expanded "><a href="../adr/010rfc-transition-explorer.html"><strong aria-hidden="true">42.</strong> RFC-010: Implementation of Transition Exploration Server</a></li><li class="chapter-item expanded "><a href="../adr/011adr-smt-arrays.html"><strong aria-hidden="true">43.</strong> ADR-011: alternative SMT encoding using arrays</a></li><li class="chapter-item expanded "><a href="../adr/012adr-adopt-adr-template.html"><strong aria-hidden="true">44.</strong> ADR-012: Adopt an ADR Template</a></li><li class="chapter-item expanded "><a href="../adr/013adr-configuration.html"><strong aria-hidden="true">45.</strong> ADR-013: Configuration Management Component</a></li><li class="chapter-item expanded "><a href="../adr/014adr-precise-records.html"><strong aria-hidden="true">46.</strong> ADR-014: Precise type inference for records and variants</a></li><li class="chapter-item expanded "><a href="../adr/015adr-trace.html"><strong aria-hidden="true">47.</strong> ADR-015: ITF: informal trace format</a></li><li class="chapter-item expanded "><a href="../adr/016adr-retla.html"><strong aria-hidden="true">48.</strong> ADR-016: ReTLA: Relational TLA</a></li><li class="chapter-item expanded "><a href="../adr/017pdr-temporal.html"><strong aria-hidden="true">49.</strong> PDR-017: Checking temporal properties</a></li><li class="chapter-item expanded "><a href="../adr/018adr-inlining.html"><strong aria-hidden="true">50.</strong> ADR-018: Inlining in Apalache</a></li><li class="chapter-item expanded "><a href="../adr/019adr-harmonize-changelog.html"><strong aria-hidden="true">51.</strong> ADR-019: Harmonize changelog management</a></li><li class="chapter-item expanded "><a href="../adr/020adr-arenas.html"><strong aria-hidden="true">52.</strong> ADR-020: Improving membership in arenas</a></li><li class="chapter-item expanded "><a href="../adr/021rfc-prioritization.html"><strong aria-hidden="true">53.</strong> RFC-021: Prioritization of Work</a></li><li class="chapter-item expanded "><a href="../adr/022adr-unification-of-configs-and-options.html"><strong aria-hidden="true">54.</strong> ADR-022: Unify Configuration Management and &quot;Pass Options&quot;</a></li><li class="chapter-item expanded "><a href="../adr/023adr-trace-evaluation.html"><strong aria-hidden="true">55.</strong> ADR-023: Trace evaluation</a></li><li class="chapter-item expanded "><a href="../adr/024adr-arena-pass.html"><strong aria-hidden="true">56.</strong> ADR-024: Arena computation isolation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#how-to-write-type-annotations" id="how-to-write-type-annotations">How to write type annotations</a></h1>
<p><strong>Revision:</strong> August 24, 2022</p>
<p><strong>Important updates:</strong></p>
<ul>
<li>
<p>Version 0.29.0: The new syntax for records and variants is enabled by
default (previously, enabled with <code>--features=rows</code>). For the transition
period, the old type syntax can be activated with <code>--features=no-rows</code>.
See <a href="#recipe9">Recipe 9</a> on transitioning to Type System 1.2.</p>
</li>
<li>
<p>Version 0.25.10: This HOWTO introduces new syntax for type aliases. See
<a href="../adr/002adr-types.html#defTypeAlias">Type Aliases</a> in ADR-002.</p>
</li>
<li>
<p>Version 0.25.9: This HOWTO introduces new syntax for record types and
variants, which is currently under testing. This syntax is activated via the
option <code>--features=rows</code>. See <a href="../adr/002adr-types.html#ts12">Type System 1.2</a>
in ADR-002.</p>
</li>
<li>
<p>Version 0.23.1: The example specification uses recursive operators, which
were removed in version 0.23.1.</p>
</li>
<li>
<p>Version 0.15.0: This HOWTO discusses how to write type annotations for the type checker
<a href="../apalache/typechecker-snowcat.html">Snowcat</a>, which is used in Apalache since version 0.15.0 (introduced in 2021).</p>
</li>
</ul>
<p>This HOWTO gives you concrete steps to extend TLA+ specifications with type
annotations. You can find the detailed syntax of type annotations in
<a href="../adr/002adr-types.html">ADR002</a>. The first rule of writing type annotations:</p>
<p><em>Do not write any annotations at all, until the type checker <a href="../apalache/typechecker-snowcat.html">Snowcat</a> is
asking you to write a type annotation.</em></p>
<p>Of course, there must be an exception to this rule. You have to write type
annotations for CONSTANTS and VARIABLES. This is because Snowcat infers types
of declarations in isolation instead of analyzing the whole specification.
The good news is that the type checker finds the types of many operators
automatically. </p>
<h2><a class="header" href="#recipe-1-annotating-variables" id="recipe-1-annotating-variables">Recipe 1: Annotating variables</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla">HourClock.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">---------------------- MODULE HourClock ----------------------
\* This is a local copy of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla
EXTENDS Naturals
VARIABLE
    \* @type: Int;
    hr

HCini  ==  hr \in (1 .. 12)
HCnxt  ==  hr' = IF hr # 12 THEN hr + 1 ELSE 1
HC  ==  HCini /\ [][HCnxt]_hr

TypeOK == hr \in (1 .. 12)
--------------------------------------------------------------
THEOREM  HC =&gt; []HCini
==============================================================
</code></pre>
<p>Without thinking much about the types, run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck HourClock.tla
</code></pre>
<p>The type checker complains about not knowing the type of the variable <code>hr</code>:</p>
<pre><code>...
Typing input error: Expected a type annotation for VARIABLE hr
...
</code></pre>
<p>Annotate the type of variable <code>hr</code> as below. Note carefully that the type
annotation should be <em>between</em> the keyword <code>VARIABLE</code> and the variable name.
This is because variable declarations may declare several variables at once.
In this case, you have to write one type annotation per name.</p>
<pre><code class="language-tla">VARIABLE
  \* @type: Int;
  hr
</code></pre>
<p>Run the type checker again. You should see the following message:</p>
<pre><code>...
 &gt; Running Snowcat .::.
 &gt; Your types are purrfect!
 &gt; All expressions are typed
...
</code></pre>
<p><a id="recipe2"></a></p>
<h2><a class="header" href="#recipe-2-annotating-constants" id="recipe-2-annotating-constants">Recipe 2: Annotating constants</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla">Channel.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">
-------------------------- MODULE Channel -----------------------------
\* This is a typed version of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla
EXTENDS Naturals
CONSTANT Data
VARIABLE chan 

TypeInvariant  ==  chan \in [val : Data,  rdy : {0, 1},  ack : {0, 1}]
-----------------------------------------------------------------------
Init  ==  /\ TypeInvariant
          /\ chan.ack = chan.rdy 

Send(d) ==  /\ chan.rdy = chan.ack
            /\ chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]

Rcv     ==  /\ chan.rdy # chan.ack
            /\ chan' = [chan EXCEPT !.ack = 1 - @]

Next  ==  (\E d \in Data : Send(d)) \/ Rcv

Spec  ==  Init /\ [][Next]_chan
-----------------------------------------------------------------------
THEOREM Spec =&gt; []TypeInvariant
=======================================================================

</code></pre>
<p>Run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck Channel.tla
</code></pre>
<p>The type checker does not know the type of the variable <code>chan</code>:</p>
<pre><code>Typing input error: Expected a type annotation for VARIABLE chan
</code></pre>
<p>According to <code>TypeInvariant</code>, the variable <code>chan</code> is a record that has three
fields: <code>val</code>, <code>rdy</code>, and <code>ack</code>. The field <code>val</code> ranges over a set <code>Data</code>,
which is actually defined as <code>CONSTANT</code>. In principle, we can annotate the
constant <code>Data</code> with a set of any type, e.g., <code>Set(Int)</code> or <code>Set(BOOLEAN)</code>.
Since the specification is not using any operators over <code>Data</code> except equality,
we can use an <em>uninterpreted type</em> as a type for set elements, e.g.,
we can define <code>Data</code> to have the type <code>Set(DATUM)</code>. Uninterpreted types are
always written in CAPITALS. Now we can annotate <code>Data</code> and <code>chan</code> as follows:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(DATUM);
    Data
VARIABLE
    \* @type: { val: DATUM, rdy: Int, ack: Int };
    chan 
</code></pre>
<p>Note carefully that the type annotation should be <em>between</em> the keyword
<code>CONSTANT</code> and the constant name. This is because constant declarations may
declare several constants at once. In this case, you have to write one type
annotation per name.</p>
<p>Have a look at the type of <code>chan</code>:</p>
<pre><code>\* @type: { val: DATUM, rdy: Int, ack: Int };
</code></pre>
<p>The type of <code>chan</code> is a record that has three fields: field <code>val</code> of type
<code>DATUM</code>, field <code>rdy</code> of type <code>Int</code>, field <code>ack</code> of type <code>Int</code>.
The record type syntax is similar to dictionary syntax from programming languages (e.g. Python).
We made it different from TLA+'s syntax for records <code>[ val |-&gt; v, rdy |-&gt; r, ack |-&gt; a ]</code>
and record sets <code>[ val: V, rdy: R, ack: A ]</code>, to avoid confusion between types and values.</p>
<p>Run the type checker again. You should see the following message:</p>
<pre><code>$ apalache-mc typecheck ChannelTyped.tla
...
&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed 
</code></pre>
<h2><a class="header" href="#recipe-3-annotating-operators" id="recipe-3-annotating-operators">Recipe 3: Annotating operators</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CarTalkPuzzle/CarTalkPuzzle.tla">CarTalkPuzzle.tla</a> from the repository of TLA+
examples. This example has 160 lines of code, so we do not inline it here.
By running the type checker as in previous sections, you should figure out
that the constants <code>N</code> and <code>P</code> should be annotated with the type <code>Int</code>.
Annotate <code>N</code> and <code>P</code> with <code>Int</code> and run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck CarTalkPuzzle.tla
</code></pre>
<p>Now you should see the following error:</p>
<pre><code>[CarTalkPuzzle.tla:52:32-52:35]: Cannot apply f to the argument x() in f[x()].
[CarTalkPuzzle.tla:50:1-52:53]: Error when computing the type of Sum
</code></pre>
<p>Although the error message may look confusing, the reason is simple: The type
checker cannot figure out whether the operator <code>Sum</code> expects a sequence
or a function of integers as its first parameter. By looking carefully at
the definition of <code>Sum</code>, we can see that it expects: (1) a function from
integers to integers as its first parameter, (2) a set of integers
as its second parameter, and (3) an integer as a result. Hence, we annotate
<code>Sum</code> as follows:</p>
<pre><code class="language-tla">RECURSIVE Sum(_,_)
\* type: (Int -&gt; Int, Set(Int)) =&gt; Int;
Sum(f,S) ==
    ...
</code></pre>
<p>Note that the annotation has to be written between <code>RECURSIVE Sum(_, _)</code> and
the definition of <code>Sum</code>. This might change later, see <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> at tlaplus.</p>
<p>After providing the type checker with the annotation for <code>Sum</code>, we get one
more type error:</p>
<pre><code>[CarTalkPuzzle.tla:160:23-160:26]: Cannot apply B to the argument x in B[x].
[CarTalkPuzzle.tla:160:7-160:37]: Error when computing the type of Image
</code></pre>
<p>This time the type checker cannot choose between two options for the second
parameter of <code>Image</code>: It could be a function, or a sequence. We help the
type checker by writing that the second parameter should be a function
of integers to integers, that is, <code>Int -&gt; Int</code>:</p>
<pre><code class="language-tla">      \* @type: (Set(Int), Int -&gt; Int) =&gt; Set(Int);
      Image(S, B) == {B[x] : x \in S}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code>...
&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed 
...
</code></pre>
<p><a id="recipe4"></a></p>
<h2><a class="header" href="#recipe-4-using-variants-in-heterogenous-sets" id="recipe-4-using-variants-in-heterogenous-sets">Recipe 4: Using variants in heterogenous sets</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> from the repository of TLA+ examples (you
will also need <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TCommit.tla">TCommit.tla</a>, which is imported by TwoPhase.tla). This
example has 176 lines of code, so we do not inline it here.</p>
<p>As you probably expected, the type checker complains about not knowing
the types of constants and variables. As for constant <code>RM</code>, we opt for using
an uninterpreted type that we call <code>RM</code>. That is:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(RM);
    RM \* The set of resource managers
</code></pre>
<p>By looking at the spec, it is easy to guess the types of the variables
<code>rmState</code>, <code>tmState</code>, and <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: RM -&gt; Str;
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
  \* @type: Str;
  tmState,       \* The state of the transaction manager.
  \* @type: Set(RM);
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<p>The type of the variable <code>msgs</code> is less obvious. We can check the original
(untyped) definitions of <code>TPTypeOK</code> and <code>Message</code> to get an idea about the
type of <code>msgs</code>:</p>
<pre><code class="language-tla">Message ==
  ({[type |-&gt; t, rm |-&gt; r]: t \in {&quot;Prepared&quot;}, r \in RM }
   \union
   {[type |-&gt; t] : t \in {&quot;Commit&quot;, &quot;Abort&quot;}})

TPTypeOK ==
  ...
  /\ msgs \in SUBSET Message
</code></pre>
<p>From these (untyped) definitions, you can see that <code>msgs</code> is a set that
contains records of two types: <code>{ type: Str }</code> and <code>{ type: Str, rm: RM }</code>.
This seems to be problematic, as we have to mix in two records types in a
single set, which requires us to specify its only type.</p>
<p>To this end, we have to use the <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Variants.tla">Variants module</a>, which is distributed with
Apalache. For reference, check the <a href="../lang/variants.html">Chapter on variants</a>. First, we declare a
type alias for the type of messages in a separate file called
<code>TwoPhaseTyped_typedefs.tla</code>:</p>
<pre><code class="language-tla">----------------------- MODULE TwoPhaseTyped_typedefs ----------------
(*
 @typeAlias: message = Commit(NIL) | Abort(NIL) | Prepared(RM);
 *)
TwoPhaseTyped_aliases == TRUE

======================================================================
</code></pre>
<p>Usually, we place type aliases in a separate file for when we have
to use the same type alias in different specifications, e.g., the specification
and its instance for model checking.</p>
<p>With the type alias <code>MESSAGE</code>, we specify that a message is a variant type,
that is, it can represent three kinds of different values:</p>
<ul>
<li>
<p>A value tagged with <code>Commit</code>. Since we do not require the variant to carry
any value here, we simply declare that the value has the uninterpreted type
<code>NIL</code>. This is simply a convention, we could use any type in this case.</p>
</li>
<li>
<p>A value tagged with <code>Abort</code>. Similar to <code>Commit</code>, we are using the <code>NIL</code>
type.</p>
</li>
<li>
<p>A value tagged with <code>Prepared</code>. In this case, the value is of importance.
We are using the value <code>RM</code>, that is, the (uninterpreted) type of a resource
manager.</p>
</li>
</ul>
<p>Once we have specified the variant type, we introduce three constructors,
one per variant option:</p>
<pre><code class="language-tla">\* @type: $message;
MkCommit == Variant(&quot;Commit&quot;, &quot;0_OF_NIL&quot;)

\* @type: $message;
MkAbort == Variant(&quot;Abort&quot;, &quot;0_OF_NIL&quot;)

\* @type: RM =&gt; $message;
MkPrepared(rm) == Variant(&quot;Prepared&quot;, rm)
</code></pre>
<p>Since the values carried by the <code>Commit</code> and <code>Abort</code> messages are not
important, we use the uninterpeted value <code>&quot;0_OF_NIL&quot;</code>. This is merely a
convention. We could use any value of type <code>NIL</code>. Importantly, the operators
<code>MkAbort</code>, <code>MkCommit</code>, and <code>MkPrepared</code> all produce values of type <code>MESSAGE</code>,
which makes it possible to add them to a single set of messages.</p>
<p>Now it should be clear how to specify the type of the variable <code>msgs</code>:</p>
<pre><code class="language-tla">  \* @type: Set($message);
  msgs
</code></pre>
<p>We run the type checker once again:</p>
<pre><code class="language-sh">$ apalache-mc typecheck TwoPhaseTyped.tla
...
 &gt; All expressions are typed
Type checker [OK]
</code></pre>
<p>As you can see, variants require quite a bit of boilerplate. If you can simply
introduce a set of records of the same type, this is usually a simpler
solution. For instance, we could partition <code>msgs</code> into three subsets: the
subset of <code>Commit</code> messages, the subset of <code>Abort</code> messages, and the subset of
<code>Prepared</code> messages. See the discussion in <a href="../idiomatic/003record-sets.html">Idiom 15</a>.</p>
<p><a id="funAsSeq"></a></p>
<h2><a class="header" href="#recipe-5-functions-as-sequences" id="recipe-5-functions-as-sequences">Recipe 5: functions as sequences</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/N-Queens/Queens.tla">Queens.tla</a> from the repository of TLA+ examples.  It has
85 lines of code, so we do not include it here. Similar to the previous
sections, we annotate constants and variables:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Int;
    N              \** number of queens and size of the board
...
VARIABLES
    \* @type: Set(Seq(Int));
    todo,
    \* @type: Set(Seq(Int));
    sols
</code></pre>
<p>After having inspected the type errors reported by Snowcat, we annotate the
operators <code>Attacks</code>, <code>IsSolution</code>, and <code>vars</code> as follows:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j) ==
  ...

\* @type: Seq(Int) =&gt; Bool;
IsSolution(queens) ==
  ...

\* @type: &lt;&lt;Set(Seq(Int)), Set(Seq(Int))&gt;&gt;;
vars == &lt;&lt;todo,sols&gt;&gt;
</code></pre>
<p>Now we run the type checker and receive the following type error:</p>
<pre><code>[Queens.tla:35:44-35:61]: The operator IsSolution of type ((Seq(Int)) =&gt; Bool) is applied to arguments of incompatible types in IsSolution(queens):
Argument queens should have type Seq(Int) but has type (Int -&gt; Int). E@11:07:53.285
[Queens.tla:35:1-35:63]: Error when computing the type of Solutions
</code></pre>
<p>Let's have a closer look at the problematic operator definition of <code>Solutions</code>:</p>
<pre><code class="language-tla">Solutions ==
    { queens \in [1..N -&gt; 1..N]: IsSolution(queens) }
</code></pre>
<p>This looks interesting: <code>IsSolution</code> expects a sequence, whereas
<code>Solutions</code> produces a set of functions. This is obviously not a
problem in untyped TLA+. In fact, it is a well-known idiom: Construct a
function by using the function set operator, and then apply sequence operators to it.
In Apalache we have to explicitly write that a function should be reinterpreted
as a sequence.  To this end, we have to use the operator <code>FunAsSeq</code> from the
module <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Apalache.tla">Apalache.tla</a>. Hence, we add <code>Apalache</code> to the <code>EXTENDS</code> clause and
apply the operator <code>FunAsSeq</code> as follows:</p>
<pre><code class="language-tla">EXTENDS Naturals, Sequences, Apalache
...
Solutions ==
  LET Queens == { FunAsSeq(queens, N, N): queens \in  [1..N -&gt; 1..N] } IN
  {queens \in Queens : IsSolution(queens)}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code>&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed
</code></pre>
<p><a id="typeAliases"></a></p>
<h2><a class="header" href="#recipe-6-type-aliases" id="recipe-6-type-aliases">Recipe 6: type aliases</a></h2>
<p>Type aliases can be used to provide a concise label for complex types, or to
clarify the intended meaning of a simple types in the given context. </p>
<p>Type aliases are declared with the <code>@typeAlias</code> annotation, as follows:</p>
<pre><code class="language-tla">\* @typeAlias: aliasNameInCamelCase = &lt;type&gt;;
</code></pre>
<p>For example, suppose we have annotated some constants as follows:</p>
<pre><code class="language-tla">CONSTANTS
    \* @type: Set(PERSON);
    Missionaries,
    \* @type: Set(PERSON);
    Cannibals 
</code></pre>
<p>If we continue annotating other declarations in the specification, we will see
that the type <code>Set(PERSON)</code> is used frequently. Type aliases let us provide a 
shortcut.</p>
<p>By convention, we introduce all type aliases by annotating an operator called
<code>&lt;PREFIX&gt;_typedefs</code>, where the <code>&lt;PREFIX&gt;</code> is replaced with a unique prefix to
prevent name clashes across different modules. Typically <code>&lt;PREFIX&gt;</code> is just the
module name. For the <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/MissionariesAndCannibalsTyped.tla">MissionariesAndCannibalsTyped.tla</a> example, we have:</p>
<pre><code class="language-tla">\* @typeAlias: persons = Set(PERSON);
MissionariesAndCannibals_typedefs = TRUE
</code></pre>
<p>Having defined the type alias, we can use it in other definitions anywhere else 
in the file:</p>
<pre><code class="language-tla">CONSTANTS
    \* @type: $persons;
    Missionaries,
    \* @type: $persons;
    Cannibals 

VARIABLES
    \* @type: Str;
    bank_of_boat,
    \* @type: Str -&gt; $persons;
    who_is_on_bank 
</code></pre>
<p>Surely, we did not gain much by writing <code>$persons</code> instead of <code>Set(PERSON)</code>.
But if your specification has complex types (e.g., records), aliases may help
you in minimizing the burden of specification maintenance. If you add one
more field to the record type, it suffices to change the definition of the type
alias, instead of changing the record type everywhere.</p>
<p>For more details on the design and usage, see <a href="../adr/002adr-types.html#defTypeAlias">Type Aliases</a> in ADR-002.</p>
<h2><a class="header" href="#recipe-7-multi-line-annotations" id="recipe-7-multi-line-annotations">Recipe 7: Multi-line annotations</a></h2>
<p>A type annotation may span over multiple lines. You may use both the <code>(* ... *)</code>
syntax as well as the single-line syntax <code>\* ...</code>.
All three examples below are accepted by the parser:</p>
<pre><code class="language-tla">VARIABLES
   (*
    @type: Int
            =&gt; Bool;
    *)           
    f,
    \* @type:
    \*       Int
    \*          =&gt; Bool;
    g,
    \* @type(&quot;Int
    \*          =&gt; Bool
    \*       &quot;)
    h
</code></pre>
<p>Note that the parser removes the leading strings <code>&quot;    \*&quot;</code> from the annotations,
similar to how multi-line strings are treated in modern programming languages.</p>
<h2><a class="header" href="#recipe-8-comments-in-annotations" id="recipe-8-comments-in-annotations">Recipe 8: Comments in annotations</a></h2>
<p>Sometimes, it helps to document the meaning of type components.
Consider the following example from <a href="#funAsSeq">Recipe 5</a>:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j)
</code></pre>
<p>If you think that an explanation of the arguments would help, you can do that as follows:</p>
<pre><code class="language-tla">(*
  @type:
    (
      // the column of an n-th queen, for n in the sequence domain
      Seq(Int),
      // the index (line number) of the first queen
      Int,
      // the index (line number) of the second queen
      Int
    ) =&gt; Bool;
*)
Attacks(queens,i,j)
</code></pre>
<p>You don't have to do that, but if you feel that types can also help you in documenting
your specification, you have this option.</p>
<p><a id="recipe9"></a></p>
<h2><a class="header" href="#recipe-9-migrate-from-type-system-1-to-type-system-12" id="recipe-9-migrate-from-type-system-1-to-type-system-12">Recipe 9: Migrate from Type System 1 to Type System 1.2</a></h2>
<p>As explained in <a href="../adr/002adr-types.html">ADR002</a>, <a href="../adr/002adr-types.html#ts12">Type System 1.2</a> (TS1.2) differs from <a href="../adr/002adr-types.html#ts1">Type
System 1</a> (TS1) as follows:</p>
<ul>
<li>
<p>TS1 allows one to mix records of varying domains, as long as the records
agree on the types of the common fields. Hence, record access is not
enforced by the type checker and thus is error-prone.</p>
</li>
<li>
<p>TS1 is using the syntax <code>[ field_n: T_1, ..., field_n: T_n ]</code>, which is
sometimes confused with the TLA+ expression <code>[ field_n: e_1, ..., field_n: e_n ]</code>.</p>
</li>
<li>
<p>TS1.2 is using the syntax <code>{ field_n: T_1, ..., field_n: T_n }</code>
for record types and the syntax <code>Tag_1(T_1) | ... | Tag_n(T_n)</code>
for variant types.</p>
</li>
<li>
<p>TS1.2 differentiates between records of different domains and does not allow
the specification writer to mix them. As a result, TS1.2 can catch incorrect
record access. Instead of mixing records, TS1.2 allows one to mix
<a href="../lang/variants.html">Variants</a>.</p>
</li>
<li>
<p>TS1.2 supports <a href="https://en.wikipedia.org/wiki/Row_polymorphism">Row polymorphism</a> and thus lets the user write type
annotations over records and variants, whose shape is only
partially-defined.  For example, <code>{ foo: Int, bar: Bool, a }</code> defines a
record type that has at least two fields (that is, <code>foo</code> of type <code>Int</code> and
<code>bar</code> of type <code>Bool</code>), but may have more fields, which are captured with the
row variable <code>a</code>.</p>
</li>
</ul>
<h3><a class="header" href="#case-1-plain-records" id="case-1-plain-records">Case 1: plain records</a></h3>
<p>Many specifications are using plain records. For instance, they do not assign
records of different domains to the same variable. Nor do they mix records of
different domains in the same set. Plenty of specifications fall into this
class.</p>
<p>For example, check <a href="#recipe2">Recipe 2</a>. In this recipe, the variable <code>chan</code> is
always carrying a record with the domain <code>{ &quot;val&quot;, &quot;rdy&quot;, &quot;ack&quot; }</code>.</p>
<p>In this case, all you have to do is to replace the old record types of the form
<code>[ field_n: T_1, ..., field_n: T_n ]</code> with the new record types of the form <code>{ field_n: T_1, ..., field_n: T_n }</code>. That is, replace <code>[</code> and <code>]</code> with <code>{</code> and
<code>}</code>, respectively.</p>
<h3><a class="header" href="#case-2-mixed-records" id="case-2-mixed-records">Case 2: mixed records</a></h3>
<p>Some specifications are using mixed records, which are similar to unions in C.</p>
<p>For example, check <a href="#recipe4">Recipe 4</a>. In this recipe, the variable
<code>tmPrepared</code> is a set that contains records of different domains. For instance,
<code>tmPrepared</code> may be equal to:</p>
<pre><code class="language-tla">{ [ type |-&gt; &quot;Commit&quot; ], [ type |-&gt; &quot;Prepared&quot;, rm |-&gt; &quot;0_OF_RM&quot; ] }
</code></pre>
<p>In this case, you have two choices:</p>
<ul>
<li>
<p>Partition the single variable into multiple variables, see <a href="../idiomatic/003record-sets.html">Idiom 15</a>.</p>
</li>
<li>
<p>Introduce variant types, see <a href="#recipe4">Recipe 4</a>.</p>
</li>
</ul>
<h2><a class="header" href="#known-issues" id="known-issues">Known issues</a></h2>
<h3><a class="header" href="#annotations-of-local-operators" id="annotations-of-local-operators">Annotations of LOCAL operators</a></h3>
<p>In contrast to all other cases, a local operator definition does require
a type annotation before the keyword <code>LOCAL</code>, not after it. For example:</p>
<pre><code class="language-tla">\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1
</code></pre>
<p>This may change later when the tlaplus <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> is resolved.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../HOWTOs/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../HOWTOs/uninterpretedTypes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../HOWTOs/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../HOWTOs/uninterpretedTypes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".././highlightjs-tlaplus/dist/tlaplus.min.js"></script>
        
        <script type="text/javascript" src=".././theme/highlightTla.js"></script>
        

        

    </body>
</html>
