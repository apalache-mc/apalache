<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ADR-018: Inlining in Apalache - Apalache Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorials/entry-tutorial.html"><strong aria-hidden="true">2.</strong> Entry-level Model Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">3.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/pluscal-tutorial.html"><strong aria-hidden="true">4.</strong> Checking Pluscal specifications</a></li><li class="chapter-item expanded "><a href="../tutorials/trail-tips.html"><strong aria-hidden="true">5.</strong> Apalache trail tips: how to check your specs faster</a></li><li class="chapter-item expanded "><a href="../tutorials/symbmc.html"><strong aria-hidden="true">6.</strong> Symbolic Model Checking</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="../apalache/index.html"><strong aria-hidden="true">7.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/index.html"><strong aria-hidden="true">7.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/jvm.html"><strong aria-hidden="true">7.1.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="../apalache/installation/docker.html"><strong aria-hidden="true">7.1.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../apalache/installation/source.html"><strong aria-hidden="true">7.1.3.</strong> Build from Source</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/running.html"><strong aria-hidden="true">7.2.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="../apalache/example.html"><strong aria-hidden="true">7.3.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="../apalache/parameters.html"><strong aria-hidden="true">7.4.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="../apalache/principles/index.html"><strong aria-hidden="true">7.5.</strong> Symbolic Model Checking with Apalache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/principles/assignments.html"><strong aria-hidden="true">7.5.1.</strong> Assignments and symbolic transitions</a></li><li class="chapter-item expanded "><a href="../apalache/principles/folds.html"><strong aria-hidden="true">7.5.2.</strong> Folding sets and sequences</a></li><li class="chapter-item expanded "><a href="../apalache/principles/invariants.html"><strong aria-hidden="true">7.5.3.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="../apalache/principles/enumeration.html"><strong aria-hidden="true">7.5.4.</strong> Enumeration of counterexamples</a></li><li class="chapter-item expanded "><a href="../apalache/principles/apalache-mod.html"><strong aria-hidden="true">7.5.5.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="../apalache/principles/naturals.html"><strong aria-hidden="true">7.5.6.</strong> Naturals</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/config.html"><strong aria-hidden="true">7.6.</strong> Apalache global configuration file</a></li><li class="chapter-item expanded "><a href="../apalache/statistics.html"><strong aria-hidden="true">7.7.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="../apalache/profiling.html"><strong aria-hidden="true">7.8.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="../apalache/theory.html"><strong aria-hidden="true">7.9.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/tlc-config.html"><strong aria-hidden="true">8.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="../apalache/typechecker-snowcat.html"><strong aria-hidden="true">9.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="../apalache/features.html"><strong aria-hidden="true">10.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../apalache/principles/recursive.html"><strong aria-hidden="true">11.</strong> Obsolete: Recursive operators and functions</a></li><li class="chapter-item expanded "><a href="../apalache/known-issues.html"><strong aria-hidden="true">12.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="../apalache/antipatterns.html"><strong aria-hidden="true">13.</strong> Antipatterns</a></li><li class="chapter-item expanded "><a href="../apalache/preprocessing.html"><strong aria-hidden="true">14.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="../apalache/tuning.html"><strong aria-hidden="true">15.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="../apalache/assignments-in-depth.html"><strong aria-hidden="true">16.</strong> Assignments and Symbolic Transitions in Depth</a></li><li class="chapter-item expanded "><a href="../apalache/kera.html"><strong aria-hidden="true">17.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="../HOWTOs/index.html"><strong aria-hidden="true">18.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">19.</strong> How to write type annotations</a></li><li class="chapter-item expanded "><a href="../HOWTOs/uninterpretedTypes.html"><strong aria-hidden="true">20.</strong> How to use uninterpreted types</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="../lang/index.html"><strong aria-hidden="true">21.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../lang/standard-operators.html"><strong aria-hidden="true">22.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/booleans.html"><strong aria-hidden="true">22.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../lang/control-and-nondeterminism.html"><strong aria-hidden="true">22.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="../lang/conditionals.html"><strong aria-hidden="true">22.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../lang/integers.html"><strong aria-hidden="true">22.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../lang/sets.html"><strong aria-hidden="true">22.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="../lang/logic.html"><strong aria-hidden="true">22.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="../lang/functions.html"><strong aria-hidden="true">22.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../lang/records.html"><strong aria-hidden="true">22.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="../lang/tuples.html"><strong aria-hidden="true">22.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../lang/sequences.html"><strong aria-hidden="true">22.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="../lang/user-operators.html"><strong aria-hidden="true">23.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/user/top-level-operators.html"><strong aria-hidden="true">23.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/let-in.html"><strong aria-hidden="true">23.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/higher-order-operators.html"><strong aria-hidden="true">23.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/lambdas.html"><strong aria-hidden="true">23.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/local-operators.html"><strong aria-hidden="true">23.5.</strong> Local operator definitions</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/apalache-operators.html"><strong aria-hidden="true">24.</strong> Apalache operators</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="../idiomatic/index.html"><strong aria-hidden="true">26.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">27.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="../idiomatic/001assignments.html"><strong aria-hidden="true">28.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="../idiomatic/002primes.html"><strong aria-hidden="true">29.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded "><a href="../idiomatic/007if-then-else.html"><strong aria-hidden="true">30.</strong> Use Boolean operators in actions, not IF-THEN-ELSE</a></li><li class="chapter-item expanded "><a href="../idiomatic/003record-sets.html"><strong aria-hidden="true">31.</strong> Avoid sets of mixed records</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="../adr/002adr-types.html"><strong aria-hidden="true">32.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/003adr-trex.html"><strong aria-hidden="true">33.</strong> ADR-003: transition executor (TRex)</a></li><li class="chapter-item expanded "><a href="../adr/004adr-annotations.html"><strong aria-hidden="true">34.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="../adr/005adr-json.html"><strong aria-hidden="true">35.</strong> ADR-005: JSON Serialization Format</a></li><li class="chapter-item expanded "><a href="../adr/006rfc-unit-testing.html"><strong aria-hidden="true">36.</strong> RFC-006: unit tests and property-based tests</a></li><li class="chapter-item expanded "><a href="../adr/007adr-restructuring.html"><strong aria-hidden="true">37.</strong> ADR-007: restructuring</a></li><li class="chapter-item expanded "><a href="../adr/008adr-exceptions.html"><strong aria-hidden="true">38.</strong> ADR-008: exceptions</a></li><li class="chapter-item expanded "><a href="../adr/009adr-outputs.html"><strong aria-hidden="true">39.</strong> ADR-009: outputs</a></li><li class="chapter-item expanded "><a href="../adr/011adr-smt-arrays.html"><strong aria-hidden="true">40.</strong> ADR-011: alternative SMT encoding using arrays</a></li><li class="chapter-item expanded "><a href="../adr/015adr-trace.html"><strong aria-hidden="true">41.</strong> ADR-015: ITF: informal trace format</a></li><li class="chapter-item expanded "><a href="../adr/016adr-retla.html"><strong aria-hidden="true">42.</strong> ADR-016: ReTLA: Relational TLA</a></li><li class="chapter-item expanded "><a href="../adr/017pdr-temporal.html"><strong aria-hidden="true">43.</strong> PDR-017: Checking temporal properties</a></li><li class="chapter-item expanded "><a href="../adr/018adr-inlining.html" class="active"><strong aria-hidden="true">44.</strong> ADR-018: Inlining in Apalache</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#adr-018-inlining-in-apalache" id="adr-018-inlining-in-apalache">ADR-018: Inlining in Apalache</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th><th>last revised</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1</td><td>Apr 21, 2022</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#summary">Summary (Overview)</a></li>
<li><a href="#context">Context (Problem)</a></li>
<li><a href="#options">Options (Alternatives)</a></li>
<li><a href="#solution">Solution (Decision)</a></li>
<li><a href="#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>This ADR defines the various kinds of inlining considered in Apalache and discusses the pros and cons of their implementations.
Since we have recently reworked the inliner in <a href="https://github.com/informalsystems/apalache/pull/1569">#1569</a>, we saw it fit to document exactly how inlining is supposed to work and we have chosen the transformations performed in the inlining pass. </p>
<h2><a class="header" href="#context" id="context">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>TLA+ allows the user to define their own operators (e.g. <code>A</code>), in addition to the standard ones built into the language itself (e.g. <code>\union</code>).
This can be done either globally, where the module directly contains a definition, or locally via LET-IN, where a local operator is defined within the body of another operator. For example:</p>
<pre><code class="language-tla">GlobalA(p, q) ==
  LET LocalB(r) == r * r
  IN LocalB(p + q)
</code></pre>
<p>defines a global operator <code>GlobalA</code>, within which there is a locally defined <code>LocalB</code>.</p>
<p>Suppose we are given an invariant <code>GlobalA(1,2) = 9</code>. How do we evaluate whether or not this invariant holds? To do that, we need to evaluate 
<code>LET LocalB(r) == r * r IN LocalB(p + q)</code>, and to do <em>that</em>, we need to evaluate <code>LocalB(p + q)</code>. 
However, we cannot evaluate <code>LocalB(p + q)</code> in a vacuum, because <code>p</code> and <code>q</code> are not values we can reason about, but instead formal parameters. 
What we need to do, is determine the value of &quot;<code>LocalB(p + q)</code>, if <code>p = 1</code> and <code>q = 2</code>&quot;. In other words, we need to apply the substitution <code>{p -&gt; 1, q -&gt;2}</code> to <code>LocalB(p + q)</code>, which gives us <code>LocalB(1 + 2)</code>. 
Repeating this process, we apply the substitution <code>{r -&gt; 1 + 2}</code> to 
<code>r * r</code>, the body of <code>LocalB</code>, to obtain the following equivalence:</p>
<pre><code class="language-tla">GlobalA(1,2) = 9 &lt;=&gt; (1 + 2) * (1 + 2) = 9
</code></pre>
<p>The process of applying these substitutions as syntactic transformations is called inlining. </p>
<p>More precisely, suppose we are given a <em>non-recursive</em> operator <code>A</code> with the following definition:</p>
<pre><code class="language-tla">A(p1,...,pn) == body
</code></pre>
<p>The term &quot;inlining&quot; (of <code>A</code>) typically refers to the process of replacing instances of operator application <code>A(e1,...,en)</code> with <code>body[e1/p1,...,en/pn]</code>, i.e. the expression obtained by replacing each instance of <code>pi</code> with <code>ei</code> within <code>body</code>.
We elect to use the term in a broader sense of &quot;replacing an operator with its definition&quot;, and define two &quot;flavors&quot; of inlining:</p>
<ol>
<li>Standard inlining: the instantiation described above
<ol>
<li>Non-nullary inlining: the instantiation described above, except the inlining skips nullary LET-defined operators</li>
</ol>
</li>
<li>Pass-by-name inlining: replacing an operator name <code>A</code> used as an argument to a higher-order operator with a local LET-definition: <code>LET A_LOCAL(p1,...,pn) == A(p1,...,pn) IN A_LOCAL</code></li>
</ol>
<p>The reason for doing (1) is that, at some point, a rewriting rule would have to generate constraints from <code>A(e1,...,en)</code>. 
To do this, we couldn't just separately encode <code>body</code> and <code>e1,...,en</code>, because the richness of the data structures allowed in TLA+ makes it difficult to combine independently generated constraints, in cases where the operator parameters are complex expressions (e.g. <code>e1</code> is some record with varied nested constructs).
This is mostly due to the fact that there is no 1-to-1 correspondence between TLA+ objects and SMT datatypes, so encoding object equality is more complicated (which would be needed to express that <code>ei</code> instantiates <code>pi</code>).
Therefore we must, no later than at the point of the rewriting rule, know <code>body[e1/p1,...,en/pn]</code>. </p>
<p>While inlining non-nullary operators is strictly necessary, inlining nullary operators is not, because nullary operators, by definition, do not have formal parameters. 
Therefore, in a well-constructed expression, all variables appearing in a nullary operator are scoped, i.e. they are  either specification-level variables (defined as <code>VARIABLE</code>), or bound in the context within which the operator is defined, if local. An example of the latter would be <code>i</code> in </p>
<pre><code class="language-tla">\E i \in S: LET i2 == i * i in i2 = 0
</code></pre>
<p>which is not bound in the nullary operator <code>i2</code>, but it is defined in the scope of the <code>\E</code> operator, under which <code>i2</code> is defined. Therefore, any analysis of <code>i2</code> will have <code>i</code> in its scope.
The non-nullary variant of (1) is therefore strictly better for performance, because it allows for a sort of caching, which avoids repetition. Consider for example:</p>
<pre><code class="language-tla">A1(p) == 
  LET pCached == p
  IN F(pCached,pCached)

A2(p) == F(p,p)
</code></pre>
<p>If we apply the substitution <code>{p -&gt; e}</code>, for some complex value <code>e</code>, to the bodies of both operators, the results are </p>
<pre><code class="language-tla">LET pCached == e
IN F(pCached,pCached)
</code></pre>
<p>and</p>
<pre><code>F(e,e)
</code></pre>
<p>In the first case, we can translate <code>pCached</code> to a cell (Apalache's SMT representation of TLA+ values, see <a href="https://dl.acm.org/doi/10.1145/3360549">this
paper</a> for details) and reuse the cell expression twice, whereas in the second, <code>e</code> is rewritten twice, independently.
So in the case that we perform (1), we will always perform the non-nullary variant, because it is strictly more efficient in our cell-arena framework fo rewriting rules.</p>
<p>The reason for doing (2) is more pragmatic; in order to rewrite expressions which feature any of the higher-order (HO) built-in operators, e.g. <code>ApaFoldSet(A, v, S)</code>, we need to know, at the time of rewriting, how to evaluate an application of <code>A</code> (e.g. <code>A(partial, current)</code> for folding). 
Performing (2) allows us to make the rewriting rule local, since the definition becomes available where the operator is used, and frees us from having to track scope in the rewriting rules.</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Suppose we have an operator </p>
<pre><code class="language-tla">A(p,q) == p + 2 * q
</code></pre>
<p>Then, the result of performing (1) for <code>A(1, 2)</code> would be <code>1 + 2 * 2</code>. 
The constant simplification could take the inlined expression and simplify it to <code>5</code>, whereas it could not do this across the application boundary of <code>A(1,2)</code>.</p>
<p>The result of performing (2) for <code>ApaFoldSet(A, 0, {1,2,3})</code> would be</p>
<pre><code class="language-tla">ApaFoldSet(LET A_LOCAL(p,q) == p + 2 * q, 0, {1,2,3})
</code></pre>
<p>While this resulting expression isn't subject to any further simplification, notice that it <em>does</em> contain all the required information to fully translate to SMT, unlike <code>ApaFoldSet(A, 0, {1,2,3})</code>, which requires external information about <code>A</code>.</p>
<h2><a class="header" href="#options" id="options">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<p>Knowing that we must perform (1) at some point, what remains is to decide whether we perform inlining on-demand as part of rewriting, or whether to isolate it to an independent inlining-pass (or as part of preprocessing), i.e. performing a syntactic transformation on the module, that replaces <code>A(e1,...,en)</code> with <code>body[e1/p1,...,en/pn]</code>, or merely generating rewriting rules that <em>encode</em> <code>A(e1,...,en)</code> equivalently as <code>body[e1/p1,...,en/pn]</code>, while preserving the specification syntax.
Additionally, if we do isolate inlining to a separate pass, we can choose whether or not to perform (2).</p>
<ol>
<li>
<p>Perform no inlining in preprocessing and inline only as needed in the rewriting rules.</p>
<ul>
<li>Pros: Spec intermediate output remains small, since inlining increases the size of the specificaiton</li>
<li>Cons: 
<ul>
<li>Fewer optimizations can be applied, as some are only applicable to the syntactic forms obtained after inlining (e.g. <code>ConstSimplifier</code> can simplify <code>IF TRUE THEN a ELSE b</code>, but not <code>IF p THEN a ELSE b</code>)</li>
<li>Rewriting rules for different encodings have to deal with operators in their generality.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Independently perform only standard (non-nullary) inlining (1), but no pass-by-name inlining (2)</p>
<ul>
<li>Pros: Allows for additional optimizations after inlining (simplification, normalization, keramelization, etc.)</li>
<li>Cons: Rewriting rules still need scope, to resolve higher-order operator arguments in certain built-in operators (e.g. folds)</li>
<li>Recall that the non-nullary variant of (1) is strictly better than the simple one (while being trivial to implement), because nullary inlining is prone to repetition.</li>
</ul>
</li>
<li>
<p>Independently perform non-nullary inlining and pass-by-name inlining</p>
<ul>
<li>Pros: 
<ul>
<li>Enables further optimizations (simplification, normalization, keramelization, etc.)</li>
<li>Using non-nullary inlining has all of the benefits of standard inlining, while additionally being able to avoid repetition (e.g. not inlining <code>A</code> in <code>A + A</code>)</li>
<li>Pass-by-name inlining allows us to keep rewriting rules local</li>
</ul>
</li>
<li>Cons: Implementation is more complex</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#solution" id="solution">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>We elect to implement option (3), as most of its downsides are developer burdens, not theoretical limitations, and its upsides (in particular the ones of non-nullary inlining) are noticeable performance benefits.
Maintaining local rewriting rules is also a major technical simplification, which avoids potential bugs with improperly tracked scope.</p>
<h2><a class="header" href="#consequences" id="consequences">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>TBD</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../adr/017pdr-temporal.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../adr/017pdr-temporal.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
