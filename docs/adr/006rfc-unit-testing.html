<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-006: unit tests and property-based tests - Apalache Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">1.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="../apalache/index.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../apalache/getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/apalache-or-tlc.html"><strong aria-hidden="true">3.1.</strong> Shall I use Apalache or TLC?</a></li><li class="chapter-item expanded "><a href="../apalache/system-reqs.html"><strong aria-hidden="true">3.2.</strong> System Requirements</a></li><li class="chapter-item expanded "><a href="../apalache/installation/index.html"><strong aria-hidden="true">3.3.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/jvm.html"><strong aria-hidden="true">3.3.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="../apalache/installation/docker.html"><strong aria-hidden="true">3.3.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../apalache/installation/source.html"><strong aria-hidden="true">3.3.3.</strong> Source</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/running.html"><strong aria-hidden="true">3.4.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="../apalache/invariants.html"><strong aria-hidden="true">3.5.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="../apalache/statistics.html"><strong aria-hidden="true">3.6.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="../apalache/example.html"><strong aria-hidden="true">3.7.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="../apalache/parameters.html"><strong aria-hidden="true">3.8.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="../apalache/principles.html"><strong aria-hidden="true">3.9.</strong> Principles of Symbolic Model Checking with Apalache</a></li><li class="chapter-item expanded "><a href="../apalache/apalache-mod.html"><strong aria-hidden="true">3.10.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="../apalache/profiling.html"><strong aria-hidden="true">3.11.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="../apalache/theory.html"><strong aria-hidden="true">3.12.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/tlc-config.html"><strong aria-hidden="true">4.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="../apalache/typechecker-snowcat.html"><strong aria-hidden="true">5.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="../apalache/features.html"><strong aria-hidden="true">6.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../apalache/known-issues.html"><strong aria-hidden="true">7.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="../apalache/preprocessing.html"><strong aria-hidden="true">8.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="../apalache/tuning.html"><strong aria-hidden="true">9.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="../apalache/kera.html"><strong aria-hidden="true">10.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded "><a href="../apalache/assignments.html"><strong aria-hidden="true">11.</strong> Assignments in Apalache</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="../HOWTOs/index.html"><strong aria-hidden="true">12.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">13.</strong> How to write type annotations</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">14.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">15.</strong> The Snowcat‚ùÑüê± Type Checker</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="../lang/index.html"><strong aria-hidden="true">16.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../lang/standard-operators.html"><strong aria-hidden="true">17.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/booleans.html"><strong aria-hidden="true">17.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../lang/control-and-nondeterminism.html"><strong aria-hidden="true">17.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="../lang/conditionals.html"><strong aria-hidden="true">17.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../lang/integers.html"><strong aria-hidden="true">17.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../lang/sets.html"><strong aria-hidden="true">17.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="../lang/logic.html"><strong aria-hidden="true">17.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="../lang/functions.html"><strong aria-hidden="true">17.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../lang/records.html"><strong aria-hidden="true">17.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="../lang/tuples.html"><strong aria-hidden="true">17.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../lang/sequences.html"><strong aria-hidden="true">17.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="../lang/user-operators.html"><strong aria-hidden="true">18.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/user/top-level-operators.html"><strong aria-hidden="true">18.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/let-in.html"><strong aria-hidden="true">18.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/higher-order-operators.html"><strong aria-hidden="true">18.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/lambdas.html"><strong aria-hidden="true">18.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/recursive-operators.html"><strong aria-hidden="true">18.5.</strong> Recursive operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/local-operators.html"><strong aria-hidden="true">18.6.</strong> Local operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/recursive-functions.html"><strong aria-hidden="true">18.7.</strong> Recursive functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="../idiomatic/index.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">21.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="../idiomatic/001assignments.html"><strong aria-hidden="true">22.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="../idiomatic/002primes.html"><strong aria-hidden="true">23.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="../adr/002adr-types.html"><strong aria-hidden="true">24.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/004adr-annotations.html"><strong aria-hidden="true">25.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="../adr/006rfc-unit-testing.html" class="active"><strong aria-hidden="true">26.</strong> RFC-006: unit tests and property-based tests</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rfc-006-unit-testing-and-property-based-testing-of-tla-specifications" id="rfc-006-unit-testing-and-property-based-testing-of-tla-specifications">RFC-006: Unit testing and property-based testing of TLA+ specifications</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov, Vitor Enes, Shon Feder, ...</td><td align="right">1</td></tr>
</tbody></table>
<!-- toc -->
<p><strong>Abstract.</strong> This document discusses a framework for testing TLA+
specifications. Our first goal is to give the writers of TLA+ specifications an
interactive approach to quickly test their specifications in the design
phase, similar to unit-testing in programming languages. Our second goal is to
give the readers of TLA+ specifications a clear framework for dissecting TLA+
specifications, in order to understand them in smaller pieces. These ideas
have not been implemented yet. We believe that the testing framework will
enable the users of Apalache and TLC to write and read TLA+ specifications in a
much more efficient manner than they do it today.</p>
<h2><a class="header" href="#1-long-rationale" id="1-long-rationale">1. Long rationale</a></h2>
<p>TLA+ is a specification language that was designed to be executable inside a
human brain. Moreover, it was intended to run in the brains that underwent a
specific software upgrade, called mathematical training. Many years have passed
since then. We now have automatic tools that can run TLA+ in a computer (to
some extent). Even more, these tools can prove or disprove certain properties
of TLA+ specs.</p>
<p>Nowadays, we have two tools that aid us in writing a TLA+ spec: our brain and a
model checker. Both these tools have the same problem. They are slow. Software
engineers are facing a similar problem when they are trying to test their
system against different inputs. Interestingly, software engineers have found a
way around this problem. They first test the individual parts of the system and
then they test the system as a whole. The former is done with unit tests,
whereas the latter is done with integration tests. (Software engineers probably
borrowed this approach from industrial engineers.) Unit tests are used almost
interactively, to debug a small part of the system, while integration tests are
run in a continuous integration environment, which is not interactive at all.</p>
<p>Actually, our brains also have a built-in ability of abstracting away from one
part of a problem while thinking about the other part. That is why some of us
can still win against automatic tools. Model checkers do not have this built-in
ability. So it looks like when we are using TLC or Apalache, we are doing
integration testing all the time. Unfortunately, when we are checking a
specification as a whole, we rarely get a quick response, except for very small
specs. This is hardly surprising, as we are interested in specifying complex
systems, not the trivial ones.</p>
<p>Surprisingly, when we are writing large TLA+ specs, our interaction with the
model checker looks more like an interaction with a <a href="https://en.wikipedia.org/wiki/Mainframe_computer">Mainframe computer</a> from
the early days of computing than a modern interactive development cycle. We
feed the model checker our specification and wait for hours in the hope that it
gives us a useful response. If it does not, we have to make the specification
parameters small enough for the model checker to do anything useful. If our
parameters are already ridiculously small, we have to throw more computing
power at the problem and wait for days. In contrast, verification tools for
programs are meant to be much more interactive, e.g., see <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a> and
<a href="https://github.com/kenmcmil/ivy">Ivy</a>.</p>
<p>Why cannot we do something like <a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> in Apalache? We believe that
we actually can do that. We can probably do it even better by implementing
<a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, that is, test parts of our specifications against a
large set of inputs instead of testing it against a few carefully crafted
inputs.</p>
<h2><a class="header" href="#2-a-motivating-example" id="2-a-motivating-example">2. A motivating example</a></h2>
<p>Let's consider a relatively simple distributed algorithm as an example.  The
repository of <a href="https://github.com/tlaplus/Examples/">TLA+ examples</a> contains the well-known leader election
algorithm called <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> (specified in TLA+ by Stephan Merz). The algorithm is
over 40 years old, but it is tricky enough to be still interesting. To
understand the algorithm, check <a href="https://dl.acm.org/doi/book/10.5555/2821576">Distributed Algorithms</a> by Nancy Lynch.</p>
<p>As the description suggests, when we fix <code>N</code> to <code>6</code> and <code>Id</code> to
<code>&lt;&lt;27, 4, 42, 15, 63, 9&gt;&gt;</code>, TLC checks that the spec satisfies the invariant
<code>Correctness</code> in just 11 seconds, after having explored 40K states.
Of course, had we wanted to check the property for all possible combinations
of six unique identifiers in the range of <code>1..6</code>, we would had to run TLC
<code>6! = 720</code> times, which would take over 2 hours.</p>
<p>In Apalache, we can setup a TLA+ module instance, to check all instances of
the algorithm that have from 2 to 6 processes:</p>
<pre><code class="language-tla">--------------------- MODULE ChangRobertsTyped_Test -------------------------
(*
 * A test setup for ChangRobertsTyped.
 *)
EXTENDS Integers, Apalache

\* a copy of constants from ChangRobertsTyped
CONSTANTS
    \* @type: Int;
    N,
    \* @type: Int -&gt; Int;
    Id

\* a copy of state variables from ChangRobertsTyped
VARIABLES
    \* @type: Int -&gt; Set(Int);
    msgs,
    \* @type: Int -&gt; Str;
    pc,
    \* @type: Int -&gt; Bool;
    initiator,
    \* @type: Int -&gt; Str;
    state

INSTANCE ChangRobertsTyped

\* We bound N in the test
MAX_N == 6

\* we override Node, as N is not known in advance
OVERRIDE_Node == { i \in 1..MAX_N: i &lt;= N }

\* initialize constants
ConstInit ==
    /\ N \in 2..MAX_N
    /\ Id \in [ 1..MAX_N -&gt; Int ]

\* The below constraints are copied from ASSUME.
\* They are not enforced automatically, see issue #69.
Assumptions ==    
    /\ Node = DOMAIN Id
    /\ \A n \in Node: Id[n] &gt;= 0
    /\ \A m,n \in Node : m # n =&gt; Id[m] # Id[n]  \* IDs are unique

InitAndAssumptions ==
    Init /\ Assumptions

</code></pre>
<p>By running Apalache as follows, we can check <code>Correctness</code> for all
configurations of 2 to 6 processes and all combinations of <code>Id</code>:</p>
<pre><code class="language-sh">apalache check --cinit=ConstInit \
  --init=InitAndAssumptions --inv=Correctness ChangRobertsTyped_Test.tla
</code></pre>
<p>Actually, we do not restrict <code>Id</code> to be a function from <code>1..N</code> to <code>1..N</code>, but
rather allow <code>Id</code> to be a function from <code>1..N</code> to <code>Int</code>. So Apalache should
be able to check an infinite number of configurations!</p>
<p>Unfortunately, Apalache starts to dramatically slow down after having explored
6 steps of the algorithm. Indeed, it does symbolic execution for a
non-deterministic algorithm and infinitely many inputs. We could try to improve
the SMT encoding, but that would only win us several steps more. A more
realistic approach would be to find an inductive invariant and let Apalache
check it.</p>
<p>It looks like we are trapped: Either we have to invest some time in
verification, or we can check the algorithm for a few data points. In case
of LCR, the choice of process identifiers is important, so it is not clear at
all, whether a few data points are giving us a good confidence.</p>
<p>This situation can be frustrating, especially when you are designing a large
protocol. For instance, both Apalache and TLC can run for hours on <a href="https://github.com/tlaplus/Examples/tree/master/specifications/raft">Raft</a>
without finishing. We should be able to quickly debug our specs like software
engineers do!</p>
<h2><a class="header" href="#3-an-approach-to-writing-tests" id="3-an-approach-to-writing-tests">3. An approach to writing tests</a></h2>
<p><em>What we describe below has not been implemented yet. Apalache has all the
necessary ingredients for implementing this approach. We are asking for your
input to find an ergonomic approach to testing TLA+ specifications.  Many of
the following ideas apply to TLC as well. We are gradually introducing
Apalache-specific features.</em></p>
<p>A complete specification can be found in <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/ChangRobertsTyped_Test.tla">ChangRobertsTyped_Test.tla</a>.</p>
<p>Our idea is to quickly check operators in isolation, without analyzing the
whole specification and without analyzing temporal behavior of the
specification. There are three principally different kinds of operators in TLA+:</p>
<ul>
<li>
<p>Stateless operators that take input parameters and return the result.
These operators are similar to functions in functional languages.</p>
</li>
<li>
<p>Action operators that act on a specification state.
These operators are similar to procedures in imperative languages.</p>
</li>
<li>
<p>Temporal operators that act on executions, which are called behaviors
in TLA+. These operators are somewhat similar to regular expressions,
but they are more powerful, as they reason about infinite executions.</p>
</li>
</ul>
<h3><a class="header" href="#31-testing-stateless-operators" id="31-testing-stateless-operators">3.1. Testing stateless operators</a></h3>
<p>Consider the following auxiliary operator in the specification:</p>
<pre><code class="language-tla">succ(n) == IF n=N THEN 1 ELSE n+1  \* successor along the ring
</code></pre>
<p>While this operator is defined in the specification, it is clear that it is
well isolated from the rest of the specification: We only have to know the
value of the constant <code>N</code> and the value of the operator parameter <code>n</code>.</p>
<pre><code class="language-tla">\* Note that succ(n) is not referring to state variables,
\* so we can test it in isolation.
\*
\* @require(ConstInit)
\* @testStateless
Test_succ ==
    \* This is like a property-based test.
    \* Note that it is exhaustive (for the range of N).
    \A n \in Node:
        succ(n) \in Node
</code></pre>
<p>This test is very simple. It requires <code>succ(n)</code> to be in the set <code>Node</code>, for
all values <code>n \in Node</code>. The body of the operator <code>Test_succ</code> is pure TLA+.
We annotate the operator with <code>@testStateless</code>, to indicate that it should
be checked in a stateless context.</p>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla Test_succ
</code></pre>
<p>We pass the test name <code>Test_succ</code>, as we expect the <code>test</code> command to run all
tests by default, if no test name is specified. Also, we have to initialize the
constants with <code>ConstInit</code>, which we specify with the annotation
<code>@require(ConstInit)</code>.</p>
<p><a id="testAction"></a></p>
<h3><a class="header" href="#32-testing-actions" id="32-testing-actions">3.2. Testing actions</a></h3>
<p>Testing stateless operators is nice. However, TLA+ is built around the concept
of a state machine. Hence, we believe that most of the testing activity will be
centered around TLA+ actions. For instance, the <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> specification has two
actions: <code>n0</code> and <code>n1</code>. Let's have a look at <code>n0</code>:</p>
<pre><code class="language-tla">n0(self) == /\ pc[self] = &quot;n0&quot;
            /\ IF initiator[self]
                  THEN /\ msgs' = [msgs EXCEPT ![succ(self)] = @ \cup {Id[self]}]
                  ELSE /\ TRUE
                       /\ msgs' = msgs
            /\ pc' = [pc EXCEPT ![self] = &quot;n1&quot;]
            /\ UNCHANGED &lt;&lt; initiator, state &gt;&gt;
</code></pre>
<p>Assume we like to test it without looking at the rest of the system, namely,
the predicates <code>Init</code> and <code>n1</code>. First of all, we have to describe the states
that could be passed to the action <code>n0</code>. In this section, we will just use
TypeOK (see <a href="#generators">Section 5</a> for a more fine-grained control over the
inputs):</p>
<pre><code class="language-tla">TypeOK ==
  /\ pc \in [Node -&gt; {&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;Done&quot;}]
  /\ msgs \in [Node -&gt; SUBSET {Id[n] : n \in Node}]
  /\ initiator \in [Node -&gt; BOOLEAN]
  /\ state \in [Node -&gt; {&quot;cand&quot;, &quot;lost&quot;, &quot;won&quot;}]

</code></pre>
<p>Further, we specify what kind of outcome we expect:</p>
<pre><code class="language-tla">\* Assertion that we expect to hold true after firing Action_n0.
Assert_n0 ==
    \E n, m \in Node:
        msgs'[n] = msgs[n] \union {m}
</code></pre>
<p>(Do you think this condition actually holds true after firing <code>n0</code>?)</p>
<p>Finally, we have to specify, how to run the action <code>n0</code>. In fact, if you look
at <code>Next</code>, this requires us to write a bit of code, instead of just calling
<code>n0</code>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>The operator <code>TestAction_n0</code> carries several annotations:</p>
<ul>
<li>The annotation <code>@require(TypeOK)</code> tells the framework that
<code>TypeOK</code> should act as an initialization predicate for testing
<code>TestAction_n0</code>.</li>
<li>The annotation <code>@testAction</code> indicates that <code>TestAction_n0</code> should be tested
as an action that is an operator over unprimed and primed variable.</li>
<li>The annotation <code>@ensure(Assert_n0)</code> tells the framework that
<code>Assert_n0</code> should hold after <code>TestAction_n0</code> has been fired.</li>
</ul>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>Importantly, we decompose the test in three parts:</p>
<ul>
<li>preparing the states by evaluating predicates <code>ConstInit</code> and <code>TypeOK</code>
(similar to <code>Init</code>),</li>
<li>executing the action by evaluating the action predicate <code>TestAction_n0</code>
(like a single instance of <code>Next</code>),</li>
<li>testing the next states against the previous states by evaluating
the predicate <code>Assert_n0</code>
(like an action invariant).</li>
</ul>
<h3><a class="header" href="#33-testing-executions" id="33-testing-executions">3.3. Testing executions</a></h3>
<p>Engineers often like to test a particular set of executions to support their
intuition, or to communicate an example to their peers. Sometimes, it is useful
to isolate a set of executions to make continuous integration break, until the
protocol is fixed. Needless to say, TLA+ tools have no support for this
standard technique, though they have all capabilities to produce such tests.</p>
<p>Similar to testing an action in isolation, we propose an interface for testing
a restricted set of executions as follows:</p>
<pre><code class="language-tla">\* Execute a sequence of 5 actions, similar to TestAction_n0.
\* We test a final state with Assert_n0.
\*
\* @require(ConstInit) \* in  the future, we will allow the user to omit quotes
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
TestExec_n0_n1 ==
    \* in this test, we only execute actions by processes 1 and 2
    \E self \in { 1, 2 }:
        n0(self) \/ n1(self)

</code></pre>
<p>In this case, we are using a different assertion in the <code>@ensure</code> annotation:</p>
<pre><code class="language-tla">Assert_noWinner ==
    \A n \in Node:
        state'[n] /= &quot;won&quot;

</code></pre>
<p>The test <code>TestExec_n0_n1</code> is similar to <code>TestAction_n0</code> in many aspects.  It
starts by initializing the state with the predicate <code>Prepare_n0</code> and it expects
a final state to satisfy the predicate <code>Assert_noWinner</code>. There is an important
difference between the variables in <code>Assert_n0</code> and <code>Assert_noWinner</code>:</p>
<ul>
<li>
<p>Unprimed variables in <code>Assert_n0</code> refer to a state before firing an action,
whereas primed variables in <code>Assert_n0</code> refer to a state after firing
the action.</p>
</li>
<li>
<p>Unprimed variables in <code>Assert_noWinner</code> refer to a state before firing
an <em>execution</em>, whereas primed variables in <code>Assert_noWinner</code> refer to
a final state of the execution.</p>
</li>
</ul>
<p><em>(If you find the above behavior of <code>Assert_noWinner</code> confusing, please let us
know.)</em></p>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<p>If the test is violated, a counterexample should be produced in the file
<code>counterexample_TestExec_n0_n1.tla</code>.</p>
<h3><a class="header" href="#34-test-executions-with-temporal-properties" id="34-test-executions-with-temporal-properties">3.4. Test executions with temporal properties</a></h3>
<p>When we wrote the test <code>TestExec_n0_n1</code>, we did not think about the
intermediate states of an execution. This test was a functional test: It is
matching the output against the input. When reasoning about state machines,
we often like to restrict the executions and check the properties of those
executions.</p>
<p>Fortunately, we have all necessary ingredients in TLA+ to do
exactly this. Test <code>TestExec_correctness_under_liveness</code>.</p>
<pre><code class="language-tla">\* Execute a sequence of 5 actions, while using temporal properties.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @require(Liveness)
\* @ensure(GlobalCorrectness)
\* @testExecution(5)
TestExec_correctness_under_liveness ==
    \E self \in Node:
        n0(self) \/ n1(self)

</code></pre>
<p>Predicates <code>Correctness</code> and <code>Liveness</code> are defined in the spec as follows:</p>
<pre><code class="language-tla">(***************************************************************************)
(* Safety property: when node n wins the election, it is the initiator     *)
(* with the smallest ID, and all other nodes know that they lost.          *)
(***************************************************************************)
Correctness ==
  \A n \in Node : state[n] = &quot;won&quot; =&gt;
     /\ initiator[n]
     /\ \A m \in Node \ {n} : 
           /\ state[m] = &quot;lost&quot;
           /\ initiator[m] =&gt; Id[m] &gt; Id[n]

Liveness == (\E n \in Node : state[n] = &quot;cand&quot;) =&gt; &lt;&gt;(\E n \in Node : state[n] = &quot;won&quot;)
</code></pre>
<p>Since <code>Correctness</code> is a state predicate, we wrap it with a temporal operator
to check it against all states of an execution:</p>
<pre><code class="language-tla">GlobalCorrectness == []Correctness

</code></pre>
<h3><a class="header" href="#35-discussion" id="35-discussion">3.5. Discussion</a></h3>
<p>As you can see, we clearly decompose a test in three parts:</p>
<ul>
<li>preparing the states (like a small version of <code>Init</code>),</li>
<li>executing the action (like a small version of <code>Next</code>),</li>
<li>testing the next states against the previous states (like an action invariant).</li>
</ul>
<p>In the rest of this section, we comment on the alternative approaches.</p>
<h4><a class="header" href="#351-but-i-can-do-all-of-that-in-tla" id="351-but-i-can-do-all-of-that-in-tla">3.5.1. But I can do all of that in TLA+</a></h4>
<p>True. TLA+ is an extremely expressive language.</p>
<p>Let's go back to the test <code>TestAction_n0</code> that was explained in <a href="#testAction">Section
3.2</a>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Can we rewrite this test in pure TLA+? Yes, but it is an error-prone approach.
Let's do it step-by-step.</p>
<p>First of all, there is no simple way to initialize constants in TLA+, as we did
with <code>ConstInit</code> (this is an Apalache-specific feature). Of course, one can
restrict constants with <code>ASSUME(...)</code>.  However, assumptions about constants
are global, so we cannot easily isolate constant initialization in one test.
The canonical way of initializing constants is to define them in a TLC
configuration file. If we forget about all these idiosyncrasies of TLC, we
could just use implication (<code>=&gt;</code>), as we normally do in logic. So our test
<code>TestAction_n0_TLA</code> in pure TLA+ would look like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt; (* ... *)
</code></pre>
<p>Second, we want to restrict the states with <code>TypeOK</code>. That should be easy:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK (* ... *)
</code></pre>
<p>Third, we want to execute the action <code>n0</code>, as we did in <code>TestAction_n0</code>.
The intuitive way is to write it like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    /\ TypeOK
    /\ \E self \in Node:
         n0(self)
    (* ... *)     
</code></pre>
<p>Although the above code looks reasonable, we cheated. It combines two steps in
one: It initializes states with <code>TypeOK</code> and it simultaneously executes the
action <code>n0</code>. If we tried that in TLC (forgetting about <code>ConstInit</code>), that would
not work. Though there is nothing wrong about this constraint from the
perspective of logic, it just restricts the unprimed variables and primed
variables.  There is probably a way to split this code in two steps by applying
the operator <code>\cdot</code>, which is implemented neither in TLC, nor in Apalache:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      \E self \in Node:
         n0(self)
      (* ... *)
    )
</code></pre>
<p>In these circumstances, a more reasonable way would be to introduce a new file
like <code>MCTestAction_n0.tla</code> and clearly specify <code>TypeOK</code> as the initial
predicate and the action as the next predicate. But we do not want
state-of-the-art dictate us our behavior.</p>
<p>Finally, we have to place the assertion <code>Assert_n0</code>. Let's try it this way:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert_n0
    )
</code></pre>
<p>Unfortunately, this is not the right solution. Instead of executing <code>n0</code>
and checking that the result satisfies <code>Assert_n0</code>, we have restricted
the next states to always satisfy <code>Assert_n0</code>!</p>
<p>Again, we would like to write something like the implication <code>Action =&gt; Assertion</code>, but we are not allowed do that with the model checkers for TLA+.
We can use the operator <code>Assert</code> that is supported by TLC:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert(Assert_n0, &quot;assertion violation&quot;)
    )
</code></pre>
<p>This time it should conceptually work. Once <code>n0</code> has been executed, TLC could
start evaluating <code>Assert(...)</code> and find a violation of <code>Assert_n0</code>.  There is
another problem. The operator <code>Assert</code> is a purely imperative operator, which
relies on the order in which the formula is evaluated. Hence, Apalache does not
support this operator and, most likely, it never will. The imperative semantics
of the operator <code>Assert</code> is simply incompatible with logical constraints.
Period.</p>
<p>Phew. It was not easy to write <code>TestAction_n0_TLA</code>. In principle, we could
fix this pattern and extract the test in a dedicated file <code>MC.tla</code> to run
it with TLC or Apalache.</p>
<p>Let's compare it with <code>TestAction_n0</code>. Which one would you choose?</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Another problem of <code>TestAction_n0_TLA</code> is that it has a very brittle structure.
What happens if one writes <code>~ConstInit \/ TypeOK ...</code> instead of <code>ConstInit =&gt; TypeOK ...</code>? In our experience, when one sees a logical formula, they expect
that an equivalent logical formula should be also allowed.</p>
<p><em>In the defense of TLA+, the issues that we have seen above are not the issues
of TLA+ as a language, but these are the problems of the TLA+ tooling. There
is a very simple and aesthetically pleasing way of writing <code>TestAction_n0</code> in
the logic of TLA+:</em></p>
<pre><code class="language-tla">TestAction_n0_pure_TLA ==
  (ConstInit /\ TypeOK) =&gt;
    (\E self \in Node: n0(self)) =&gt; Assert_n0
</code></pre>
<p>The operator <code>TestAction_n0_pure_TLA</code> could be probably reasoned about in <a href="">TLA+
Proof System</a>.  From the automation perspective, it would require a
completely automatic constraint-based solver for TLA+, which we do not have.
In practice, this would mean either rewriting TLC and Apalache from scratch, or
hacking them to enforce the right semantics of the above formula.</p>
<h4><a class="header" href="#352-why-annotations-instead-of-special-operators" id="352-why-annotations-instead-of-special-operators">3.5.2. Why annotations instead of special operators</a></h4>
<p>The annotations <code>@require</code> and <code>@ensure</code> are not our invention. You can find
them in <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design-by-contract</a> languages. In particular, they are used as pre-
and post-conditions in code verification tools, e.g., <a href="https://www.thestrangeloop.com/2018/contracts-for-getting-more-programs-less-wrong.html">JML</a>, <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a>, <a href="http://mcmil.net/pubs/SIGCOMM19.pdf">QUIC
testing</a> with <a href="https://github.com/kenmcmil/ivy">Ivy</a>. </p>
<p>You could ask a reasonable question: Why cannot we introduce operators such
as <code>Require</code> and <code>Ensure</code> instead of writing annotations? For instance,
we could rewrite <code>TestAction_n0</code> as follows:</p>
<pre><code class="language-tla">TestAction_n0_no_annotations ==
  /\ Require(ConstInit)
  /\ Require(TypeOK)
  /\ \E self \in Node:
        n0(self)
  /\ Ensure(Assert_n0)
</code></pre>
<p>The above test looks self-contained, no annotations. Moreover, we have probably
given more power to the users: They could pass expressions to <code>Require</code> and
<code>Ensure</code>, or they could combine <code>Require</code> and <code>Ensure</code> in other ways and do
something great... Well, we have actually introduced more problems to the users
than solutions. Since logical formulas can be composed in a lot of ways, we
could start writing interesting things:</p>
<pre><code class="language-tla">Can_I_do_that ==
  /\ ~Require(ConstInit)
  /\ Require(TypeOK) =&gt; Ensure(ConstInit)
  /\ \E self \in Node:
        n0(self) /\ Require(self \in { 1, 2 })
  /\ Ensure(Assert_n0) \/ Ensure(Assert_noWinner)
</code></pre>
<p>It is not clear to us how the test <code>Can_I_do_that</code> should be understood.
But what is written is kind of legal, so it should work, right?</p>
<p><em>The annotations gives us a clear structure instead of obfuscating the
requirements in logical formulas.</em></p>
<p>For the moment, we are using Apalache annotations in code comments.  However,
TLA+ could be extended with ensure/require one day, if they prove to be useful.</p>
<h2><a class="header" href="#4-using-tests-for-producing-quick-examples" id="4-using-tests-for-producing-quick-examples">4. Using tests for producing quick examples</a></h2>
<p>It is often nice to see examples of test inputs that pass the
test. Apalache has all the ingredients to do that that. We should be able
to run a command like that:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>The above call would produce <code>example_TestAction_n0.tla</code>, a TLA+ description of
two states that satisfy the test. This is similar to <code>counterexample.tla</code>,
which is produced when an error is found.</p>
<p>In a similar way we should be able to produce an example of an execution:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<h2><a class="header" href="#5-bounding-the-inputs" id="5-bounding-the-inputs">5. Bounding the inputs</a></h2>
<p>The following ideas clearly stem from <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, e.g., we use
generators similar to <a href="https://www.scalacheck.org/">Scalacheck</a>. In contrast to property-based testing, we
want to run the test not only on some random inputs, but to run it exhaustively
on all inputs within a predefined bounded scope.</p>
<p><a id="generators"></a></p>
<h3><a class="header" href="#51-using-apalache-generators" id="51-using-apalache-generators">5.1. Using Apalache generators</a></h3>
<p>Let's go back to the example in <a href="#testAction">Section 3.2</a>.</p>
<p>In <code>TestAction_n0</code> we used <code>TypeOK</code> to describe the states that can be used as
the input to the test. While this conceptually works, it often happens that
<code>TypeOK</code> describes a large set of states. Sometimes, this set is even infinite,
e.g., when <code>TypeOK</code> refers to the infinite set of sequences <code>Seq(S)</code>.
In Apalache, we can use the operator <code>Gen</code> that produces bounded data structures,
similar to <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. Here is how we could describe the set
of input states, by bounding the size of the data structures:</p>
<pre><code class="language-tla">\* Preparing the inputs for the second test. Note that this is a step of its own.
\* This is similar to an initialization predicate.
Prepare_n0 ==
    \* the following constraint should be added automatically in the future
    /\ Assumptions
    \* let the solver pick some data structures within the bounds
    \* up to 15 messages
    /\ msgs = Gen(3 * MAX_N)
    /\ pc = Gen(MAX_N)
    /\ initiator = Gen(MAX_N)
    /\ state = Gen(MAX_N)
    \* restrict the contents with TypeOK,
    \* so we don't generate useless data structures
    /\ TypeOK
</code></pre>
<p>In <code>Prepare_n0</code>, we let the solver to produce bounded data structures with
<code>Gen</code>, by providing bounds on the size of every set, function, sequence, etc.
Since we don't want to have completely arbitrary values for the data
structures, we further restrict them with <code>TypeOK</code>, which we conveniently have
in the specification.</p>
<p>The more scoped version of <code>TestAction_n0</code> looks like following:</p>
<pre><code class="language-tla">\* Another version of the test where we further restrict the inputs.
\* 
\* @require(ConstInit)
\* @require(Prepare_n0)
\* @ensure(Assert_n0)
\* @testAction
TestAction2_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<h3><a class="header" href="#52-using-tlc-random" id="52-using-tlc-random">5.2. Using TLC Random</a></h3>
<p>Leslie Lamport has recently introduced a solution that allows one to run TLC
in the spirit of <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. This is done by initializing
states with the operators that are defined in the module <code>Randomization</code>. For
details, see Leslie's paper on <a href="http://lamport.azurewebsites.net/tla/inductive-invariant.pdf">Inductive invariants with TLC</a>.</p>
<h2><a class="header" href="#6-test-options" id="6-test-options">6. Test options</a></h2>
<p>To integrate unit tests in the standard TLA+ development cycle, the tools
should remember how every individual test was run. To avoid additional
scripting on top of the command-line interface, we can simply pass the tool
options with the annotation <code>@testOption</code>. The following example demonstrates
how it could be done:</p>
<pre><code class="language-tla">\* A copy of TestExec_n0_n1 that passes additional flags to the model checker.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
\* @testOption(&quot;tool&quot;, &quot;apalache&quot;)
\* @testOption(&quot;search.smt.timeout&quot;, 10)
\* @testOption(&quot;checker.algo&quot;, &quot;offline&quot;)
\* @testOption(&quot;checker.nworkers&quot;, 2)
TestExec_n0_n1_with_options ==
    TestExec_n0_n1

</code></pre>
<p>The test options in the above example have the following meaning:</p>
<ul>
<li>
<p>The annotation <code>testOption(&quot;tool&quot;, &quot;apalache&quot;)</code> runs the test only if it is
executed in Apalache. For example, if we run this test in TLC, it should be
ignored.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;search.smt.timeout&quot;, 10)</code> sets the tool-specific
option <code>search.smt.timeout</code> to 10, meaning that the SMT solver should time
out if it cannot solve a problem in 10 seconds.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.algo&quot;, &quot;offline&quot;)</code> sets the tool-specific
option <code>checker.algo</code> to <code>offline</code>, meaning that the model checker should
use the offline solver instead of the incremental one.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.nworkers&quot;, 2)</code> sets the tool-specific
option <code>checker.nworkers</code> to <code>2</code>, meaning that the model checker should
use two cores.</p>
</li>
</ul>
<p>By having all test options specified directly in tests, we reach two goals:</p>
<ul>
<li>We let the users to save their experimental setup, to enable reproducibility
of the experiments and later re-design of specifications.</li>
<li>We let the engineers integrate TLA+ tests in continuous integration, to
make sure that updates in a specification do not break the tests.
This would allow us to integrate TLA+ model checkers in a CI/CD loop,
e.g., at GitHub.</li>
</ul>
<h2><a class="header" href="#7-what-do-you-think" id="7-what-do-you-think">7. What do you think?</a></h2>
<p>Let us know:</p>
<ul>
<li>
<p>At <a href="https://informal-systems.zulipchat.com/#narrow/stream/265309-apalache">Apalache Zulip stream</a>,</p>
</li>
<li>
<p>On <a href="https://twitter.com/ApalacheTLA">ApalacheTLA Twitter</a>,</p>
</li>
<li>
<p>email: igor at informal.systems.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../adr/004adr-annotations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../adr/004adr-annotations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
