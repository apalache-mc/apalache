<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apalache Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="apalache/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="apalache/getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/apalache-or-tlc.html"><strong aria-hidden="true">2.1.</strong> Shall I use Apalache or TLC?</a></li><li class="chapter-item expanded "><a href="apalache/system-reqs.html"><strong aria-hidden="true">2.2.</strong> System Requirements</a></li><li class="chapter-item expanded "><a href="apalache/installation/index.html"><strong aria-hidden="true">2.3.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/installation/jvm.html"><strong aria-hidden="true">2.3.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="apalache/installation/docker.html"><strong aria-hidden="true">2.3.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="apalache/installation/source.html"><strong aria-hidden="true">2.3.3.</strong> Source</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/running.html"><strong aria-hidden="true">2.4.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="apalache/statistics.html"><strong aria-hidden="true">2.5.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="apalache/example.html"><strong aria-hidden="true">2.6.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="apalache/parameters.html"><strong aria-hidden="true">2.7.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="apalache/principles.html"><strong aria-hidden="true">2.8.</strong> Principles of Symbolic Model Checking with Apalache</a></li><li class="chapter-item expanded "><a href="apalache/apalache-mod.html"><strong aria-hidden="true">2.9.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="apalache/profiling.html"><strong aria-hidden="true">2.10.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="apalache/theory.html"><strong aria-hidden="true">2.11.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/tlc-config.html"><strong aria-hidden="true">3.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="apalache/types-and-annotations.html"><strong aria-hidden="true">4.</strong> Types and Annotations</a></li><li class="chapter-item expanded "><a href="apalache/typechecker-snowcat.html"><strong aria-hidden="true">5.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="apalache/features.html"><strong aria-hidden="true">6.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="apalache/preprocessing.html"><strong aria-hidden="true">7.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="apalache/tuning.html"><strong aria-hidden="true">8.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="apalache/kera.html"><strong aria-hidden="true">9.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded "><a href="apalache/assignments.html"><strong aria-hidden="true">10.</strong> Assignments in Apalache</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">11.</strong> How to write type annotations</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="lang/index.html"><strong aria-hidden="true">12.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="lang/standard-operators.html"><strong aria-hidden="true">13.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/booleans.html"><strong aria-hidden="true">13.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="lang/control-and-nondeterminism.html"><strong aria-hidden="true">13.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="lang/conditionals.html"><strong aria-hidden="true">13.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="lang/integers.html"><strong aria-hidden="true">13.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="lang/sets.html"><strong aria-hidden="true">13.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="lang/logic.html"><strong aria-hidden="true">13.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="lang/functions.html"><strong aria-hidden="true">13.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="lang/records.html"><strong aria-hidden="true">13.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="lang/tuples.html"><strong aria-hidden="true">13.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="lang/sequences.html"><strong aria-hidden="true">13.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="lang/user-operators.html"><strong aria-hidden="true">14.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/user/top-level-operators.html"><strong aria-hidden="true">14.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/let-in.html"><strong aria-hidden="true">14.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="lang/user/higher-order-operators.html"><strong aria-hidden="true">14.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="lang/user/lambdas.html"><strong aria-hidden="true">14.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/recursive-operators.html"><strong aria-hidden="true">14.5.</strong> Recursive operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/local-operators.html"><strong aria-hidden="true">14.6.</strong> Local operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/recursive-functions.html"><strong aria-hidden="true">14.7.</strong> Recursive functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="idiomatic/index.html"><strong aria-hidden="true">16.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">17.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="idiomatic/001assignments.html"><strong aria-hidden="true">18.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="idiomatic/002primes.html"><strong aria-hidden="true">19.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="adr/002adr-types.html"><strong aria-hidden="true">20.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="adr/004adr-annotations.html"><strong aria-hidden="true">21.</strong> ADR-004: code annotations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>This book collects four related, but independent, sets of documentation:</p>
<ol>
<li><a href="./apalache/index.html">The Apalache User Manual</a></li>
<li><a href="./HOWTOs/index.html">HOWTOs</a></li>
<li><a href="./lang/index.html">A TLA+ Language Reference Manual</a></li>
<li><a href="./idiomatic/index.html">Guidelines for Idiomatic TLA+</a></li>
</ol>
<h1><a class="header" href="#apalache-manual" id="apalache-manual">Apalache Manual</a></h1>
<p><strong>Authors: Igor Konnov, Jure Kukovec, Andrey Kuprianov, Shon Feder</strong></p>
<p><strong>Contact: {igor,andrey,shon} at informal.systems, jkukovec at forsyte.at</strong></p>
<p>Apalache is a symbolic model checker for
<a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+</a>. (<em>Still looking for a
better tool name.</em>) Our model checker is a recent alternative to
<a href="https://lamport.azurewebsites.net/tla/tools.html?unhideBut=hide-tlc&amp;unhideDiv=tlc">TLC</a>.
Whereas TLC enumerates the states produced by the behaviors of a TLA+
specification, Apalache translates the verification problem to a set of logical
constraints. These constraints are solved by an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT
solver</a>, for
instance, by <a href="https://github.com/Z3Prover/z3">Microsoft's Z3</a>. That is, Apalache
operates on formulas (i.e., <em>symbolicly</em>), not by enumerating states one by one
(i.e., <em>state enumeration</em>).</p>
<p>Apalache is working under the following assumptions:</p>
<ol>
<li>As in TLC, all specification parameters are fixed and finite, i.e., the
system state is initialized with integers, finite sets, and functions of
finite domains and co-domains.</li>
<li>As in TLC, all data structures evaluated during an execution are finite,
e.g., a system specification cannot operate on the set of all integers.</li>
<li>Only finite executions of bounded length are analyzed.</li>
</ol>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This section covers all the basic information you need to get started with the
Apalache model checker.</p>
<p>If you just need to get the model checker up and running, you can jump to</p>
<ul>
<li><a href="apalache/./installation/index.html">Installation</a></li>
<li><a href="apalache/./running.html">Running the Tool</a></li>
</ul>
<h1><a class="header" href="#shall-i-use-apalache-or-tlc" id="shall-i-use-apalache-or-tlc">Shall I use Apalache or TLC?</a></h1>
<p>We recommend starting with TLC. It is mature, well-documented, and
well-integrated into TLA+ Toolbox. Once you have debugged your TLA+
specification, and TLC is still producing too many reachable states, switch to
Apalache. We are using this approach at <a href="https://informal.systems/">Informal
Systems</a>.</p>
<h1><a class="header" href="#system-requirements" id="system-requirements">System requirements</a></h1>
<p>Every commit to <a href="https://github.com/informalsystems/apalache">master</a> and
<a href="https://github.com/informalsystems/apalache/tree/unstable">unstable</a> is built
with <a href="https://github.com/informalsystems/apalache/actions?query=branch%3Aunstable+workflow%3Abuild">GitHub
actions</a>
on MacOS (JDK 1.8.0) and Linux (OpenJDK8). If you would like to run Apalache in
Windows, use a docker image. Check the <a href="https://docs.docker.com/docker-for-windows/">Docker
manual</a> and the section on <a href="apalache/./installation/docker.html">Using
a docker image</a> for details.</p>
<p>As Apalache is using Microsoft Z3 as a backend SMT solver, the required memory
largely depends on Z3. We recommend to allocate at least 4GB of memory for the
tool.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>There are three ways to run Apalache:</p>
<ol>
<li><a href="apalache/installation/./jvm.html">JVM</a>: download a prebuilt package and run it in the JVM.</li>
<li><a href="apalache/installation/./docker.html">Docker</a>: download and run a Docker image.</li>
<li><a href="apalache/installation/./source.html">Source</a>: build Apalache from sources and run the compiled package.</li>
</ol>
<p>If you just want to try the tool, we recommend <a href="apalache/installation/./jvm.html">downloading the
release</a> or <a href="apalache/installation/./docker.html">pulling the docker image</a>. If you would like
to run the tool on a daily basis or <a href="https://github.com/informalsystems/apalache/blob/unstable/CONTRIBUTING.md">contribute</a> to the project, we recommend
<a href="apalache/installation/./source.html">building the project from the source</a>.</p>
<h1><a class="header" href="#running-in-java-virtual-machine" id="running-in-java-virtual-machine">Running in Java Virtual Machine</a></h1>
<p>You have to download and install a Java Virtual Machine first. For instance,
<a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> should work (we tried Apalache with
OpenJDK 11 and OpenJDK 15).</p>
<p>Once you have installed Java, download the <a href="https://github.com/informalsystems/apalache/releases">latest
release</a> and unpack into
a directory of your choice. Depending on your OS, you have two options.</p>
<p><em>Option 1: Linux, MacOS.</em> You can run the script <code>./bin/apalache-mc</code>. It is
that simple.</p>
<p><em>Option 2: Windows.</em> You have to run Java directly:</p>
<ul>
<li>
<p>Check the application name in the directory <code>mod-distribution\target</code>.
It should be called <code>apalache-pkg-X.Y.Z-RELEASE-full.jar</code>, where <code>X.Y.Z</code>
is the release number, for instance, 0.8.0.</p>
</li>
<li>
<p>Run Java as follows:</p>
</li>
</ul>
<pre><code>java.exe -jar mod-distribution\target\apalache-pkg-X.Y.Z-RELEASE-full.jar &lt;args&gt;
</code></pre>
<p>The arguments <code>&lt;args&gt;</code> are explained in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
<p>If you would like to contribute a command-line script for running Apalache in
Windows, please <a href="https://github.com/informalsystems/apalache/blob/unstable/CONTRIBUTING.md#making-a-pull-request">open a pull
request</a>.</p>
<h1><a class="header" href="#using-a-docker-image" id="using-a-docker-image">Using a docker image</a></h1>
<p><strong>We publish Docker images for every release</strong> üòé</p>
<p><a href="https://www.docker.com/">Docker</a> lets you to run Apalache in an isolated container.
All dependencies are already installed in docker. However, you have to install docker.</p>
<p>To get the latest Apalache image, issue the command:</p>
<pre><code class="language-bash">docker pull apalache/mc
</code></pre>
<h2><a class="header" href="#running-the-docker-image" id="running-the-docker-image">Running the docker image</a></h2>
<p>To run an Apalache image, issue the command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache apalache/mc &lt;args&gt;
</code></pre>
<p>The following docker parameters are used:</p>
<ul>
<li>
<p><code>--rm</code> to remove the container on exit</p>
</li>
<li>
<p><code>-v &lt;your-spec-directory&gt;:/var/apalache</code> bind-mounts <code>&lt;your-spec-directory&gt;</code> into
<code>/var/apalache</code> in the container. <strong>This is necessary for
Apalache to access your specification and the modules it
extends.</strong>
From the user perspective, it works as if Apalache was
executing in <code>&lt;your-spec-directory&gt;</code>.
In particular the tool logs are written in that directory.</p>
<p>When using SELinux, you might have to use the modified form of <code>-v</code> option:
<code>-v &lt;your-spec-directory&gt;:/var/apalache:z</code></p>
</li>
<li>
<p><code>apalache/mc</code> is the APALACHE docker image name. By default, the <code>latest</code> stable
version is used; you can also refer to a specific tool version, e.g., <code>apalache/mc:0.6.0</code> or <code>apalache/mc:unstable</code></p>
</li>
<li>
<p><code>&lt;args&gt;</code> are the tool arguments as described in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
</li>
</ul>
<p>We provide a convenience wrapper for this docker command in
<code>script/run-docker.sh</code>. To run the <code>latest</code> image using the script, execute</p>
<pre><code class="language-bash">$ $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<p>To specify a different image, set <code>APALACHE_TAG</code> like so:</p>
<pre><code class="language-bash">$ APALACHE_TAG=foo $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<h2><a class="header" href="#setting-an-alias" id="setting-an-alias">Setting an alias</a></h2>
<p>If you are running Apalache on Linux üêß or MacOS
üçè, you can define this handy alias in your rc file, which runs
Apalache in docker while sharing the working directory:</p>
<pre><code class="language-bash">
###### using the latest stable

$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc'

###### using the latest unstable

$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc:unstable'
</code></pre>
<h2><a class="header" href="#using-the-unstable-version-of-apalache" id="using-the-unstable-version-of-apalache">Using the unstable version of Apalache</a></h2>
<p>The development of Apalache proceeds at a high pace, and we introduce a
substantial number of improvements in the unstable branch before the next stable
release. Please refer to the <a href="https://github.com/informalsystems/apalache/blob/unstable/CHANGES.md">change
log</a> and
<a href="https://github.com/informalsystems/apalache/blob/unstable/docs/src/manual.md">manual</a>
on the unstable branch for the description of the newest features. <strong>We
recommend using the unstable version if you want to try all the exciting new
features of Apalache. But be warned: It is called &quot;unstable&quot; for a reason</strong>. To
use <code>unstable</code>, just type <code>apalache/mc:unstable</code> instead of <code>apalache/mc</code>
everywhere.</p>
<p>Do not forget to pull the docker image from time to time:</p>
<pre><code class="language-bash">docker pull apalache/mc:unstable
</code></pre>
<p>Run it with the following command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache apalache/mc:unstable &lt;args&gt;
</code></pre>
<p>To create an alias pointing to the <code>unstable</code> version:</p>
<pre><code class="language-bash">$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc:unstable'
</code></pre>
<h2><a class="header" href="#building-an-image" id="building-an-image">Building an image</a></h2>
<p>For an end user there is no need to build an Apalache image. If you like to
produce a modified docker image, take into account that it will take about 30
minutes for the image to get built, due to compilation times of Microsoft Z3. To
build a docker image of Apalache, issue the following command in
<code>$APALACHE_HOME</code>:</p>
<pre><code class="language-bash">$ docker image build -t apalache:0.7.0 .
</code></pre>
<h1><a class="header" href="#building-from-source" id="building-from-source">Building from source</a></h1>
<ol>
<li>Install <code>git</code>.</li>
<li>Install <a href="https://openjdk.java.net/install/">OpenJDK8</a> or <a href="https://www.azul.com/downloads/zulu-community/?version=java-8-lts&amp;architecture=x86-64-bit&amp;package=jdk">Zulu JDK8</a>.
<ul>
<li>Apalache currently requires Scala 12.0 so <strong>you must install version 8 of
Java, otherwise Scala will not compile!</strong> See the <a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">compatibility table</a>.</li>
</ul>
</li>
<li>Install <a href="https://maven.apache.org/">Apache Maven</a>.
<ul>
<li>On Debian Linux or Ubuntu: <code>sudo apt-get install maven</code>.</li>
<li>On Arch: <code>sudo pacman -Syu maven</code></li>
</ul>
</li>
<li>Clone the git repository: <code>git clone https://github.com/informalsystems/apalache.git</code>.</li>
<li>Change into the project directory: <code>cd apalache</code>.</li>
<li>Run <code>make</code>.
<ul>
<li>For a slightly faster build, you can run <code>make apalache-jar</code></li>
</ul>
</li>
<li><em>Optionally</em> install <a href="https://direnv.net/">direnv</a> and run <code>direnv allow</code></li>
<li>Confirm you can run the executable. It should print the inline CLI help message.
<ul>
<li>If you used <code>direnv</code>, then <code>apalache-mc</code> will be in your path.</li>
<li>Otherwise, run <code>./bin/apalache-mc</code>.</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#running-the-tool" id="running-the-tool">Running the Tool</a></h1>
<p><strong>Opt-in statistics programme</strong>: if you opt-in for statistics collection (off by default), then every run of Apalache
will submit anonymized statistics to
<code>tlapl.us</code>. See the details in <a href="apalache/./statistics.html">TLA+ Anonymized Execution Statistics</a>.</p>
<h2><a class="header" href="#model-checker-command-line-parameters" id="model-checker-command-line-parameters">Model checker command-line parameters</a></h2>
<p>The model checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache check [--config=filename] [--init=Init] [--cinit=ConstInit] \
    [--next=Next] [--inv=Inv] [--length=10] [--algo=(incremental|offline)] \
    [--discard-disabled] [--no-deadlock] [--tuning=filename] [--tune-here=options] \
    &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>
<p>General parameters:</p>
<ul>
<li><code>--config</code> specifies the <a href="apalache/./tlc-config.html">TLC configuration file</a>, the default name is <code>&lt;myspec&gt;.cfg</code></li>
<li><code>--init</code> specifies the initialization predicate, <em><code>Init</code> by default</em></li>
<li><code>--next</code> specifies the transition predicate, <em><code>Next</code> by default</em></li>
<li><code>--cinit</code> specifies the constant initialization predicate, <em>optional</em></li>
<li><code>--inv</code> specifies the invariant to check, <em>optional</em></li>
<li><code>--length</code> specifies the maximal number of <code>Next</code> steps, <em>10 by default</em></li>
</ul>
</li>
<li>
<p>Advanced parameters:</p>
<ul>
<li><code>--algo</code> lets you to choose the search algorithm: <code>incremental</code> is using the incremental SMT solver, <code>offline</code> is
using the non-incremental
(offline) SMT solver</li>
<li><code>--discard-disabled</code> does a pre-check on transitions and discard the disabled ones at every step. If you know that
many transitions are always enabled, set it to false. Sometimes, this pre-check may be slower than checking the
invariant. Default: true.</li>
<li><code>--no-deadlock</code> disables deadlock-checking, when <code>--discard-disabled=false</code> is on. When <code>--discard-disabled=true</code>,
deadlocks are found in any case.</li>
<li><code>--tuning</code> specifies the properties file that stores the options for
<a href="apalache/tuning.html">fine tuning</a></li>
<li><code>--tuning-options=key1=val1:key2=val2:...</code> pass the tuning options right in the command line as a single string.
The options that are passed with the option <code>--tuning-options</code>
have priority over the options that are passed with the option <code>--tuning</code>.</li>
</ul>
</li>
</ul>
<p>If an initialization predicate, transition predicate, or invariant is specified both in the configuration file, and on
the command line, the command line parameters take precedence over those in the configuration file.</p>
<h3><a class="header" href="#bounded-model-checking" id="bounded-model-checking">Bounded model checking</a></h3>
<p>By default, Apalache performs <em>bounded model checking</em>, that is, it encodes a symbolic execution of length <code>k</code> and an
invariant violation in SMT:</p>
<pre><code class="language-tla">/\ Init[v_0/v]
/\ Next[v_0/v, v_1/v'] /\ Next[v_1/v, v_2/v'] /\ ... /\ Next[v_{k-1}/v, v_k/v']
/\ ~Inv[v_0/v] \/ ~Inv[v_1/v] \/ ... \/ ~Inv[v_k/v]
</code></pre>
<p>Here an expression <code>Inv[v_i/v]</code> means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the
state <code>i</code>. Likewise, <code>Next[v_i/v,v_{i+1}/v']</code>
means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the state <code>i</code>, whereas the state
variables <code>v'</code> are replaced with their copies
<code>v_{i+1}</code> for the state <code>i+1</code>.</p>
<h4><a class="header" href="#bounded-model-checking-is-an-incomplete-technique" id="bounded-model-checking-is-an-incomplete-technique">Bounded model checking is an incomplete technique</a></h4>
<p>If Apalache finds a bug in this symbolic execution (by querying z3), then it reports a counterexample. Otherwise, it
reports that no bug was found up to the given length. If a bug needs a long execution to get revealed, bounded model
checking may miss it!</p>
<h3><a class="header" href="#checking-an-inductive-invariant" id="checking-an-inductive-invariant">Checking an inductive invariant</a></h3>
<p>To check executions of arbitrary lengths, one usually finds a formula that satisfies the two following properties:</p>
<pre><code class="language-tla">/\ Init =&gt; TypeOK /\ IndInv
/\ TypeOK /\ IndInv /\ Next =&gt; TypeOK' /\ IndInv'
</code></pre>
<p>In normal words: (1) The initial states satisfy the constraint <code>TypeOK /\ IndInv</code>, and (2) whenever the specification makes a step when starting in a state that satisfies <code>TypeOK /\ IndInv</code>, it
ends up in a state that again satisfies <code>TypeOK /\ IndInv</code>.</p>
<p>Note that we usually check <code>IndInv</code> in conjunction with <code>TypeOK</code>, as we have to constrain the variable values. In
the <code>y2k</code> example, our inductive invariant is actually constraing the variables. In fact, such an inductive invariant is
usually called <code>TypeOK</code>.</p>
<p>To check an inductive invariant <code>IndInv</code> in Apalache, you run two commands that check the above two formulas:</p>
<pre><code class="language-bash">$ apalache check --init=Init --inv=IndInv --length=0 &lt;myspec&gt;.tla
</code></pre>
<p>and</p>
<pre><code class="language-bash">$ apalache check --init=IndInv --inv=IndInv --length=1 &lt;myspec&gt;.tla
</code></pre>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#checking-safety-up-to-20-steps" id="checking-safety-up-to-20-steps">Checking safety up to 20 steps</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache check --length=20 --inv=Safety y2k_override.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. If <code>Safety</code> is not violated, your spec
might still have a bug that requires a computation longer than 20 steps to manifest.</p>
<h3><a class="header" href="#checking-an-inductive-invariant-1" id="checking-an-inductive-invariant-1">Checking an inductive invariant:</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache check --length=0 --init=Init --inv=Inv y2k_override.tla
$ apalache check --length=1 --init=Inv  --inv=Inv y2k_override.tla
</code></pre>
<p>The first call to apalache checks, whether the initial states satisfy the invariant. The second call to apalache checks,
whether a single specification step satisfies the invariant, when starting in a state that satisfies the invariant. (
That is why these invariants are called inductive.)</p>
<h3><a class="header" href="#using-a-constant-initializer" id="using-a-constant-initializer">Using a constant initializer:</a></h3>
<pre><code class="language-bash">$ cd test/tla
apalache check --cinit=ConstInit --length=20 --inv=Safety y2k_cinit.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. The constants are initialized with the
predicate
<code>ConstInit</code>, defined in <code>y2k_cinit.tla</code> as:</p>
<pre><code class="language-tla">ConstInit == BIRTH_YEAR \in 0..99 /\ LICENSE_AGE \in 10..99
</code></pre>
<p>In this case, Apalache finds a safety violation, e.g., for
<code>BIRTH_YEAR=89</code> and <code>LICENSE_AGE=10</code>. A complete counterexample is printed in <code>counterexample.tla</code>.</p>
<p>The final lines in the file clearly indicate the state that violates the invariant:</p>
<pre><code class="language-tla">State14 ==
/\ BIRTH_YEAR = 89
/\ LICENSE_AGE = 10
/\ hasLicense = TRUE
/\ year = 0

(* The following formula holds true in the last state and violates the invariant *)

InvariantViolation == hasLicense /\ year - BIRTH_YEAR &lt; LICENSE_AGE
</code></pre>
<p><a name="lookup"></a></p>
<h2><a class="header" href="#module-lookup" id="module-lookup">Module lookup</a></h2>
<p>Apalache uses <a href="https://lamport.azurewebsites.net/tla/tools.html">the SANY parser</a>, which is the standard parser of TLC
and TLA+ Toolbox. By default, SANY is looking for the modules in the current working directory and in the Java package
<code>tla2sany.StandardModules</code>, which is usually provided by the <code>tla2tools.jar</code> that is included in the Java classpath.</p>
<p>In addition to the modules in the current working directory, Appalache provides</p>
<ul>
<li>a small standard library (located in <code>$APALACHE_HOME/src/tla</code>), and</li>
<li>support for additional source directories specified in the environment variable <code>TLA_PATH</code>. <code>TLA_PATH</code> should be a
list of paths to directories separated by <code>:</code>.</li>
</ul>
<p>(Directories in the <code>TLA_PATH</code> are provided to SANY via the <code>TLA-Library</code> Java system variable.)</p>
<p>So the module lookup order in Apalache is as follows:</p>
<ol>
<li>The current working directory.</li>
<li>The directory <code>$APALACHE_HOME/src/tla</code>.</li>
<li>The directories specified in the environment variable <code>TLA_PATH</code>.</li>
<li>The Java package <code>tla2sany.StandardModules</code>.</li>
</ol>
<p><strong>Note:</strong> To let TLA+ Toolbox and TLC know about the Apalache modules, include
<code>$APALACHE_HOME/src/tla</code> in the lookup directories, as explained by Markus Kuppe for
the <a href="https://github.com/tlaplus/CommunityModules">TLA+ Community Modules</a>.</p>
<p><a name="detailed"></a></p>
<h2><a class="header" href="#detailed-output" id="detailed-output">Detailed output</a></h2>
<p>The tool will display only important messages on stdout, but a detailed log can be found in <code>detailed.log</code>.</p>
<p>Additionally, each pass of the model checker produces an intermediate TLA+ file in the run-specific
directory <code>x/hh.mm-DD.MM.YYYY-&lt;id&gt;</code>:</p>
<ul>
<li>File <code>out-parser.tla</code> is produced as a result of parsing and importing into the intermediate representation, Apalache
TLA IR.</li>
<li>File <code>out-parser.json</code> is produced as a result of converting the Apalache TLA IR representation of the input into JSON
format.</li>
<li>File <code>out-config.tla</code> is produced as a result of substituting CONSTANTS, as described
in <a href="apalache/./parameters.html">Setting up specification parameters</a>.</li>
<li>File <code>out-inline.tla</code> is produced as a result of inlining operator definitions and <code>LET-IN</code> definitions.</li>
<li>File <code>out-priming.tla</code> is produced as a result of replacing constants and variables in <code>ConstInit</code> and <code>Init</code> with
their primed versions.</li>
<li>File <code>out-vcgen.tla</code> is produced as a result of extracting verification conditions, e.g., invariants to check.</li>
<li>File <code>out-prepro.tla</code> is produced as a result of running all preprocessing steps.</li>
<li>File <code>out-transition.tla</code> is produced as a result of finding assignments and symbolic transitions.</li>
<li>File <code>out-opt.tla</code> is produced as a result of expression optimizations.</li>
<li>File <code>out-analysis.tla</code> is produced as a result of analysis, e.g., marking Skolemizable expressions and expressions to
be expanded.</li>
</ul>
<p><a name="parsing"></a></p>
<h2><a class="header" href="#parsing-and-pretty-printing" id="parsing-and-pretty-printing">Parsing and pretty-printing</a></h2>
<p>If you'd like to check that your TLA+ specification is syntactically correct, without running the model checker, you can
run the following command:</p>
<pre><code class="language-bash">$ apalache parse &lt;myspec&gt;.tla
</code></pre>
<p>In this case, Apalache performs the following steps:</p>
<ol>
<li>
<p>It parses the specification with <a href="https://lamport.azurewebsites.net/tla/tools.html">SANY</a>.</p>
</li>
<li>
<p>It translates SANY semantic nodes
into <a href="https://github.com/informalsystems/apalache/blob/master/tlair/src/main/scala/at/forsyte/apalache/tla/lir/package.scala">Apalache IR</a>
.</p>
</li>
<li>
<p>It pretty-prints the IR into <code>out-parser.tla</code>, see <a href="apalache/running.html#detailed">Detailed output</a>.</p>
</li>
</ol>
<h1><a class="header" href="#tla-anonymized-execution-statistics" id="tla-anonymized-execution-statistics">TLA+ Anonymized Execution Statistics</a></h1>
<p>Apalache participates in the optional <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a> along
with <a href="http://lamport.azurewebsites.net/tla/toolbox.html">TLA+ Toolbox</a>, TLC (which is part of the Toolbox), and <a href="https://marketplace.visualstudio.com/items?itemName=alygin.vscode-tlaplus">Visual Studio
Code Plugin for TLA+</a>.</p>
<p>The statistics collection is <strong>never enabled by default</strong>. You have to <strong>opt-in</strong>
for the programme either in TLA+ Toolbox, or in Apalache. When statistics
collection is enabled by the user, it is submitted to <code>tlapl.us</code> via the
util.<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.java">ExecutionStatisticsCollector</a>, which is part of <code>tla2tools.jar</code>. Apalache
accesses this class in at.forsyte.apalache.tla.<a href="https://github.com/informalsystems/apalache/blob/unstable/mod-tool/src/main/scala/at/forsyte/apalache/tla/Tool.scala">Tool</a>.</p>
<p>As explained in <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a>, if you never create the file
<code>$HOME/.tlaplus/esc.txt</code>, then the statistics is not submitted to <code>tlapl.us</code>.
If you opt-in for the programme and later remove the file, then the statistics
will not be submitted too.</p>
<h2><a class="header" href="#why-do-we-ask-you-to-help-us" id="why-do-we-ask-you-to-help-us">Why do we ask you to help us</a></h2>
<p>There are several reasons:</p>
<ul>
<li>
<p>Although our project is open source, developing Apalache is our main job.
We are grateful to <a href="https://informal.systems">Informal Systems</a> for supporting us and to <a href="https://www.tuwien.at/">TU Wien</a>,
<a href="https://www.wwtf.at/index.php?lang=EN">Vienna Science and Technology Fund</a>, and <a href="https://www.inria.fr/en/centre-inria-nancy-grand-est">Inria Nancy/LORIA</a>, who
supported us in the past.  It is easier to convince our decision makers to
continue the development, if we have clear feedback on how many people
<strong>use and need Apalache</strong>.</p>
</li>
<li>
<p>We would like to know which features you are using most, so we can focus on
them.</p>
</li>
<li>
<p>We would like to know which operating systems and Java versions need care
and better be included in automated test suites.</p>
</li>
</ul>
<h2><a class="header" href="#how-to-opt-in-and-opt-out" id="how-to-opt-in-and-opt-out">How to opt-in and opt-out</a></h2>
<p>To opt-in in the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=true
</code></pre>
<p>As a result of this command, a random identifier is written in
<code>$HOME/.tlaplus/esc.txt</code>. This identifier is used by the execution statistics
code.</p>
<p>To opt-out from the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=false
</code></pre>
<h2><a class="header" href="#what-exactly-is-submitted-to-tlaplus" id="what-exactly-is-submitted-to-tlaplus">What exactly is submitted to tlapl.us</a></h2>
<p>You can check the daily log at <a href="https://exec-stats.tlapl.us/">exec-stats.tlapl.us</a>.</p>
<p>The following data is submitted for each run, if you have opted in:</p>
<ul>
<li>Total number of CPU cores and cores assigned
(the latter is 1 for now, but will change soon)</li>
<li>Java heap memory size (in Megabytes)</li>
<li>Apalache version (semantic version + build)</li>
<li>Command mode: <code>parse</code>, <code>check</code>, or <code>typecheck</code></li>
<li>Name, version, and architecture of the OS</li>
<li>Vendor, version, and architecture of JVM</li>
<li>Timestamp + salt (a random number to make time less precise)</li>
<li>An installation ID that is stored in <code>$HOME/.tlaplus/esc.txt</code></li>
</ul>
<h1><a class="header" href="#an-example-of-a-tla-specification" id="an-example-of-a-tla-specification">An example of a TLA+ specification</a></h1>
<p>To illustrate the features of Apalache, we use the following TLA+ specification,
which can be found in <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a>:</p>
<pre><code class="language-tla">-------------------------------- MODULE y2k --------------------------------
(*
 * A simple specification of a year counter that is subject to the Y2K problem.
 * In this specification, a registration office keeps records of birthdays and
 * issues driver's licenses. As usual, a person may get a license, if they
 * reached a certain age, e.g., age of 18. The software engineers never thought
 * of their program being used until the next century, so they stored the year
 * of birth using only two digits (who would blame them, the magnetic tapes
 * were expensive!). The new millenium came with new bugs.
 *
 * This is a made up example, not reflecting any real code.
 * To learn more about Y2K, check: https://en.wikipedia.org/wiki/Year_2000_problem
 *
 * Igor Konnov, January 2020
 *)

EXTENDS Integers
 
CONSTANT BIRTH_YEAR,    \* the year to start with, between 0 and 99
         LICENSE_AGE    \* the minimum age to obtain a license
         
ASSUME(BIRTH_YEAR \in 0..99)              
ASSUME(LICENSE_AGE \in 1..99)              
 
VARIABLE year, hasLicense

Age == year - BIRTH_YEAR 

Init ==
    /\ year = BIRTH_YEAR
    /\ hasLicense = FALSE
    
NewYear ==
    /\ year' = (year + 1) % 100 \* the programmers decided to use two digits
    /\ UNCHANGED hasLicense
    
IssueLicense ==
    /\ Age &gt;= LICENSE_AGE
    /\ hasLicense' = TRUE
    /\ UNCHANGED year
    
Next ==
    \/ NewYear
    \/ IssueLicense

\* The somewhat &quot;obvious&quot; invariant, which is violated    
Safety ==
    hasLicense =&gt; (Age &gt;= LICENSE_AGE)

\* This is probably the only invariant we can formulate, usually, it is called TypeOK    
Inv ==
    /\ year \in 0..99
    /\ hasLicense \in BOOLEAN

=============================================================================
</code></pre>
<pre><code></code></pre>
<h1><a class="header" href="#setting-up-specification-parameters" id="setting-up-specification-parameters">Setting up specification parameters</a></h1>
<p>Similar to TLC, Apalache requires the specification parameters to be restricted
to finite values. In contrast to TLC, there is a way to initialize parameters
by writing a symbolic constraint, see <a href="apalache/parameters.html#ConstInit">Section 5.3</a>.</p>
<h2><a class="header" href="#using-instance" id="using-instance">Using INSTANCE</a></h2>
<p>You can set the specification parameters, using the standard <code>INSTANCE</code>
expression of TLA+. For instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_instance.tla"><code>y2k_instance.tla</code></a>,
which instantiates <code>y2k.tla</code>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_instance ----------------------------
(*
 * Another way to instantiate constants for apalache is to
 * use INSTANCE.
 *)
 
VARIABLE year, hasLicense

INSTANCE y2k WITH BIRTH_YEAR &lt;- 80, LICENSE_AGE &lt;- 18

=============================================================================
</code></pre>
<p>The downside of this approach is that you have to declare the variables of the
extended specification. This is easy with only two variables, but can quickly
become unwieldy.</p>
<h2><a class="header" href="#convention-over-configuration" id="convention-over-configuration">Convention over configuration</a></h2>
<p>Alternatively, you can extend the base module and use overrides:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_override ----------------------------
(*
 * One way to instantiate constants for apalache is to use the OVERRIDE prefix. 
 *)
 
EXTENDS y2k

OVERRIDE_BIRTH_YEAR == 80
OVERRIDE_LICENSE_AGE == 18

=============================================================================
</code></pre>
<p><a name="ConstInit"></a></p>
<h2><a class="header" href="#constinit-predicate" id="constinit-predicate">ConstInit predicate</a></h2>
<p>This approach is similar to the <code>Init</code> operator, but applied to the
constants. We define a special operator, e.g., called <code>ConstInit</code>. For
instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_cinit.tla"><code>y2k_cinit.tla</code></a>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_cinit ----------------------------
(*
 * Another way to instantiate constants for apalache is give it constraints
 * on the constants.
 *)
 
EXTENDS y2k

ConstInit ==
    /\ BIRTH_YEAR \in 0..99
    /\ LICENSE_AGE \in 10..99

=============================================================================
</code></pre>
<p>To use <code>ConstInit</code>, pass it as the argument to <code>apalache</code>. For instance, for
<code>y2k_cinit</code>, we would run the model checker as follows:</p>
<pre><code class="language-tla">$ cd $APALACHE_HOME/test/tla
$ apalache check --inv=Safety \
  --length=20 --cinit=ConstInit y2k_cinit.tla
</code></pre>
<h3><a class="header" href="#parameterized-initialization" id="parameterized-initialization">Parameterized initialization</a></h3>
<p>As a bonus of this approach, Apalache allows one to check a specification over a
bounded set of parameters. For example:</p>
<pre><code class="language-tla">CONSTANT N, Values

ConstInit ==
  /\ N \in 3..10
  /\ Values \in SUBSET 0..4
  /\ Values /= {}
</code></pre>
<p>The model checker will try the instances for all the combinations of
the parameters specified in <code>ConstInit</code>, that is, in our example, it will
consider <code>N \in 3..10</code> and all non-empty value sets that are subsets of <code>0..4</code>.</p>
<h3><a class="header" href="#limitation" id="limitation">Limitation</a></h3>
<p><code>ConstInit</code> should be a conjunction of assignments and possibly of additional
constraints on the constants. For instance, you should not write <code>N = 10 \/ N = 20</code>. However, you can write <code>N \in {10, 20}</code>.</p>
<h2><a class="header" href="#tlc-configuration-file" id="tlc-configuration-file">TLC configuration file</a></h2>
<p>We support configuring Apalache via TLC configuration files; these files are
produced automatically by TLA Toolbox, for example. TLC configuration files
allow one to specify which initialization predicate and transition predicate to
employ, which invariants to check, as well as to initialize specification
parameters. Some features of the TLC configuration files are not supported yet.
Check the manual page on <a href="apalache/./tlc-config.html">&quot;Syntax of TLC Configuration Files&quot;</a>.</p>
<p><em>If you are checking a file <code>&lt;myspec&gt;.tla</code>, and the file <code>&lt;myspec&gt;.cfg</code> exists in
the same directory, it will be picked up by Apalache automatically. You can also
explicitly specify which configuration file to use via the <code>--config</code> option.</em></p>
<h1><a class="header" href="#principles-of-symbolic-model-checking-with-apalache" id="principles-of-symbolic-model-checking-with-apalache">Principles of Symbolic Model Checking with Apalache</a></h1>
<p>In order to take advantage of Apalache's symbolic model checking, there are a
few principles one must bear in mind when writing TLA.</p>
<p><a name="assignments"></a>
<a name="symbolicTransitions"></a></p>
<h2><a class="header" href="#assignments-and-symbolic-transitions" id="assignments-and-symbolic-transitions">Assignments and symbolic transitions</a></h2>
<p>Let us go back to the example <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a> and
run <code>apalache</code> against <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_override.tla"><code>test/tla/y2k_override.tla</code></a>:</p>
<pre><code class="language-console">$ apalache check y2k_override.tla
</code></pre>
<p>We can check the detailed output of the <code>TransitionFinderPass</code> in the file
<code>x/&lt;timestamp&gt;/out-transition.tla</code>, where <code>&lt;timestamp&gt;</code> looks like
<code>09.03-10.03.2020-508266549191958257</code>:</p>
<pre><code class="language-tla">----- MODULE y2k_override -----
VARIABLE year
VARIABLE hasLicense
ASSUME(80 \in 0 .. 99)
ASSUME(18 \in 1 .. 99)

Init$0 == year' := 80 /\ hasLicense' := FALSE
Next$0 == year' := ((year + 1) % 100) /\ (hasLicense' := hasLicense)
Next$1 == year - 80 &gt;= 18 /\ hasLicense' := TRUE /\ (year' := year)
===============
</code></pre>
<p>As you can see, the model checker did two things:</p>
<ol>
<li>It has translated several expressions that look like <code>x' = e</code> into <code>x' := e</code>.
For instance, you can see <code>year' := 80</code> and <code>hasLicense' := FALSE</code> in
<code>Init$0</code>. We call these expressions <strong>assignments</strong>.</li>
<li>It has factored the operator <code>Next</code> into two operators <code>Next$0</code> and <code>Next$1</code>.
We call these operators <strong>symbolic transitions</strong>.</li>
</ol>
<p>Pure TLA+ does not have the notions of assignments and symbolic
transitions.  However, TLC sometimes treats expressions <code>x' = e</code> and <code>x' \in S</code>
as if they were assigning a value to the variable <code>x'</code>. TLC does so
dynamically, during the breadth-first search. Apalache looks statically for assignments
among the expressions <code>x' = e</code> and <code>x' \in S</code>.</p>
<p>When factoring out operators into symbolic transitions, Apalache splits the
action operators <code>Init</code> and <code>Next</code> into disjunctions (e.g., <code>A_0 \/ ... \/ A_n</code>),
represented in the concrete syntax as a sequence of operator definitions of the
form</p>
<pre><code class="language-tla">A$0 == ...
...
A$n == ...
</code></pre>
<p>The main contract between the assignments and symbolic transitions is as
follows:</p>
<blockquote>
<p>For every variable <code>x</code> declared with <code>VARIABLE</code>, there is exactly one
assignment of the form <code>x' := e</code> in every symbolic transition <code>A_n</code>.</p>
</blockquote>
<p>If Apalache cannot find expressions with the above properties, it fails.
Consider the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Assignments20200309.tla"><code>test/tla/Assignments20200309.tla</code></a>:</p>
<pre><code class="language-tla">----- MODULE Assignments20200309 -----
VARIABLE a
\* this specification fails, as it has no expression
\* that can be treated as an assignment
Init == TRUE
Next == a' = a
Inv == FALSE
===============
</code></pre>
<p>Running the checker with</p>
<pre><code class="language-bash">apalache check Assignments20200309.tla
</code></pre>
<p>Apalache reports an error as follows:</p>
<pre><code class="language-console">...
PASS #6: TransitionFinderPass                                     I@09:39:33.527
To understand the error, check the manual:
[https://github.com/informalsystems/apalache/blob/unstable/docs/src/manual.md#assignments]
Assignment error: Failed to find assignments and symbolic transitions in InitPrimed E@09:39:33.676
It took me 0 days  0 hours  0 min  1 sec                          I@09:39:33.678
Total time: 1.88 sec                                              I@09:39:33.678
EXITCODE: ERROR (99)
</code></pre>
<p>This error is cryptic. It does not indicate which parts of the specification
have caused the problem. In the future, we will add better diagnostic in the
assignment finder, see <a href="https://github.com/informalsystems/apalache/issues/111">the open
issue</a>. Our current approach is
to debug assignments by running TLC first. If running TLC takes too long, you
may try to comment out parts of the specification to find the problematic
action. Although this is tedious, it allows one to find missing assignments
rather quickly.</p>
<p>If you are interested in the technique for finding the assignments and symbolic
transitions implemented in Apalache, check our <a href="http://forsyte.at/wp-content/uploads/abz2018_full.pdf">paper at
ABZ'18</a>.  The <a href="http://dx.doi.org/https://doi.org/10.1016/j.scico.2019.102361">journal
version</a> is
unfortunately behind the Elsevier paywall, which will be lifted after the
two-year embargo period.</p>
<p><a name="types"></a></p>
<h2><a class="header" href="#type-annotations" id="type-annotations">Type annotations</a></h2>
<p><strong>NOTE 1</strong>: <a href="https://forsyte.at/people/kukovec/">Jure Kukovec</a> is developing
a completely automatic type inference engine. As soon as it is ready, type
annotations will no longer be required. Until that happy day, refer to <a href="apalache/types-and-annotations.html">type
annotations</a>.</p>
<p><strong>NOTE 2</strong>: We are currently working on a better syntax for type annotations
and a better type checker. Hence, the syntax will change in the future.</p>
<p>Apalache requires two kinds of type annotations:</p>
<ul>
<li>type annotations for empty sets and sequences, and</li>
<li>type annotations for records and sets of records.</li>
</ul>
<h3><a class="header" href="#empty-sets-and-sequences" id="empty-sets-and-sequences">Empty sets and sequences</a></h3>
<p>Consider the following example <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/NeedForTypes.tla"><code>NeedForTypes.tla</code></a>:</p>
<pre><code class="language-tla">------------------------ MODULE NeedForTypes ------------------------------
(**
 * This simple example transforms a set into a sequence.
 *)
EXTENDS Integers, Sequences, FiniteSets

CONSTANTS InSet     \* an input set
VARIABLES Left,     \* a storage for the yet untransformed elements
          OutSeq    \* the output sequence

ConstInit == InSet = 1..4

Init ==
    /\ OutSeq = &lt;&lt; &gt;&gt;
    /\ Left = InSet

Next ==
    IF Left = {}
    THEN UNCHANGED &lt;&lt;Left, OutSeq&gt;&gt;
    ELSE \E x \in Left:
          /\ OutSeq' = Append(OutSeq, x)
          /\ Left' = Left \ {x}

Inv == InSet = Left \union { OutSeq[i]: i \in DOMAIN OutSeq }
===========================================================================
</code></pre>
<p>While this example is perfectly fine for TLC, Apalache has to assign types to
the variables, in order to construct SMT constraints. In some cases, Apalache
can infer types completely automatically, e.g., as in the <code>y2k</code> example (see
<a href="apalache/./example.html">the example</a>). However, if you run <code>apalache check --cinit=ConstInit NeedForTypes.tla</code>, the tool will complain:</p>
<pre><code>Step 0, level 0: checking if 1 transition(s) are enabled and violate the invariant I@15:17:14.313
Step 0, level 1: collecting 1 enabled transition(s)               I@15:17:14.360
Step 1, level 1: checking if 2 transition(s) are enabled and violate the invariant I@15:17:14.374
NeedForTypes.tla:18:8-18:16, =(...), type error: Expected equal types: FinSet[Int] and FinSet[Unknown] E@15:17:14.379
The outcome is: Error                                             I@15:17:14.388
</code></pre>
<p>In a somewhat obfuscated way, Apalache tells us the following. It has inferred
that <code>Left</code> is a set of integers, that is, <code>FinSet[Int]</code>. First, it found that
<code>InSet</code> is a set of integers, by applying <code>ConstInit</code>. Second, as <code>Left = InSet</code>
in <code>Init</code>, it inferred that <code>Left</code> is also a set of integers. Third, when
applying <code>Next</code>, it processed <code>{}</code>, which is an empty set of any kind of
objects. Hence, <code>{}</code> was assigned the type <code>FinSet[Unknown]</code>, that is, a set of
some type. Finally, it found the expression <code>Left = {}</code>, and here the type
checker has failed.</p>
<p>To help the type checker, we have to introduce a few type annotations. But
before doing that, we introduce the notation for type annotations in the
specification.</p>
<h4><a class="header" href="#syntax-for-type-annotations" id="syntax-for-type-annotations">Syntax for type annotations</a></h4>
<p>Apalache reads any expression formed with the <code>&lt;:</code> operator as an annotation of
the value of the left hand side with the type on the right. E.g.,</p>
<pre><code class="language-tla">v &lt;: T
</code></pre>
<p>means &quot;value <code>v</code> has type <code>T</code>&quot;.</p>
<p>However, other tools (such as TLC and TLAPS) have no support for these
annotations. To tell them to ignore type annotations, we maintain the convention
that any file using Apalache type annotations begins with the following definition:</p>
<pre><code class="language-tla">v &lt;: T == v
</code></pre>
<p>With this in place, Apalache can parse out the type annotations in the rest of
the file, but other tools are told to simply read any occurrence of <code>v &lt;: T</code> as
<code>v</code>, effectively erasing the type ascription.</p>
<p>Now we can help the type checker by rewriting the condition in <code>Next</code> as follows:</p>
<h4><a class="header" href="#example-of-using-type-annotations" id="example-of-using-type-annotations">Example of using type annotations</a></h4>
<pre><code class="language-tla">Next ==
    IF Left = {} &lt;: {Int}
    THEN ...
    ELSE ...
</code></pre>
<p>Now the type checker treats the expression <code>{}</code> as a set of integers. However,
it complains about another line:</p>
<pre><code>Step 0, level 0: checking if 1 transition(s) are enabled and violate the invariant I@15:43:35.932
Step 0, level 1: collecting 1 enabled transition(s)               I@15:43:35.977
Step 1, level 1: checking if 2 transition(s) are enabled and violate the invariant I@15:43:35.992
NeedForTypes.tla:23:24-23:40, x$1, type error: Expected type Unknown, found Int E@15:43:36.012
NeedForTypes.tla:23:24-23:40, Append(...), type error: Expected a type, found: None E@15:43:36.018
NeedForTypes.tla:23:11-24:31, /\(...), type error: Expected a Boolean, found: None E@15:43:36.020
The outcome is: Error
</code></pre>
<p>Here the type checker stumbles upon the sequence operator <code>Append(OutSeq, x)</code>
and complains about the type mismatch. Similar to <code>{}</code>, it has treated
the expression <code>&lt;&lt; &gt;&gt;</code> as a sequence of an unknown type. (In case of <code>&lt;&lt;1, 2&gt;&gt;</code>
it would be even worse, as the type checker would not know, whether <code>&lt;&lt;1, 2&gt;&gt;</code>
should be treated as a sequence or a tuple). Again, we help the type checker
by modifying <code>Init</code> as follows:</p>
<pre><code class="language-tla">Init ==
    /\ OutSeq = &lt;&lt; &gt;&gt; &lt;: Seq(Int)
    ...
</code></pre>
<p>Having these two annotations, the type checker stops complaining. You can find
the annotated specification in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/NeedForTypesWithTypes.tla"><code>test/tla/NeedForTypesWithTypes.tla</code></a>.</p>
<h3><a class="header" href="#records-and-sets-of-records" id="records-and-sets-of-records">Records and sets of records</a></h3>
<p>Consider the following example in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Handshake.tla"><code>test/tla/Handshake.tla</code></a>:</p>
<pre><code class="language-tla">------------------------ MODULE Handshake ------------------------
(**
 * A TCP-like handshake protocol:
 * https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment
 *
 * Igor Konnov, 2020
 *)
EXTENDS Integers

VARIABLES msgs,     \* the set of all messages
          iseqno,   \* Initiator's sequence number
          rseqno,   \* Receiver's sequence number
          istate,   \* Initiator's state
          rstate    \* Receiver's state

a &lt;: b == a

Init ==
    /\ msgs = {}
    /\ iseqno = 0
    /\ rseqno = 0
    /\ istate = &quot;INIT&quot;
    /\ rstate = &quot;LISTEN&quot;

SendSyn ==
    /\ istate = &quot;INIT&quot;
    /\ \E no \in Nat:
        /\ msgs' = msgs \union {[syn |-&gt; TRUE,
                                 ack |-&gt; FALSE, seqno |-&gt; no]}
        /\ iseqno' = no + 1
        /\ istate' = &quot;SYN-SENT&quot;
        /\ UNCHANGED &lt;&lt;rseqno, rstate&gt;&gt;

SendSynAck ==
    /\ rstate = &quot;LISTEN&quot;
    /\ \E seqno, ackno \in Nat:
        /\ [syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; seqno] \in msgs
        /\ msgs' = msgs \union {[syn |-&gt; TRUE, ack |-&gt; TRUE,
                                 seqno |-&gt; seqno + 1,
                                 ackno |-&gt; ackno]}
        /\ rseqno' = ackno + 1
        /\ rstate' = &quot;SYN-RECEIVED&quot;
        /\ UNCHANGED &lt;&lt;iseqno, istate&gt;&gt;

SendAck ==
    /\ istate = &quot;SYN-SENT&quot;
    /\ \E ackno \in Nat:
        /\ [syn |-&gt; TRUE, ack |-&gt; TRUE,
            seqno |-&gt; iseqno, ackno |-&gt; ackno] \in msgs
        /\ istate' = &quot;ESTABLISHED&quot;
        /\ msgs' = msgs \union {[syn |-&gt; FALSE, ack |-&gt; TRUE,
                                 seqno |-&gt; iseqno,
                                 ackno |-&gt; ackno + 1]}
        /\ UNCHANGED &lt;&lt;iseqno, rseqno, rstate&gt;&gt;

RcvAck ==
    /\ rstate = &quot;SYN-RECEIVED&quot;
    /\ \E seqno \in Nat:
        /\ ([syn |-&gt; FALSE, ack |-&gt; TRUE,
             seqno |-&gt; seqno, ackno |-&gt; rseqno]) \in msgs
        /\ rstate' = &quot;ESTABLISHED&quot;
        /\ UNCHANGED &lt;&lt;msgs, iseqno, rseqno, istate&gt;&gt;


Next == SendSyn \/ SendSynAck \/ SendAck \/ RcvAck

Inv == (rstate = &quot;ESTABLISHED&quot; =&gt; istate = &quot;ESTABLISHED&quot;)
======================================================================
</code></pre>
<p>As we have seen before, the type checker complains about the set <code>msgs</code>,
which is initialized as <code>{}</code>. So we have to specify the type of <code>{}</code>. But which
type shall we use for the empty set?</p>
<p>In our example, the set <code>msgs</code> may contain records of three kinds:</p>
<ul>
<li>a <strong>SYN</strong> request that is modeled as a record
<code>[ack |-&gt; FALSE, syn |-&gt; TRUE, seqno |-&gt; i]</code> for some number <code>i</code>,</li>
<li>a <strong>SYN-ACK</strong> reply that is modeled as a record
<code>[ack |-&gt; TRUE, syn |-&gt; TRUE, seqno |-&gt; i, ackno |-&gt; j]</code>
for some numbers <code>i</code> and <code>j</code>,</li>
<li>an <strong>ACK</strong> reply that is modeled as a record
<code>[ack |-&gt; TRUE, syn |-&gt; FALSE, seqno |-&gt; i, ackno |-&gt; j]</code>
for some numbers <code>i</code> and <code>j</code>.</li>
</ul>
<p>From the perspective of the type checker, the three records shown above have
three different types. Although we would love to reject this example as an
ill-typed one, mixing records of different types is a widely-accepted idiom in
TLA+, for instance, see <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Lamport's specification of
Paxos</a>.
Think of records as of C unions, rather than C structs!</p>
<p>To help the type checker, we first introduce a handy operator for the type that
contains the fields of the three records:</p>
<pre><code class="language-tla">MT == [syn |-&gt; BOOLEAN, ack |-&gt; BOOLEAN, seqno |-&gt; Int, ackno |-&gt; Int]
</code></pre>
<p>Then we add annotations as follows:</p>
<pre><code class="language-tla">Init ==
  /\ msgs = {} &lt;: {MT}
    ...

SendSyn ==
  ...
  /\ \E no \in Nat:
    /\ msgs' = msgs \union {[syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; no] &lt;: MT}
  ...

SendSynAck ==
  ...
  /\ \E seqno, ackno \in Nat:
    /\ ([syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; seqno] &lt;: MT) \in msgs
    ...

SendAck ==
  ...
  /\ \E ackno \in Nat:
    ...
</code></pre>
<p>As you can see, we have to annotate only those records that do not have all
four fields of <code>MT</code>. As soon as we have added the annotations, the type checker
stopped complaining and let the model checker to run. The annotated code can be
found in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/HandshakeWithTypes.tla"><code>test/tla/HandshakeWithTypes.tla</code></a>.</p>
<p>Type annotations can be also applied to sets of records. For example:</p>
<pre><code class="language-tla">[syn |-&gt; BOOLEAN, ack |-&gt; BOOLEAN, seqno |-&gt; Int] &lt;: {MT}
</code></pre>
<p>You can find more details on the simple type inference algorithm and the type
annotations in <a href="apalache/types-and-annotations.html">type annotations</a>.</p>
<h3><a class="header" href="#naturals" id="naturals">Naturals</a></h3>
<p>If you look carefully at the <a href="apalache/types-and-annotations.html">type annotations</a>, you
will find that there is no designated type for naturals. Indeed, one can just
use the type <code>Int</code>, whenever a natural number is required. If we introduced a
special type for naturals, that would cause a lot of confusion for the type
checker. What would be the type of the literal <code>42</code>? That depends on, whether
you extend <code>Naturals</code> or <code>Integers</code>. And if you extend <code>Naturals</code> and later
somebody else extends your module and also <code>Integers</code>, should be the type
of <code>42</code> be an integer?</p>
<p>Apalache still allows you to extend <code>Naturals</code>. However, it will treat all
number-like literals as integers. This is consistent with the view that the naturals are
a subset of the integers, and the integers are a subset of the reals.  Classically, one
would not define subtraction for naturals. However, the module <code>Naturals</code>
defines binary minus, which can easily drive a variable outside of <code>Nat</code>. For
instance, see the following example:</p>
<pre><code class="language-tla">----------------------------- MODULE NatCounter ------------------------
EXTENDS Naturals

VARIABLE x

Init == x = 3

\* a natural counter can go below zero, and this is expected behavior
Next == x' = x - 1

Inv == x &gt;= 0
========================================================================
</code></pre>
<p>Given that you will need the value <code>Int</code> for a type annotation, it probably
does not make a lot of sense to extend <code>Naturals</code> in your own specifications,
as you will have to extend <code>Integers</code> for the type annotation too.  We are
currently working on a different kind of type annotations, which would not
require <code>Int</code>.</p>
<p><a name="recursion"></a></p>
<h2><a class="header" href="#recursive-operators-and-functions" id="recursive-operators-and-functions">Recursive operators and functions</a></h2>
<p><a name="rec-op"></a></p>
<h3><a class="header" href="#recursive-operators" id="recursive-operators">Recursive operators</a></h3>
<p>In the preprocessing phase, Apalache replaces every application of a user
operator with its body. We call this process &quot;operator inlining&quot;.
This cannot be done for recursive operators, for two reasons:</p>
<ol>
<li>
<p>A recursive operator may be non-terminating (although a non-terminating
operator is useless in TLA+);</p>
</li>
<li>
<p>A terminating call to an operator may take an unpredicted number of iterations.</p>
</li>
</ol>
<p>However, in practice, when one fixes specification parameters (that is,
<code>CONSTANTS</code>), it is usually easy to find a bound on the number of operator
iterations. For instance, consider the following specification:</p>
<pre><code class="language-tla">--------- MODULE Rec6 -----------------
CONSTANTS N
VARIABLES set, count

RECURSIVE Sum(_)

Sum(S) ==
  IF S = {}
  THEN 0
  ELSE LET x == CHOOSE x \in S: TRUE IN
    x + Sum(S \ {x})

Init ==
  /\ set = {}
  /\ count = 0

Next ==
  \E x \in (1..N) \ set:
    /\ count' = count + x
    /\ set' = set \union {x}

Inv == count = Sum(set)
=======================================
</code></pre>
<p>It is clear that the expression <code>Sum(S)</code> requires the number of iterations that
is equal to <code>Cardinality(S) + 1</code>. Moreover, the expression <code>set \subseteq 1..N</code> is an invariant, and thus every call <code>Sum(set)</code> requires up to <code>N+1</code>
iterations.</p>
<p>When we can find an upper bound on the number of iterations, Apalache can
unroll the recursive operator up to this bound. To this end, we define two
additional operators. For instance:</p>
<pre><code class="language-tla">--------- MC_Rec6 ----------
VARIABLES set, count

INSTANCE Rec6 WITH N &lt;- 3

UNROLL_TIMES_Sum == 4
UNROLL_DEFAULT_Sum == 0
============================
</code></pre>
<p>In this case, Apalache unrolls every call to <code>Sum</code> exactly <code>UNROLL_TIMES_Sum</code>
times, that is, four times. On the default branch, Apalache places
<code>UNROLL_DEFAULT_Sum</code>, that is, 0.</p>
<p>All recursively defined operators should follow this convention where, for every such operator <code>Oper</code>, the user defines both <code>UNROLL_TIMES_Oper</code>, which expands to a positive integer value, and <code>UNROLL_DEFAULT_Oper</code>, which expands to some default value <code>Oper(args*)</code> should take, if the computation would require more than <code>UNROLL_TIMES_Oper</code> recursive calls.
At present, we only support literals (e.g. <code>4</code>) or primitive arithmetic expressions (e.g. <code>2 + 2</code>) in the body of <code>UNROLL_TIMES_Oper</code>.</p>
<p><a name="rec-fun"></a></p>
<h4><a class="header" href="#recursive-functions" id="recursive-functions">Recursive functions</a></h4>
<p>Apalache offers limited support for recursive functions. However, read the
warning below on why you should not use recursive functions. The restrictions
are as follows:</p>
<ol>
<li>
<p>Apalache supports recursive functions that return an integer or a Boolean.</p>
</li>
<li>
<p>As Apalache's simple type checker is not able to find the type of a
recursive function, all uses of a recursive function should come with a type
annotation.</p>
</li>
<li>
<p>As in TLC, the function domain must be a finite set.</p>
</li>
</ol>
<p>The example below shows a recursive function that computes the factorial of <code>n</code>.</p>
<pre><code class="language-tla">------------------------------ MODULE Rec8 ------------------------------------
EXTENDS Integers

VARIABLES n, factSpec, factComp

\* the syntax for type annotations
a &lt;: b == a

\* the type of the factorial function
FactT == [Int -&gt; Int]

(*
 Defining a recursive function on a finite domain. Although it is rather
 unnatural to define factorial on a finite set, both Apalache and TLC
 require finite domains. As is usual for function application, the result
 of the application is not defined on the elements outside of the function
 domain.
 *)
Fact[k \in 1..20] ==
    IF k &lt;= 1
    THEN 1
    ELSE k * (Fact &lt;: FactT)[k - 1]

Init ==
    /\ n = 1
    /\ factSpec = Fact[n]
    /\ factComp = 1

Next ==
    /\ n' = n + 1
    /\ factSpec' = Fact[n']
    /\ factComp' = n' * factComp

Inv ==
    factComp = factSpec
===============================================================================
</code></pre>
<p>Check other examples in
<a href="https://github.com/informalsystems/apalache/tree/unstable/test/tla"><code>test/tla</code></a> that
start with the prefix <code>Rec</code>.</p>
<p><strong>Why you should avoid recursive functions.</strong> Sometimes, recursive functions
concisely describe the function that you need. The nice examples are the
factorial function (see above) and Fibonacci numbers (see
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Rec3.tla">Rec3</a>).
However, when you define a recursive function over sets, the complexity gets
ugly really fast.</p>
<p>Consider the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Rec9.tla">Rec9</a>,
which computes set cardinality. Here is a fragment of the spec:</p>
<pre><code class="language-tla">a &lt;: b == a

IntSet(S) == S &lt;: {Int}

\* the type of the function Card
CardT == [{Int} -&gt; Int]

(*
 The set cardinality function. It needs an upper bound on the set size.
 Although this function looks nice, be warned that this definition requires us
 to construct the powerset SUBSET NUMS and then write down the constraints
 for the function Card. This encoding is (at least) double-exponential.
 *)
Card[S \in SUBSET NUMS] ==
</code></pre>
<p>Since we cannot fix the order, in which the set elements are evaluated, we
define function <code>Card</code> over <code>SUBSET NUMS</code>, that is, all possible subsets of
<code>NUMS</code>. Apalache translates the function in a quantifier-free theory of SMT.
Hence, in this case, Apalache expands <code>SUBSET NUMS</code>, so it introduces
<code>2^|NUMS|</code> sets! Further, Apalache writes down the SMT constraints for the
domain of <code>Card</code>. As a result, it produces <code>NUMS * 2^|NUMS|</code> constraints.
As you can see, recursive functions over sets explode quite fast.</p>
<p>It is usually a good idea to use recursive operators over sets rather than
recursive functions. The downside is that you have to provide an upper bound on
the number of the operator iterations. The upside is that recursive operators
are usually unrolled more efficiently. (If they contain only constant
expressions, they are even computed by the translator!) For instance, set
cardinality does not require <code>2^|NUMS|</code> constraints, when using a recursive
operator.</p>
<h1><a class="header" href="#the-apalache-module" id="the-apalache-module">The Apalache Module</a></h1>
<p>Similar to the <code>TLC</code> module, we provide the module called <code>Apalache</code>, which can
be found in
<a href="https://github.com/informalsystems/apalache/tree/unstable/src/tla">src/tla</a>.
Most of the operators in that modules are introduced internally by Apalache,
when it is rewriting a TLA+ specification.  It is useful to read the comments
to the operators defined in <code>Apalache.tla</code>, as they will help you in
understanding the <a href="apalache/./running.html#detailed">detailed output</a> produced by the tool, see.
Perhaps, the most interesting operator in <code>Apalache</code> is the type assignment
operator that is defined as follows:</p>
<pre><code class="language-tla">x := e == x = e
</code></pre>
<p>See the <a href="apalache/./principles.html#assignments">discussion</a> on the role of assignments in Apalache.</p>
<h1><a class="header" href="#profiling-your-specification" id="profiling-your-specification">Profiling Your Specification</a></h1>
<p>As Apalache translates the TLA+ specification to SMT, it often defeats
our intuition about the standard bottlenecks that one learns about when running
TLC. For instance, whereas TLC needs a lot of time to compute the initial states
for the following specification, Apalache can check the executions of length up
to ten steps in seconds:</p>
<pre><code class="language-tla">---------------------------- MODULE powerset ----------------------------
EXTENDS Integers
VARIABLE S

Init ==
    /\ S \in SUBSET (1..50)
    /\ 3 \notin S

Next ==
    \/ \E x \in S:
        S' = S \ {x}
    \/ UNCHANGED S

Inv ==
    3 \notin S
=========================================================================
</code></pre>
<p>Apalache has its own bottlenecks. As it's using the SMT solver z3,
we cannot precisely profile your TLA+ specification. However, we can profile
the number of SMT variables and constraints that Apalache produces for different
parts of your specification. To activate this profiling mode, use the option
<code>--smtprof</code>:</p>
<pre><code class="language-sh">apalache check --smtprof powerset.tla
</code></pre>
<p>The profiling data is written in the file <code>profiler.csv</code>:</p>
<pre><code># weight,nCells,nConsts,nSmtExprs,location
4424,2180,2076,28460,powerset.tla:11:5-13:18
4098,2020,1969,12000,powerset.tla:12:9-12:20
4098,2020,1969,12000,powerset.tla:12:14-12:20
...
</code></pre>
<p>The meaning of the columns is as follows:</p>
<ul>
<li>
<p><code>weight</code> is the weight of the expression.
Currently it is computed as <code>nCells + nConsts + sqrt(nSmtExprs)</code>.
We may change this formula in the future.</p>
</li>
<li>
<p><code>nCells</code> is the number of arena cells that are created during the translation.
Intuitively, the cells are used to keep the potential shapes of the data structures
that are captured by the expression.</p>
</li>
<li>
<p><code>nConsts</code> is the number of SMT constants that are produced by the translator.</p>
</li>
<li>
<p><code>nSmtExprs</code> is the number of SMT expressions that are produced by the translator.
We also include all subexpressions, when counting this metric.</p>
</li>
<li>
<p><code>location</code> is the location in the source code where the expression
was found, indicated by the file name correlated with a range of <code>line:column</code> pairs.</p>
</li>
</ul>
<p>To visualize the profiling data, you can use the script <code>script/heatmap.py</code>:</p>
<pre><code class="language-sh">$APALACHE_HOME/script/heatmap.py profile.csv heatmap.html
</code></pre>
<p>The produced file <code>heatmap.html</code> looks as follows:</p>
<p><img src="apalache/./img/profiler2.png" alt="Here you should see a heatmap" title="A heatmap" /></p>
<p>The heatmap may give you an idea about the expression that are hard for Apalache.
The following picture highlights one part of the Raft specification that produces
a lot of constraints:</p>
<p><img src="apalache/./img/profiler.png" alt="Here you should see a heatmap" title="A heatmap of Raft" /></p>
<h1><a class="header" href="#five-minutes-of-theory" id="five-minutes-of-theory">Five minutes of theory</a></h1>
<p><strong>You can safely skip this section</strong></p>
<p>Given a TLA+ specification, with all parameters fixed, our model checker
performs the following steps:</p>
<ol>
<li>
<p>It automatically extracts symbolic transitions from the specification. This
allows us to partition the action <code>Next</code> into a disjunction of simpler actions
<code>A_1, ..., A_n</code>.</p>
</li>
<li>
<p>Apalache translates operators <code>Init</code> and <code>A_1, ..., A_n</code> to SMT formulas.
This allows us to explore bounded executions with an SMT solver (we are using
<a href="https://github.com/Z3Prover/z3">Microsoft's Z3</a>). For instance, a sequence of
<code>k</code> steps <code>s_0, s_1, ..., s_k</code>, all of which execute action <code>A_1</code>, is encoded
as a formula <code>Run(k)</code> that looks as follows:</p>
</li>
</ol>
<pre><code class="language-tla">[[Init(s_0)]] /\ [[A_1(s_0, s_1)]] /\ ... /\ [[A_1(s_(k-1), s_k)]]
</code></pre>
<p>To find an execution of length <code>k</code> that violates an invariant <code>Inv</code>, the tool
adds the following constraint to the formula <code>Run(k)</code>:</p>
<pre><code class="language-tla">[[~Inv(s_0)]] \/ ... \/ [[~Inv(s_k)]]
</code></pre>
<p>Here, <code>[[_]]</code> is the translator from TLA+ to SMT. Importantly, the values for
the states <code>s_0</code>, ..., <code>s_k</code> are not enumerated as in TLC, but have to be found
by the SMT solver.</p>
<p>If you would like to learn more about theory behind Apalache, check the <a href="https://dl.acm.org/doi/10.1145/3360549">paper
delivered at OOPSLA19</a>.</p>
<h1><a class="header" href="#syntax-of-tlc-configuration-files" id="syntax-of-tlc-configuration-files">Syntax of TLC Configuration Files</a></h1>
<p><strong>Author:</strong> Igor Konnov, 2020</p>
<p>This file presents the syntax of
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a> configuration files
in <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> and
comments on the treatment of its sections in
<a href="https://github.com/informalsystems/apalache">Apalache</a>. A detailed discussion
on using the config files with TLC can be found in Leslie Lamport's
<a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>,
Chapter 14 and in
<a href="https://lamport.azurewebsites.net/tla/current-tools.pdf">Current Versions of the TLA+ Tools</a>.
In particular, the TLA+ specification of TLC configuration files
is given in Section 14.7.1. The standard parser can be found in
<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/tlc2/tool/impl/ModelConfig.java"><code>tlc2.tool.impl.ModelConfig</code></a>.
As the configuration files have simple syntax, we implement our own parser in
Apalache.</p>
<pre><code class="language-ebnf">// The configuration file is a non-empty sequence of configuration options.
config ::=
    options+

// Possible options, in no particular order, all of them are optional.
// Apalache expects Init after Next, or Next after Init.
options ::=
    Init
  | Next
  | Specification
  | Constants
  | Invariants
  | Properties
  | StateConstraints
  | ActionConstraints
  | Symmetry
  | View
  | Alias
  | Postcondition
  | CheckDeadlock

// Set the initialization predicate (over unprimed variables), e.g., Init.
Init ::=
    &quot;INIT&quot; ident

// Set the next predicate (over unprimed and primed variables), e.g., Next.
Next ::=
    &quot;NEXT&quot; ident

// Set the specification predicate, e.g., Spec.
// A specification predicate usually looks like Init /\ [][Next]_vars /\ ...
Specification ::=
    &quot;SPECIFICATION&quot; ident

// Set the constants to specific values or substitute them with other names.
Constants ::=
    (&quot;CONSTANT&quot; | &quot;CONSTANTS&quot;) (replacement | assignment)*

// Replace the constant in the left-hand side
// with the identifier in the right-hand side.
replacement ::=
    ident &quot;&lt;-&quot; ident

// Replace the constant in the left-hand side
// with the constant expression in the right-hand side.
assignment ::=
    ident &quot;=&quot; constExpr

// A constant expression that may appear in
// the right-hand side of an assignment.
constExpr ::=
    modelValue
  | integer
  | string
  | boolean
  | &quot;{&quot; &quot;}&quot;
  | &quot;{&quot; constExpr (&quot;,&quot; constExpr)* &quot;}&quot;

// The name of a model value, see Section 14.5.3 of Specifying Systems.
// A model value is essentially an uninterpreted constant.
// All model values are distinct from one another. Moreover, they are
// not equal to other values such as integers, strings, sets, etc.
// Apalache treats model values as strings, which it declares as
// uninterpreted constants in SMT.
modelValue ::= ident

// An integer (no bit-width assumed)
integer ::=
      &lt;string matching regex [0-9]+&gt;
    | &quot;-&quot; &lt;string matching regex [0-9]+&gt;

// A string, starts and ends with quotes,
// a restricted set of characters is allowed (pre-UTF8 era, Paxon scripts?)
string ::=
    '&quot;' &lt;string matching regex [a-zA-Z0-9_~!@#\$%^&amp;*-+=|(){}[\],:;`'&lt;&gt;.?/ ]*&gt; '&quot;'

// A Boolean literal
boolean ::= &quot;FALSE&quot; | &quot;TRUE&quot;

// Set an invariant (over unprimed variables) to be checked against
// every reachable state.
Invariants ::=
    (&quot;INVARIANT&quot; | &quot;INVARIANTS&quot;) ident*

// Set a temporal property to be checked against the initial states.
// Temporal properties reason about finite or infinite computations,
// which are called behaviors in TLA+. Importantly, the computations
// originate from the initial states.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Properties ::=
    (&quot;PROPERTY&quot; | &quot;PROPERTIES&quot;) ident*

// Set a state predicate (over unprimed variables)
// that restricts the state space to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
StateConstraints ::=
    (&quot;CONSTRAINT&quot; | &quot;CONSTRAINTS&quot;) ident*

// Set an action predicate (over unprimed and primed variables)
// that restricts the transitions to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
ActionConstraints ::=
    (&quot;ACTION-CONSTRAINT&quot; | &quot;ACTION-CONSTRAINTS&quot;) ident*

// Set the name of an operator that produces a set of permutations
// for symmetry reduction.
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Symmetry ::=
    &quot;SYMMETRY&quot; ident

// Set the name of an operator that produces a state view
// (some form of abstraction).
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
View ::=
    &quot;VIEW&quot; ident

// Whether the tools should check for deadlocks.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
CheckDeadlock ::=
    &quot;CHECK_DEADLOCK&quot; (&quot;FALSE&quot; | &quot;TRUE&quot;)

// Recent feature: https://lamport.azurewebsites.net/tla/current-tools.pdf
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Postcondition ::=
    &quot;POSTCONDITION&quot; ident

// Very recent feature: https://github.com/tlaplus/tlaplus/issues/485
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Alias ::=
    &quot;ALIAS&quot; ident

// A TLA+ identifier, must be different from the above keywords.
ident ::=
    &lt;string matching regex [a-zA-Z_]([a-zA-Z0-9_])*&gt;

</code></pre>
<h2><a class="header" href="#simple-type-inference-and-type-annotations" id="simple-type-inference-and-type-annotations">Simple type inference and type annotations</a></h2>
<p><strong>WARNING:</strong> We have recently implemented a new type checker called Snowcat.
See the <a href="apalache/./typechecker-snowcat.html">chapter in the manual</a>.
Snowcat is user-friendly and much smarter than the current trivial type
checker.  To get the idea about the new type checker, see <a href="https://youtu.be/hnp25hmCMN8">the talk at TLA+
Community Meeting 2020</a>. We are preparing a
tutorial on the new typechecker. The old type annotations will be replaced with
the new annotations as documented in <a href="apalache/../adr/002adr-types.html">ADR002</a>
and <a href="apalache/../adr/004adr-annotations.html">ADR004</a>.</p>
<p>You can try Snowcat and the new type annotations in the <a href="https://github.com/informalsystems/apalache">unstable
branch</a>.  Be warned though that
the model checker is still expecting the old type annotations, which are
explained below.</p>
<hr />
<p>Our model checker assigns types to variables, in order to encode TLA+ expressions
in <a href="https://github.com/Z3Prover/z3">Z3</a>. Hence, the expressions that are ill-typed
(from the point of view of our type system), will be rejected right away. Some
expressions, such as <code>{}</code> and <code>&lt;&lt;&gt;&gt;</code> require an advanced type inference algorithm,
so the model checker will ask the user to provide the tool with a type annotation.
To get an idea of our type system, check Section 2. In a nutshell,
if a TLA+ expression cannot be decorated with a type annotation,
it is not supported <em>yet</em>. Exception is made for non-recursive TLA+ operators, as they are
expanded before the type inference is run.</p>
<h3><a class="header" href="#1-type-inference" id="1-type-inference">1. Type inference</a></h3>
<p>Starting with the version <code>0.4.0</code>, our model checker runs the naive type
inference algorithm for every computation step:</p>
<ol>
<li>
<p>It assumes that all operator definitions have been replaced with their
bodies. (This is done automatically by Apalache.)</p>
</li>
<li>
<p>It assumes that non-primed variables have been assigned types already.
As expected, the non-primed variables get their initial types by running
type inference on <code>Init</code>.</p>
</li>
<li>
<p>It recursively computes the types of subexpressions in a TLA+ expression in
a bottom-up way as follows:</p>
<ol>
<li>A literal is assigned the respective basic type. That is, an integer,
a Boolean, or a string gets assigned the integer, Boolean, or the constant
type respectively.</li>
<li>An assignment-like expression <code>x' = e</code> or <code>x' \in S</code> assigns to <code>x'</code>
the type of <code>e</code> and the type of <code>S</code> elements respectively. The type
checker requires that <code>x'</code> is assigned the same type across all formula
branches. However, variables <em>may</em> have different types at different steps.
For instance, the definitions <code>Init == x = 1</code> and <code>Next == x' = {x}</code>
will be processed perfectly fine: <code>x</code> is assigned the type <code>Int</code> in the initial
states, and the type <code>Set(...(Set(Int)))</code> of <em>n</em> nested sets at the <em>n</em>-th step, <code>n &gt;= 0</code>.</li>
<li>The expressions that introduce bound variables, e.g., <code>{e: x \in S}</code>,
are treated as usual: first, the type of <code>S</code> is computed and <code>x</code> is assigned
the element type, and then the type of <code>e</code> is computed, which immediately
gives us the type of the set expression.</li>
</ol>
</li>
</ol>
<p>This approach manages to automatically compute types of many TLA+ expressions.
However, there a few problematic cases that require type annotations:</p>
<ol>
<li>An empty set <code>{}</code> gets assigned the type <code>Set[Unknown]</code>. When it is later
combined with a more precise type, e.g., as in <code>{} \cup {1}</code>, the type finder
reports a type error. In this case, the user has to write a type annotation.
For instance, the above-mentioned problematic expression can be fixed as follows:
<code>({} &lt;: {Int}) \cup {1}</code>.</li>
<li>Similar to an empty set, an empty sequence <code>&lt;&lt;&gt;&gt;</code> gets assigned the type
<code>Seq[Unknown]</code>. Hence <code>&lt;&lt;&gt;&gt; \o &lt;&lt;1&gt;&gt;</code> produces a type error. To resolve this,
the user has to write a type annotation <code>(&lt;&lt;&gt;&gt; &lt;: Seq(Int)) \o &lt;&lt;1&gt;&gt;</code>.</li>
<li>It is common to mix records that have different sets of fields, e.g.,
see <a href="https://github.com/tlaplus/Examples/tree/master/specifications/Paxos">Paxos</a>.
However, our type checker will report a type error on the following expression:
<code>{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1]} \cup {[type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}</code>.
To resolve this, the user has to write a type annotation:
<code>{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1] &lt;: MT} \cup {[type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}</code>,
where <code>MT</code> is defined as <code>[type |-&gt; STRING, bal |-&gt; Int, val |-&gt; Int]</code>.
The type checker requires that the fields with the same name are assigned
the same type.</li>
</ol>
<h3><a class="header" href="#2-type-annotations" id="2-type-annotations">2. Type annotations</a></h3>
<p>As there is no standard way of specifying types in TLA+ (hey, it is untyped by design),
we introduce a simple convention to specify types by writing special TLA+ expressions.</p>
<p>As a preliminary step, the user has to introduce the operator <code>&lt;:</code> as follows:</p>
<pre><code class="language-tla">a &lt;: b == a
</code></pre>
<p>This operator does not nothing else but returns its first argument, so the standard TLA+
tools will ignore the second argument, which contains a type annotation. Our model checker
interprets the second argument of the operator <code>&lt;:</code> as a type annotation.
(This also means that you should not assign any other meaning to <code>&lt;:</code> in your specifications.)</p>
<p>Further, the user may use <code>&lt;:</code> to define types of problematic expressions, see the
examples in Section 1.</p>
<p>The syntax for type annotations is given below. Note that these expressions should not be
understood as sets of values, as one would expects from type invariants such as <code>TypeOK</code>. Rather,
they are TLA+ expressions that are parsed by the model checker, in order to construct types.</p>
<p>The syntax of type annotations is as follows:</p>
<ol>
<li><code>Int</code> specifies the integer type. For instance, <code>x &lt;: Int</code> specifies that <code>x</code>
is an integer, but not a set of integers.</li>
<li><code>BOOLEAN</code> specifies the Boolean type. Again, although we are using a set here,
its purpose is to say that an expression is a Boolean, not a set of Booleans.</li>
<li><code>STRING</code> specifies the type of constants, e.g., <code>&quot;a&quot;</code> and <code>&quot;hello&quot;</code>
are such constants.</li>
<li><code>{T}</code> specifies the set whose elements have type <code>T</code>. For instance,
<code>{Int}</code> specifies a set of integers, whereas <code>{{BOOLEAN}}</code> specifies
a set of sets of Booleans. Note that you should always use singleton sets in
type annotations. For instance, <code>{Int, BOOLEAN}</code> would be immediately rejected.
Hence, sets should contain the elements of the same type (there is some flexibility
for records, see Section 1)</li>
<li><code>[T_1 -&gt; T_2]</code> specifies the type of a function whose arguments have type <code>T_1</code>,
and the results are of type <code>T_2</code>. Hence, a function should return the values
of the same type.</li>
<li><code>&lt;&lt;T_1, ..., T_k&gt;&gt;</code> specifies the type of a <em>k</em>-element tuple whose
elements have types <code>T_1, ..., T_k</code> respectively. Note that different fields
of a tuple are allowed to have different types. In these sense, we differentiate them
from the general functions.</li>
<li><code>[f_1 |-&gt; T_1, ..., f_k |-&gt; T_k]</code> specifies the type of a <em>k</em>-field record,
whose field <code>f_i</code> is of the type <code>T_i</code>. The types <code>T_1, ..., T_k</code> may differ. Again,
that makes them different from the general functions.</li>
<li><code>Seq(T)</code> specifies the type of finite sequences, whose elements are of type <code>T</code>.
There are no restrictions on the sequence length, except finiteness. In theory,
a sequence of type <code>Seq[T]</code> is no different from a function of type <code>[Int -&gt; T]</code>.
In practice, we use different encodings for the general functions and sequences.</li>
</ol>
<h2><a class="header" href="#the-new-type-checker-snowcat" id="the-new-type-checker-snowcat">The new type checker Snowcat</a></h2>
<p><strong>WARNING:</strong> Snowcat has not been integrated with the model checker yet. The
integration is coming soon. The model checker is still expecting the <a href="apalache/./types-and-annotations.html">old type
annotations</a>.</p>
<p>For the moment, you can use Snowcat as a standalone tool. New type annotations are written in comments, so they are
ignored by the model checker (until the integration happens). Hence, you can start writing new type annotations and
debug them with Snowcat. As the new type annotations are written in comments, they will be ignored by the model
checker (until the integration happens). Snowcat ignores the old annotations and warns the user about the new type
annotations. So you can start preparing for the transition to new annotations right now.</p>
<hr />
<h3><a class="header" href="#how-to-write-type-annotations" id="how-to-write-type-annotations">How to write type annotations</a></h3>
<p>Check the <a href="apalache/../HOWTOs/howto-write-type-annotations.html">HOWTO</a>.  You can find
detailed syntax of type annotations in <a href="apalache/../adr/002adr-types.html">ADR002</a>. </p>
<h3><a class="header" href="#how-to-run-the-type-checker" id="how-to-run-the-type-checker">How to run the type checker</a></h3>
<p>The type checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache typecheck [--infer-poly=&lt;bool&gt;] &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>General parameters:
<ul>
<li><code>--infer-poly</code> controls whether the type checker should infer polymorphic
types. As many specs do not need polymorphism, you can set this option
to <code>false</code>. The default value is <code>true</code>.</li>
</ul>
</li>
</ul>
<p>There is not much to explain about running the tool. When it successfully finds
the types of all expressions, it reports:</p>
<pre><code> &gt; Running Snowcat .::..
 &gt; Your types are great!
  ...
Type checker [OK]
</code></pre>
<p>When the type checker finds an error, it explains the error like that:</p>
<pre><code> &gt; Running Snowcat .::.
[QueensTyped.tla:42:44-42:61]: Mismatch in argument types. Expected: (Seq(Int)) =&gt; Bool
[QueensTyped.tla:42:14-42:63]: Error when computing the type of Solutions
 &gt; Snowcat asks you to fix the types. Meow.
Type checker [FAILED]
</code></pre>
<p>Here is the list of the TLA+ language features that are currently supported by Apalache, following the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of TLA+</a>.</p>
<h2><a class="header" href="#safety-vs-liveness" id="safety-vs-liveness">Safety vs. Liveness</a></h2>
<p>At the moment, Apalache is able to check invariants and inductive invariants.
It means that you can only check safety with Apalache, unless you employ
<a href="https://www.sciencedirect.com/science/article/pii/S1571066104804109?via%3Dihub">liveness-to-safety</a> transformation in your spec. It does not support
liveness properties.  If you really like to see liveness implemented, upvote
the <a href="https://github.com/informalsystems/apalache/issues/488">liveness feature</a>.</p>
<h2><a class="header" href="#language" id="language">Language</a></h2>
<h3><a class="header" href="#module-level-constructs" id="module-level-constructs">Module-Level constructs</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>EXTENDS module</code></td><td align="center">‚úî</td><td align="center">-</td><td>As soon as SANY imports the module. Some standard modules are not supported yet</td></tr>
<tr><td><code>CONSTANTS C1, C2</code></td><td align="center">‚úî</td><td align="center">-</td><td>Either define a <code>ConstInit</code> operator to initialize the constants, or declare operators instead of constants, e.g., C1 == 111</td></tr>
<tr><td><code>VARIABLES x, y, z</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>ASSUME P</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parsed, but not propagated to the solver</td></tr>
<tr><td><code>F(x1, ..., x_n) == exp</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Every application of <code>F</code> is replaced with its body. Recursive operators need <a href="apalache/./principles.html#recursive-operators">unrolling annotations</a>.</td></tr>
<tr><td><code>f[x ‚àà S] == exp</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Only recursive functions that return integers or Booleans are supported.</td></tr>
<tr><td><code>INSTANCE M WITH ...</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>No special treatment for <code>~&gt;</code>, <code>\cdot</code>, <code>ENABLED</code></td></tr>
<tr><td><code>N(x1, ..., x_n) == INSTANCE M WITH...</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parameterized instances are not supported</td></tr>
<tr><td><code>THEOREM P</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parsed but not used</td></tr>
<tr><td><code>LOCAL def</code></td><td align="center">‚úî</td><td align="center">-</td><td>Replaced with local LET-IN definitions</td></tr>
</tbody></table>
<h3><a class="header" href="#the-constant-operators" id="the-constant-operators">The constant operators</a></h3>
<h4><a class="header" href="#logic" id="logic">Logic</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>/\</code>, <code>\/</code>, <code>~</code>, <code>=&gt;</code>, <code>&lt;=&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>TRUE</code>, <code>FALSE</code>, <code>BOOLEAN</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>\A x \in S: p</code>, <code>\E x \in S : p</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>CHOOSE x \in S : p</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Similar to TLC, we implement a non-deterministic choice. We will add a deterministic version in the future.</td></tr>
<tr><td><code>CHOOSE x : x \notin S</code></td><td align="center">‚úñ</td><td align="center">?</td><td>That is a commonly used idiom</td></tr>
<tr><td><code>\A x : p, \E x : p</code></td><td align="center">‚úñ</td><td align="center"><strong>NEVER</strong></td><td>Use the versions above</td></tr>
<tr><td><code>CHOOSE x : p</code></td><td align="center">‚úñ</td><td align="center"><strong>NEVER</strong></td><td>Use the version above</td></tr>
</tbody></table>
<h4><a class="header" href="#sets" id="sets">Sets</a></h4>
<p><strong>Note:</strong> only finite sets are supported. Additionally, existential
quantification over <code>Int</code> and <code>Nat</code> is supported, as soon as it can be
replaced with a constant.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>=</code>, <code>/=</code>, <code>\in</code>, <code>\notin</code>, <code>\intersect</code>, <code>\union</code>, <code>\subseteq</code>, <code>\</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e_1, ..., e_n}</code></td><td align="center">‚úî</td><td align="center">-</td><td>Empty sets <code>{}</code> require <a href="apalache/types-and-annotations.html">type annotations</a></td></tr>
<tr><td><code>{x \in S : p}</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e : x \in S}</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>SUBSET S</code></td><td align="center">‚úî</td><td align="center">-</td><td>Sometimes, the powersets are expanded</td></tr>
<tr><td><code>UNION S</code></td><td align="center">‚úî</td><td align="center">-</td><td>Provided that S is expanded</td></tr>
</tbody></table>
<h4><a class="header" href="#functions" id="functions">Functions</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>f[e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>DOMAIN f</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ x \in S ‚Ü¶ e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ S -&gt; T ]</code></td><td align="center">‚úî</td><td align="center">-</td><td>Sometimes, the functions sets are expanded</td></tr>
<tr><td><code>[ f EXCEPT ![e1] = e2 ]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#records" id="records">Records</a></h4>
<p><em>Use <a href="apalache/types-and-annotations.html">type annotations</a> to help the model checker in finding the right types.</em>
Note that our type system distinguishes records from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e.h</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>r[e]</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Provided that e is a constant expression.</td></tr>
<tr><td><code>[ h1 ‚Ü¶ e1, ..., h_n ‚Ü¶ e_n]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ h1 : S1, ..., h_n : S_n]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ r EXCEPT !.h = e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#tuples" id="tuples">Tuples</a></h4>
<p><em>Use <a href="apalache/types-and-annotations.html">type annotations</a> to help the model checker in finding the right types.</em>
Note that our type system distinguishes tuples from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e[i]</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
<tr><td><code>&lt;&lt; e1, ..., e_n &gt;&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>By default, a tuple is constructed. Use a <a href="apalache/types-and-annotations.html">type annotation</a> to construct a sequence of proper type.</td></tr>
<tr><td><code>S1 \X ... \X S_n</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ t EXCEPT ![i] = e]</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
</tbody></table>
<h4><a class="header" href="#strings-and-numbers" id="strings-and-numbers">Strings and numbers</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&quot;c1...c_n&quot;</code></td><td align="center">‚úî</td><td align="center">-</td><td>A string is always mapped to a unique uninterpreted constant</td></tr>
<tr><td><code>STRING</code></td><td align="center">‚úñ</td><td align="center">-</td><td>It is an infinite set. We cannot handle infinite sets.</td></tr>
<tr><td><code>d1...d_n</code></td><td align="center">‚úî</td><td align="center">-</td><td>As long as the SMT solver (Z3) accepts that large number</td></tr>
<tr><td><code>d1...d_n.d_n+1...d_m</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Technical issue. We will implement it upon a user request.</td></tr>
</tbody></table>
<h4><a class="header" href="#miscellaneous-constructs" id="miscellaneous-constructs">Miscellaneous Constructs</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IF p THEN e1 ELSE e2</code></td><td align="center">‚úî</td><td align="center">-</td><td>Provided that both e1 and e2 have the same type</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n [] OTHER -&gt; e</code></td><td align="center">‚úî</td><td align="center">-</td><td>See the comment above</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Introduce the default arm with <code>OTHER</code>.</td></tr>
<tr><td><code>LET d1 == e1 ... d_n == e_n IN e</code></td><td align="center">‚úî</td><td align="center"></td><td>All applications of <code>d1</code>, ..., <code>d_n</code> are replaced with the expressions <code>e1</code>, ... <code>e_n</code> respectively. LET-definitions without arguments are kept in place.</td></tr>
<tr><td>multi-line <code>/\</code> and <code>\/</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-action-operators" id="the-action-operators">The Action Operators</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e'</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[A]_e</code></td><td align="center">‚úñ</td><td align="center">-</td><td>It does not matter for safety</td></tr>
<tr><td><code>&lt; A &gt;_e</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
<tr><td><code>ENABLED A</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
<tr><td><code>UNCHANGED &lt;&lt;e_1, ..., e_k&gt;&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>Always replaced with <code>e_1' = e_1 /\ ... /\ e_k' = e_k</code></td></tr>
<tr><td><code>A ‚àô B</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-temporal-operators" id="the-temporal-operators">The Temporal Operators</a></h3>
<p>The model checker assumes that the specification has the form <code>Init /\ [][Next]_e</code>. Given an invariant candidate <code>Inv</code>, the tool checks, whether
<code>Inv</code> is violated by an execution whose length is bounded by the given
argument.</p>
<p>Except the standard form <code>Init /\ [][Next]_e</code>, no temporal operators are supported.</p>
<h2><a class="header" href="#standard-modules" id="standard-modules">Standard modules</a></h2>
<h3><a class="header" href="#integers-and-naturals" id="integers-and-naturals">Integers and Naturals</a></h3>
<p>For the moment, the model checker does not differentiate between integers and naturals. They are all translated as integers in SMT.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>These operators are translated into integer arithmetic of the SMT solver. Linear integer arithmetic is preferred.</td></tr>
<tr><td><code>\div</code>, <code>%</code></td><td align="center">‚úî</td><td align="center">-</td><td>Integer division and modulo</td></tr>
<tr><td><code>a^b</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Provided a and b are constant expressions</td></tr>
<tr><td><code>a..b</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Sometimes, <code>a..b</code> needs a constant upper bound on the range.  When Apalache complains, use <code>{x \in A..B : a &lt;= x /\ x &lt;= b}</code>, provided that <code>A</code> and <code>B</code> are constant expressions.</td></tr>
<tr><td><code>Int</code>, <code>Nat</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Supported in <code>\E x \in Nat: p</code> and <code>\E x \in Int: p</code>, if the expression is not located under <code>\A</code> and <code>~</code>. We also support assignments like <code>f' \in [S -&gt; Int]</code> and tests <code>f \in [S -&gt; Nat]</code></td></tr>
<tr><td><code>/</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Real division, not supported</td></tr>
</tbody></table>
<h3><a class="header" href="#sequences" id="sequences">Sequences</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;...&gt;&gt;</code>, <code>Head</code>, <code>Tail</code>, <code>Len</code>, <code>SubSeq</code>, <code>Append</code>, <code>\o</code>, <code>f[e]</code></td><td align="center">‚úî</td><td align="center">-</td><td>The sequence constructor <code>&lt;&lt;...&gt;&gt;</code> needs a <a href="apalache/types-and-annotations.html">type annotation</a>.</td></tr>
<tr><td><code>EXCEPT</code></td><td align="center">‚úñ</td><td align="center"></td><td>If you need it, let us know, issue #324</td></tr>
<tr><td><code>Seq(S)</code></td><td align="center">‚úñ</td><td align="center">-</td><td>If you need it, let us know, issue #314</td></tr>
<tr><td><code>SelectSeq</code></td><td align="center">‚úñ</td><td align="center">-</td><td>will not be supported in the near future</td></tr>
</tbody></table>
<h3><a class="header" href="#finitesets" id="finitesets">FiniteSets</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IsFinite</code></td><td align="center">‚úî</td><td align="center">-</td><td>Always returns true, as all the supported sets are finite</td></tr>
<tr><td><code>Cardinality</code></td><td align="center">‚úî</td><td align="center">-</td><td>Try to avoid it, as Cardinality(S) produces <code>O(n^2)</code> constraints in SMT for cardinality <code>n</code></td></tr>
</tbody></table>
<h3><a class="header" href="#tlc" id="tlc">TLC</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>f @@ a :&gt; b</code></td><td align="center">‚úî</td><td align="center">-</td><td>Extends the function relation with the pair <code>&lt;&lt;a, b&gt;&gt;</code></td></tr>
</tbody></table>
<h3><a class="header" href="#reals" id="reals">Reals</a></h3>
<p>Not supported, not a priority</p>
<h1><a class="header" href="#preprocessing-in-apalache" id="preprocessing-in-apalache">Preprocessing in APALACHE</a></h1>
<p>Before translating a specification into SMT, <code>apalache</code> performs a number of
preprocessing steps:</p>
<ul>
<li><code>InlinerOfUserOper</code>: replaces every call to a user-defined operator with the operator's body.</li>
<li><code>LetInExpander</code>: replaces every call to a let-in defined operator of arity at least 1 with the operator's body</li>
<li><code>PrimingPass</code>: adds primes to variables in <code>Init</code> and <code>ConstInit</code> (required by <code>TransitionPass</code>)</li>
<li><code>VCGen</code>: extracts verification conditions from the invariant candidate.</li>
<li><code>Desugarer</code>: removes syntactic sugar like short-hand expressions in <code>EXCEPT</code>.</li>
<li><code>Normalizer</code>: rewrites all expressions in <a href="https://en.wikipedia.org/wiki/Negation_normal_form">negation-normal form</a>.</li>
<li><code>Keramelizer</code>: translates TLA+ expressions into the kernel language <a href="apalache/./kera.html">KerA</a>.</li>
<li><code>ExprOptimizer</code>: statically computes select expressions (e.g. record field access from a known record)</li>
<li><code>ConstSimplifier</code>: propagates constants</li>
</ul>
<h2><a class="header" href="#keramelizer" id="keramelizer">Keramelizer</a></h2>
<p>Keramelizer rewrites TLA+ expressions into <a href="apalache/./kera.html">KerA</a>. For many TLA+ expressions
this translation is clear, however, some expressions cannot be easily translated. Below
we discuss such expressions and the decisions that we have made.</p>
<h3><a class="header" href="#case-a-namekera-casea" id="case-a-namekera-casea">CASE <a name="kera-case"></a></a></h3>
<p>TLA+ supports two kinds of CASE expressions:</p>
<ul>
<li><code>CASE</code>. These are expressions without a default value:</li>
</ul>
<pre><code class="language-tla">    CASE
         p_1 -&gt; e_1
      [] p_2 -&gt; e_2
         ...
      [] p_n -&gt; e_n
</code></pre>
<ul>
<li><code>CASE-OTHER</code>. These are expressions with a default value:</li>
</ul>
<pre><code class="language-tla">   CASE
        p_1 -&gt; e_1
     [] p_2 -&gt; e_2
        ...
     [] p_n -&gt; e_n
     [] OTHER -&gt; e_def
</code></pre>
<p>Keramelizer supports only <code>CASE-OTHER</code> and asks the user to translate <code>CASE</code> expressions
into <code>CASE-OTHER</code>. One could imagine that <code>CASE</code> could be expressed as
<code>(p_1 /\ e_1) \/ ... \/ (p_n /\ e_n)</code>. However, this approach only works for Boolean
expressions, which requires type inference. Moreover, the user expects a warning when
neither of the conditions <code>p_1, ..., p_n</code> holds true.
Hence, Leslie Lamport defines semantics of case in <a href="apalache/preprocessing.html#spec2004">Specifying Systems, p. 298</a> as:</p>
<pre><code class="language-tla">  CHOOSE v: (p_1 /\ (v = e_1) \/ ... \/ (p_n /\ (v = e_n)))
</code></pre>
<p>Similarly, <code>CASE-OTHER</code> is defined  as:</p>
<pre><code class="language-tla"> CHOOSE v: (p_1 /\ (v = e_1) \/ ... \/ (p_n /\ (v = e_n)) \/ (~p_1 /\ ... ~p_n /\ (v = e_ def)))
</code></pre>
<p>As a result, if there are several conditions among <code>p_1, ..., p_n</code> that hold true,
then <code>CHOOSE</code> always selects the same condition <code>p_i</code> for equivalent formulas.
<em>It is hard to enforce these general semantics in a model checker</em>. Thus, we have decided to select
a fixed order of evaluating the conditions: the top-to-bottom order that is commonly used in
programming languages. By using this approach, it is easy to translate <code>CASE-OTHER</code> as follows:</p>
<pre><code class="language-tla">IF p_1
THEN e_1
ELSE
  IF p_2
  THEN e_2
  ...
    IF p_n
    THEN e_n
    ELSE e_def
</code></pre>
<p>With this approach it is not obvious how one would translate <code>CASE</code> in a sound way.
We could drop the last condition <code>p_n</code> and unconditionally use the expression <code>e_n</code> in the bottom
else arm. Hence, we ask the user to add the <code>OTHER</code> case to a <code>CASE</code> expression. Usually,
the user has a better idea about the default case than an automatic tool. For instance,
one can also rewrite the (presumably impossible) default case using the <code>CHOOSE</code> operator:</p>
<pre><code class="language-tla">   CASE
        p_1 -&gt; e_1
     [] p_2 -&gt; e_2
        ...
     [] p_n -&gt; e_n
     [] OTHER -&gt; CHOOSE x \in {}: FALSE
</code></pre>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li>Leslie Lamport. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers.
Addison-Wesley Professional, 2004. <a name="spec2004"></a></li>
</ul>
<h1><a class="header" href="#parameters-for-fine-tuning" id="parameters-for-fine-tuning">Parameters for fine tuning</a></h1>
<p>The parameters for fine tuning can be passed to the checker in a properties
file.  Its name is given with the command-line option <code>--tuning=my.properties.</code>
This file supports variable substitution, e.g., <code>${x}</code> is replaced with the
value of <code>x</code>, if it was previously declared.</p>
<p>Alternatively, you can pass the tuning options right in the command-line by
passing the option <code>--tune-here</code> that has the following format:</p>
<pre><code>```
--tune-here=key1=val1
--tune-here=key1=val1:key2=val2
...
```
</code></pre>
<ol>
<li>
<p><strong>Randomization</strong>: <code>smt.randomSeed=&lt;int&gt;</code> passes the random seed to <code>z3</code>
(via <code>z3</code>'s parameters <code>sat.random_seed</code> and <code>smt.random_seed</code>).</p>
</li>
<li>
<p><strong>Timeouts</strong>: <code>search.smt.timeout=&lt;seconds&gt;</code> defines the timeout to the
SMT solver in seconds. The default value is <code>0</code>, which stands for the unbounded
timeout.  For instance, the timeout is used in the following cases: checking if
a transition is enabled, checking an invariant, checking for deadlocks.  If the
solver times out, it reports 'UNKNOWN', and the model checker reports a runtime
error.</p>
</li>
<li>
<p><strong>Invariant mode</strong>: <code>search.invariant.mode=(before|after)</code> defines the
moment when the invariant is checked. In the <code>after</code> mode, all transitions are
first translated, one of them is picked non-deterministically and then the
invariant is checked. Although this mode reduces the number of SMT queries, it
usually requires more memory than the <code>before</code> mode. In the <code>before</code> mode, the
invariant is checked for every enabled transition independently. The <code>before</code>
mode may drastically reduce memory consumption, but it may take longer than the
<code>after</code> mode, provided that Apalache has enough memory. The default mode is
<code>before</code>.</p>
</li>
<li>
<p><strong>Guided search</strong>: <code>search.transitionFilter=&lt;regex&gt;</code>.
Restrict the choice of symbolic transitions at every step with a regular expression.
The regular expression should recognize words over of the form 's-&gt;t', where <code>s</code>
is a regular expression over step numbers and <code>t</code> is a regular expression over
transition numbers. For instance,
<code>search.transitionFilter=(0-&gt;0|1-&gt;5|2-&gt;2|3-&gt;3|[4-9]-&gt;.*|[1-9][0-9]+-&gt;.*)</code>
requires to start with the 0th transition, continue with the 5th transition,
then execute either the 2nd or the 3rd transition and after that execute
arbitrary transitions until the <code>length.</code> Note that there is no direct correspondence
between the transition numbers and the actions in the TLA+ spec. Check the
transition numbers in <code>./x/**/out-transition.tla</code>: 0th transition is called <code>Next$0</code>, 1st transition is called <code>Next$1</code>, etc.</p>
</li>
<li>
<p><strong>Invariant checking at certain steps</strong>: <code>search.invariantFilter=regex</code>.
Check the invariant only at the steps that satisfy the regular expression.
For instance, <code>search.invariantFilter=10|15|20</code> tells the model checker to
check the invariant only <em>after</em> exactly 10, 15, or 20 step were made. Step 0 corresponds
to the initialization with <code>Init</code>, step 1 is the first step with <code>Next</code>, etc.
This option is useful for checking consensus algorithms, where the decision
cannot be revoked. So instead of checking the invariant after each step, we can
do that after the algorithm has made a good number of steps.</p>
</li>
<li>
<p><strong>Translation to SMT</strong>:</p>
</li>
<li>
<p><strong>Short circuiting</strong>: <code>rewriter.shortCircuit=(false|true)</code>. When <code>rewriter.shortCircuit=true</code>, <code>A \/ B</code> and <code>A /\ B</code> are translated to SMT as if-then-else expressions, e.g., <code>(ite A true B)</code>. Otherwise, disjunctions and conjunctions are directly translated to <code>(or ...)</code> and <code>(and ...)</code> respectively. By default, <code>rewriter.shortCircuit=false</code>.</p>
</li>
<li>
<p><strong>Lazy short circuiting</strong>: <code>rewriter.lazyCircuit=(false|true)</code>. Given <code>A /\ B</code>, first check with the solver, whether <code>A</code> is satisfiable. If not, return reduce to <code>false</code> immediately; otherwise, rewrite <code>B</code>. By default, <code>rewriter.lazyCircuit=false</code>.</p>
</li>
</ol>
<h1><a class="header" href="#kera-kernel-logic-of-actions" id="kera-kernel-logic-of-actions">KerA: kernel logic of actions</a></h1>
<p>See <a href="https://dl.acm.org/citation.cfm?id=3360549">TLA+ model checking made symbolic</a>.</p>
<h1><a class="header" href="#assignments-in-apalache" id="assignments-in-apalache">Assignments in Apalache</a></h1>
<p>Any run of Apalache requires an operator name as the value for the parameter <code>--next</code> (by default, this value is <code>&quot;Next&quot;</code>). We refer to this operator as the <em>transition operator</em> (or <em>transition predicate</em>).</p>
<h2><a class="header" href="#actions-slices-and-minimal-actions" id="actions-slices-and-minimal-actions">Actions, Slices and Minimal Actions</a></h2>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>In TLA+, an <em>action</em> is any Boolean-valued expression or operator, that contains primed variables (e.g. <code>Next</code>). For the sake of this definition, assume <code>UNCHANGED x</code> is just syntactic sugar for <code>x' = x</code>.
Intuitively, actions are used to define the values of state variables after a transition, for example:</p>
<pre><code class="language-tla">VARIABLE x
...

Next == x' = x + 1
</code></pre>
<p>The state transition described by <code>Next</code> is fairly obvious; if <code>x</code> has the value of <code>4</code> in the current state, it will have the value of <code>5</code> in any successor state.
This brings us to the first natural requirement by Apalache: <em>the transition operator must be an action.</em></p>
<h3><a class="header" href="#successor-state-encodings" id="successor-state-encodings">Successor State Encodings</a></h3>
<p>Unfortunately, the notion of an action is too broad to be a sufficient requirement for the transition operator.
Consider this slight modification of the above example:</p>
<pre><code class="language-tla">VARIABLE x, y (* new variable *)
...

Next == x' = x + 1
</code></pre>
<p>Just as in the first example, the expression <code>x' = x + 1</code> is, by definition, an action.
However, since the second example defines a state variable <code>y</code>, this action is
no longer a sufficient description of a relation between a current state and a successor state; it does not determine a successor value <code>y'</code>.
This brings us to the second requirement: <em>the transition operator must allow Apalache to directly encode the relation between two successive states.</em>
This captures two sub-requirements: firstly, we disallow transition operators which fail to specify the value of one or more variables in the successor states, like the one in the example above. Secondly, we also disallow transition operators where the value of a successor state variable is determined only by implicit equations. Consider the following two cases:</p>
<pre><code class="language-tla">VARIABLE y
...

A == y' = 1
B == y' * y' - 2 * y' + 1 = 0
</code></pre>
<p>Using some basic math, we see that action <code>B</code> can be equivalently written as <code>(y' - 1)*(y' - 1) = 0</code>, so it describes the exact same successor state, in which the new value of <code>y</code> is <code>1</code>.
What makes it different from action <code>A</code> is the fact that this is far from immediately obvious from the syntax.
The fact that there happened to be a closed-form solution for which gave us an integer value for <code>y'</code>, is a lucky coincidence, as <code>B</code> could have been, for example, <code>y' * y' + 1 = 0</code>, with no real roots.
To avoid cases like this, we require that transition operators explicitly declare the values of state variables in successor states.</p>
<p>We call syntactic forms, which explicitly represent successor state values, <em>assignment candidates</em>. An assignment candidate for <code>x</code> is a TLA+ expression that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <a href="https://github.com/informalsystems/apalache/blob/unstable/src/tla/Apalache.tla">Apalache.tla</a>)</li>
</ul>
<p>So to reformulate the second requirement: the transition operator must contain at least one assignment candidate for each variable declared in the specification.</p>
<h3><a class="header" href="#control-flow-minimal-and-compound-actions" id="control-flow-minimal-and-compound-actions">Control Flow: Minimal and Compound Actions</a></h3>
<p>When writing non-trivial specifications, authors often end up with something similar to the following:</p>
<pre><code class="language-tla">EventA == ...
EventB == ...
...

Next == \/ EventA
        \/ EventB
</code></pre>
<p>Specifically, <code>EventA</code> and <code>EventB</code> often represent mutually exclusive possibilities of execution.
Just like before, the basic definition of an action is not sufficient to explain the relation of <code>EventA</code> or <code>EventB</code> and <code>Next</code>;
if <code>EventA</code> is an action and <code>EventB</code> is an action, then <code>Next</code> is also an action.
To more accurately describe this scenario, we observe that the operator or ( <code>\/</code>) sometimes serves as a kind of parallel composition operator (<code>||</code>) in process algebra - it connects two (or more) actions into a larger one.</p>
<p>There are only two operators in TLA+ that could be considered control-flow operators in this way, the or (<code>\/</code>) operator and the if-then-else operator.
We distinguish their uses as action- and as value operators:</p>
<pre><code class="language-tla">
A == x = 1 \/ x = 2 (* arguments are not actions *)
B == x' = 1 \/ x' = 2 (* arguments are actions *)
</code></pre>
<p>Simply put, if all arguments to an operator <code>\/</code> are actions, then that operator is an action-or, otherwise it is a value-or. Similarly, if both the <code>THEN _</code> and <code>ELSE _</code> subexpressions of if-then-else are actions, it is an action-ITE, otherwise it is a value-ITE (in particular, a value-ITE can be non-Boolean).</p>
<p>Using these two operators we can define the following terms:
A <em>minimal action</em> is an action which contains no action-or and no action-ITE.
Conversely, a <em>compound action</em> is an action which contains at least one action-or or at least one action-ITE.</p>
<h3><a class="header" href="#slices" id="slices">Slices</a></h3>
<p>Given a transition operator, which is most commonly a compound action, we can decompose it into as many minimal actions as possible. We call this process <em>slicing</em> and the resulting minimal actions <em>slices</em>.
This allows us to write transition operators in the following equivalent way:</p>
<pre><code class="language-tla">Next == \/ Slice1
        \/ Slice2
        ...
        \/ SliceN
</code></pre>
<p>Where each <code>Slice[i]</code> is a minimal action.</p>
<p>The details of slicing are nuanced and depend on operators other than or (<code>\/</code>) and if-then-else, but we give two examples here:</p>
<p>If a formula <code>A</code> has the shape <code>A1 \/ ... \/ An</code> (where <code>A1</code>, ... <code>An</code> are actions), then a slice of A has the shape <code>Si</code>, where <code>Si</code> is a slice of some <code>Ai</code>.</p>
<p>If a formula <code>A</code> has the shape <code>IF p THEN A1 ELSE A2</code> (where <code>A1</code>, <code>A2</code> are actions), then a slice of A has the shape
<code>p /\ S1</code> or <code>\neg p /\ S2</code>, where <code>S1</code> is a slice of <code>A1</code> and <code>S2</code> is a slice of <code>S2</code>.</p>
<p>Slices allow us to formulate the final requirement: the transition operator must be such, that we can select one assignment candidate for each variable in each of its slices (minimal actions) as an <em>assignment</em>. The process and conditions of selecting assignments from assignment candidates is described in the next section.</p>
<h2><a class="header" href="#a-idasgn--assignments-and-assignment-candidates" id="a-idasgn--assignments-and-assignment-candidates"><a id='asgn' /> Assignments and Assignment Candidates</a></h2>
<p>Recall, an <em>assignment candidate</em> for <code>x</code> is a TLA+ expression that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <code>Apalache.tla</code>)</li>
</ul>
<p>While a transition operator may contain multiple assignment candidates for the same variable, not all of them are chosen as <em>assignments</em> by Apalache. The subsections below describe how the assignments are selected.</p>
<h3><a class="header" href="#minimality" id="minimality">Minimality</a></h3>
<p>Assignments aren't spurious; each variable must have at least one assignment per transition operator, but no more than necessary to satisfy all of the additional constraints below (i.e. no more than one assignment per slice).</p>
<p>If all possible slices fail to assign one or more variables, an error, like the one below, is reported:</p>
<pre><code>Assignment error: No assignments found for: x, z
</code></pre>
<p>Such errors are usually the result of adding a <code>VARIABLE</code> without any accompanying TLA+ code relating to it.
The case where at least one transition, but not all of them, fails to assign a variable is shown below.</p>
<h3><a class="header" href="#syntax-order" id="syntax-order">Syntax Order</a></h3>
<p>For the purpose of evaluating assignments, Apalache considers the left-to-right syntax order of and-operator (<code>/\</code>) arguments.
Therefore, as many assignments as possible are selected from the first (w.r.t. syntax order) argument of and (<code>/\</code>), then from the second, and so on.</p>
<p>Example:</p>
<pre><code class="language-tla">Next == x' = 1 /\ x' = 2
</code></pre>
<p>In the above example, <code>x' = 1</code> would be chosen as an assignment to <code>x</code>, over <code>x' = 2</code>.</p>
<h3><a class="header" href="#assignment-before-use-convention" id="assignment-before-use-convention">Assignment-before-use Convention</a></h3>
<p>If, in the syntax order defined above, an expression containing a primed variable <code>x'</code> syntactically precedes an assignment to <code>x</code>, the assignment finder throws an exception of the following shape:</p>
<pre><code>Assignment error: test.tla:10:16-10:17: x' is used before it is assigned.
</code></pre>
<p>notifying the user of any variables used before assignment. In particular, right-hand-sides of assignment candidates ( e.g. <code>x' + 2</code> in <code>y' = x' + 2</code> )are subject to this restriction as well. Consider:</p>
<pre><code class="language-tla">A == x' &gt; 0 /\ x' = 1
B == y' = x' + 2 /\ x' = 1
</code></pre>
<p>In <code>A</code>, the expression <code>x' &gt; 0</code> precedes any assignment to <code>x</code> and in <code>B</code>, while <code>y' = x' + 2</code> is an assignment candidate for <code>y</code>, it precedes any assignment to <code>x</code>, so both expressions are inadmissible (and would trigger exceptions).</p>
<p>Note that this only holds true if <code>A</code> (resp. <code>B</code>) is chosen as the transition operator. If <code>A</code> is called inside another transition operator, for example in <code>Next == x' = 1 /\ A</code>, no error is reported.</p>
<h3><a class="header" href="#balance" id="balance">Balance</a></h3>
<p>In cases of the or-operator (<code>\/</code>), all arguments must have assignments for the same set of variables. In particular, if one argument contains an assignment candidate and another does not, such as in this example:</p>
<pre><code>\/ y = 1
\/ y' = 2
</code></pre>
<p>the assignment finder will report an error, like the one below:</p>
<pre><code>Assignment error: test.tla:10:15-10:19: Missing assignments to: y
</code></pre>
<p>notifying the user of any variables for which assignments exist in some, but not all, arguments to <code>\/</code>.
Note that if we correct and extend the above example to</p>
<pre><code class="language-tla">/\ \/ y' = 1
   \/ y' = 2
/\ y' = 3
</code></pre>
<p>the assignments to <code>y</code> would be <code>y' = 1</code> and <code>y' = 2</code>, but not <code>y' = 3</code>; minimality prevents us from selecting all three, the syntax order constraint forces us to select assignments in <code>y' = 1 \/ y' = 2</code> before <code>y' = 3</code> and balance requires that we select both <code>y' = 1</code> and <code>y' = 2</code>.
On the other hand, if we change the example to</p>
<pre><code class="language-tla">/\ y' = 3
/\ \/ y = 1
   \/ y' = 2
</code></pre>
<p>the only assignment has to be <code>y' = 3</code>. While one of the disjuncts is an assignment candidate and the other is not, the balance requirement is not violated here, since neither disjunct is chosen as an assignment.</p>
<p>Similar rules apply to if-then-else: both the <code>THEN _</code> and <code>ELSE _</code> branch must assign the same variables, however, the <code>IF _</code> condition is ignored when determining assignments.</p>
<h3><a class="header" href="#assignment-free-expressions" id="assignment-free-expressions">Assignment-free Expressions</a></h3>
<p>Not all expressions may contain assignments.
While Apalache permits the use of all assignment candidates, except ones defined with <code>:=</code>(details <a href="apalache/assignments.html#manual">here</a>), inside other expressions, some of these candidates will never be chosen as assignments, based on the syntactic restrictions outlined below:</p>
<p>Given a transition operator <code>A</code>, based on the shape of <code>A</code>, the following holds:</p>
<ul>
<li>If <code>A</code> has the shape <code>A_1 /\ ... /\ A_n</code>, then assignments are selected from <code>A_1, ... , A_n</code> sequentially, subject to the syntax-order rule.</li>
<li>If <code>A</code> has the shape <code>A_1 \/ ... \/ A_n</code>, then assignments are selected in all <code>A_1, ... , A_n</code> independently, subject to the balance rule.</li>
<li>If <code>A</code> has the shape <code>IF p THEN A_1 ELSE A_2</code>, then:
<ul>
<li><code>p</code> may not contain assignments. Any assignment candidates in <code>p</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in both <code>A_1</code> and <code>A_n</code> independently, subject to the balance rule.</li>
</ul>
</li>
<li>If <code>A</code> has the shape <code>\E x \in S: A_1</code>, then:
<ul>
<li><code>S</code> may not contain assignments. Any assignment candidates in <code>S</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in <code>A_1</code></li>
</ul>
</li>
<li>In any other case, <code>A</code> may not contain assignments, however, any assignment candidates in <code>A</code> are subject to the assignment-before-use rule.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-tla">A == /\ x' = 2
     /\ \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Operator <code>A</code> contains assignments to both <code>x</code> and <code>y</code>; while <code>x' &gt; t</code> uses <code>x'</code>, it does not violate the assignment-before-use rule, since the assignment to <code>x</code> precedes the expression, w.r.t. syntax order.</p>
<pre><code class="language-tla">(* INVALID *)
B == \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>In operator <code>B</code>, the assignment to <code>x</code> is missing, therefore <code>x' &gt; t</code> produces an error, as it violates assignment-before-use.</p>
<pre><code class="language-tla">C == /\ x' = 1
     /\ IF x' = 0 /\ 2 \in {x', x' + 2, 0}
        THEN y' = 1
        ELSE y' = 2
</code></pre>
<p>The case in <code>C</code> is similar to <code>A</code>; conditions of the if-then-else operator may not contain assignments to <code>x</code>, so <code>x' = 0</code> can never be one, but they may use <code>x'</code>, since a preceding expression (<code>x' = 1</code>) qualifies as an assignment.</p>
<pre><code class="language-tla">(* INVALID *)
D == IF x' = 0
     THEN y' = 1
     ELSE y' = 2
</code></pre>
<p>The operator <code>D</code> produces an error, for the same reason as <code>B</code>; even though <code>x' = 0</code> is an assignment candidate, if-conditions are assignment-free, so <code>x' = 0</code> cannot be chosen as an assignment to <code>x</code>.</p>
<pre><code class="language-tla">(* INVALID *)
E == /\ x' = 2
     /\ \A s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Lastly, while <code>E</code> looks almost identical to <code>A</code>, the key difference is that expressions under universal quantifiers may not contain assignments. Therefore, <code>y' = s</code> is <em>not</em> an assignment to <code>y</code> and thus violates assignment-before-use.</p>
<h2><a class="header" href="#a-idmanual--manual-assignments" id="a-idmanual--manual-assignments"><a id='manual' /> Manual Assignments</a></h2>
<p>Users may choose, but aren't required, to use manual assignments <code>x' := e</code> in place of <code>x' = e</code>.
While the use of this operator does not change Apalache's internal search for assignments (in particular, using manual assignment annotations is <em>not</em> a way of circumventing the syntax order requirement), we encourage the use of manual assignments for clarity.</p>
<p>Unlike other shapes of assignment candidates, whenever a manual assignment is used in a position where the assignment candidate would not be chosen as an assignment (either within assignment-free expressions or in violation of, for example, the syntax order rule) an error, like one of the two below, is reported:</p>
<pre><code>Assignment error: test.tla:10:12-10:18: Manual assignment is spurious, x is already assigned!
</code></pre>
<p>or</p>
<pre><code>Assignment error: test.tla:10:15-10:21: Illegal assignment inside an assignment-free expression.
</code></pre>
<p>The benefit of using manual assignments, we believe, lies in synchronizing the user's and the tool's understanding of where assignments happen.
This helps prevent unexpected results, where the user's expectations or intuition regarding assignment positions are incorrect.</p>
<p>Note: To use manual assignments where the assignment candidate has the shape of <code>x' \in S</code> use <code>\E s \in S: x' := s</code>.</p>
<h1><a class="header" href="#how-to-write-type-annotations-1" id="how-to-write-type-annotations-1">How to write type annotations</a></h1>
<p><strong>Warning:</strong> <em>This HOWTO discusses how to write type annotations for the new
type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a>, which has not been integrated with the model checker
yet.  If you want to run the model checker, you have to write the <a href="HOWTOs/../apalache/types-and-annotations.html">old type
annotations</a>, until we release the integration (soon!)</em> :(</p>
<p>This HOWTO gives you concrete steps to extend TLA+ specifications with type
annotations. You can find the detailed syntax of type annotations in
<a href="HOWTOs/../adr/002adr-types.html">ADR002</a>. The first rule of writing type annotations:</p>
<p><em>Do not to write any annotations at all, until the type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> is
asking you to write a type annotation.</em></p>
<p>Of course, there must be an exception to this rule. You have to write type
annotations for CONSTANTS and VARIABLES. This is because Snowcat infers types
of declarations in isolation instead of analyzing the whole specification.
The good news is that the type checker finds the types of many operators
automatically. </p>
<h2><a class="header" href="#recipe-1-recipe-variables" id="recipe-1-recipe-variables">Recipe 1: Recipe variables</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla">HourClock.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">---------------------- MODULE HourClock ----------------------
\* This is a local copy of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla
EXTENDS Naturals
VARIABLE hr
HCini  ==  hr \in (1 .. 12)
HCnxt  ==  hr' = IF hr # 12 THEN hr + 1 ELSE 1
HC  ==  HCini /\ [][HCnxt]_hr

TypeOK == hr \in (1 .. 12)
--------------------------------------------------------------
THEOREM  HC =&gt; []HCini
==============================================================
</code></pre>
<p>Without thinking much about the types, run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck HourClock.tla
</code></pre>
<p>The type checker complains about not knowing the type of the variable <code>hr</code>:</p>
<pre><code>...
[HourClock.tla:6:12-6:13]: Undefined name hr. Introduce a type annotation.
...
</code></pre>
<p>Annotate the type of variable <code>hr</code> as below. Note carefully that the type
annotation should be <em>between</em> the keyword <code>VARIABLE</code> and the variable name.
This is because variable declarations may declare several variables at once.
In this case, you have to write one type annotation per name.</p>
<pre><code class="language-tla">VARIABLE
  \* @type: Int;
  hr
</code></pre>
<p>Run the type checker again. You should see the following message:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-2-annotating-constants" id="recipe-2-annotating-constants">Recipe 2: Annotating constants</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla">Channel.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">
-------------------------- MODULE Channel -----------------------------
\* This is a typed version of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla
EXTENDS Naturals
CONSTANT Data
VARIABLE chan 

TypeInvariant  ==  chan \in [val : Data,  rdy : {0, 1},  ack : {0, 1}]
-----------------------------------------------------------------------
Init  ==  /\ TypeInvariant
          /\ chan.ack = chan.rdy 

Send(d) ==  /\ chan.rdy = chan.ack
            /\ chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]

Rcv     ==  /\ chan.rdy # chan.ack
            /\ chan' = [chan EXCEPT !.ack = 1 - @]

Next  ==  (\E d \in Data : Send(d)) \/ Rcv

Spec  ==  Init /\ [][Next]_chan
-----------------------------------------------------------------------
THEOREM Spec =&gt; []TypeInvariant
=======================================================================

</code></pre>
<p>Run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck Channel.tla
</code></pre>
<p>The type checker does not know the type of the variable <code>chan</code>:</p>
<pre><code>[Channel.tla:6:20-6:23]: Undefined name chan. Introduce a type annotation.
</code></pre>
<p>According to <code>TypeInvariant</code>, the variable <code>chan</code> is a record that has three
fields: <code>val</code>, <code>rdy</code>, and <code>ack</code>. The field <code>val</code> ranges over a set <code>Data</code>,
which is actually defined as <code>CONSTANT</code>. In principle, we can annotate the
constant <code>Data</code> with a set of any type, e.g., <code>Set(Int)</code> or <code>Set(BOOLEAN)</code>.
Since the specification is not using any operators over <code>Data</code> except equality,
we can use an <em>uninterpreted type</em> as a type for set elements, e.g.,
we can define <code>Data</code> to have the type <code>Set(DATUM)</code>. Uninterpreted types are
always written in CAPITALS. Now we can annotate <code>Data</code> and <code>chan</code> as follows:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(DATUM);
    Data
VARIABLE
    \* @type: [val: DATUM, rdy: Int, ack: Int];
    chan 
</code></pre>
<p>Note carefully that the type annotation should be <em>between</em> the keyword
<code>CONSTANT</code> and the constant name. This is because constant declarations may
declare several constants at once. In this case, you have to write one type
annotation per name.</p>
<p>Run the type checker again. You should see the following message:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-3-annotating-operators" id="recipe-3-annotating-operators">Recipe 3: Annotating operators</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CarTalkPuzzle/CarTalkPuzzle.tla">CarTalkPuzzle.tla</a> from the repository of TLA+
examples. This example has 160 lines of code, so we do not inline it here.
By running the type checker as in previous sections, you should figure out
that the constants <code>N</code> and <code>P</code> should be annotated with the type <code>Int</code>.
Annotate <code>N</code> and <code>P</code> with <code>Int</code> and run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck CarTalkPuzzle.tla
</code></pre>
<p>Now you should see the following error:</p>
<pre><code>[CarTalkPuzzle.tla:57:9-57:12]: Need annotation. Arguments match
2 operator signatures: (((a56 -&gt; a57), a56) =&gt; a57) and ((Seq(a56), Int) =&gt; a56)
</code></pre>
<p>Although the error message may look confusing, the reason is simple: The type
checker cannot figure out, whether the operator <code>Sum</code> expects a sequence
or a function of integers as its first parameter. By looking carefully at
the definition of <code>Sum</code>, we can see that it expects: (1) a function from
integers to integers as its first parameter, (2) a set of integers
as its second parameter, and (3) an integer as a result. Hence, we annotate
<code>Sum</code> as follows:</p>
<pre><code class="language-tla">RECURSIVE Sum(_,_)
\* type: (Int -&gt; Int, Set(Int)) =&gt; Int;
Sum(f,S) ==
    ...
</code></pre>
<p>Note that the annotation has to be written between <code>RECURSIVE Sum(_, _)</code> and
the definition of <code>Sum</code>. This might change later, see <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> at tlaplus.</p>
<p>After providing the type checker with the annotation for <code>Sum</code>, we get one
more type error:</p>
<pre><code>[CarTalkPuzzle.tla:172:23-172:26]: Need annotation. Arguments match
2 operator signatures: (((p -&gt; q), p) =&gt; q) and ((Seq(p), Int) =&gt; p)
</code></pre>
<p>This time the type checker cannot choose between two options for the second
parameter of <code>Image</code>: It could be a function, or a sequence. We help the
type checker by writing that the second parameter should be a function
of integers to integers, that is, <code>Int -&gt; Int</code>:</p>
<pre><code class="language-tla">      \* @type: (Set(Int), Int -&gt; Int) =&gt; Set(Int);
      Image(S, B) == {B[x] : x \in S}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-4-annotating-records" id="recipe-4-annotating-records">Recipe 4: Annotating records</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> from the repository of TLA+ examples. This
example has 176 lines of code, so we do not inline it here.</p>
<p>As you probably expected, the type checker complains about not knowing
the types of constants and variables. As for constant <code>RM</code>, we opt for using
an uninterpreted type that we call <code>RM</code>. That is:</p>
<pre><code class="language-tla">CONSTANT
        \* @type: Set(RM);
        RM
</code></pre>
<p>By looking at the spec, it is easy to guess the types of the variables
<code>rmState</code>, <code>tmState</code>, and <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: RM -&gt; Str;
  rmState,
  \* @type: Str;
  tmState,
  \* @type: Set(RM);
  tmPrepared
</code></pre>
<p>The type of the variable <code>msgs</code> is less obvious. We can check the definitions
of <code>TPTypeOK</code> and <code>Message</code> to get the idea about the type of <code>msgs</code>:</p>
<pre><code class="language-tla">Message ==
  ({[type |-&gt; t, rm |-&gt; r]: t \in {&quot;Prepared&quot;}, r \in RM }
   \cup
   {[type |-&gt; t] : t \in {&quot;Commit&quot;, &quot;Abort&quot;}})

TPTypeOK ==
  ...
  /\ msgs \in SUBSET Message
</code></pre>
<p>From these definitions, you can see that <code>msgs</code> is a set that contains records
of two types: <code>[type: Str]</code> and <code>[type: Str, rm: RM]</code>. When you have a set of
heterogeneous records, you have to choose the type of a super-record that
contains the fields of all records that could be put in the set. That is:</p>
<pre><code class="language-tla">  \* @type: Set([type: Str, rm: RM]);
  msgs           
</code></pre>
<p>A downside of this approach is that <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> will not help you in finding
an incorrect field access. We probably will introduce more precise types for
records later. See <a href="https://github.com/informalsystems/apalache/issues/401">Issue 401</a>.</p>
<h2><a class="header" href="#recipe-5-functions-as-sequences" id="recipe-5-functions-as-sequences">Recipe 5: functions as sequences</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/N-Queens/Queens.tla">Queens.tla</a> from the repository of TLA+ examples.  It has
85 lines of code, so we do not include it here. Similar to the previous
sections, we annotate constants and variables:</p>
<pre><code class="language-tla">CONSTANT 
         \* @type: Int;
         N
...         
VARIABLES
    \* @type: Set(Seq(Int));
    todo,
    \* @type: Set(Seq(Int));
    sols
</code></pre>
<p>After having inspected the type errors reported by Snowcat, we annotate the
operators <code>Attacks</code>, <code>IsSolution</code>, and <code>vars</code> as follows:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j) == ...

\* @type: Seq(Int) =&gt; Bool;
IsSolution(queens) == ...

\* @type: &lt;&lt;Set(Seq(Int)), Set(Seq(Int))&gt;&gt;;
vars == &lt;&lt;todo,sols&gt;&gt;
</code></pre>
<p>Now we run the type checker and receive the following type error:</p>
<pre><code>[Queens.tla:47:21-47:38]: Mismatch in argument types.
Expected: ((Seq(Int)) =&gt; Bool)
</code></pre>
<p>Let's have a closer look at the problematic operator definition of <code>Solutions</code>:</p>
<pre><code class="language-tla">Solutions ==
    { queens \in [1..N -&gt; 1..N]: IsSolution(queens) }
</code></pre>
<p>This looks funny: <code>IsSolution</code> is expecting a sequence, whereas <code>Solutions</code> is
clearly producing a set of functions. Of course, it is not a problem in the
untyped TLA+. In fact, it is a well-known idiom: Construct a function by using
function operators and then apply sequence operators to it. In Apalache we have
to explicitly write that a function should be reinterpreted as a sequence.  To
this end, we have to use the operator <code>FunAsSeq</code> from the module
<a href="https://github.com/informalsystems/apalache/blob/unstable/src/tla/Apalache.tla">Apalache.tla</a>. Hence, we add <code>Apalache</code> to the <code>EXTENDS</code> clause and
apply the operator <code>FunAsSeq</code> as follows:</p>
<pre><code class="language-tla">EXTENDS Naturals, Sequences, Apalache
...
Solutions ==
  LET Queens == { queens \in [1..N -&gt; 1..N] : FunAsSeq(queens, N) } IN
  { FunAsSeq(queens, N): queens \in Queens }
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#known-issues" id="known-issues">Known issues</a></h2>
<p>In contrast to all other cases, a local operator definition does require
a type annotation before the keyword <code>LOCAL</code>, not after it. For example:</p>
<pre><code class="language-tla">\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1
</code></pre>
<p>This may change later, when the tlaplus <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> is resolved.</p>
<h1><a class="header" href="#tla-language-reference-manual-" id="tla-language-reference-manual-">TLA+ Language Reference Manual üìó</a></h1>
<p>In this manual, we summarize our knowledge about TLA+ and about its treatment
with the <a href="https://github.com/informalsystems/apalache">Apalache model checker</a>. This is not the manual on Apalache, which
can be found in <a href="lang/../.">Apalache manual</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video Course</a> by Leslie Lamport is
an excellent starting point, if you are new to TLA+. For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. There are plenty of interesting talks on TLA+ at <a href="https://www.youtube.com/channel/UCLHtwjeqBxVSEhjV0clKblA/videos">TLA
Channel</a> of Markus Kuppe. This manual completely ignores Pluscal -- a
higher-level language on top of TLA+.  If you are interested in learning
Pluscal, check <a href="https://learntla.com">LearnTla.com</a> by Hillel Wayne.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ol>
<li><a href="lang/./standard-operators.html">The standard operators of TLA+</a> üîå</li>
<li><a href="lang/./user-operators.html">User-defined operators</a> üí°</li>
<li><a href="lang/./modules.html">Modules and instances</a>: MODULE, EXTENDS and INSTANCES ‚úÇ</li>
</ol>
<h1><a class="header" href="#the-standard-operators-of-tla" id="the-standard-operators-of-tla">The standard operators of TLA+</a></h1>
<p>In this document, we summarize the standard TLA+ operators in a form that is
similar to manuals on programming languages. The purpose of this document is to
provide you with a quick reference, whenever you are looking at the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of
TLA</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video
Course</a> by Leslie Lamport
is an excellent starting point, if you are new to TLA+.  For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. You can find handy extensions of the standard library in
<a href="https://github.com/tlaplus/CommunityModules">Community Modules</a>.</p>
<p>We explain the semantics of the operators under the lenses of the <a href="https://github.com/informalsystems/apalache">Apalache
model checker</a>.  Traditionally, the emphasis was put on the temporal operators
and action operators, as they build the foundation of TLA. We focus on the &quot;+&quot;
aspect of the language, which provides you with a language for writing a single
step by a state machine.  This part of the language is absolutely necessary for
writing and reading system specifications.  Moreover, we treat equally the
&quot;core&quot; operators of TLA+ and the &quot;library&quot; operators: This distinction is less
important to the language users than to the tool developers.</p>
<p>In this document, we present the semantics of TLA+, as if it was executed on a
computer that is equipped with an additional device that we call an <em>oracle</em>.
Most of the TLA+ operators are understood as deterministic operators, so they
can be executed on your computer. A few operators are non-deterministic, so
they require the oracle to resolve non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>. This is one of the most important features that makes TLA+
distinct from programming languages.  Wherever possible, we complement the
English semantics with code in <a href="https://www.python.org/">Python</a>. Although our
semantics are more restrictive than the denotational semantics in Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, they are very close to the treatment of TLA+ by the model
checkers: <a href="https://github.com/informalsystems/apalache">Apalache</a> and
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a>. Our relation between
TLA+ operators and Python code bears some resemblance to
<a href="https://github.com/Viasat/salt">SALT</a> and
<a href="https://github.com/tlaplus/PlusPy">PlusPy</a>.</p>
<p><em>Here, we are using the ASCII notation of TLA+, as this is what you
type. We give the nice LaTeX notation in the detailed description.  The
translation table between the LaTeX notation and ASCII can be found in <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary
of TLA</a>.</em></p>
<h2><a class="header" href="#the--operators-in-tla" id="the--operators-in-tla">The &quot;+&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#booleans-" id="booleans-">Booleans üö•</a></h3>
<p><em>Good old Booleans</em>. <a href="lang/./booleans.html">Learn more...</a></p>
<ul>
<li>Boolean algebra:
<ul>
<li><a href="lang/./booleans.html#const"><code>FALSE</code></a> and <a href="lang/./booleans.html#const"><code>TRUE</code></a>,</li>
<li><a href="lang/./booleans.html#and"><code>A /\ B</code></a> (also <code>A \land B</code>),</li>
<li><a href="lang/./booleans.html#or"><code>A \/ B</code></a> (also <code>A \lor B</code>),</li>
<li><a href="lang/./booleans.html#not"><code>~A</code></a> (also <code>\lnot A</code> and <code>\neg A</code>),</li>
<li><a href="lang/./booleans.html#implies"><code>A =&gt; B</code></a>,</li>
<li><a href="lang/./booleans.html#equiv"><code>A &lt;=&gt; B</code></a> (also <code>A \equiv B</code>)</li>
</ul>
</li>
<li>Boolean set: <a href="lang/./booleans.html#const"><code>BOOLEAN</code></a></li>
</ul>
<h3><a class="header" href="#control-flow-and-non-determinism-" id="control-flow-and-non-determinism-">Control flow and non-determinism üîÄ</a></h3>
<p><em>Hidden powers of TLA+</em>. <a href="lang/./control-and-nondeterminism.html">Learn more...</a></p>
<ul>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetOr"><code>A_1 \/ ... \/ A_n</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetExists"><code>\E x \in S: P</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetIte"><code>IF p THEN e_1 ELSE e_2</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetCase"><code>CASE</code> and <code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#deterministic-conditionals-" id="deterministic-conditionals-">Deterministic conditionals üöï</a></h3>
<p><em>You need them less often than you think</em>. <a href="lang/./conditionals.html">Learn more...</a></p>
<ul>
<li>Deterministic <a href="lang/./conditionals.html#ite"><code>IF-THEN-ELSE</code></a></li>
<li>Deterministic <a href="lang/./conditionals.html#case"><code>CASE</code></a> and <a href="lang/./conditionals.html#caseOther"><code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#integers-" id="integers-">Integers üî¢</a></h3>
<p><em>Unbounded integers like in Python.</em> <a href="lang/./integers.html">Learn more...</a></p>
<ul>
<li>Integer algebra:
<ul>
<li><a href="lang/./integers.html#uminus"><code>-i</code></a>, <a href="lang/./integers.html#plus"><code>i + k</code></a>,
<a href="lang/./integers.html#minus"><code>i - k</code></a>,</li>
<li><a href="lang/./integers.html#mult"><code>i * k</code></a>,
<a href="lang/./integers.html#div"><code>i \div k</code></a>, <a href="lang/./integers.html#mod"><code>i % k</code></a>,
<a href="lang/./integers.html#pow"><code>i^k</code></a></li>
</ul>
</li>
<li>Integer predicates:
<ul>
<li><a href="lang/./integers.html#lt"><code>i &lt; k</code></a>, <a href="lang/./integers.html#gt"><code>i &gt; k</code></a>,</li>
<li><a href="lang/./integers.html#lte"><code>i &lt;= k</code></a> (also <code>i =&lt; k</code> and <code>i \leq k</code>),
<a href="lang/./integers.html#gte"><code>i &gt;= k</code></a> (also <code>i \geq k</code>)</li>
</ul>
</li>
<li>Integer sets: <a href="lang/./integers.html#range"><code>i..k</code></a>,
<a href="lang/./integers.html#const"><code>Int</code></a>, <a href="lang/./integers.html#const"><code>Nat</code></a></li>
</ul>
<h3><a class="header" href="#strings-" id="strings-">Strings üî°</a></h3>
<p><em>String constants</em>. You learned it!</p>
<ul>
<li>String literals, e.g., <code>&quot;hello&quot;</code> and <code>&quot;TLA+ is awesome&quot;</code></li>
<li>Set of all finite strings: <code>STRING</code></li>
</ul>
<h3><a class="header" href="#sets-" id="sets-">Sets üç£</a></h3>
<p><em>Like frozen sets in Python, but cooler</em> <a href="lang/./sets.html">Learn more...</a></p>
<ul>
<li>Set constructors:
<ul>
<li>Enumeration: <a href="lang/./sets.html#setEnum"><code>{ e_1, ..., e_n }</code></a></li>
<li>Filter: <a href="lang/./sets.html#filter"><code>{ x \in S: p }</code></a></li>
<li>Map: <a href="lang/./sets.html#map"><code>{ e: x \in S }</code></a></li>
<li>Powers: <a href="lang/./sets.html#powerset"><code>SUBSET S</code></a> and <a href="lang/./sets.html#fold"><code>UNION S</code></a></li>
</ul>
</li>
<li>Set algebra:
<ul>
<li>Union: <a href="lang/./sets.html#union"><code>S \union T</code></a> (also <code>S \cup T</code>),</li>
<li>Intersection: <a href="lang/./sets.html#intersect"><code>S \intersect T</code></a> (also <code>S \cap T</code>),</li>
<li>Difference: <a href="lang/./sets.html#setminus"><code>S \ T</code></a></li>
</ul>
</li>
<li>Set predicates:
<ul>
<li>Membership: <a href="lang/./sets.html#in"><code>x \in S</code></a> and <a href="lang/./sets.html#notin"><code>x \notin S</code></a>,</li>
<li>Subsets: <a href="lang/./sets.html#subset"><code>S \subset T</code></a>,
<a href="lang/./sets.html#subseteq"><code>S \subseteq T</code></a>,
<a href="lang/./sets.html#supset"><code>S \supset T</code></a>,
<a href="lang/./sets.html#supseteq"><code>S \supseteq T</code></a></li>
<li>Finiteness: <a href="lang/./sets.html#finite"><code>IsFinite</code></a></li>
</ul>
</li>
<li>Cardinality of a finite set: <a href="lang/./sets.html#card"><code>Cardinality</code></a></li>
</ul>
<h3><a class="header" href="#logic-" id="logic-">Logic üêô</a></h3>
<p><em>How logicians write loops</em>. <a href="lang/./logic.html">Learn more...</a></p>
<ul>
<li>Equality:
<a href="lang/./logic.html#eq"><code>=</code></a> and <a href="lang/./logic.html#neq"><code>/=</code></a> (also <code>#</code>)</li>
<li>Bounded quantifiers:
<a href="lang/./logic.html#forallBounded"><code>\A x \in S: p</code></a> and <a href="lang/./logic.html#existsBounded"><code>\E x \in S: p</code></a></li>
<li>Unbounded quantifiers:
<a href="lang/./logic.html#forall"><code>\A x: p</code></a> and <a href="lang/./logic.html#exists"><code>\E x: p</code></a></li>
<li>Choice:
<a href="lang/./logic.html#chooseBounded"><code>CHOOSE x \in S: p</code></a> and <a href="lang/./logic.html#choose"><code>CHOOSE x: p</code></a></li>
</ul>
<h3><a class="header" href="#functions-" id="functions-">Functions üíπ</a></h3>
<p><em>Like frozen dictionaries in Python, but cooler</em>. <a href="lang/./functions.html">Learn more...</a></p>
<ul>
<li><a href="lang/./functions.html#funCtor">Function constructor</a>: <code>[ x \in S |-&gt; e ]</code></li>
<li><a href="lang/./functions.html#funSetCtor">Set of functions</a>: <code>[S -&gt; T]</code></li>
<li><a href="lang/./functions.html#funApp">Function application</a>: <code>f[e]</code></li>
<li><a href="lang/./functions.html#except">Function replacement</a>: <code>[ f EXCEPT ![e_1] = e_2 ]</code></li>
<li><a href="lang/./functions.html#domain">Function domain</a>: <code>DOMAIN f</code></li>
</ul>
<h3><a class="header" href="#records-" id="records-">Records üìö</a></h3>
<p><em>Records like everywhere else</em>. <a href="lang/./records.html">Learn more...</a></p>
<ul>
<li><a href="lang/./records.html#recCtor">Record constructor</a>: <code>[ h_1 |-&gt; e_1, ..., h_n |-&gt; e_n ]</code></li>
<li><a href="lang/./records.html#recSetCtor">Set of records</a>: <code>[ h_1: S_1, ..., h_n: S_n ]</code></li>
<li><a href="lang/./records.html#recApp">Access by field name</a>: <code>e.h</code></li>
<li>Records are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#tuples-" id="tuples-">Tuples üìê</a></h3>
<p><em>Well, tuples</em>, indexed with 1, 2, 3... <a href="lang/./tuples.html">Learn more...</a></p>
<ul>
<li><a href="lang/./tuples.html#tuple">Tuple constructor</a>: <code>&lt;&lt; e_1, ..., e_n &gt;&gt;</code></li>
<li><a href="lang/./tuples.html#times">Cartesian product</a>: <code>S_1 \X ... \X S_n</code> (also <code>S_1 \times ... \times S_n</code>)</li>
<li>Tuples are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#sequences-" id="sequences-">Sequences üêç</a></h3>
<p><em>Functions that pretend to be lists, indexed with 1, 2, 3,...</em></p>
<ul>
<li>Add to end: <a href="lang/./sequences.html#append"><code>Append(s, e)</code></a></li>
<li>First and rest: <a href="lang/./sequences.html#head"><code>Head(s)</code></a> and <a href="lang/./sequences.html#tail"><code>Tail(s)</code></a></li>
<li>Length: <a href="lang/./sequences.html#len"><code>Len(s)</code></a></li>
<li>Concatenation: <a href="lang/./sequences.html#concat"><code>s \o t</code></a> (also <code>s \circ t</code>)</li>
<li>Subsequence: <a href="lang/./sequences.html#subseq"><code>SubSeq(s, i, k)</code></a></li>
<li>Sequence filter: <a href="lang/./sequences.html#filter"><code>SelectSeq(s, Test)</code></a></li>
<li>Set of finite sequences over <code>S</code>: <a href="lang/./sequences.html#seq"><code>Seq(S)</code></a></li>
<li>Sequences are functions.
All operators of <a href="lang/./functions.html">functions</a> and <a href="lang/./tuples.html">tuples</a> are supported.</li>
</ul>
<h3><a class="header" href="#bags-" id="bags-">Bags üëú</a></h3>
<ul>
<li>TBD</li>
</ul>
<h3><a class="header" href="#reals-" id="reals-">Reals üç≠</a></h3>
<p><em>Like &quot;reals&quot; in your math classes, not floating point</em></p>
<ul>
<li>
<p>All operators of <code>Integers</code> but interpreted over reals</p>
</li>
<li>
<p><code>a / b</code>, <code>Real</code>, <code>Infinity</code></p>
</li>
</ul>
<h3><a class="header" href="#naturals-" id="naturals-">Naturals üêæ</a></h3>
<p><em>If you are Indiana Jones...</em></p>
<ul>
<li>All operators of <code>Integers</code> except: unary minus <code>-a</code> and <code>Int</code></li>
</ul>
<h2><a class="header" href="#the-a-operators-in-tla" id="the-a-operators-in-tla">The &quot;A&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#action-operators-" id="action-operators-">Action operators üèÉ</a></h3>
<p><em>Taking a step</em></p>
<ul>
<li>Prime: <code>e'</code></li>
<li>Preservation: <code>UNCHANGED e</code></li>
<li>Stuttering: <code>[A]_e</code> and <code>&lt;A&gt;_e</code></li>
<li>Action enablement: <code>ENABLED A</code></li>
<li>Sequential composition: <code>A \cdot B</code></li>
</ul>
<h2><a class="header" href="#the-tl-operators-in-tla" id="the-tl-operators-in-tla">The &quot;TL&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#temporal-operators-" id="temporal-operators-">Temporal operators üîú</a></h3>
<p><em>Talking about computations, finite and infinite</em></p>
<ul>
<li>Always: <code>[]F</code></li>
<li>Eventually: <code>&lt;&gt;F</code></li>
<li>Weak fairness: <code>WF_e(A)</code></li>
<li>Strong fairness: <code>SF_e(A)</code></li>
<li>Leads-to: <code>F ~&gt; G</code></li>
<li>Guarantee: <code>F -+-&gt; G</code></li>
<li>Temporal hiding: <code>\EE x: F</code></li>
<li>Temporal universal quantification: <code>\AA x: F</code></li>
</ul>
<h1><a class="header" href="#booleans" id="booleans">Booleans</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>You find these operators in every programming language and every textbook on
logic. These operators form <em>propositional logic</em>.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants" id="constants">Constants</a></h2>
<p>TLA+ contains three special constants: <code>TRUE</code>, <code>FALSE</code>, and <code>BOOLEAN</code>.
The constant <code>BOOLEAN</code> is defined as the set <code>{FALSE, TRUE}</code>.</p>
<p>A note for set-theory purists: In theory, <code>TRUE</code> and <code>FALSE</code> are also sets, but
in practice they are treated as indivisible values. For instance, Apalache and
TLC will report an error, if you try to treat <code>FALSE</code> and <code>TRUE</code> as sets.</p>
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<p><strong>Warning</strong>: Below, we discuss Boolean operators in terms of the way they are usually
defined in programming languages. However, it is important to understand that the
disjunction operator <code>F \/ G</code> induces a nondeterministic effect when <code>F</code> or <code>G</code> contain
the prime operator  (<code>'</code>), or when they are used inside the initialization predicate <code>Init</code>.
We discuss this effect <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<hr />
<p><a name="and"></a></p>
<h3><a class="header" href="#and-conjunction" id="and-conjunction">And (conjunction)</a></h3>
<p><strong>Notation:</strong> <code>F /\ G</code> or <code>F \land G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/land.png" alt="land" /></p>
<p><strong>Arguments:</strong> Two or more arbitrary expressions.</p>
<p><strong>Effect:</strong> The binary case <code>F /\ G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>FALSE</code>,
or <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 /\ ... /\ F_n</code> can be understood by evaluating
the expression <code>F_1 /\ (F_2 /\ ... /\ (F_{n-1} /\ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> Deterministic, if the arguments are deterministic.  Otherwise,
the possible effects of non-determinism of each argument are combined.  See
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if either conjunct evaluates to
a non-Boolean value (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  /\ TRUE    \* TRUE
FALSE /\ TRUE    \* FALSE
TRUE  /\ FALSE   \* FALSE
FALSE /\ FALSE   \* FALSE
FALSE /\ 1       \* FALSE in TLC, type error in Apalache
    1 /\ FALSE   \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">True  and True # True
False and True # False
True  and False # False
False and False # False
False and 1 # False, because 1 is cast to True
1 and False # False, because 1 is cast to True
</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, conjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  /\ F_1
    /\ G_1
    ...
    /\ G_k
  /\ F_2
  ...
  /\ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>/\</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 /\ (G_1 /\ ... /\ G_k) /\ F_2 /\ ... /\ F_n
</code></pre>
<hr />
<p><a name="or"></a></p>
<h3><a class="header" href="#or-disjunction" id="or-disjunction">Or (disjunction)</a></h3>
<p><strong>Notation:</strong> <code>F \/ G</code> or <code>F \lor G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lor.png" alt="lor" /></p>
<p><strong>Arguments:</strong> Two or more Boolean expressions.</p>
<p><strong>Effect:</strong></p>
<p>The binary case <code>F \/ G</code> evaluates to:</p>
<ul>
<li>
<p><code>FALSE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>TRUE</code>,
or <code>F</code> evaluates to <code>FALSE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 \/ ... \/ F_n</code> can be understood by evaluating
the expression <code>F_1 \/ (F_2 \/ ... \/ (F_{n-1} \/ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> deterministic, if the arguments may not update primed
variables.  If the arguments may update primed variables, disjunctions may
result in non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if a non-Boolean argument
is involved in the evaluation (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  \/ TRUE    \* TRUE
FALSE \/ TRUE    \* TRUE
TRUE  \/ FALSE   \* TRUE
FALSE \/ FALSE   \* FALSE
TRUE  \/ 1       \* TRUE in TLC, type error in Apalache
    1 \/ TRUE    \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">True  or True   # True
False or True   # True
True  or False  # True
False or False  # False
</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, disjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  \/ F_1
    \/ G_1
    ...
    \/ G_k
  \/ F_2
  ...
  \/ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>\/</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 \/ (G_1 \/ ... \/ G_k) \/ F_2 \/ ... \/ F_n
</code></pre>
<p>The indented form allows you to combine conjunctions and disjunctions:</p>
<pre><code class="language-tla">  \/ /\ F
     /\ G
  \/ \/ H
     \/ J
</code></pre>
<p>The above formula is equivalent to:</p>
<pre><code class="language-tla">  (F /\ G) \/ (H \/ J)
</code></pre>
<hr />
<p><a name="not"></a></p>
<h3><a class="header" href="#negation" id="negation">Negation</a></h3>
<p><strong>Notation:</strong> <code>~F</code> or <code>\neg F</code> or <code>\lnot F</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lnot.png" alt="lnot" /></p>
<p><strong>Arguments:</strong> One argument that should evaluate to a Boolean value.</p>
<p><strong>Effect:</strong></p>
<p>The value of <code>~F</code> is computed as follows:</p>
<ul>
<li>if <code>F</code> is evaluated to <code>FALSE</code>, then <code>~F</code> is evaluated to <code>TRUE</code>,</li>
<li>if <code>F</code> is evaluated to <code>TRUE</code>, then <code>~F</code> is evaluated to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if the argument evaluates to
a non-Boolean value. In this case, Apalache statically reports a type error,
whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">~TRUE    \* FALSE
~FALSE   \* TRUE
~(1)     \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">not True    # False
not False   # True
</code></pre>
<hr />
<p><a name="implies"></a></p>
<h3><a class="header" href="#implication" id="implication">Implication</a></h3>
<p><strong>Notation:</strong> <code>F =&gt; G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/implies.png" alt="implies" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Effect:</strong> <code>F =&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>FALSE</code>, or
<code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE =&gt; TRUE    \* TRUE
TRUE  =&gt; TRUE    \* TRUE
FALSE =&gt; FALSE   \* TRUE
TRUE  =&gt; FALSE   \* FALSE
FALSE =&gt; 1       \* TRUE in TLC, type error in Apalache
TRUE  =&gt; 1       \* runtime error in TLC, type error in Apalache
1     =&gt; TRUE    \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Recall that <code>A =&gt; B</code> is equivalent to <code>~A \/ B</code>.</p>
<pre><code class="language-python">(not False) or True     # True
(not True)  or True     # True
(not False) or False    # True
(not True)  or False    # False
</code></pre>
<hr />
<p><a name="equiv"></a></p>
<h3><a class="header" href="#equivalence" id="equivalence">Equivalence</a></h3>
<p><strong>Notation:</strong> <code>F &lt;=&gt; G</code> or <code>F \equiv G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/equiv.png" alt="equiv" /> or <img src="lang/./img/equiv2.png" alt="equiv2" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Effect:</strong> <code>F &lt;=&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>,
or both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if one of the arguments evaluates to <code>TRUE</code>,
while the other argument evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>How is <code>F &lt;=&gt; G</code> different from <code>F = G</code>? Actually, <code>F &lt;=&gt; G</code> is equality
that is defined only for Boolean values. In other words, if <code>F</code> and <code>G</code> are
evaluated to Boolean values, then <code>F &lt;=&gt; G</code> and <code>F = G</code> are evaluated to the
same Boolean value. We prefer <code>F &lt;=&gt; G</code> to <code>F = G</code>, as <code>F &lt;=&gt; G</code> clearly
indicates the intended types of <code>F</code> and <code>G</code> and thus makes the logical
structure more obvious.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE &lt;=&gt; TRUE   \* FALSE
TRUE  &lt;=&gt; TRUE   \* TRUE
FALSE &lt;=&gt; FALSE  \* TRUE
TRUE  &lt;=&gt; FALSE  \* TRUE
FALSE &lt;=&gt; 1      \* runtime error in TLC, type error in Apalache
1     &lt;=&gt; TRUE   \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Assuming that both expressions are Boolean, <code>F &lt;=&gt; G</code> is equivalent to <code>F = G</code>.</p>
<pre><code class="language-python">False == True   # False
True  == True   # True
False == False  # True
True  == False  # False
</code></pre>
<h1><a class="header" href="#control-flow-and-non-determinism-in-tla" id="control-flow-and-non-determinism-in-tla">Control Flow and Non-determinism in TLA+</a></h1>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<p><strong>Author:</strong> Igor Konnov</p>
<p><strong>Peer review:</strong> Shon Feder, Jure Kukovec</p>
<p>Non-determinism is one of the TLA+ features that makes it different from
mainstream programming languages. However, it is very easy to overlook it: There is no
special syntax for expressing non-determinism. In pure TLA+, whether your
specification is deterministic or not depends on the evaluation of the initial
predicate and of the transition predicate. These are usually called <code>Init</code> and
<code>Next</code>, respectively. In the following, we first intuitively explain what non-determinism
means in the mathematical framework of TLA+, and then proceed with the
explanation that is friendly to computers and software engineers.</p>
<h2><a class="header" href="#explaining-non-determinism-to-humans" id="explaining-non-determinism-to-humans">Explaining non-determinism to humans</a></h2>
<p><strong>States, transitions, actions, computations.</strong> Every TLA+ specification comes
with a set of state variables. For instance, the following specification
declares two state variables <code>x</code> and <code>y</code>:</p>
<pre><code class="language-tla">-------- MODULE coord ----------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ y' = y + 1
================================
</code></pre>
<p>A <em>state</em> is a mapping from state variables to TLA+ values. We do not go into
the mathematical depths of precisely defining TLA+ values. Due to the
background theory of ZFC, this set is well-defined and is not subject to
logical paradoxes. Basically, the values are Booleans, integers, strings, sets,
functions, etc.</p>
<p>In the above example, the operator <code>Init</code> evaluates to <code>TRUE</code> on exactly one
state, which we can conveniently write using the record constructor as follows:
<code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>The operator <code>Next</code> contains primes (<code>'</code>) and thus represents pairs of states,
which we call <em>transitions</em>. An operator over unprimed and primed variables
is called an <em>action</em> in TLA+. Intuitively, the operator <code>Next</code> in our example
evaluates to <code>TRUE</code> on infinitely many pairs of states. For instance, <code>Next</code>
evaluates to <code>TRUE</code> on the following pairs:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; 0, y |-&gt; 0], [x |-&gt; 1, y |-&gt; 1]&gt;&gt;
&lt;&lt;[x |-&gt; 1, y |-&gt; 1], [x |-&gt; 2, y |-&gt; 2]&gt;&gt;
&lt;&lt;[x |-&gt; 2, y |-&gt; 2], [x |-&gt; 3, y |-&gt; 3]&gt;&gt;
...
</code></pre>
<p>In our example, the second state of every transition matches the first state
of the next transition in the list. This is because the above sequence of
transitions describes the following sequence of states:</p>
<pre><code class="language-tla">[x |-&gt; 0, y |-&gt; 0]
[x |-&gt; 1, y |-&gt; 1]
[x |-&gt; 2, y |-&gt; 2]
[x |-&gt; 3, y |-&gt; 3]
...
</code></pre>
<p>Actually, we have just written a computation of our specification.
A <em>finite computation</em> is a finite sequence of states <code>s_0, s_1, ..., s_k</code>
that satisfies the following properties:</p>
<ul>
<li>The operator <code>Init</code> evaluates to <code>TRUE</code> on state <code>s_0</code>, and</li>
<li>The operator <code>Next</code> evaluates to <code>TRUE</code> on every pair of states <code>&lt;&lt;s_i, s_j&gt;&gt;</code>
for <code>0 &lt;= i &lt; k</code> and <code>j = i + 1</code>.</li>
</ul>
<p>We can also define an <em>infinite computation</em> by considering an infinite
sequence of states that are connected via <code>Init</code> and <code>Next</code> as above, but
without stopping at any index <code>k</code>.</p>
<p>Below we plot the values of <code>x</code> and <code>y</code> in the first 16 states with red dots.
Not surprisingly, we just get a line.</p>
<p><img src="lang/./img/diagonal.png" alt="diagonal" /></p>
<p><strong>Note:</strong> In the above examples, we only showed transitions that could be
produced by computations, which (by our definition) originate from the initial
states. These transitions contain <em>reachable</em> states. In principle, <code>Next</code> may
also describe transitions that contain unreachable states. For instance, the
operator <code>Next</code> from our example evaluates to <code>TRUE</code> on the following pairs as
well:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; -100, y |-&gt; -100], [x |-&gt; -99, y |-&gt; -99]&gt;&gt;
&lt;&lt;[x |-&gt; -100, y |-&gt; 100], [x |-&gt; -99, y |-&gt; 101]&gt;&gt;
&lt;&lt;[x |-&gt; 100, y |-&gt; -100], [x |-&gt; 101, y |-&gt; -99]&gt;&gt;
...
</code></pre>
<p>There is no reason to restrict transitions only to the reachable states
(and it would be hard to do, technically). This feature is often used to reason
about inductive invariants.</p>
<p><strong>Determinism and non-determinism.</strong> Our specification is quite boring: It
describes exactly one initial state, and there is no variation in computing the
next states.  We can make it a bit more interesting:</p>
<pre><code class="language-tla">------------ MODULE coord2 ---------------
VARIABLES x, y
Init == x = 0 /\ (y = 0 \/ y = 1 \/ y = 2)
Next == x' = x + 1 /\ y' = y + 1
==========================================
</code></pre>
<p>Now our plot has a bit more variation. It presents three computations
that are starting in three different initial states: <code>[x |-&gt; 0, y |-&gt; 0]</code>,
<code>[x |-&gt; 0, y |-&gt; 1]</code>, and <code>[x |-&gt; 0, y |-&gt; 2]</code>.</p>
<p><img src="lang/./img/diagonal3.png" alt="diagonal3" /></p>
<p>However, there is still not much variation in <code>Next</code>. For every state <code>s</code>,
we can precisely say which state follows <code>s</code> according to <code>Next</code>. We can
define <code>Next</code> as follows (note that <code>Init</code> is defined as in <code>coord</code>):</p>
<pre><code class="language-tla">------------ MODULE coord3 -----------------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ (y' = x \/ y' = x + 1)
============================================
</code></pre>
<p>The following plot shows the states that are visited by the computations
of the specification <code>coord3</code>:</p>
<p><img src="lang/./img/diag2.png" alt="diag2" /></p>
<p>Notice that specification <code>coord</code> describes one infinite computation (and
infinitely many finite computations that are prefixes of the infinite
computation).  Specification <code>coord2</code> describes three infinite computations.
Specification <code>coord3</code> describes infinitely many infinite computations: At
every step, <code>Next</code> may choose between <code>y' = x</code> or <code>y' = x + 1</code>.</p>
<p>Why are these specifications so different? The answer lies in non-determinism.
Specification <code>coord</code> is completely deterministic: There is just one state that
evaluates <code>Init</code> to <code>TRUE</code>, and every state is the first component of exactly
one transition, as specified by <code>Next</code>. Specification <code>coord2</code> has
non-determinism in the operator <code>Init</code>. Specification <code>coord3</code> has
non-determinism in the operator <code>Next</code>.</p>
<p><strong>Discussion.</strong>
So far we have been talking about the intuition. If you would like to know more about
the logic behind TLA+ and the semantics of TLA+, check Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and <a href="https://members.loria.fr/SMerz/papers/tla+logic2008.pdf">The Specification Language TLA+</a>.</p>
<p>When we look at the operators like <code>Init</code> and <code>Next</code> in our examples, we can
guess the states and transitions. If we could ask our logician friend to guess
the states and transitions for us every time we read a TLA+ specification, that
would be great. But this approach does not scale well.</p>
<p><strong>Can we explain non-determinism to a computer?</strong> It turns out that we can.
In fact, many model checkers support non-determinism in their input languages.
For instance, see <a href="https://github.com/boogie-org/boogie">Boogie</a> and <a href="http://spinroot.com/spin/whatispin.html">Spin</a>.
Of course, this comes with constraints on the structure of the specifications.
After all, people are much better at solving certain logical puzzles than
computers, though people get bored much faster than computers.</p>
<p>To understand how TLC enumerates states, check Chapter 14 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying
Systems</a>. In the rest of this document, we focus on treatment of
non-determinism that is close to the approach in Apalache.</p>
<h2><a class="header" href="#explaining-non-determinism-to-computers" id="explaining-non-determinism-to-computers">Explaining non-determinism to computers</a></h2>
<p>To see how a program could evaluate a TLA+ expression, we need two more
ingredients: bindings and oracles.</p>
<p><strong>Bindings.</strong> We generalize states to bindings: Given a set of names <code>N</code>, a
<em>binding</em> maps every name from <code>N</code> to a value.  When <code>N</code> is the set of all
state variables, a binding describes a state.  However, a binding does not have
to assign values to all state variables.  Moreover, a binding may assign values
to names that are not the names of state variables. In the following, we are
using bindings over subsets of names that contain: (1) names of the state
variables, and (2) names of the primed state variables.</p>
<p>To graphically distinguish bindings from states, we use parentheses and arrows
to define bindings. For instance, <code>(x -&gt; 1, x' -&gt; 3)</code> is a binding that maps
<code>x</code> to 1 and <code>x'</code> to 3. (This is our notation, not a common TLA+ notation.)</p>
<p><strong>Evaluating deterministic expressions.</strong> Consider the specification <code>coord</code>,
which was given above.  By starting with the empty binding <code>()</code>, we can see how
to automatically evaluate the body of the operator <code>Init</code>:</p>
<pre><code class="language-tla">x = 0 /\ y = 0
</code></pre>
<p>By following <a href="lang/./booleans.html">semantics of conjunction</a>, we see that <code>/\</code> is
evaluated from left-to-right. The left-hand side equality <code>x = 0</code> is treated as
an assignment to <code>x</code>, since <code>x</code> is not assigned a value in the empty binding
<code>()</code>, which it is evaluated against.  Hence, the expression <code>x = 0</code> produces
the binding <code>(x -&gt; 0)</code>. When applied to this binding, the right-hand side
equality <code>y = 0</code> is also treated as an assignment to <code>y</code>. Hence, the expression
<code>y = 0</code> results in the binding <code>(x -&gt; 0, y -&gt; 0)</code>. This binding is defined over
all state variables, so it gives us the only initial state <code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>Let's see how to evaluate the body of the operator <code>Next</code>:</p>
<pre><code class="language-tla">x' = x + 1 /\ y' = y + 1
</code></pre>
<p>As we have seen, <code>Next</code> describes pairs of states. Thus, we will produce
bindings over non-primed and primed variables, that is, over <code>x, x', y, y'</code>.
Non-primed variables represent the state before a transition fires, whereas
primed variables represent the state after the transition has been fired.</p>
<p>Consider evaluation of <code>Next</code> in the state <code>[x |-&gt; 3, y |-&gt; 3]</code>, that is, the
evaluation starts with the binding <code>(x -&gt; 3, y -&gt; 3)</code>.  Similar to the
conjunction in <code>Init</code>, the conjunction in <code>Next</code> first produces the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4)</code> and then the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4, y' -&gt; 4)</code>.  Moreover, <code>Next</code> evaluates to <code>TRUE</code> when it is evaluated against the
binding <code>(x -&gt; 3, y -&gt; 3)</code>. Hence, the state <code>[x |-&gt; 3, y |-&gt; 3]</code> has the only
successor <code>[x |-&gt; 4, y |-&gt; 4]</code>, when following the transition predicate <code>Next</code>.</p>
<p>In contrast, if we evaluate <code>Next</code> when starting with the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, the result will be <code>FALSE</code>, as the left-hand side of
the conjunction <code>x' = x + 1</code> evaluates to <code>FALSE</code>.  Indeed, <code>x'</code> has value <code>1</code>,
whereas <code>x</code> has value <code>3</code>, so <code>x' = x + 1</code> is evaluated as <code>1 = 3 + 1</code> against
the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, which gives us <code>FALSE</code>.
Hence, the pair of states <code>[x |-&gt; 3, y |-&gt; 3]</code> and <code>[x |-&gt; 1, y |-&gt; 1]</code> is not
a valid transition as represented by <code>Next</code>.</p>
<p>So far, we only considered unconditional operators. Let's have a look at the
operator <code>A</code>:</p>
<pre><code class="language-tla">A ==
  y &gt; x /\ y' = x /\ x' = x
</code></pre>
<p>Evaluation of <code>A</code> against the binding <code>(x -&gt; 3, y -&gt; 10)</code> produces the binding
<code>(x -&gt; 3, y -&gt; 10, x' -&gt; 3, y' -&gt; 3)</code> and the result <code>TRUE</code>.  However, in the
evaluation of <code>A</code> against the binding <code>(x -&gt; 10, y -&gt; 3)</code>, the leftmost
condition <code>y &gt; x</code> evaluates to <code>FALSE</code>, so <code>A</code> evaluates to <code>FALSE</code> against the
binding <code>(x -&gt; 10, y -&gt; 3)</code>. Hence, no next state can be produced from the
the state <code>[x |-&gt; 3, y |-&gt; 10]</code> by using operator <code>A</code>.</p>
<p>Until this moment, we have been considering only deterministic examples, that is,
there was no &quot;branching&quot; in our reasoning. Such examples can be easily put into
a program. What about the operators, where we can choose from multiple options
that are simultaneously enabled? We introduce an oracle to resolve this issue.</p>
<p><strong>Oracles.</strong> For multiple choices, we introduce an external device that we call
an oracle. More formally, we assume that there is a device called <code>GUESS</code> that
has the following properties:</p>
<ol>
<li>For a non-empty set <code>S</code>, a call <code>GUESS S</code> returns
some value <code>v \in S</code>.</li>
<li>A call <code>GUESS {}</code> halts the evaluation.</li>
<li>There are no assumptions about fairness of <code>GUESS</code>. It is free to return
elements in any order, produce duplicates and ignore some elements.</li>
</ol>
<p>Why do we call it a device? We cannot call it a function, as functions are
deterministic by definition. For the same reason, it is not a TLA+
operator. In logic, we would say that <code>GUESS</code> is simply a binary relation on
sets and their elements, which would be no different from the membership
relation <code>\in</code>.</p>
<p>Why do we need <code>GUESS S</code> and cannot use <code>CHOOSE x \in S: TRUE</code> instead?
Actually, <code>CHOOSE x \in S: TRUE</code> is <em>deterministic</em>. It is guaranteed to return
the same value, when it is called on two equals sets: if <code>S = T</code>, then
<code>(CHOOSE x \in S: TRUE) = (CHOOSE x \in T: TRUE)</code>. Our <code>GUESS S</code> does not have
this guarantee. It is free to return an arbitrary element of <code>S</code> each time
we call it.</p>
<p>How to implement <code>GUESS S</code>? There is no general answer to this question.
However, we know of multiple sources of non-determinism in computer science. So
we can think of <code>GUESS S</code> as being one of the following implementations:</p>
<ol>
<li>
<p><code>GUESS S</code> can be a remote procedure call in a distributed system.  Unless,
we have centralized control over the distributed system, the returned value of
RPC may be non-deterministic.</p>
</li>
<li>
<p><code>GUESS S</code> can be simply the user input. In this case, the user resolves
non-determinism.</p>
</li>
<li>
<p><code>GUESS S</code> can be controlled by an adversary, who is trying to break the
system.</p>
</li>
<li>
<p><code>GUESS S</code> can pick an element by calling a pseudo-random number generator.
However, note that RNG is a very special way of resolving non-determinism: It
assumes probabilistic distribution of elements (usually, it is close to the
<a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution">uniform
distribution</a>).
Thus, the probability of producing an unfair choice of elements with RNG will
be approaching 0.</p>
</li>
</ol>
<p>As you see, there are multiple sources of non-determinism. With <code>GUESS S</code> we can
model all of them. As TLA+ does not introduce special primitives for different
kinds of non-determinism, neither do we fix any implementation of <code>GUESS S</code>.</p>
<p><strong>Halting.</strong> Note that <code>GUESS {}</code> halts the evaluation. What does it mean? The
evaluation cannot continue. It does not imply that we have found a deadlock in
our TLA+ specification. It simply means that we made wrong choices on the way.
If we would like to enumerate all possible state successors, like TLC does, we
have to backtrack (though that needs fairness of <code>GUESS</code>). In general, the
course of action depends on the program analysis that you implement. For
instance, a random simulator could simply backtrack and randomly choose another
value.</p>
<p><a name="nondetExists"></a></p>
<h3><a class="header" href="#non-determinism-in-e-x-in-s-p" id="non-determinism-in-e-x-in-s-p">Non-determinism in <code>\E x \in S: P</code></a></h3>
<p>We only have to consider the following case: <code>\E x \in S: P</code> is evaluated against
a binding <code>s</code>, and there is a primed state variable <code>y'</code> that satisfies two
conditions:</p>
<ol>
<li>The predicate <code>P</code> refers to <code>y'</code>, that is, <code>P</code> has to assign a value to <code>y'</code>.</li>
<li>The value of <code>y'</code> is not defined yet, that is, binding <code>s</code> does not have a
value for the name <code>y'</code>.</li>
</ol>
<p>If the above assumptions do not hold true, the expression <code>\E x \in S: P</code> does
not have non-determinism and it can be evaluated by following the standard
deterministic semantics of exists, see <a href="lang/./logic.html">Logic</a>.</p>
<p><strong>Note:</strong> We do not consider action operators like <code>UNCHANGED y</code>. They can be
translated into an equivalent form, e.g., <code>UNCHANGED x</code> is equivalent to <code>y' = y</code>.</p>
<p>Now it is very easy to evaluate <code>\E x \in S: P</code>. We simply evaluate the
following expression:</p>
<pre><code class="language-tla">  LET x == GUESS S IN P
</code></pre>
<p>It is the job of <code>GUESS S</code> to tell us what value of <code>x</code> should be
evaluated. There are three possible outcomes:</p>
<ol>
<li>Predicate <code>P</code> evaluates to <code>TRUE</code> when using the provided value of <code>x</code>.
In this case, <code>P</code> assigns the value of an expression <code>e</code> to <code>y'</code> as soon as
the evaluator meets the expression <code>y' = e</code>.
The evaluation may continue.</li>
<li>Predicate <code>P</code> evaluates to <code>FALSE</code> when using the provided value of <code>x</code>.
Well, that was a wrong guess. According to our semantics, the evaluation
halts. See the above discussion on &quot;halting&quot;.</li>
<li>The set <code>S</code> is empty, and <code>GUESS S</code> halts.  See the above discussion on
&quot;halting&quot;.</li>
</ol>
<p><strong>Example.</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLE x
Init == x = 0
Next ==
  \E i \in Int:
    i &gt; x /\ x' = i
</code></pre>
<p>It is easy to evaluate <code>Init</code>: It does not contain non-determinism and it
produces the binding <code>(x -&gt; 0)</code> and the state <code>[x |-&gt; 0]</code>, respectively. When
evaluating <code>Next</code> against the binding <code>(x -&gt; 0)</code>, we have plenty of choices.
Actually, we have infinitely many choices, as the set <code>Int</code> is infinite.  TLC
would immediately fail here. But there is no reason for our evaluation to fail.
Simply ask the oracle. Below we give three examples of how the evaluation
works:</p>
<pre><code>1. (GUESS Int) returns 10. (LET i == 10 IN i &gt; x /\ x' = i) is TRUE, x' is assigned 10.
2. (GUESS Int) returns 0. (LET i == 0 IN i &gt; x /\ x' = i) is FALSE. Halt.
3. (GUESS Int) returns -20. (LET i == -20 IN i &gt; x /\ x' = i) is FALSE. Halt.
</code></pre>
<p><a name="nondetOr"></a></p>
<h3><a class="header" href="#non-determinism-in-disjunctions" id="non-determinism-in-disjunctions">Non-determinism in disjunctions</a></h3>
<p>Consider a disjunction that comprises <code>n</code> clauses:</p>
<pre><code class="language-tla">  \/ P_1
  \/ P_2
  ...
  \/ P_n
</code></pre>
<p>Assume that we evaluate the disjunction against a binding <code>s</code>. Further,
let us say that <code>Unassigned(s)</code> is the set of variables that are not
defined in <code>s</code>. For every <code>P_i</code> we construct the set of state variables
<code>Use_i</code> that contains every variable <code>x'</code> that is mentioned in <code>P_i</code>.
There are three cases to consider:</p>
<ol>
<li>All sets <code>Use_i</code> agree on which variables are to be assigned.
Formally, <code>Use_i \intersect Unassigned(s) = Use_j \intersect Unassigned(s) /= {}</code>
for <code>i, j \in 1..n</code>. This is the case that we consider below.</li>
<li>Two clauses disagree on the set of variables to be assigned.
Formally, there is a pair <code>i, j \in 1..n</code> that satisfy the inequality:
<code>Use_i \intersect Unassigned(s) /= Use_j \intersect Unassigned(s)</code>.
In this case, the specification is ill-structured. TLC would
raise an error when it found a binding like this.
Apalache would detect this problem when preprocessing the specification.</li>
<li>The clauses do not assign values to the primed variables.
Formally, <code>Use_i \intersect Unassigned(s) = {}</code> for <code>i \in 1..n</code>.
This is the deterministic case. It can be evaluated by using the
deterministic semantics of <a href="lang/./booleans.html">Boolean operators</a>.</li>
</ol>
<p>We introduce a fresh variable to contain the choice of the clause.  Here we
call it <code>choice</code>. In a real implementation of an evaluator, we would have to
give it a unique name. Now we evaluate the following <em>conjunction</em>:</p>
<pre><code class="language-tla">LET choice == GUESS 1..n IN
  /\ (choice = 1) =&gt; P_1
  /\ (choice = 2) =&gt; P_2
  ...
  /\ (choice = n) =&gt; P_n
</code></pre>
<p>Importantly, at most one clause in the conjunction will be actually evaluated.
As a result, we cannot produce conflicting assignments to the primed variables.</p>
<p><strong>Example:</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLES x, y
Init == x == 0 /\ y == 0
Next ==
    \/ x &gt;= 0 /\ y' = x /\ x' = x + 1
    \/ x &lt;= 0 /\ y' = -x /\ x' = -(x + 1)
</code></pre>
<p>As you can see, the operator <code>Next</code> is non-deterministic since both clauses may
be activated when <code>x = 0</code>.</p>
<p>First, let's evaluate <code>Next</code> against the binding <code>(x -&gt; 3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE, x' is assigned 4, y' is assigned 3.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is FALSE. Halt.
</code></pre>
<p>Second, evaluate <code>Next</code> against the binding <code>(x -&gt; -3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is FALSE. Halt.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned 4, y' is assigned -3.
</code></pre>
<p>Third, evaluate <code>Next</code> against the binding <code>(x -&gt; 0, y -&gt; 0)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE. x' is assigned 1, y' is assigned 0.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned -1, y' is assigned 0.
</code></pre>
<p><em>Important note. In contrast to <a href="lang/./booleans.html">short-circuiting of
disjunction</a> in the deterministic case, we have
non-deterministic choice here. Hence, short-circuiting does not apply to
non-deterministic disjunctions.</em></p>
<p><a name="nondetIte"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-if-then-else" id="non-determinism-in-boolean-if-then-else">Non-determinism in Boolean <code>IF-THEN-ELSE</code></a></h3>
<p>For the deterministic use of <code>IF-THEN-ELSE</code>, see <a href="lang/./conditionals.html">Deterministic
conditionals</a>.</p>
<p>Consider an <code>IF-THEN-ELSE</code> expression to be evaluated in a partial state <code>s</code>:</p>
<pre><code class="language-tla">IF A THEN B ELSE C
</code></pre>
<p>Here we assume that both <code>B</code> and <code>C</code> produce Boolean results and <code>B</code> and <code>C</code>
refer to at least one primed variable <code>y'</code> that is undefined in <code>s</code>. Otherwise, the
expression can be evaluated as a <a href="lang/./conditionals.html">deterministic
conditional</a>.</p>
<p>In this case, <code>IF-THEN-ELSE</code> can be evaluated as the equivalent expression:</p>
<pre><code class="language-tla">  \/  A /\ B
  \/ ~A /\ C
</code></pre>
<p><em>We do not recommend you to use IF-THEN-ELSE with non-determinism. The structure
of the disjunction provides a clear indication that the expression may
assign to variables as a side effect. IF-THEN-ELSE has two thinking
steps: what is the expected result, and what are the possible side effects.</em></p>
<p><strong>Warning:</strong> While it is technically possible to write <code>x' = e</code> inside the
condition, the effect of <code>x' = e</code> is not obvious when <code>x'</code> is not assigned a
value.</p>
<p><a name="nondetCase"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-case" id="non-determinism-in-boolean-case">Non-determinism in Boolean <code>CASE</code></a></h3>
<p>For the deterministic use of <code>CASE</code>,
see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p><strong>CASE without OTHER.</strong>
Consider a <code>CASE</code> expression:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
</code></pre>
<p>We assume that <code>e_1, ..., e_n</code> produce Boolean results. Otherwise,
see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
</code></pre>
<p><em>Similar to IF-THEN-ELSE, we do not recommend using CASE for expressing
non-determinism. When you are using disjunction, the Boolean result and
possible side effects are expected.</em></p>
<p><strong>CASE with OTHER.</strong> The more general form of <code>CASE</code> is like follows:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
  [] OTHER -&gt; e_other
</code></pre>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
\/ ~P_1 /\ ... /\ ~P_n /\ e_other
</code></pre>
<p><em>The use of CASE with OTHER together with non-determinism is quite rare.
It is not clear why would one need a fallback option in the Boolean formula.
We recommend you to use the disjunctive form instead.</em></p>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<h1><a class="header" href="#deterministic-conditionals" id="deterministic-conditionals">Deterministic conditionals</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, we consider the instances of <code>IF-THEN-ELSE</code> and <code>CASE</code> that
may not update primed variables. For the case, when the operators inside
<code>IF-THEN-ELSE</code> or <code>CASE</code> can be used to do non-deterministic assignments, see
<a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Warning:</strong> Because frequent use of <code>IF-THEN-ELSE</code> is very common in most
programming languages, TLA+ specification authors with programming experience
often default to writing expressions such as <code>IF A THEN B ELSE C</code>.  We
encourage those authors to use this construct more sparingly.  In our
experience, the use of <code>IF-THEN-ELSE</code> is rarely required.  Many things can be
done with <a href="lang/./booleans.html">Boolean operators</a>, which provide more structure in
TLA+ code than in programming languages.  We recommend using <code>IF-THEN-ELSE</code> to
compute predicate-dependent values, not to structure code.</p>
<p><strong>Warning 2:</strong> <code>CASE</code> is considered deterministic in this
section, as it is defined with the <code>CHOOSE</code> operator in
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, Section 16.1.4.
For this reason, <code>CASE</code> should only be used when all of its guards are mutually exclusive.
Given all the intricacies of <code>CASE</code>,
we recommend using nested <code>IF-THEN-ELSE</code> instead.</p>
<hr />
<p><a name="ite"></a></p>
<h2><a class="header" href="#deterministic-if-then-else" id="deterministic-if-then-else">Deterministic IF-THEN-ELSE</a></h2>
<p><em>Use it when choosing between two values, not to structure your code.</em></p>
<p><strong>Notation:</strong> <code>IF A THEN B ELSE C</code></p>
<p><strong>LaTeX notation:</strong> the same</p>
<p><strong>Arguments:</strong> a Boolean expression <code>A</code> and two expressions <code>B</code> and <code>C</code></p>
<p><strong>Effect:</strong> <code>IF A THEN B ELSE C</code> evaluates to:</p>
<ul>
<li>The value of <code>B</code>, if <code>A</code> evaluates to <code>TRUE</code>.</li>
<li>The value of <code>C</code>, if <code>A</code> evaluates to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> This is a deterministic version. For the non-deterministic
version, see <a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> If <code>A</code> evaluates to a non-Boolean value, the result is undefined.
TLC raises an error during model checking. Apalache raises a type error when
preprocessing. Additionally, if <code>B</code> and <code>C</code> may evaluate to values of different
types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> Consider the following TLA+ expression:</p>
<pre><code class="language-tla">IF x THEN 100 ELSE 0
</code></pre>
<p>As you most likely expected, this expression evaluates to <code>100</code>, when <code>x</code>
evaluates to <code>TRUE</code>; and it evaluates to <code>0</code>, when <code>x</code> evaluates to <code>FALSE</code>.</p>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-tla">100 if x else 0
</code></pre>
<p>Note that we are using the expression syntax for <code>if-else</code> in python.
This is because we write an expression, not a series of statements that assign
values to variables!</p>
<p><a name="case"></a></p>
<h2><a class="header" href="#deterministic-case" id="deterministic-case">Deterministic CASE</a></h2>
<p><em>Read the description and never use this operator</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case.png" alt="case" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_1, ..., e_n</code>.</p>
<p><strong>Effect:</strong> Given a state <code>s</code>, define the set <code>I \subseteq 1..n</code> as follows:
The set <code>I</code> includes the index <code>j \in 1..n</code> if
and only if <code>p_j</code> evaluates to <code>TRUE</code> in the state <code>s</code>.
Then the above <code>CASE</code> expression evaluates to:</p>
<ul>
<li>the value of the expression <code>e_i</code> for some <code>i \in I</code>, if <code>I</code> is not empty; or</li>
<li>an undefined value, if the set <code>I</code> is empty.</li>
</ul>
<p>As you can see, when several predicates <code>{p_i: i \in I}</code> are evaluated
to <code>TRUE</code> in the state <code>s</code>, then the result of <code>CASE</code> is equal to one of the
elements in the set <code>{e_i: i \in I}</code>. Although the result should be stable,
the exact implementation is unknown.</p>
<p>Whenever <code>I</code> is a singleton set, the result is easy to define: Just take the
only element of <code>I</code>. <em>Hence, when <code>p_1, ..., p_n</code> are mutually exclusive,
the result is deterministic and implementation-agnostic.</em></p>
<p>Owing to the flexible semantics of simultaneously enabled predicates,
TLC interprets the above <code>CASE</code> operator as a chain of <code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE TLC!Assert(FALSE)
</code></pre>
<p><em>As TLC fixes the evaluation order, TLC may miss a bug in an arm that is never
activated in this order!</em></p>
<p>Note that the last arm of the ITE-series ends with <code>Assert(FALSE)</code>, as the
result is undefined, when no predicate evaluates to <code>TRUE</code>. As the type
of this expression cannot be precisely defined, Apalache does not support <code>CASE</code>
expressions, but only supports <code>CASE-OTHER</code> expressions (see below), which
it treats as a chain of <code>IF-THEN-ELSE</code> expressions.</p>
<p><strong>Determinism.</strong> The result of <code>CASE</code> is deterministic, if there are no primes
inside.  For the non-deterministic version, see <a href="lang/control-and-nondeterminism.html">[Control Flow and
Non-determinism]</a>.  When the predicates are
mutually exclusive, the evaluation result is clearly specified. When the predicates are
not mutually exclusive, the operator is still deterministic, but only one of
the simultaneously enabled branches is evaluated.
Which branch is evaluated depends on the <code>CHOOSE</code> operator, see <a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing. Additionally, if <code>e_1</code>, ..., <code>e_n</code>
may evaluate to values of different types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> The following expression classifies an integer variable
<code>n</code> with one of the three strings: &quot;negative&quot;, &quot;zero&quot;, or &quot;positive&quot;.</p>
<pre><code class="language-tla">  CASE n &lt; 0 -&gt; &quot;negative&quot;
    [] n = 0 -&gt; &quot;zero&quot;
    [] n &gt; 0 -&gt; &quot;positive&quot;
</code></pre>
<p>Importantly, the predicates <code>n &lt; 0</code>, <code>n = 0</code>, and <code>n &gt; 0</code> are mutually
exclusive.</p>
<p>The following expression contains non-exclusive predicates:</p>
<pre><code class="language-tla">  CASE n % 2 = 0 -&gt; &quot;even&quot;
    [] (\A k \in 2..(1 + n \div 2): n % k /= 0) -&gt; &quot;prime&quot;
    [] n % 2 = 1 -&gt; &quot;odd&quot;

</code></pre>
<p>Note that by looking at the specification, we cannot tell, whether this
expression returns &quot;odd&quot; or &quot;prime&quot;, when <code>n = 17</code>. We only know that the
case expression should consistently return the same value, whenever it is
evaluated with <code>n = 17</code>.</p>
<p><strong>Example in Python:</strong> Consider our first example in TLA+. Similar to TLC, we
give executable semantics for the fixed evaluation order of the predicates.</p>
<pre><code class="language-python">  def case_example():
    if n &lt; 0:
      return &quot;negative&quot;
    elif n == 0 :
      return &quot;zero&quot;
    elif n &gt; 0:
      return &quot;positive&quot;
    else:
      assert(False)

  case_example()
</code></pre>
<p><a name="caseOther"></a></p>
<h2><a class="header" href="#deterministic-case-other" id="deterministic-case-other">Deterministic CASE-OTHER</a></h2>
<p><em>Better use IF-THEN-ELSE.</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] OTHER -&gt; e_0
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case-other.png" alt="case-other" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_0, e_1, ..., e_n</code>.</p>
<p><strong>Effect:</strong> This operator is equivalent to the following version of <code>CASE</code>:</p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] ~(p_1 \/ p_2 \/ ... \/ p_n) -&gt; e_0
</code></pre>
<p>Both TLC and Apalache interpret this <code>CASE</code> operator as a chain of
<code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE e_0
</code></pre>
<p>All the idiosyncrasies of <code>CASE</code> apply to <code>CASE-OTHER</code>. Hence, we recommend
using <code>IF-THEN-ELSE</code> instead of <code>CASE-OTHER</code>. Although <code>IF-THEN-ELSE</code>
is a bit more verbose, its semantics are precisely defined.</p>
<p><strong>Determinism.</strong> The result of <code>CASE-OTHER</code> is deterministic, if <code>e_0</code>, <code>e_1</code>,
..., <code>e_n</code> may not update primed variables.  For the non-deterministic version,
see <a href="lang/control-and-nondeterminism.html">[Control Flow and Non-determinism]</a>.  When
the predicates are mutually exclusive, the semantics is clearly specified. When
the predicates are not mutually exclusive, the operator is still deterministic,
but only one of the simultaneously enabled branches is evaluated. The choice of
the branch is implemented with the operator <code>CHOOSE</code>, see
<a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing.  Additionally, if <code>e_0</code>, <code>e_1</code>, ...,
<code>e_n</code> may evaluate to values of different types, Apalache raises a type error.</p>
<h1><a class="header" href="#integers" id="integers">Integers</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>The integer literals belong to the core language. They are written by
using the standard syntax: 0, 1, -1, 2, -2, 3, -3, ... Importantly, TLA+
integers are unbounded. They do not have any fixed bit width, and they cannot
overflow.</p>
<p>The integer operators are defined in the standard module <code>Integers</code>. To use
it, write the <code>EXTENDS</code> clause in the first lines of your module. Like this:</p>
<pre><code class="language-tla">---- MODULE MyArithmetics ----
EXTENDS Integers
...
==============================
</code></pre>
<h2><a class="header" href="#integers-in-apalache-and-smt" id="integers-in-apalache-and-smt">Integers in Apalache and SMT</a></h2>
<p>Although you can write arbitrary expressions over integers in TLA+, Apalache
translates these expressions as constraints in
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>.  Some
expressions are easier to solve than the others. For instance, the expression
<code>2 * x &gt; 5</code> belongs to linear integer arithmetic, which can be solved more
efficiently than general arithmetic.  For state variables <code>x</code> and <code>y</code>, the
expression <code>x * y &gt; 5</code> belongs to non-linear integer arithmetic, which is
harder to solve than linear arithmetic.</p>
<p>When your specification is using only integer literals, e.g., <code>1</code>, <code>2</code>, <code>42</code>,
but none of the operators from the <code>Integers</code> module, the integers can
be avoided altogether.  For instance, you can replace the integer constants
with string constants, e.g., <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;42&quot;</code>. The string constants are
translated as constants in the SMT constraints. This simple trick may bring
your specification into a much simpler theory. Sometimes, this trick allows z3
to use parallel algorithms.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants-1" id="constants-1">Constants</a></h2>
<p>The module <code>Integers</code> defines two constant sets (technically, they are
operators without arguments):</p>
<ul>
<li>The set <code>Int</code> that consists of all integers. <em>This set is infinite.</em></li>
<li>The set <code>Nat</code> that consists of all natural numbers, that is,
<code>Nat</code> contains every integer <code>x</code> that has the property <code>x &gt;= 0</code>.
<em>This set is infinite.</em></li>
</ul>
<hr />
<h2><a class="header" href="#operators-1" id="operators-1">Operators</a></h2>
<p><a name="range"></a></p>
<h3><a class="header" href="#integer-range" id="integer-range">Integer range</a></h3>
<p><strong>Notation:</strong> <code>a..b</code></p>
<p><strong>LaTeX notation:</strong> <code>a..b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a..b</code> evaluates to the finite set <code>{i \in Int: a &lt;= i /\ i &lt;= b}</code>,
that is, the set of all integers in the range from <code>a</code> to <code>b</code>, including <code>a</code>
and <code>b</code>.  If <code>a &gt; b</code>, then <code>a..b</code> is the empty set <code>{}</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  0..10    \* { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  -5..3    \* { -5, -4, -3, -2, -1, 0, 1, 2, 3 }
  10..0    \* { }
  &quot;a&quot;..&quot;z&quot; \* runtime error in TLC, type error in Apalache
  {1}..{3} \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> <code>a..b</code> can be written as <code>set(range(a, b + 1))</code> in
python.</p>
<pre><code class="language-python">  set(range(0, 10 + 1))     # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  set(range(10, 2))         # set()
</code></pre>
<hr />
<p><a name="uminus"></a></p>
<h3><a class="header" href="#unary-integer-negation" id="unary-integer-negation">Unary integer negation</a></h3>
<p><strong>Notation:</strong> <code>-i</code></p>
<p><strong>LaTeX notation:</strong> <code>-i</code></p>
<p><strong>Arguments:</strong> One argument. The result is only defined when the argument
evaluates to an integer.</p>
<p><strong>Effect:</strong> <code>-i</code> evaluates to the negation of <code>i</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if the argument
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  -(5)    \* -5, note that '-5' is just a literal, not operator application
  -(-5)   \* 5
  -x      \* negated value of x
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  -(5)
  -(-5)
</code></pre>
<hr />
<p><a name="plus"></a></p>
<h3><a class="header" href="#integer-addition" id="integer-addition">Integer addition</a></h3>
<p><strong>Notation:</strong> <code>a + b</code></p>
<p><strong>LaTeX notation:</strong> <code>a + b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a + b</code> evaluates to the sum of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 + 3     \* 8
  (-5) + 3  \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  5 + 3
  (-5) + 3
</code></pre>
<hr />
<p><a name="minus"></a></p>
<h3><a class="header" href="#integer-subtraction" id="integer-subtraction">Integer subtraction</a></h3>
<p><strong>Notation:</strong> <code>a - b</code></p>
<p><strong>LaTeX notation:</strong> <code>a - b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a - b</code> evaluates to the difference of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 - 3         \* 2
  (-5) - 3      \* -8
  (-5) - (-3)   \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  5 - 3
  (-5) - 3
  (-5) - (-3)
</code></pre>
<hr />
<p><a name="mult"></a></p>
<h3><a class="header" href="#integer-multiplication" id="integer-multiplication">Integer multiplication</a></h3>
<p><strong>Notation:</strong> <code>a * b</code></p>
<p><strong>LaTeX notation:</strong> <code>a * b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a * b</code> evaluates to the product of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 * 3     \* 15
  (-5) * 3  \* -15
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  5 * 3
  (-5) * 3
</code></pre>
<hr />
<p><a name="div"></a></p>
<h3><a class="header" href="#integer-division" id="integer-division">Integer division</a></h3>
<p><strong>Notation:</strong> <code>a \div b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/div.png" alt="div" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Effect:</strong> <code>a \div b</code> is defined as follows:</p>
<ol>
<li>When <code>a &gt;= 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &gt;= 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
</ol>
<p><em>When <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer division <code>a \div b</code> according to the TLA+ definition is different from the integer division <code>a / b</code> in the programming languages (C, Java, Scala, Rust).  See the
table below.</em></p>
<table><thead><tr><th>¬†  C (clang 12)</th><th>Scala 2.13</th><th>Rust</th><th>Python 3.8.6</th><th>TLA+ (TLC)</th><th>SMT (z3 4.8.8)</th></tr></thead><tbody>
<tr><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 // 3 == 33</td><td>(100 \div 3) = 33</td><td>(assert (= 33 (div 100 3)))</td></tr>
<tr><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 // 3 == -34</td><td>((-100) \div 3) = -34</td><td>(assert (= (- 0 34) (div (- 0 100) 3)))</td></tr>
<tr><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 // (-3) == -34</td><td>(100 \div (-3)) = -34</td><td>(assert (= (- 0 33) (div 100 (- 0 3))))</td></tr>
<tr><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 // (-3) == 33</td><td>((-100) \div (-3)) = 33</td><td>(assert (= 34 (div (- 0 100) (- 0 3))))</td></tr>
</tbody></table>
<p><em>Unfortunately, <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> only gives us the definition for the case
<code>b &gt; 0</code> (that is, cases 1-2 in our description). The implementation in SMT and
TLC produce incompatible results for <code>b &lt; 0</code>. See <a href="https://github.com/informalsystems/apalache/issues/331">issue #331 in
Apalache</a>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a \div b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs
(according to TLC):</p>
<pre><code class="language-tla">    100  \div   3   \*  33
  (-100) \div   3   \* -34
    100  \div (-3)  \* -34 in TLC
  (-100) \div (-3)  \*  33 in TLC
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">  100    //   3     #  33
  -100   //   3     # -34
  100    // (-3)    # -34
  (-100) // (-3)    #  33
</code></pre>
<hr />
<p><a name="mod"></a></p>
<h3><a class="header" href="#integer-remainder" id="integer-remainder">Integer remainder</a></h3>
<p><strong>Notation:</strong> <code>a % b</code></p>
<p><strong>LaTeX notation:</strong> <code>a % b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Effect:</strong> <code>a % b</code> is the number <code>c</code> that has the property:
<code>a = b * (a \div b) + c</code>.</p>
<p><em>Note that when <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer remainder <code>a % b</code>
according to the TLA+ definition is different from the integer remainder <code>a % b</code> in the programming languages (C, Python, Java, Scala, Rust).  See the
examples below.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a % b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs:</p>
<pre><code class="language-tla">  100  % 3      \* 1
  -100 % (-3)   \* 2
  100  % (-3)   \* 1
  -100 % 3      \* 2
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">  100 % 3          # 1
  -100 % (-3) + 3  # 2
  100 % (-3) + 3   # 1
  -100 % 3         # 2
</code></pre>
<hr />
<p><a name="pow"></a></p>
<h3><a class="header" href="#integer-exponentiation" id="integer-exponentiation">Integer exponentiation</a></h3>
<p><strong>Notation:</strong> <code>a^b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exp.png" alt="exp" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and these values fall into one of the several
cases:</p>
<ol>
<li><code>b &gt; 0</code>,</li>
<li><code>b = 0</code> and <code>a /= 0</code>.</li>
</ol>
<p><strong>Effect:</strong> <code>a^b</code> evaluates to <code>a</code> raised to the <code>b</code>-th power:</p>
<ul>
<li>If <code>b = 1</code>, then <code>a^b</code> is defined as <code>a</code>.</li>
<li>If <code>a = 0</code> and <code>b &gt; 0</code>, then <code>a^b</code> is defined as <code>0</code>.</li>
<li>If <code>a /= 0</code> and <code>b &gt; 1</code>, then <code>a^b</code> is defined as <code>a * a^(b-1)</code>.</li>
<li>In all other cases, <code>a^b</code> is undefined.</li>
</ul>
<p>In TLA+, <code>a^b</code> extends to reals, see Chapter 18 in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.
For instance, <code>3^(-5)</code> is defined on reals. However, reals are supported
neither by TLC, nor by Apalache.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5^3       \* 125
  (-5)^3    \* -125
  0^3       \* 0
  1^5       \* 1
  (-1)^5    \* -1
  0^0       \* undefined on integers, TLC reports a runtime error
  5^(-3)    \* undefined on integers, TLC reports a runtime error
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  5 ** 3
  (-5) ** 3
  0 ** 3
  1 ** 5
  (-1) ** 5
  0 ** 0    # 0 in python %)
  5 ** (-3) # floating point 0.008 in python
</code></pre>
<hr />
<p><a name="lt"></a></p>
<h3><a class="header" href="#integer-less-than" id="integer-less-than">Integer less-than</a></h3>
<p><strong>Notation:</strong> <code>a &lt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &lt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a &lt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is less than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt; 5     \* TRUE
  5 &lt; 5     \* FALSE
  5 &lt; 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  1 &lt; 5
  5 &lt; 5
  5 &lt; 1
</code></pre>
<hr />
<p><a name="lte"></a></p>
<h3><a class="header" href="#integer-less-than-or-equal" id="integer-less-than-or-equal">Integer less-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &lt;= b</code> or <code>a =&lt; b</code> or <code>a \leq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/leq.png" alt="leq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a &lt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &lt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt;= 5     \* TRUE
  5 &lt;= 5     \* TRUE
  5 &lt;= 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  1 &lt;= 5
  5 &lt;= 5
  5 &lt;= 1
</code></pre>
<hr />
<p><a name="gt"></a></p>
<h3><a class="header" href="#integer-greater-than" id="integer-greater-than">Integer greater-than</a></h3>
<p><strong>Notation:</strong> <code>a &gt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &gt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a &gt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is greater than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt; 5     \* FALSE
  5 &lt; 5     \* FALSE
  5 &gt; 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  1 &gt; 5
  5 &gt; 5
  5 &gt; 1
</code></pre>
<hr />
<p><a name="gte"></a></p>
<h3><a class="header" href="#integer-greater-than-or-equal" id="integer-greater-than-or-equal">Integer greater-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &gt;= b</code> or <code>a \geq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/geq.png" alt="geq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Effect:</strong> <code>a &gt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &gt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt;= 5     \* FALSE
  5 &gt;= 5     \* TRUE
  5 &gt;= 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  1 &gt;= 5
  5 &gt;= 5
  5 &gt;= 1
</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality" id="equality-and-inequality">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+ and thus they are
not defined in the module <code>Integers</code>, see <a href="lang/./logic.html">Logic</a>.</p>
<h1><a class="header" href="#sets-1" id="sets-1">Sets</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Sets are the foundational data structure in TLA+. (Similar to what lists are in
Lisp and Python). The other TLA+ data structures can be all expressed with
sets: functions, records, tuples, sequences. In theory, even Booleans and
integers can be expressed with sets. In practice, TLA+ tools treat Booleans and
integers as special values that are different from sets. It is important to
understand TLA+ sets well. In contrast to programming languages, there is no
performance penalty for using sets instead of sequences: TLA+ does not have a
compiler, the efficiency is measured in the time it takes the human brain to
understand the specification.</p>
<p><strong>Immutability.</strong> In TLA+, a set is an <em>immutable</em> data structure that stores
its elements in <em>no particular order</em>. All elements of a set are unique. In
fact, those two sentences do not make a lot of sense in TLA+. We have written
them to build the bridge from a programming language to TLA+, as TLA+ does not
have a memory model. üòâ</p>
<p>Sets may be constructed by enumerating values in <em>some order</em>, allowing for
duplicates:</p>
<pre><code class="language-tla">  { 1, 2, 3, 2, 4, 3 }
</code></pre>
<p>Note that the above set is equal to the sets <code>{ 1, 2, 3, 4 }</code> and <code>{ 4, 3, 2, 1 }</code>. They are actually the same set, though they are constructed by passing
various number of arguments in different orders.</p>
<p>The most basic set operation is the set membership that checks, whether a set
contains a value:</p>
<pre><code class="language-tla">  3 \in S
</code></pre>
<p>TLA+ sets are similar to
<a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset</code></a> in
Python and immutable <code>Set[Object]</code> in Java.  In contrast to programming
languages, set elements do not need hashes, as implementation efficiency is not
an issue in TLA+.</p>
<p><strong>Types.</strong> In pure TLA+, sets may contain any kinds of elements. For instance,
a set may mix integers, Booleans, and other sets:</p>
<pre><code class="language-tla">  { 2020, { &quot;is&quot; }, TRUE, &quot;fail&quot; }
</code></pre>
<p>TLC restricts set elements to comparable values. See Section 14.7.2 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. In a nutshell, if you do not mix the following five
kinds of values in a single set, TLC would not complain about your sets:</p>
<ol>
<li>Booleans,</li>
<li>integers,</li>
<li>strings,</li>
<li>sets,</li>
<li>functions, tuples, records, sequences.</li>
</ol>
<p>Apalache requires set elements to have the same type. This is enforced by the
type checker.</p>
<hr />
<h2><a class="header" href="#operators-2" id="operators-2">Operators</a></h2>
<p><a name="setEnum"></a></p>
<h3><a class="header" href="#set-constructor-by-enumeration" id="set-constructor-by-enumeration">Set constructor by enumeration</a></h3>
<p><strong>Notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>LaTeX notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>Arguments:</strong> Any number of arguments, <code>n &gt;= 0</code>.</p>
<p><strong>Effect:</strong> Produce the set that contains the values of the expressions <code>e_1, ..., e_n</code>, in no particular order, and only these values. If <code>n = 0</code>, the
empty set is constructed.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the set elements. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC only allows a user to construct sets out of elements that are comparable. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further and requires that all set elements have the same type.
If this is not the case, the type checker flags an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 1, 2, 3 }               \* a flat set of integers
  { { 1, 2 }, { 2, 3 } }    \* a set of sets of integers
  { FALSE, 1 }              \* a set of mixed elements.
                            \* Model checking error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> TLA+ sets are immutable, so we are using <code>frozenset</code>:</p>
<pre><code class="language-python">  frozenset({1, 2, 3})
  frozenset({frozenset({1, 2}), frozenset({2, 3})})
  frozenset({False, 1})
</code></pre>
<hr />
<p><a name="in"></a></p>
<h3><a class="header" href="#set-membership" id="set-membership">Set membership</a></h3>
<p><strong>Notation:</strong> <code>e \in S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/in-set.png" alt="in" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>FALSE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> If you are using the special form <code>x' \in S</code>, this operator may
assign a value to <code>x'</code> as a side effect. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic, unless you are using the special form <code>x' \in S</code> to assign a value to <code>x'</code>, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \in { 1, 2, 3 }        \* TRUE
  10 \in { 1, 2, 3 }        \* FALSE
  {} \in { {1}, {2} }       \* FALSE
   1 \in { &quot;a&quot;, &quot;b&quot; }       \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>in</code>:</p>
<pre><code class="language-python">  1 in frozenset({1, 2, 3})     # True
  10 in frozenset({1, 2, 3})    # False
  1 in frozenset({&quot;a&quot;, &quot;b&quot;})    # False
</code></pre>
<hr />
<p><a name="notin"></a></p>
<h3><a class="header" href="#set-non-membership" id="set-non-membership">Set non-membership</a></h3>
<p><strong>Notation:</strong> <code>e \notin S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/notin-set.png" alt="notin" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>FALSE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>TRUE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> In contrast to <code>x' \in S</code>, the expression <code>x' \notin T</code>,
which is equivalent to <code>~(x' \in T)</code> is never
treated as an assignment in Apalache and TLC.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \notin { 1, 2, 3 }     \* FALSE
  10 \notin { 1, 2, 3 }     \* TRUE
  {} \notin { {1}, {2} }    \* TRUE
   1 \notin { &quot;a&quot;, &quot;b&quot; }    \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>not in</code>:</p>
<pre><code class="language-python">  1 not in frozenset({1, 2, 3})     # False
  10 not in frozenset({1, 2, 3})    # True
  1 not in frozenset({&quot;a&quot;, &quot;b&quot;})    # True
</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality-1" id="equality-and-inequality-1">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+,
see <a href="lang/./logic.html">Logic</a>.</p>
<hr />
<p><a name="subseteq"></a></p>
<h3><a class="header" href="#set-inclusion" id="set-inclusion">Set inclusion</a></h3>
<p><strong>Notation:</strong> <code>S \subseteq T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/subseteq.png" alt="subseteq" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> and <code>T</code> are sets, and every element of <code>S</code> is a member of <code>T</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and there is an element of <code>S</code> that
is not a member of <code>T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2 }        \* FALSE
      { {1} } \subseteq { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                        \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&lt;=</code>:</p>
<pre><code class="language-python">  frozenset({1, 2}) &lt;= frozenset({1, 2, 3})             # True
  frozenset({1, 2, 3}) &lt;= frozenset({1, 2, 3})          # True
  frozenset({1, 2, 3}) &lt;= frozenset({1, 2})             # False
  frozenset({frozenset({1})}) &lt;= frozenset({1, 2, 3})   # False
</code></pre>
<hr />
<p><a name="subset"></a></p>
<h3><a class="header" href="#proper-set-inclusion" id="proper-set-inclusion">Proper set inclusion</a></h3>
<p><strong>Notation:</strong> <code>S \subset T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/subset.png" alt="subset" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S \subseteq T /\ S /= T</code> evaluates to <code>TRUE</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and <code>~(S \subseteq T) \/ S = T</code> evaluates
to <code>TRUE</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \subset { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subset { 1, 2, 3 }     \* FALSE
  { 1, 2, 3 } \subset { 1, 2 }        \* FALSE
      { {1} } \subset { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                      \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&lt;</code>:</p>
<pre><code class="language-python">  frozenset({1, 2}) &lt; frozenset({1, 2, 3})             # True
  frozenset({1, 2, 3}) &lt; frozenset({1, 2, 3})          # False
  frozenset({1, 2, 3}) &lt; frozenset({1, 2})             # False
  frozenset({frozenset({1})}) &lt; frozenset({1, 2, 3})   # False
</code></pre>
<hr />
<p><a name="supseteq"></a></p>
<h3><a class="header" href="#set-containment" id="set-containment">Set containment</a></h3>
<p><strong>Notation:</strong> <code>S \supseteq T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/supseteq.png" alt="supseteq" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> and <code>T</code> are sets, and every element of <code>T</code> is a member of <code>S</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and there is an element of <code>T</code> that
is not a member of <code>S</code>.</li>
</ul>
<p>It is easy to see, that <code>S \supseteq T</code> if and only if <code>T \subseteq S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \supseteq { 1, 2, 3 }     \* FALSE
  { 1, 2, 3 } \supseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \supseteq { 1, 2 }        \* TRUE
      { {1} } \supseteq { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                        \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&gt;=</code>:</p>
<pre><code class="language-python">  frozenset({1, 2}) &gt;= frozenset({1, 2, 3})             # False
  frozenset({1, 2, 3}) &gt;= frozenset({1, 2, 3})          # True
  frozenset({1, 2, 3}) &gt;= frozenset({1, 2})             # True
  frozenset({frozenset({1})}) &gt;= frozenset({1, 2, 3})   # False
</code></pre>
<hr />
<p><a name="supset"></a></p>
<h3><a class="header" href="#proper-set-containment" id="proper-set-containment">Proper set containment</a></h3>
<p><strong>Notation:</strong> <code>S \supset T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/supset.png" alt="supset" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S \supseteq T /\ S /= T</code> evaluates to <code>TRUE</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and <code>~(S \supseteq T) \/ S = T</code> evaluates
to <code>TRUE</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \supset { 1, 2, 3 }       \* FALSE
  { 1, 2, 3 } \supset { 1, 2, 3 }       \* FALSE
  { 1, 2, 3 } \supset { 1, 2 }          \* TRUE
      { {1} } \supseteq { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                        \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&gt;</code>:</p>
<pre><code class="language-python">  frozenset({1, 2}) &gt; frozenset({1, 2, 3})              # False
  frozenset({1, 2, 3}) &gt; frozenset({1, 2, 3})           # False
  frozenset({1, 2, 3}) &gt; frozenset({1, 2})              # True
  frozenset({frozenset({1})}) &gt;= frozenset({1, 2, 3})   # False
</code></pre>
<hr />
<p><a name="union"></a></p>
<h3><a class="header" href="#binary-set-union" id="binary-set-union">Binary set union</a></h3>
<p><strong>Notation:</strong> <code>S \union T</code> or <code>S \cup T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cup.png" alt="cup" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains the elements
of <code>S</code> <strong>as well</strong> as the elements of <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \union { 1, 2, 3 } \* { 0, 1, 2, 3 }
          { } \union { 1, 2, 3 } \* { 1, 2, 3 }
  { 1, 2, 3 } \union { }         \* { 1, 2, 3 }
      { {1} } \union { 1, 2 }    \* { {1}, 1, 2 }, model checking error in TLC
                                 \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>union</code>
that can be written as <code>|</code>:</p>
<pre><code class="language-python">  frozenset({0, 1, 2}) | frozenset({1, 2, 3})  # frozenset({0, 1, 2, 3})
  frozenset({}) | frozenset({1, 2, 3})         # frozenset({ 1, 2, 3})
  frozenset({1, 2, 3}) | frozenset({})         # frozenset({ 1, 2, 3})
  frozenset({frozenset({1})}) | frozenset({1, 2}) # frozenset({1, 2, frozenset({1})})
</code></pre>
<hr />
<p><a name="intersect"></a></p>
<h3><a class="header" href="#set-intersection" id="set-intersection">Set intersection</a></h3>
<p><strong>Notation:</strong> <code>S \intersect T</code> or <code>S \cap T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cap.png" alt="cap" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>also</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \intersect { 1, 2, 3 } \* { 1, 2 }
          { } \intersect { 1, 2, 3 } \* { }
  { 1, 2, 3 } \intersect { }         \* { }
      { {1} } \intersect { 1, 2 }    \* { }, model checking error in TLC
                                     \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>intersection</code>, which
can be also written as <code>&amp;</code>:</p>
<pre><code class="language-python">  frozenset({0, 1, 2}) &amp; frozenset({1, 2, 3})  # frozenset({ 1, 2 })
  frozenset({}) &amp; frozenset({1, 2, 3})         # frozenset()
  frozenset({1, 2, 3}) &amp; frozenset({})         # frozenset()
  frozenset({frozenset({1})}) &amp; frozenset({1, 2}) # frozenset()
</code></pre>
<hr />
<p><a name="setminus"></a></p>
<h3><a class="header" href="#set-difference" id="set-difference">Set difference</a></h3>
<p><strong>Notation:</strong> <code>S \ T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/setminus.png" alt="setminus" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>do not</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \ { 1, 2, 3 }     \* { 0 }
          { } \ { 1, 2, 3 }     \* { }
  { 1, 2, 3 } \ { }             \* { 1, 2, 3 }
      { {1} } \ { 1, 2 }        \* { {1} }, model checking error in TLC
                                \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>difference</code>, which
can be also written as <code>-</code>:</p>
<pre><code class="language-python">  frozenset({0, 1, 2}) - frozenset({1, 2, 3})  # frozenset({ 0 })
  frozenset({}) - frozenset({1, 2, 3})         # frozenset()
  frozenset({1, 2, 3}) - frozenset({})         # frozenset({ 1, 2, 3 })
  frozenset({frozenset({1})}) - frozenset({1, 2}) # frozenset({frozenset({1})})
</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#set-filter" id="set-filter">Set filter</a></h3>
<p><strong>Notation:</strong> <code>{ x \in S: P }</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/filter.png" alt="filter" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name (or a tuple of names, see
<strong>Advanced syntax</strong>), a set, and an expression.</p>
<p><strong>Effect:</strong> This operator constructs a new set <code>F</code> as follows.  For every
element <code>e</code> of <code>S</code>, do the following (we give a sequence of steps to ease
the understanding):</p>
<ol>
<li>Bind the element <code>e</code> to variable <code>x</code>,</li>
<li>Evaluate the predicate <code>P</code>,</li>
<li>If <code>P</code> evaluates to <code>TRUE</code> under the binding <code>[x |-&gt; e]</code>,
then insert the element of <code>e</code> into set <code>F</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use a tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ &lt;&lt;x, y&gt;&gt; \in S: P }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The filter expression constructs the set of elements (tuples) that make
<code>P</code> evaluate to <code>TRUE</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { x \in {1, 2, 3, 4}: x &gt; 2 }             \* { 3, 4 }
  { x \in {1, 2, 3, 4}: x &gt; 10 }            \* { }
  \* check the section on tuples to understand the following syntax
  { &lt;&lt;x, y&gt;&gt; \in (1..4) \X (1..4): y = 3 }  \* {&lt;&lt;1, 3&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;, &lt;&lt;4, 3&gt;&gt;}
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">  S = frozenset({1, 2, 3, 4})
  frozenset({ x for x in S if x &gt; 2 })      # frozenset({3, 4})
  frozenset({ x for x in S if x &gt; 10 })     # frozenset()
  S2 = frozenset({(x, y) for x in S for y in S})
  frozenset({(x, y) for (x, y) in S2 if y == 3})
    # frozenset({(1, 3), (2, 3), (3, 3), (4, 3)})
</code></pre>
<hr />
<p><a name="map"></a></p>
<h3><a class="header" href="#set-map" id="set-map">Set map</a></h3>
<p><strong>Notation:</strong> <code>{ e: x \in S }</code> or <code>{ e: x \in S, y \in T }</code>, or more arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/map.png" alt="map" /></p>
<p><strong>Arguments:</strong> At least three arguments: a mapping expression,
a variable name (or a tuple of names, see <strong>Advanced syntax</strong>),
a set. Additional arguments are variables names and sets, interleaved.</p>
<p><strong>Effect:</strong> We give the semantics for two arguments.
We write it as a sequence of steps to ease understanding.
This operator constructs a new set <code>M</code> as follows.
For every element <code>e_1</code> of <code>S</code> and every element <code>e_2</code> of <code>T</code>:</p>
<ol>
<li>Bind the element <code>e_1</code> to variable <code>x</code>,</li>
<li>Bind the element <code>e_2</code> to variable <code>y</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; e_1, y |-&gt; e_2]</code>,</li>
<li>Insert the value <code>e</code> into the set <code>M</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>e</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ x + y: &lt;&lt;x, y&gt;&gt; \in S }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The map expression constructs the set of expressions that are computed
under this binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 2 * x: x \in { 1, 2, 3, 4 } }          \* { 2, 4, 6, 8 }
  { x + y: x \in 1..2, y \in 1..2 }        \* { 2, 3, 4 }
  \* check the section on tuples to understand the following syntax
  { x + y: &lt;&lt;x, y&gt;&gt; \in (1..2) \X (1..2) } \* { 2, 3, 4 }
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">  S = frozenset({1, 2, 3, 4})
  frozenset({ 2 * x for x in S })           # frozenset({2, 4, 6, 8})
  T = frozenset({1, 2})
  frozenset({ x + y for x in T for y in T}) # frozenset({2, 3, 4})
  T2 = frozenset((x, y) for x in T for y in T) # {(1,1), (1, 2), (2, 1), (2, 2) }
  frozenset({ x + y for (x, y) in T2})      # frozenset({2, 3, 4})
</code></pre>
<hr />
<p><a name="powerset"></a></p>
<h3><a class="header" href="#powerset" id="powerset">Powerset</a></h3>
<p><strong>Notation:</strong> <code>SUBSET S</code></p>
<p><strong>LaTeX notation:</strong> <code>SUBSET S</code></p>
<p><strong>Warning:</strong> Do not confuse <code>SUBSET S</code> with <code>S \subset T</code>. These are two
different operators, which unfortunately have similar-looking names.</p>
<p><strong>Arguments:</strong> One argument. If it is not a set, the result
is undefined.</p>
<p><strong>Effect:</strong> This operator computes the set of all subsets of <code>S</code>.
That is, the set <code>T</code> the has the following properties:</p>
<ul>
<li>If <code>X \in T</code>, then <code>X \subseteq S</code>.</li>
<li>If <code>X \subseteq S</code>, then <code>X \in T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set.  Apalache
produces a static type error, if the type of <code>S</code> is not a set type.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SUBSET { 0, 1, 2 }
  \* { {}, {0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}, {0, 1, 2} }
</code></pre>
<p><strong>Example in Python:</strong> An implementation of <code>SUBSET S</code> in Python is not trivial.
To appreciate the power of TLA+, see <a href="lang/./examples/subset.py">subset.py</a>.</p>
<hr />
<p><a name="fold"></a></p>
<h3><a class="header" href="#set-folding" id="set-folding">Set folding</a></h3>
<p><strong>Notation:</strong> <code>UNION S</code></p>
<p><strong>LaTeX notation:</strong> <code>UNION S</code></p>
<p><strong>Warning:</strong> Do not confuse <code>UNION S</code> with <code>S \union T</code>. These are two
different operators, which unfortunately have similar-looking names.</p>
<p><strong>Arguments:</strong> One argument. If it is not a set of sets, the result
is undefined.</p>
<p><strong>Effect:</strong> Given that <code>S</code> is a set of sets, this operator computes the set
<code>T</code> that contains all elements of elements of <code>S</code>:</p>
<ul>
<li>If <code>X \in S</code>, then <code>X \subseteq T</code>.</li>
<li>If <code>y \in T</code>, then there is a set <code>Y \in S</code> that contains <code>y</code>,
that is, <code>y \in Y</code>.</li>
</ul>
<p>In particular, <code>UNION</code> folds the explosion that is produced by <code>SUBSET</code>. That
is, <code>(UNION (SUBSET S)) = S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set of sets.
Apalache produces a static type error, if the type of <code>S</code> is different from a
set of sets.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  UNION { {0, 1}, {1, 2}, {3} }
  \* { 0, 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong> In contrast to <code>SUBSET S</code>, an implementation of <code>UNION S</code>
in Python is quite simple:</p>
<pre><code class="language-python">    functools.reduce(lambda x, y: x | y, s, frozenset())
</code></pre>
<hr />
<p><a name="card"></a></p>
<h3><a class="header" href="#set-cardinality" id="set-cardinality">Set cardinality</a></h3>
<p><strong>Notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>Warning:</strong> <code>Cardinality(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, or <code>S</code> is an infinite set,
the result is undefined.</p>
<p><strong>Effect:</strong> <code>Cardinality(S)</code> evaluates to the number of (unique) elements in
<code>S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set, or when it is an
infinite set.  Apalache produces a static type error, if the type of <code>S</code> is
different from a finite set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  Cardinality({ 1, 2, 3 })
  \* 3
</code></pre>
<p><strong>Example in Python:</strong> In Python, we just use the set size:</p>
<pre><code class="language-python">    S = frozenset({ 1, 2, 3 })
    len(S)  # 3
</code></pre>
<hr />
<p><a name="finite"></a></p>
<h3><a class="header" href="#set-finiteness" id="set-finiteness">Set finiteness</a></h3>
<p><strong>Notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>Warning:</strong> <code>IsFinite(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, the result is undefined.</p>
<p><strong>Effect:</strong> <code>IsFinite(S)</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, when <code>S</code> is a finite set,</li>
<li><code>FALSE</code>, when <code>S</code> is an infinite set.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set. Apalache
produces a static type error, if the type of <code>S</code> is different from a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  IsFiniteSet({ 1, 2, 3 })      \* TRUE
  IsFiniteSet(BOOLEAN)          \* TRUE
  IsFiniteSet(Nat)              \* FALSE
  IsFiniteSet(Int)              \* FALSE
  IsFiniteSet(STRING)           \* FALSE
</code></pre>
<p><strong>Example in Python:</strong> We can construct only finite sets in Python.</p>
<h1><a class="header" href="#logic-1" id="logic-1">Logic</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, you find the operators that, together with <a href="lang/./sets.html">Sets</a>
form the foundation of TLA+. It is a bit strange that we call this section
&quot;Logic&quot;, as the whole language of TLA+ is a logic. However, the operators
of this section are often seen in first-order logic, as opposed to
propositional logic (see <a href="lang/./booleans.html">Booleans</a>).</p>
<p>Note that the special form <code>\E y \in S: x' = y</code> is often used to express
non-determinism in TLA+. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>. In this
section, we only consider the deterministic use of the existential quantifier.</p>
<hr />
<p><a name="forallBounded"></a></p>
<h3><a class="header" href="#bounded-universal-quantifier" id="bounded-universal-quantifier">Bounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall-bounded.png" alt="forall-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined. You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\A x \in S: P</code> evaluates to <code>TRUE</code>, if for every element <code>e</code> of <code>S</code>, the
expression <code>P</code> evaluates to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\A x \in S: P</code> evaluates to <code>FALSE</code>, if there exists an element
<code>e</code> of <code>S</code> that makes the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\A x \in S: P</code> evaluates to
<code>TRUE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\A x \in S: P</code> evaluates to <code>TRUE</code>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type
of <code>x</code> that is expected in the predicate <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\A &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\A x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\A x \in S: \A y \in T: P</code>. Similarly, <code>\A x, y \in S: P</code> is syntax sugar for
<code>\A x \in S: \A y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \A x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \A x \in {1, 2, 3, 4}:
    x &gt; 2
  \* FALSE
  \* check the section on tuples to understand the following syntax
  \A &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">  S = frozenset({1, 2, 3, 4})
  all(x &gt; 0 for x in S)         # True
  all(x &gt; 2 for x in S)         # False
  T2 = frozenset((x, y) for x in [1, 2] for y in [3, 4])
  all(x &lt; y for (x, y) in T2)   # True
</code></pre>
<hr />
<p><a name="existsBounded"></a></p>
<h3><a class="header" href="#bounded-existential-quantifier" id="bounded-existential-quantifier">Bounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists-bounded.png" alt="exists-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined.You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\E x \in S: P</code> evaluates to <code>TRUE</code>, if there is an element <code>e</code> of <code>S</code>
that makes the expression <code>P</code> evaluate to <code>TRUE</code> against the binding
<code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\E x \in S: P</code> evaluates to <code>FALSE</code>, if for all elements
<code>e</code> of <code>S</code>, the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to
<code>FALSE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to <code>FALSE</code>.</em></p>
<p>As you probably have noticed, <code>\E x \in S: P</code> is equivalent to <code>~(\A x \in S: ~P)</code>, and <code>\A x \in S: P</code> is equivalent to <code>~(\E x \in S: ~P)</code>. This is called
<em>duality</em> in logic. But take care!  If <code>\E x \in S: P</code> may act as a
non-deterministic assignment, duality does not work anymore!  See <a href="lang/./control-and-nondeterminism.html">Control
Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic when <code>P</code> contains no action operators (including
the prime operator <code>'</code>).  For the non-deterministic case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>P</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\E &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\E x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\E x \in S: \E y \in T: P</code>. Similarly, <code>\E x, y \in S: P</code> is syntax sugar for <code>\E x \in S: \E y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \E x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \E x \in {1, 2, 3, 4}:
    x &gt; 2
  \* TRUE
  \* check the section on tuples to understand the following syntax
  \E &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">  S = frozenset({1, 2, 3, 4})
  some(x &gt; 0 for x in S)        # True
  some(x &gt; 2 for x in S)        # False
  T2 = frozenset((x, y) for x in [1, 2] for y in [3, 4])
  some(x &lt; y for (x, y) in T2)  # True
</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality" id="equality">Equality</a></h3>
<p><em>A foundational operator in TLA+</em></p>
<p><strong>Notation:</strong> <code>e_1 = e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/eq.png" alt="eq" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It tests the values
of <code>e_1</code> and <code>e_2</code> for structural equality. The exact effect depends on the
values of <code>e_1</code> and <code>e_2</code>. Let <code>e_1</code> and <code>e_2</code> evaluate to the values
<code>v_1</code> and <code>v_2</code>. Then <code>e_1 = e_2</code> evaluates to:</p>
<ul>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are Booleans, then <code>e_1 = e_2</code> evaluates to <code>v_1 &lt;=&gt; v_2</code>.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are integers, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same integers.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are strings, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same strings.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are sets, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">v_1 \subseteq v_2 /\ v_2 \subseteq v_1
</code></pre>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are functions, tuples, records, or sequences,
then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">  DOMAIN v_1 = DOMAIN v_2 /\ \A x \in DOMAIN v_1: v_1[x] = v_2[x]
</code></pre>
</li>
<li>
<p>In other cases, <code>e_1 = e_2</code> evaluates to <code>FALSE</code> if the values have comparable types.</p>
</li>
<li>
<p>TLC and Apalache report an error, if the values have incomparable types.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic, unless <code>e_1</code> has the form <code>x'</code>, which can be
interpreted as an assignment to the variable <code>x'</code>.  For the non-deterministic
case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments. TLC flags a
model checking error, if <code>e_1</code> and <code>e_2</code> evaluate to incomparable values.
Apalache produces a static type error, if the types of <code>e_1</code> and <code>e_2</code> do not
match.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  FALSE = FALSE         \* TRUE
  FALSE = TRUE          \* FALSE
  10 = 20               \* FALSE
  15 = 15               \* TRUE
  &quot;Hello&quot; = &quot;world&quot;     \* FALSE
  &quot;Hello&quot; = &quot;hello&quot;     \* FALSE
  &quot;Bob&quot; = &quot;Bob&quot;         \* TRUE
  { 1, 2 } = { 2, 3}    \* FALSE
  { 1, 2 } = { 2, 1}    \* TRUE
  { 1 } \ { 1 } = { &quot;a&quot; } \ { &quot;a&quot; } \* TRUE in pure TLA+ and TLC,
                                    \* type error in Apalache
  { { 1, 2 } } = { { 1, 2, 2, 2 } } \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;a&quot;&gt;&gt;           \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;b&quot;&gt;&gt;           \* FALSE
  &lt;&lt;1, FALSE&gt;&gt; = &lt;&lt;2&gt;&gt;              \* FALSE in pure TLA+ and TLC,
                                    \* type error in Apalache
  &lt;&lt;1, 2&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;            \* FALSE in pure TLA+ and TLC,
                                    \* FALSE in Apalache, when both values
                                    \* are treated as sequences
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1, b |-&gt; 3 ]           \* TRUE
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1 ]                    \* FALSE
  [ x \in 2..2 |-&gt; x + x ] = [ x \in {2} |-&gt; 2 * x ]    \* TRUE
  [ x \in 2..3 |-&gt; x + x ] = [ x \in {2, 3} |-&gt; 2 * x ] \* FALSE
</code></pre>
<p><strong>Example in Python:</strong> The standard data structures also implement
structural equality in Python, though we have to be careful to
use <code>==</code> instead of <code>=</code>:</p>
<pre><code class="language-python">  False == False
  False == True
  10 == 20
  15 == 15
  &quot;Hello&quot; == &quot;world&quot;
  &quot;Hello&quot; == &quot;hello&quot;
  &quot;Bob&quot; == &quot;Bob&quot;
  frozenset({ 1, 2 }) == frozenset({ 2, 3 })
  frozenset({ 1, 2 }) == frozenset({ 2, 1 })
  frozenset({ 1 }) - frozenset({ 1 }) == frozenset({ &quot;a&quot; }) - frozenset({ &quot;a&quot; })
  frozenset({ frozenset({ 1, 2 }) }) == frozenset({ frozenset({ 1, 2, 2, 2 }) })
  (1, &quot;a&quot;) == (1, &quot;a&quot;)
  (1, &quot;a&quot;) == (1, &quot;b&quot;)
  (1, False) == (2, )
  (1, 2) == (1, 2, 3)
  { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1, &quot;b&quot;: 3 }
  { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1 }
  { x: (x + x) for x in { 2 } } == { x: (x * x) for x in { 2 } }
  { x: (x + x) for x in { 2, 3 } } == { x: 2 * x for x in { 2, 3 } }
</code></pre>
<hr />
<p><a name="neq"></a></p>
<h3><a class="header" href="#inequality" id="inequality">Inequality</a></h3>
<p><strong>Notation:</strong> <code>e_1 /= e_2</code> or <code>e_1 # e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/ne.png" alt="ne" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Effect:</strong> This operator is syntax sugar for <code>~(e_1 = e_2)</code>. Full stop.</p>
<hr />
<p><a name="chooseBounded"></a></p>
<h3><a class="header" href="#bounded-choice" id="bounded-choice">Bounded Choice</a></h3>
<p><em>This operator causes a lot of confusion. Read carefully!</em></p>
<p><strong>Notation:</strong> <code>CHOOSE x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/choose-bounded.png" alt="choose-bounded" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name, a set, and an
expression.</p>
<p><strong>Effect:</strong> This operator implements a black-box algorithm that <em>somehow</em> picks
one element from the set <code>{x \in S: P}</code>.  Is it an algorithm? Yes! <code>CHOOSE x \in S: P</code> is deterministic.  When you give it two equal sets and two equivalent
predicates, <code>CHOOSE</code> produces the same value. Formally, the only known property
of <code>CHOOSE</code> is as follows (which is slightly more general than what we wrote
above):</p>
<pre><code class="language-tla">  {x \in S: P} = {y \in T: Q} =&gt;
      (CHOOSE x \in S: P) = (CHOOSE y \in T: Q)
</code></pre>
<p>Importantly, when <code>{x \in S: P} = {}</code>, the expression <code>CHOOSE x \ in S: P</code>
evaluates to an undefined value.</p>
<p>How does <code>CHOOSE</code> actually work? TLA+ does not fix an algorithm for <code>CHOOSE</code> by
design. Maybe it returns the first element of the set? Sets are not ordered, so
there is no first element.</p>
<p>Why should you use <code>CHOOSE</code>? Actually, you should not. Unless you have no other
choice üéÄ</p>
<p>There are two common use cases, where the use of <code>CHOOSE</code> is well justified:</p>
<ul>
<li>
<p><em>Use case 1:</em> Retrieving the only element of a singleton set. If you know
that <code>Cardinality({x \in S: P}) = 1</code>, then <code>CHOOSE x \in S: P</code> returns
the only element of <code>{x \in S: P}</code>. No magic.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L63-L64">Min and Max in FiniteSetsExt</a>.</p>
</li>
<li>
<p><em>Use case 2:</em> Enumerating set elements in a fixed but unknown order.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L5-L17">ReduceSet in FiniteSetsExt</a>.</p>
</li>
</ul>
<p>In other cases, we believe that <code>CHOOSE</code> is bound to do <a href="https://en.wikipedia.org/wiki/Program_synthesis">Program synthesis</a>.
So TLC does some form of synthesis by brute force when it has to evaluate
<code>CHOOSE</code>.</p>
<p><strong>Determinism:</strong> Deterministic. Very much deterministic. Don't try to model
non-determinism with <code>CHOOSE</code>. For non-determinism, see:
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p>Apalache picks a set element that satisfies the predicate <code>P</code>, but it does not
guarantee the repeatability property of CHOOSE. It does not guarantee
non-determinism either. Interestingly, this behavior does not really make a
difference for the use cases 1 and 2. If you believe that this causes a problem
in your specification, <a href="https://github.com/informalsystems/apalache/issues/new/choose">open an issue...</a></p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  CHOOSE x \in 1..3: x &gt;= 3
  \* 3
  CHOOSE x \in 1..3:
    \A y \in 1..3: y &gt;= x
  \* 1, the minimum
  CHOOSE f \in [ 1..10 -&gt; BOOLEAN ]:
    \E x, y \in DOMAIN f:
      f[x] /\ ~f[y]
  \* some Boolean function from 1..10 that covers FALSE and TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python does not have anything similar to <code>CHOOSE</code>.
The closest possible solution is to sort the filtered set by the string values
and pick the first one (or the last one). So we have introduced a particular
way of implementing CHOOSE, see <a href="lang/./examples/choose.py">choose.py</a>:</p>
<pre><code class="language-python"># A fixed implementation of CHOOSE x \in S: TRUE
# that sorts the set by the string representation and picks the head
def choose(s):
    lst = sorted([(str(e), e) for e in s], key=(lambda pair: pair[0]))
    (_, e) = lst[0]
    return e


if __name__ == &quot;__main__&quot;:
    s = frozenset({ 1, 2, 3})
    print(&quot;CHOOSE {} = {}&quot;.format(s, choose(s)))
    s2 = frozenset({ frozenset({1}), frozenset({2}), frozenset({3})})
    print(&quot;CHOOSE {} = {}&quot;.format(s2, choose(s2)))
</code></pre>
<hr />
<p><a name="forall"></a></p>
<h3><a class="header" href="#unbounded-universal-quantifier" id="unbounded-universal-quantifier">Unbounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall.png" alt="forall" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when every element in the logical universe makes the expression <code>P</code> evaluate to
<code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to consider
only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="exists"></a></p>
<h3><a class="header" href="#unbounded-existential-quantifier" id="unbounded-existential-quantifier">Unbounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists.png" alt="exists" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when at least one element in the logical universe makes the expression <code>P</code>
evaluate to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to
consider only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="choose"></a></p>
<h3><a class="header" href="#unbounded-choose" id="unbounded-choose">Unbounded CHOOSE</a></h3>
<p><strong>Notation:</strong> <code>CHOOSE x: P</code></p>
<p><strong>LaTeX notation:</strong> CHOOSE x: P</p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to some value <code>v</code> in the logical universe
that evaluates <code>P</code> to <code>TRUE</code> against the binding <code>[x |-&gt; v]</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe and introduce a fixed rule for enumerating its elements.</p>
<p>Congratulations! You have reached the bottom of this page. If you want to learn
more about unbounded <code>CHOOSE</code>, read Section 16.1.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<h1><a class="header" href="#functions-1" id="functions-1">Functions</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Functions are probably the second most used TLA+ data structure after sets. TLA+
functions are not like functions in programming languages. In programming
languages, functions contain code that calls other functions. Although it is
technically possible to use functions when constructing a function in TLA+,
functions are more often used like tables or dictionaries: they are simple maps from a set of inputs to a set of outputs. For instance, in
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">Two-phase commit</a>, the function <code>rmState</code> stores the transaction state for
each process:</p>
<table><thead><tr><th>argument</th><th>rmState[argument]</th></tr></thead><tbody>
<tr><td>&quot;process1&quot;</td><td>&quot;working&quot;</td></tr>
<tr><td>&quot;process2&quot;</td><td>&quot;aborted&quot;</td></tr>
<tr><td>&quot;process3&quot;</td><td>&quot;prepared&quot;</td></tr>
</tbody></table>
<p>In the above table, the first column is the value of the function argument,
while the second column is the function result. An important property of this
table is that no value appears in the first column more than once, so
<em>every argument value is assigned at most one result value</em>.</p>
<p>Importantly, every function is defined in terms of the set of arguments over which it is
defined. This set is called the function's <em>domain</em>.  There is even a special
operator <code>DOMAIN f</code>, which returns the domain of a function <code>f</code>.</p>
<p>In contrast to TLA+ operators, <em>TLA+ functions are proper values</em>, so they can be
used as values in more complex data structures.</p>
<p><strong>Construction.</strong> Typically, the predicate <code>Init</code> constructs a function that
maps all elements of its domain to a default value.
In the example below we map the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code>
to the value &quot;working&quot;:</p>
<pre><code class="language-tla">Init ==
  rmState = [ p \in { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } |-&gt; &quot;working&quot; ]
</code></pre>
<p>In general, we can construct a function by giving an expression that shows us
how to map every argument to the result:</p>
<pre><code class="language-tla">  [ fahrenheit \in Int |-&gt; (fahrenheit - 32) * 5 \div 9 ]
</code></pre>
<p>Note that this function effectively defines an infinite table, as the set <code>Int</code>
is infinite. Both TLC and Apalache would give up on a function with an infinite
domain. (Though in the above example, it is obvious that we could treat the
function symbolically, without enumerating all of its elements.)</p>
<p>Another way to construct a function is to <em>non-deterministically</em> pick one
from a set of functions by using the <a href="lang/functions.html#funSetCtor">function set constructor</a>, <code>-&gt;</code>. E.g.:</p>
<pre><code class="language-tla">Init ==
    \E f \in [ { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } -&gt;
                    { &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; } ]:
        rmState = f
</code></pre>
<p>In the above example we are not talking about one function that is somehow
initialized &quot;by default&quot;. Rather, we say that <code>rmState</code> can be set to an
arbitrary function that receives arguments from the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code> and returns values that belong to the set <code>{ &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; }</code>. As a result, TLC has to
enumerate all possible functions that match this constraint. On the contrary,
Apalache introduces one instance of a function and restricts it with the
symbolic constraints. So it efficiently considers all possible functions
without enumerating them. However, this trick only works with existential
quantifiers. If you use a universal quantifier over a set of functions,
both TLC and Apalache unfold this set.</p>
<p><strong>Immutability</strong>. As you can see, TLA+ functions are similar to <a href="https://docs.python.org/3/library/stdtypes.html#dict">dictionaries
in Python</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">maps in
Java</a> rather than
to normal functions in programming languages. However, <em>TLA+ functions are
immutable</em>. Hence, they are even closer to immutable maps in Scala.  As in the
case of sets, you do not need to define hash or equality, in order to use
functions.</p>
<p>If you want to update a function, you have to produce another function and
describe how it is different from the original function. Luckily, TLA+ provides
you with operators for describing these updates in a compact way: By using the
function constructor (above) along with <code>EXCEPT</code>. For instance, to produce a
new function from <code>rmState</code>, we write the following:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process3&quot;] = &quot;committed&quot; ]
</code></pre>
<p>This new function is like <code>rmState</code>, except that it returns <code>&quot;committed&quot;</code>
on the argument <code>&quot;process3&quot;</code>:</p>
<pre><code class="language-tla">&quot;process1&quot;,  &quot;working&quot;
&quot;process2&quot;,  &quot;aborted&quot;
&quot;process3&quot;,  &quot;committed&quot;
</code></pre>
<p><em>Importantly, you cannot extend the function domain by using <code>EXCEPT</code>.</em>
For instance, the following expression produces the function that is
equivalent to <code>rmState</code>:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process10&quot;] = &quot;working&quot; ]
</code></pre>
<p><strong>Types.</strong> In pure TLA+, functions are free to mix values of different types in their domains.
See the example below:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
        IF x \in { 1, &quot;TRUE&quot;, TRUE}
        THEN TRUE
        ELSE FALSE
  ]
</code></pre>
<p>TLA+ functions are also free to return any kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
    CASE x = 0 -&gt; 1
      [] x = 1 -&gt; 0
      [] x = &quot;FALSE&quot; -&gt; &quot;TRUE&quot;
      [] x = &quot;TRUE&quot; -&gt; &quot;FALSE&quot;
      [] x = FALSE -&gt; TRUE
      OTHER -&gt; FALSE
  ]
</code></pre>
<p>As in the case of <a href="lang/./sets.html">sets</a>, TLC restricts function domains to comparable
values. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. So, TLC rejects the two
examples that are given above.</p>
<p>However, functions in TLC are free to return different kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 1, 2 } |-&gt;
                        IF x = 1 THEN FALSE ELSE 3 ]
</code></pre>
<p>This is why, in pure TLA+ and TLC, records, tuples, and sequences are just
functions over particular domains (finite sets of strings and finite sets
of integers).</p>
<p>Apalache enforces stricter types. It has designated types for all four
data structures: general functions, records, tuples, and sequences.
Moreover, all elements of the function domain must have the same type.
The same is true for the codomain. This is enforced
by the type checker.</p>
<p>In this sense, the type restrictions of Apalache are similar to those for the
generic collections of Java and Scala.  As a result, the type checker in
Apalache rejects the three above examples.</p>
<hr />
<h2><a class="header" href="#operators-3" id="operators-3">Operators</a></h2>
<p><strong>NOTE</strong>: In the Python examples below we use the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="funCtor"></a></p>
<h3><a class="header" href="#function-constructor" id="function-constructor">Function constructor</a></h3>
<p><strong>Notation:</strong> <code>[ x \in S |-&gt; e ]</code> or <code>[ x \in S, y \in T |-&gt; e ]</code>, or more
arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/fun-ctor.png" alt="fun-ctor" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name (or a tuple of names,
see <strong>Advanced syntax</strong>), a set, and a mapping expression. Instead of one
variable and one set, you can use multiple variables and multiple sets.</p>
<p><strong>Effect:</strong> We give the semantics for one argument.  We write a sequence of
steps to ease the understanding.  This operator constructs a function <code>f</code> over
the domain <code>S</code> as follows.  For every element <code>elem</code> of <code>S</code>, do the following:</p>
<ol>
<li>Bind the element <code>elem</code> to variable <code>x</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; elem]</code> and store it
in a temporary variable called <code>result</code>.</li>
<li>Set <code>f[elem]</code> to <code>result</code>.</li>
</ol>
<p>Of course, the semantics of the function constructor in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>
does not require us to compute the function at all. We believe that
our description helps you to see that there is a way to compute this data
structure, though in a very straightforward and inefficient way.</p>
<p>If the function constructor introduces multiple variables, then the constructed
function maps a tuple to a value. See <strong>Example</strong>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the function domain and the mapping
expression. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC accepts function domains of comparable values. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further: It requires the function domain to be well-typed (as a
set), and it requires the mapping expression <code>e</code> to be well-typed. If this
is not the case, the type checker flags an error.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>[ &lt;&lt;x, y&gt;&gt; \in S |-&gt; x + y ]</code>. In this case, for
every element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound
to <code>e[2]</code>. The function constructor maps the tuples from <code>S</code> to the values
that are computed under such a binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ x \in 1..3 |-&gt; 2 * x ]  \* a function that maps 1, 2, 3 to 2, 4, 6
  [ x, y \in 1..3 |-&gt; x * y ]
    \* a function that maps &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;, ..., &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
    \* to 1, 2, 3, ..., 6, 9
  [ &lt;&lt;x, y&gt;&gt; \in (1..3) \X (4..6) |-&gt; x + y ]
    \* a function that maps &lt;&lt;1, 4&gt;&gt;, &lt;&lt;1, 5&gt;&gt;, &lt;&lt;1, 6&gt;&gt;, ..., &lt;&lt;2, 6&gt;&gt;, &lt;&lt;3, 6&gt;&gt;
    \* to 5, 6, 7, ..., 8, 9
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]]
    \* a function that maps a number n from 1 to 3
    \* to a function from 1..n to n + i. Like an array of arrays.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  X = frozenset({ 1, 2, 3 })
  frozendict({ x: 2 * x for x in X })
  frozendict({ (x, y): x * y for x in X for y in X })
  Y = frozenset({ 4, 5, 6 })
  XY = frozenset((x, y) for x in X for y in Y)
  frozendict({ (x, y): x + y  for (x, y) in XY })
</code></pre>
<hr />
<p><a name="funSetCtor"></a></p>
<h3><a class="header" href="#function-set-constructor" id="function-set-constructor">Function set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ S -&gt; T ]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/funset.png" alt="funset" /></p>
<p><strong>Arguments:</strong> Two arguments. Both have to be sets. Otherwise, the result is
undefined.</p>
<p><strong>Effect:</strong> This operator constructs the set of all possible functions that
have <code>S</code> as their domain, and for each argument <code>x \in S</code> return a value <code>y \in T</code>.</p>
<p>Note that if one of the sets is infinite, then the set <code>[S -&gt; T]</code> is infinite
too. TLC flags an error, if <code>S</code> or <code>T</code> are infinite. Apalache flags an error,
if <code>S</code> is infinite, but when it does not have to explicitly construct <code>[S -&gt; T]</code>, it may accept infinite <code>T</code>. For instance:</p>
<pre><code class="language-tla">  \E f \in [ 1..3 -&gt; 4..6]:
    ...
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, if <code>S</code> and <code>T</code> are not sets, then <code>[S -&gt; T]</code>
is undefined. If either <code>S</code> or <code>T</code> is not a set, TLC flags a model checking error.
Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ 1..3 -&gt; 1..100 ]
    \* the set of functions that map 1, 2, 3 to values from 1 to 100
  [ Int -&gt; BOOLEAN ]
    \* The infinite set of functions that map every integer to a Boolean.
    \* Error in TLC.
</code></pre>
<p><strong>Example in Python:</strong> We do not give here the code that enumerates all
functions. It should be similar in spirit to <a href="lang/./examples/subset.py">subset.py</a>,
but it should enumerate strings over the alphabet of <code>0..(Cardinality(T) - 1)</code>
values, rather than over the alphabet of 2 values.</p>
<p><a name="funApp"></a></p>
<h3><a class="header" href="#function-application" id="function-application">Function application</a></h3>
<p><strong>Notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>Arguments:</strong> At least two arguments. The first one should be a function,
the other arguments are the arguments to the function. Several arguments
are treated as a tuple. For instance, <code>f[e_1, ..., e_n]</code> is shorthand for
<code>f[&lt;&lt;e_1, ..., e_n&gt;&gt;]</code>.</p>
<p><strong>Effect:</strong> This operator is evaluated as follows:</p>
<ul>
<li>If <code>e \in DOMAIN f</code>, then <code>f[e]</code> evaluates to the value that function
<code>f</code> associates with the value of <code>e</code>.</li>
<li>If <code>e \notin DOMAIN f</code>, then the value is undefined.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>e \notin DOMAIN f</code>, TLC flags a model checking error.</p>
<p>When <code>e</code> has a type incompatible with the type of <code>DOMAIN f</code>, Apalache flags
a type error. When <code>e \notin DOMAIN f</code>, Apalache assigns some type-compatible
value to <code>f[e]</code>, but does not report any error. This is not a bug in Apalache,
but a feature of the SMT encoding. Usually, an illegal access surfaces
somewhere, when checking a specification.  If you want to detect an access
outside of the function domain, instrument your code with an additional state
variable.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [x \in 1..10 |-&gt; x * x][5]                \* 25
  [x \in 1..3, y \in 1..3 |-&gt; x * y][2, 2]
    \* Result = 4. Accessing a two-dimensional matrix by a pair
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]][3][2]
    \* The first access returns a function, the second access returns 5.
  [x \in 1..10 |-&gt; x * x][100]              \* model checking error in TLC,
                                            \* Apalache produces some value
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  S10 = frozenset(range(1, 10 + 1))
  # TLA: [x \in 1..10 |-&gt; x * x]
  f1 = frozendict({ x: x * x for x in S10 })
  f1[5]         # 25
  S3 = frozenset({ 1, 2, 3 })
  # TLA: [x, y \in 1..3 |-&gt; x * y]
  f2 = frozendict({ (x, y): x * y for x in S3 for y in S3 })
  f2[(2, 2)]    # 4
  # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]]
  f3 = frozendict({
    n: frozendict({
      i: n + i
        for i in frozenset(range(1, n + 1))
    })
        for n in S3
  })
  f3[3][2]
</code></pre>
<hr />
<p><a name="except"></a></p>
<h3><a class="header" href="#function-replacement" id="function-replacement">Function replacement</a></h3>
<p><strong>Notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>Arguments:</strong> At least three arguments. The first one should be a function,
the other arguments are interleaved pairs of argument expressions and value
expressions.</p>
<p><strong>Effect:</strong> This operator evaluates to a new function <code>g</code> that is constructed
as follows:</p>
<ul>
<li>Set the domain of <code>g</code> to <code>DOMAIN f</code>.</li>
<li>For every element <code>b \in DOMAIN f</code>, do:
<ul>
<li>If <code>b = a_i</code> for some <code>i \in 1..n</code>, then set <code>g[b]</code> to <code>e_i</code>.</li>
<li>If <code>b \notin { a_1, ..., a_n }</code>, then set <code>g[b]</code> to <code>f[b]</code>.</li>
</ul>
</li>
</ul>
<p><em>Importantly, <code>g</code> is a new function: the function <code>f</code> is not modified!</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>a_i \notin DOMAIN f</code> for some <code>i \in 1..n</code>,
TLC flags a model checking error.</p>
<p>When <code>a_1, ..., a_n</code> are not type-compatible with the type of <code>DOMAIN f</code>,
Apalache flags a type error. When <code>a_i \notin DOMAIN f</code>, Apalache ignores this
argument. This is consistent with the semantics of TLA+ in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p><strong>Advanced syntax:</strong> There are three extensions to the basic syntax.</p>
<p><em>Extension 1</em>. If the domain elements of a function <code>f</code> are tuples, then, similar to
function application, the expressions <code>a_1, ..., a_n</code> can be written without
the tuple braces <code>&lt;&lt;...&gt;&gt;</code>. For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1, 2] = e ]
</code></pre>
<p>In the above example, the element <code>f[&lt;&lt;1, 2&gt;&gt;]</code> is replaced with <code>e</code>.
As you can see, this is just syntax sugar.</p>
<p><em>Extension 2</em>. The operator <code>EXCEPT</code> introduces an implicit alias <code>@</code>
that refers to the element <code>f[a_i]</code> that is going to be replaced:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1] = @ + 1, ![2] = @ + 3 ]
</code></pre>
<p>In the above example, the element <code>f[1]</code> is replaced with <code>f[1] + 1</code>, whereas
the element <code>f[2]</code> is replaced with <code>f[2] + 3</code>.
This is also syntax sugar.</p>
<p><em>Extension 3</em>. The advanced syntax of <code>EXCEPT</code> allows for chained replacements.
For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1][a_2]...[a_n] = e ]
</code></pre>
<p>This is syntax sugar for:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1] =
    [ @ EXCEPT ![a_2] =
        ...
            [ @ EXCEPT ![a_n] = e ]]]
</code></pre>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET f1 == [ p \in 1..3 |-&gt; &quot;working&quot; ] IN
  [ f1 EXCEPT ![2] = &quot;aborted&quot; ]
    \* a new function that maps: 1 to &quot;working&quot;, 2 to &quot;aborted&quot;, 3 to &quot;working&quot;

  LET f2 == [x \in 1..3, y \in 1..3 |-&gt; x * y] IN
  [ f2 EXCEPT ![1, 1] = 0 ]
    \* a new function that maps:
    \*   &lt;&lt;1, 1&gt;&gt; to 0, and &lt;&lt;x, y&gt;&gt; to x * y when `x /= 0` or `y /= 0`
  LET f3 ==  [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]] IN
  [ f3 EXCEPT ![2][2] = 100 ]
    \* a new function that maps:
    \*   1 to the function that maps: 1 to 2
    \*   2 to the function that maps: 1 to 3, 2 to 100
    \*   3 to the function that maps: 1 to 4, 2 to 5, 3 to 6
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  f1 = frozendict({ i: &quot;working&quot; for i in range(1, 3 + 1) })
  tmp = dict(f1)
  tmp[2] = &quot;aborted&quot;
  g1 = frozendict(tmp)
  # g1 is &lt;frozendict {1: 'working', 2: 'aborted', 3: 'working'}&gt;

  S3 = frozenset({ 1, 2, 3 })
  # TLA: [x, y \in 1..3 |-&gt; x * y]
  f2 = frozendict({ (x, y): x * y for x in S3 for y in S3 })
  tmp = dict(f2)
  tmp[(1, 1)] = 0
  g2 = frozendict(tmp)
  # &lt;frozendict {(1, 1): 0, (1, 2): 2, (1, 3): 3, (2, 1): 2, (2, 2): 4,
  #              (2, 3): 6, (3, 1): 3, (3, 2): 6, (3, 3): 9}&gt;

  # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]]
  f3 = frozendict({
    n: frozendict({
      i: n + i
        for i in frozenset(range(1, n + 1))
    })
        for n in S3
  })
  # [ f3 EXCEPT ![2][2] = 100 ]
  tmp = dict(f3[2])
  tmp[2] = 100
  tmp2 = dict(f3)
  tmp2[2] = tmp
  g3 = frozendict(tmp2)
  # &lt;frozendict {1: &lt;frozendict {1: 2}&gt;,
  #              2: {1: 3, 2: 100},
  #              3: &lt;frozendict {1: 4, 2: 5, 3: 6}&gt;}&gt;
</code></pre>
<hr />
<p><a name="domain"></a></p>
<h3><a class="header" href="#function-domain" id="function-domain">Function domain</a></h3>
<p><strong>Notation:</strong> <code>DOMAIN f</code></p>
<p><strong>LaTeX notation:</strong> <code>DOMAIN f</code></p>
<p><strong>Arguments:</strong> One argument, which should be a function
(respectively, a record, tuple, sequence).</p>
<p><strong>Effect:</strong> <code>DOMAIN f</code> returns the set of values, on which the function
has been defined, see: Function constructor and Function set constructor.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if <code>f</code> is not a function
(respectively, a record, tuple, or sequence). TLC flags a model checking error
if <code>f</code> is a value that does not have a domain. Apalache flags a type checking
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  DOMAIN [ x \in 1..3 |-&gt; 2 * x ]
  \* { 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">  X = frozenset({ 1, 2, 3 })
  f = frozendict({ x: 2 * x for x in X })
  frozenset(f.keys())
  # frozenset({1, 2, 3})
</code></pre>
<h1><a class="header" href="#records-1" id="records-1">Records</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Records in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that have the
following properties:</p>
<ul>
<li>The domain of a record contains only strings.</li>
<li>The domain of a record is finite.</li>
</ul>
<p>That is it in pure TLA+. Essentially, TLA+ is following the duck-typing principle for
records: Any function over strings can be also treated as a record, and vice
versa, a record is also a function. So you can use all function operators on
records too.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
records.  For instance, the following example shows how to construct a record
that has two fields: Field <code>&quot;a&quot;</code> is assigned value <code>2</code>, and field <code>&quot;b&quot;</code> is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  [ a |-&gt; 2, b |-&gt; TRUE ]
</code></pre>
<p>Similar to the function set <code>[S -&gt; T]</code>, there is a record set constructor:</p>
<pre><code class="language-tla">  [ name: { &quot;Alice&quot;, &quot;Bob&quot; }, year_of_birth: 1900..2000 ]
</code></pre>
<p>The expression in the above example constructs a set of records that have: the
<code>name</code> field set to either &quot;Alice&quot; or &quot;Bob&quot;, and the <code>year_of_birth</code> field set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> TLA+ provides you with a shorthand operator for accessing
a record field by following C-style struct-member notation. For example:</p>
<pre><code class="language-tla">  r.myField
</code></pre>
<p>This is essentially syntax sugar for <code>r[&quot;myField&quot;]</code>.</p>
<p><strong>Immutability</strong>. As records are special kinds of <a href="lang/./functions.html">functions</a>,
records are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions and records. When Apalache processes a
record constructor, it assigns the record type to the result. This record type
carries the information about the names of the record fields and their types.
Similarly, Apalache assigns the type of a set of records, when it processes a
record set constructor.  See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types.</p>
<p><em>Owing to the type information, records are translated into SMT more efficiently
by Apalache than the general functions.</em></p>
<p>It is quite common to mix records of different shapes into sets. For instance,
see how the variable <code>msgs</code> is updated in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>. To address this pattern,
Apalache treats records that do not disagree on field types to be
type-compatible. For instance, the records <code>[type |-&gt; &quot;A&quot;, a |-&gt; 3]</code>
and <code>[type |-&gt; &quot;B&quot;, b |-&gt; TRUE]</code> have the joint type:</p>
<pre><code>  [type: Str, a: Int, b: Bool]
</code></pre>
<hr />
<h2><a class="header" href="#operators-4" id="operators-4">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="recCtor"></a></p>
<h3><a class="header" href="#record-constructor" id="record-constructor">Record constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/rec-ctor.png" alt="rec-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Effect:</strong> The record constructor returns a function <code>r</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN r</code> to <code>{ field_1, ..., field_n }</code>,</li>
<li>set <code>r[field_i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ]
    \* A record that has two fields:
    \* field &quot;name&quot; that is equal to &quot;Printer&quot;, and field &quot;port&quot; that is equal to 631.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  frozendict({ &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 })
</code></pre>
<hr />
<p><a name="recSetCtor"></a></p>
<h3><a class="header" href="#record-set-constructor" id="record-set-constructor">Record set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1: S_1, ..., field_n: S_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/recset-ctor.png" alt="recset-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Effect:</strong> The record set constructor <code>[ field_1: S_1, ..., field_n: S_n]</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ [ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]: e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite records sets in some cases, when one record
is picked with <code>\E r \in [ field_1: S_1, ..., field_n: S_n]</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name: { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, port: 1..65535 ]
    \* A set of records. Each has two fields:
    \* field &quot;name&quot; that has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \* field &quot;port&quot; that has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  frozenset({ frozendict({ &quot;name&quot;: n, &quot;port&quot;: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="recApp"></a></p>
<h3><a class="header" href="#access-by-field-name" id="access-by-field-name">Access by field name</a></h3>
<p><strong>Notation:</strong> <code>r.field</code></p>
<p><strong>LaTeX notation:</strong> <code>r.field</code></p>
<p><strong>Arguments:</strong> Two arguments: a record and a field name (as an identifier).</p>
<p><strong>Effect:</strong> As records are also functions, this operator works as <code>r[&quot;field&quot;]</code>.</p>
<p>Apalache treats records as values of a record type. In comparison to the
general function application <code>r[&quot;field&quot;]</code>, the operator <code>r.field</code> is handled
much more efficiently in Apalache. Due to the use of types, Apalache can
extract the respective field when translating the access expression into SMT.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET r == [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ] IN
  r.name    \* &quot;Printer&quot;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  r = frozendict({ &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 })
  r[&quot;name&quot;]    # &quot;Printer&quot;
</code></pre>
<hr />
<h1><a class="header" href="#tuples-1" id="tuples-1">Tuples</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Tuples in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that satisfy one
of the following properties:</p>
<ul>
<li>The domain is either empty, that is, <code>{}</code>, or</li>
<li>The domain is <code>1..n</code> for some <code>n &gt; 0</code>.</li>
</ul>
<p>That is right. You can construct the empty tuple <code>&lt;&lt;&gt;&gt;</code> in TLA+ as well as a
single-element tuple, e.g., <code>&lt;&lt;1&gt;&gt;</code>. You can also construct pairs, triples, an
so on, e.g., <code>&lt;&lt;1, TRUE&gt;&gt;</code>, <code>&lt;&lt;&quot;Hello&quot;, &quot;world&quot;, 2020&gt;&gt;</code>. If you think that
empty tuples do not make sense: In TLA+, there is no difference between tuples
and <a href="lang/./sequences.html">sequences</a>.  Again, it is duck typing: Any function with
the domain <code>1..n</code> can be also treated as a tuple (or a sequence!), and vice
versa, tuples and sequences are also functions. So you can use all function
operators on tuples.</p>
<p>Importantly, the domain of a nonempty tuple is <code>1..n</code> for some <code>n &gt; 0</code>. So tuples never
have a 0th element. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us 1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
tuples. For instance, the following example shows how to construct a tuple
that has two fields: Field 1 is assigned value <code>2</code>, and field 2 is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  &lt;&lt;2, TRUE&gt;&gt;
</code></pre>
<p>There is a tuple set constructor, which is well-known as <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>:</p>
<pre><code class="language-tla">  { &quot;Alice&quot;, &quot;Bob&quot; } \X (1900..2000)
</code></pre>
<p>The expression in the above example constructs a set of tuples <code>&lt;&lt;n, y&gt;&gt;</code>: the
first field <code>n</code> is set to either &quot;Alice&quot; or &quot;Bob&quot;, and the second field <code>y</code> is set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>t[2]</code>.</p>
<p><strong>Immutability</strong>. As tuples are special kinds of <a href="lang/./functions.html">functions</a>,
tuples are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>A -&gt; B</code> that
restricts the arguments and results as follows: the arguments have the type
<code>A</code> and the results have the type <code>B</code>. A sequence has the type
<code>Seq(C)</code>, which restricts the sequence elements to have the same type <code>C</code>. In
contrast, tuples have more fine-grained types in Apalache: <code>&lt;&lt;T_1&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2, T_3&gt;&gt;</code> and so on. As a result, different tuple fields are
allowed to carry elements of different types, whereas functions and sequences
are not allowed to do that. See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types for details.</p>
<p>As tuples are also sequences in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence. This needs a <a href="lang/../apalache/types-and-annotations.html">type annotation</a>.</p>
<p><em>Owing to the type information, tuples are translated into SMT much more efficiently
by Apalache than the general functions and sequences!</em></p>
<hr />
<h2><a class="header" href="#operators-5" id="operators-5">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="tuple"></a></p>
<h3><a class="header" href="#tuplesequence-constructor" id="tuplesequence-constructor">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Effect:</strong> The tuple constructor returns a function <code>t</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a <a href="lang/../apalache/types-and-annotations.html">type
annotation</a>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
tuples, which are indexed with 0!. If we want to stick to the
principle &quot;tuples are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">  (&quot;Printer&quot;, 631)                      # the pythonic way, introducing fields 0 and 1
  frozendict({ 1: &quot;Printer&quot;, 2: 631 })  # the &quot;tuples-are-functions&quot; way
</code></pre>
<hr />
<p><a name="times"></a></p>
<h3><a class="header" href="#cartesian-product" id="cartesian-product">Cartesian product</a></h3>
<p><strong>Notation:</strong> <code>S_1 \X ... \X S_n</code> (or <code>S_1 \times ... \times S_n</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/set-prod.png" alt="set-prod" /></p>
<p><strong>Arguments:</strong> At least two arguments. All of them should be sets.</p>
<p><strong>Effect:</strong> The Cartesian product <code>S_1 \X ... \X S_n</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ &lt;&lt; e_1, ..., e_n &gt;&gt; : e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite sets in some cases, e.g., when one tuple
is picked with <code>\E t \in S_1 \X S_2</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } \X (1..65535)
    \* A set of tuples. Each tuple has two fields:
    \*   - field 1 has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \*   - field 2 has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a set of python tuples (indexed with 0, 1, ...)
  frozenset({ (n, p)
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
  # the TLA+ way
  frozenset({ frozendict({ 1: n, 2: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-1" id="function-application-1">Function application</a></h3>
<p>As tuples are functions, you can access tuple elements by
<a href="lang/./functions.html#funApp">function application</a>, e.g., <code>tup[2]</code>.</p>
<h1><a class="header" href="#sequences-1" id="sequences-1">Sequences</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>On the surface, TLA+ sequences are very much like lists in your programming
language of choice.  If you are writing code in Java, Python, Lisp, C++, Scala,
you will be tempted to use sequences in TLA+ too. This is simply due to the
fact that arrays, vectors, and lists are the most efficient collections in
programming languages (for many tasks, but not all of them). But TLA+ is not
about efficient compilation of your data structures!  Many algorithms can be
expressed in a much nicer way with <a href="lang/./sets.html">sets</a> and
<a href="lang/./functions.html">functions</a>. In general, use sequences when you really need
them.</p>
<p>In pure TLA+, sequences are just <a href="lang/./tuples">tuples</a>. As a tuple, a sequence is
a function of the domain <code>1..n</code> for some <code>n &gt;= 0</code> (the domain may be empty).
The duck-typing principle applies to sequences too: Any function with the domain <code>1..n</code> can also be
treated as a sequence (or a tuple), and vice versa, tuples and sequences are
also functions. So you can use all function and tuple operators on sequences.</p>
<p>Importantly, the domain of a sequence is <code>1..n</code> for some <code>n &gt;= 0</code>. So the
indices in a sequence start with 1, not 0. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us
1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p>The operators on sequences are defined in the standard module <code>Sequences</code>. To
use it, write the <code>EXTENDS</code> clause in the first lines of your module. Like
this:</p>
<pre><code class="language-tla">------ MODULE MyLists ----====
EXTENDS Sequences
...
==============================
</code></pre>
<p><strong>Construction.</strong> Sequences are constructed exactly as tuples in TLA+:</p>
<pre><code class="language-tla">  &lt;&lt;2, 4, 8&gt;&gt;
</code></pre>
<p>Sometimes, you have to talk about all possible sequences. The operator
<code>Seq(S)</code> constructs the set of all (finite) sequences that draw elements
from the set <code>S</code>. For instance, <code>&lt;&lt;1, 2, 2, 1&gt;&gt; \in Seq({1, 2, 3})</code>.
Note that <code>Seq(S)</code> is an infinite set. To use it with TLC, you often have
to override this operator, see <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, page 237.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>s[2]</code>.</p>
<p><strong>Immutability.</strong> As sequences are special kinds of
<a href="lang/./functions.html">functions</a>, sequences are immutable.</p>
<p><strong>Sequence operators.</strong> The module <code>Sequences</code> provides you with convenient
operators on sequences:</p>
<ul>
<li>Add to end: <code>Append(s, e)</code></li>
<li>First and rest: <code>Head(s)</code> and <code>Tail(s)</code></li>
<li>Length: <code>Len(s)</code></li>
<li>Concatenation: <code>s \o t</code></li>
<li>Subsequence: <code>SubSeq(s, i, k)</code></li>
<li>Sequence filter: <code>SelectSeq(s, Test)</code></li>
</ul>
<p>See the detailed description in <strong>Operators</strong>.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>T_1 -&gt; T_2</code> that
restricts the arguments and results as follows: the arguments have the type
<code>T_1</code> and the results have the type <code>T_2</code>. A sequence has the type <code>Seq(T_3)</code>,
which restricts the sequence elements to have the same type <code>T_3</code>.</p>
<p>As sequences are also tuples in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence. This needs a <a href="lang/../apalache/types-and-annotations.html">type annotation</a>.</p>
<p><em>The current SMT encoding of sequences in Apalache is not optimized,
so operations on sequences are often significantly slower than operations
on sets.</em></p>
<hr />
<h2><a class="header" href="#operators-6" id="operators-6">Operators</a></h2>
<p><a name="seqCtor"></a></p>
<h3><a class="header" href="#tuplesequence-constructor-1" id="tuplesequence-constructor-1">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Effect:</strong> The tuple/sequence constructor returns a function <code>t</code> that is
constructed as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a <a href="lang/../apalache/types-and-annotations.html">type
annotation</a>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
lists, which are indexed with 0!. If we want to stick to the
principle &quot;sequences are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">  [&quot;Printer&quot;, 631]                      # the pythonic way, a two-element list
  frozendict({ 1: &quot;Printer&quot;, 2: 631 })  # the &quot;sequences-are-functions&quot; way
</code></pre>
<hr />
<p><a name="append"></a></p>
<h3><a class="header" href="#sequence-append" id="sequence-append">Sequence append</a></h3>
<p><strong>Notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>LaTeX notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>Arguments:</strong> Two arguments. The first argument should be a sequence, the
second one is an arbitrary expression.</p>
<p><strong>Effect:</strong> The operator <code>Append(seq, e)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \union { Len(seq) + 1 }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i]</code> for <code>i \in 1..Len(seq)</code>.</li>
<li>set <code>newSeq[Len(seq) + 1]</code> to <code>e</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined in pure TLA+.
TLC raises a model checking error. Apalache flags a static type error.</p>
<p>Apalache flags a static type error, when the type of <code>e</code> is not compatible with
the type of the sequence elements.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Append(&lt;&lt;1, 2&gt;&gt;, 5)
    \* The sequence &lt;&lt;1, 2, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a list (indexed with 0, 1, ...)
  l = [ 1, 2 ]
  l.append(5)
  # the TLA+ way
  l = frozendict({ 1: 1, 2: 2 })
  frozendict({ i: l[i] if i &lt;= len(l) else 5
    for i in range(1, len(l) + 2) })
</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-2" id="function-application-2">Function application</a></h3>
<p>As sequences are functions, you can access sequence elements with
<a href="lang/./functions.html#funApp">function application</a>, e.g., <code>seq[2]</code>.</p>
<hr />
<p><a name="head"></a></p>
<h3><a class="header" href="#sequence-head" id="sequence-head">Sequence head</a></h3>
<p><strong>Notation:</strong> <code>Head(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Head(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Effect:</strong> The operator <code>Head(seq)</code> evaluates to <code>seq[1]</code>.
If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Head(&lt;&lt;3, 4&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: using the list
  l = [ 3, 4 ]
  l[0]  # 3
  # the TLA+ way
  l = frozendict({ 1: 3, 2: 4 })
  l[1]  # 3
</code></pre>
<hr />
<p><a name="tail"></a></p>
<h3><a class="header" href="#sequence-tail" id="sequence-tail">Sequence tail</a></h3>
<p><strong>Notation:</strong> <code>Tail(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Tail(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Effect:</strong> The operator <code>Tail(seq)</code> constructs a new sequence <code>newSeq</code> as
follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \ { Len(seq) }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i + 1]</code> for <code>i \in 1..(Len(seq) - 1)</code>.</li>
</ul>
<p>If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Tail</code> is a very simple operation that just increments <code>start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Tail(&lt;&lt;3, 4, 5&gt;&gt;)
    \* &lt;&lt;4, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: using the list
  l = [ 3, 4, 5 ]
  l[1:]  # 4, 5
  # the TLA+ way
  l = frozendict({ 1: 3, 2: 4, 3: 5 })
  frozendict({ i: l[i + 1] for i in range(1, len(l)) })
</code></pre>
<hr />
<p><a name="len"></a></p>
<h3><a class="header" href="#sequence-length" id="sequence-length">Sequence length</a></h3>
<p><strong>Notation:</strong> <code>Len(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Len(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Effect:</strong> The operator <code>Len(seq)</code> is semantically equivalent to
<code>Cardinality(DOMAIN seq)</code>.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Len</code> is simply computed as <code>end - start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Len(&lt;&lt;3, 4, 5&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: using the list
  l = [ 3, 4, 5 ]
  len(l)    # 3
  # the TLA+ way
  l = frozendict({ 1: 3, 2: 4, 3: 5 })
  len(l.keys())
</code></pre>
<hr />
<p><a name="concat"></a></p>
<h3><a class="header" href="#sequence-concatenation" id="sequence-concatenation">Sequence concatenation</a></h3>
<p><strong>Notation:</strong> <code>s \o t</code> (or <code>s \circ t</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/seq-concat.png" alt="seq-concat" /></p>
<p><strong>Arguments:</strong> Two arguments: both should be sequences (or tuples).</p>
<p><strong>Effect:</strong> The operator <code>s \o t</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(Len(s) + Len(t))</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[i]</code> for <code>i \in 1..Len(s)</code>.</li>
<li>set <code>newSeq[Len(s) + i]</code> to <code>t[i]</code> for <code>i \in 1..Len(t)</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>s</code> and <code>t</code> must be sequences, that is, functions
over integers <code>1..n</code> and <code>1..k</code> for some <code>n</code> and <code>k</code>. Otherwise, the result is
undefined in pure TLA+. TLC raises a model checking error. Apalache flags a
static type error.</p>
<p>Apalache flags a static type error, when the types of <code>s</code> and <code>t</code> are
incompatible.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;3, 5&gt;&gt; \o &lt;&lt;7, 9&gt;&gt;
    \* The sequence &lt;&lt;3, 5, 7, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a list (indexed with 0, 1, ...)
  l1 = [ 3, 5 ]
  l2 = [ 7, 9 ]
  l1 + l2
  # the TLA+ way
  l1 = frozendict({ 1: 3, 2: 5 })
  l2 = frozendict({ 1: 7, 2: 9 })
  frozendict({ i: l1[i] if i &lt;= len(l1) else l2[i - len(l1)]
    for i in range(1, len(l1) + len(l2) + 1) })
</code></pre>
<hr />
<p><a name="subseq"></a></p>
<h3><a class="header" href="#subsequence" id="subsequence">Subsequence</a></h3>
<p><strong>Notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>LaTeX notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>Arguments:</strong> Three arguments: a sequence (tuple), and two integers.</p>
<p><strong>Effect:</strong> The operator <code>SubSeq(seq, m, n)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(n - m)</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[m + i - 1]</code> for <code>i \in 1..(n - m + 1)</code>.</li>
</ul>
<p>If <code>m &gt; n</code>, then <code>newSeq</code> is equal to the empty sequence <code>&lt;&lt; &gt;&gt;</code>.
If <code>m &lt; 1</code> or <code>n &gt; Len(seq)</code>, then the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..k</code> for some <code>k</code>. The arguments <code>m</code> and <code>n</code> must be integers.
Otherwise, the result is undefined in pure TLA+. TLC raises a model checking
error. Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SubSeq(&lt;&lt;3, 5, 9, 10&gt;&gt;, 2, 3)
    \* The sequence &lt;&lt;5, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a list (indexed with 0, 1, ...)
  l = [ 3, 5, 9, 10 ]
  l[1:3]
  # the TLA+ way
  l = frozendict({ 1: 3, 2: 5, 3: 9, 4: 10 })
  m = 2
  n = 3
  frozendict({ i: l[i + m - 1]
    for i in range(1, n - m + 2) })
</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#sequence-filter" id="sequence-filter">Sequence filter</a></h3>
<p><strong>Notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>LaTeX notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>Arguments:</strong> Two arguments: a sequence (a tuple) and a one-argument
operator that evaluates to <code>TRUE</code> or <code>FALSE</code> when called with
an element of <code>seq</code> as its argument.</p>
<p><strong>Effect:</strong> The operator <code>SelectSeq(seq, Test)</code> constructs a new sequence
<code>newSeq</code> that contains every element <code>e</code> of <code>seq</code> on which <code>Test(e)</code> evaluates
to <code>TRUE</code>.</p>
<p>It is much easier to describe the effect of <code>SelectSeq</code> in words than to
give a precise sequence of steps. See <strong>Examples</strong>.</p>
<p><em>This operator is not supported by Apalache, as it inlines all operators,
before translating the specification in SMT. Hence, it cannot pass <code>Test</code>
into a built-in operator. To work around it, write a user-defined
recursive operator that is equivalent to <code>SelectSeq</code>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> If the arguments are not as described in <strong>Arguments</strong>, then the
result is undefined in pure TLA+. TLC raises a model checking error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET Test(x) ==
    x % 2 = 0
  IN
  SelectSeq(&lt;&lt;3, 4, 9, 10, 11&gt;&gt;, Test)
    \* The sequence &lt;&lt;4, 10&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a list (indexed with 0, 1, ...)
  def test(x):
    return x % 2 == 0

  l = [ 3, 4, 9, 10, 11 ]
  [ x for x in l if test(x) ]
  # the TLA+ way
  l = frozendict({ 1: 3, 2: 4, 3: 9, 4: 10, 5: 11 })
  as_list = sorted(list(l.items()))
  filtered = [ x for (_, x) in as_list if test(x) ]
  frozendict({ i: x
    for (i, x) in zip(range(1, len(filtered) + 1), filtered)
  })
</code></pre>
<hr />
<p><a name="seq"></a></p>
<h3><a class="header" href="#all-sequences" id="all-sequences">All sequences</a></h3>
<p><strong>Notation:</strong> <code>Seq(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Seq(S)</code></p>
<p><strong>Arguments:</strong> One argument that should be a set.</p>
<p><strong>Effect:</strong> The operator <code>Seq(S)</code> constructs the set of all (finite) sequences
that contain elements from <code>S</code>. This set is infinite.</p>
<p>It is easy to give a recursive definition of all sequences whose length
is bounded by some <code>n &gt;= 0</code>:</p>
<pre><code class="language-tla">RECURSIVE BSeq(_, _)
BSeq(S, n) ==
  IF n = 0
  THEN {&lt;&lt; &gt;&gt;}  \* the set that contains the empty sequence
  ELSE LET Shorter == BSeq(S, n - 1) IN
        Shorter \union { Append(seq, x): seq \in Shorter, x \in S }
</code></pre>
<p>Then we can define <code>Seq(S)</code> to be <code>UNION { BSeq(S, n): n \in Nat }</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>S</code> must be a set.
Apalache flags a static type error, if <code>S</code> is not a set.</p>
<p>TLC raises a model checking error, when it meets <code>Seq(S)</code>, as <code>Seq(S)</code> is
infinite. You can override <code>Seq(S)</code> with its bounded version <code>BSeq(S, n)</code>
for some <code>n</code>. See: <a href="https://groups.google.com/g/tlaplus/c/sYx_6e3YyWk/m/4CnwPqIVAgAJ">Overriding Seq in TLC</a>.</p>
<p>Apalache does not support <code>Seq(S)</code> yet. As a workaround, you can manually
replace <code>Seq(S)</code> with <code>BSeq(S, n)</code> for some constant <code>n</code>.  See the progress in
<a href="https://github.com/informalsystems/apalache/issues/314">Issue 314</a>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Seq({1, 2, 3})
    \* The infinite set
      { &lt;&lt;&gt;&gt;,
        &lt;&lt;1&gt;&gt;, &lt;&lt;2&gt;&gt;, &lt;&lt;3&gt;&gt;,
        &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;,
            &lt;&lt;2, 1&gt;&gt;, &lt;&lt;2, 2&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 1&gt;&gt;, &lt;&lt;3, 2&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
        ...
      }
</code></pre>
<p><strong>Example in Python:</strong> We cannot construct an infinite set in Python. However,
we could write an iterator that enumerates the sequences in <code>Seq(S)</code>
till the end of the universe.</p>
<h1><a class="header" href="#user-defined-operators-and-recursive-functions" id="user-defined-operators-and-recursive-functions">User-defined operators and recursive functions</a></h1>
<p><em>Like macros, to do a lot of things in one system step...</em></p>
<p>User-defined operators in TLA+ may be confusing. At first, they look like
functions in programming languages. (Recall that <a href="lang/./functions.html">TLA+
functions</a> are more like dictionaries or hash maps, not
functions in PL.) Then you realize that operators such as <code>Init</code> and <code>Next</code> are
used as logic predicates. However, large specifications often contain operators
that are not predicates, but in fact are similar to pure functions in
programming languages: They are computing values over the system state but pose
no constraints over the system states. On top of that, there are <a href="lang/./user/recursive-functions.html">Recursive
functions</a> that syntactically looks very similar to
operators.</p>
<p>Recently, Leslie Lamport has extended the syntax of TLA+ operators in <a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf">TLA+
version 2</a>, which supports recursive operators and lambda operators.  The
operator syntax that is described in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying Systems</a> describes TLA+
version 1. This page summarizes the syntax of user-defined operators in
versions 1 and 2.</p>
<p><strong>Short digression</strong>. The most important thing to understand about user-defined
operators is that they are normally used inside <code>Init</code> and <code>Next</code>. While the
operator <code>Init</code> describes the initial states, the operator <code>Next</code> describes a
single step of the system.  That is, these two operators are describing the
initial states and the possible transitions of the system, respectively. They
do not describe the whole system computation.  Most of the time, we are writing
<em>canonical specifications</em>, which are written in temporal logic as <code>Init /\ [][Next]_vars</code>. Actually, you do not have to understand temporal logic, in
order to write canonical specifications. A canonical specification is saying:
(1) Initialize the system as <code>Init</code> prescribes, and (2) compute system
transitions as <code>Next</code> prescribes. It also allows for stuttering, but this
belongs to <a href="http://lamport.azurewebsites.net/tla/advanced.html?back-link=user-operators.html">Advanced topics</a>.</p>
<p>After the digression, you should now see that user-defined operators in TLA+
are (normally) describing a single step of the system. Hence, they should be
terminating. That is why user operators are often understood as macros.  The
same applies to <a href="lang/./user/recursive-operators.html">Recursive operator definitions</a>. They have to
terminate within a single system step.</p>
<p><strong>Quirks of TLA+ operators.</strong> Below we summarize features of
user-defined operators that you would probably find unexpected:</p>
<ol>
<li>
<p>Some operators are used as predicates and some are used to compute
values (<em>√† la pure</em>).</p>
</li>
<li>
<p>Operators may accept other operators as parameters. Such operators are
called <a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a>.</p>
</li>
<li>
<p>Although operators may be passed as parameters, they are not first-class
citizens in TLA+. For instance, an operator cannot be returned as a result of
another operator. Nor can an operator be assigned to a variable (only the result
of its application may be assigned to a variable).</p>
</li>
<li>
<p>Operators do not support <a href="https://en.wikipedia.org/wiki/Currying">Currying</a>. That is, you can only apply an operator
by providing values for all of its expected arguments.</p>
</li>
<li>
<p>Operators can be nested. However, nested operators require a slightly
different syntax. They are defined with LET-IN definitions.</p>
</li>
</ol>
<p><strong>Details about operators.</strong> We go in detail about different kinds of operators
and recursive functions below:</p>
<ul>
<li>
<p><a href="lang/./user/top-level-operators.html">Top-level operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/let-in.html">LET-IN definitions</a></p>
</li>
<li>
<p><a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/lambdas.html">Anonymous operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/recursive-operators.html">Recursive operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/local-operators.html">Local operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/recursive-functions.html">Recursive functions</a></p>
</li>
</ul>
<h1><a class="header" href="#top-level-operator-definitions" id="top-level-operator-definitions">Top-level operator definitions</a></h1>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h2><a class="header" href="#quick-example" id="quick-example">Quick example</a></h2>
<p>Here is a quick example of a top-level user operator (which has to be defined
in a module) and of its application:</p>
<pre><code class="language-tla">----------------------- MODULE QuickTopOperator -------------------------------
...
Abs(i) == IF i &gt;= 0 THEN i ELSE -i
...
B(k) == Abs(k)
===============================================================================
</code></pre>
<p>As you most probably guessed, the operator <code>Abs</code> expects one argument <code>i</code>.
Given an integer <code>j</code>, then the result of computing <code>Abs(j)</code> is the absolute
value of <code>j</code>. The same applies, when <code>j</code> is a natural number or a real number.</p>
<h2><a class="header" href="#syntax-of-operator-definitions" id="syntax-of-operator-definitions">Syntax of operator definitions</a></h2>
<p>In general, operators of <code>n</code> arguments are
defined as follows:</p>
<pre><code class="language-tla">\* an operator without arguments (nullary)
Opa0 == body_0

\* an operator of one argument (unary)
Opa1(param1) == body_1

\* an operator of two arguments (binary)
Opa2(param1, param2) == body_2
...
</code></pre>
<p>In this form, the operator arguments are not allowed to be operators. If you want
to receive an operator as an argument, see the syntax of <a href="lang/user/./higher-order-operators.html">Higher-order operators</a>.</p>
<p>Here are concrete examples of operator definitions:</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
...

ABSOLUTE_ZERO_IN_CELCIUS ==
    -273

Fahrenheit2Celcius(t) ==
    (t - 32) * 10 / 18

Max(s, t) ==
    IF s &gt;= t THEN s ELSE t
...
===============================================================================
</code></pre>
<p><em>What is their arity (number of arguments)?</em></p>
<p>If you are used to imperative languages such as Python or Java, then you are
probably surprised that operator definitions do not have any <code>return</code>
statement. The reason for that is simple: TLA+ is not executed on any hardware.
To understand how operators are evaluated, see the semantics below.</p>
<h2><a class="header" href="#syntax-of-operator-applications" id="syntax-of-operator-applications">Syntax of operator applications</a></h2>
<p>Having defined an operator, you can apply it inside another operator as follows
(in a module):</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
VARIABLE fahrenheit, celcius
\* skipping the definitions of
\* ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius, and Max
...

UpdateCelcius(t) ==
    celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(t))

Next ==
    /\ fahrenheit' \in -1000..1000
    /\ UpdateCelcius(fahrenheit')
...
===============================================================================
</code></pre>
<p>In the above example, you see examples of four operator applications:</p>
<ol>
<li>
<p>The nullary operator <code>ABSOLUTE_ZERO_IN_CELCIUS</code> is applied without any
arguments, just by its name. Note how a nullary operator does not require
parentheses <code>()</code>. Yet another quirk of TLA+.</p>
</li>
<li>
<p>The one-argument operator Fahrenheit2Celcius is applied to <code>t</code>,
which is a parameter of the operator <code>UpdateCelcius</code>.</p>
</li>
<li>
<p>The two-argument operator <code>Max</code> is applied to <code>ABSOLUTE_ZERO_IN_CELCIUS</code>
and <code>Fahrenheit2Celcius(t)</code>.</p>
</li>
<li>
<p>The one-argument operator <code>UpdateCelcius</code> is applied to <code>fahrenheit'</code>,
which is the value of state variable <code>fahrenheit</code> in the next state of the
state machine. TLA+ has no problem applying the operator to <code>fahrenheit'</code> or
to <code>fahrenheit</code>.</p>
</li>
</ol>
<p>Technically, there are more than four operator applications in our example.
However, all other operators are the <a href="lang/user/./standard-operators.html">standard
operators</a>. We do not focus on them here.</p>
<p><strong>Note on the operator order.</strong> As you can see, we are applying operators after
they have been defined in a module. This is a general rule in TLA+: A name can
be only referred to, if it has been defined in the code before. TLA+ is not
the first language to impose that rule. For instance, <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal</a> had it too.</p>
<p><strong>Note on shadowing.</strong> TLA+ does not allow you to use the same name as an
operator parameter, if it has been defined in the context of the operator
definition. For instance, the following is not allowed:</p>
<pre><code class="language-tla">-------------------------- MODULE NoShadowing ---------------------------------
VARIABLE x

\* the following operator definition produces a semantic error:
\* the parameter x is shadowing the state variable x
IsZero(x) == x = 0
===============================================================================
</code></pre>
<p>There are a few tricky cases, where shadowing can actually happen, e.g., see
the operator <code>dir</code> in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SlidingPuzzles/SlidingPuzzles.tla">SlidingPuzzles</a>. However, we recommend to keep things
simple and avoid shadowing at all.</p>
<h2><a class="header" href="#semantics-of-operator-application" id="semantics-of-operator-application">Semantics of operator application</a></h2>
<p>Precise treatment of operator application is given on page 320 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying
Systems</a>. In a nutshell, operator application in TLA+ is a <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_macro_expansion">Call by macro
expansion</a>, though it is a bit smarter: It does not blindly mix names from the
operator's body and its application context. For example, the following
semantics by substitution is implemented in the <a href="https://apalache.informal.systems">Apalache</a> model checker.</p>
<p>Here we give a simple explanation for non-recursive operators. Consider the
definition of an <code>n</code>-ary operator <code>A</code> and its application in the definition
of another operator <code>B</code>:</p>
<pre><code class="language-tla">A(p_1, ..., p_n) == body_of_A
...
B(p_1, ..., p_k) ==
    ...
    A(e_1, ..., e_n)
    ...
</code></pre>
<p>The following three steps allow us to replace application of the operator <code>A</code>
in <code>B</code>:</p>
<ol>
<li>Change the names in the definition of <code>A</code> in such a way such they do not
clash with the names in <code>B</code> (as well as with other names that may be used in
<code>B</code>). This is the well-known technique of <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> in programming
languages. This may also require renaming of the parameters <code>p_1, ..., p_n</code>.
Let the result of alpha conversion be the following operator:</li>
</ol>
<pre><code class="language-tla">uniq_A(uniq_p_1, ..., uniq_p_n) == body_of_uniq_A
</code></pre>
<ol>
<li>
<p>Substitute the expression <code>A(e_1, ..., e_n)</code> in the definition of <code>B</code> with
<code>body_of_uniq_A</code>.</p>
</li>
<li>
<p>Substitute the names <code>uniq_p_1, ..., uniq_p_n</code> with the expressions <code>e_1, ..., e_n</code>, respectively.</p>
</li>
</ol>
<p>The above transformation is usually called <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a>.</p>
<p><strong>Example.</strong> Let's go back to the module <code>FandC</code>, which we considered above. By
applying the substitution approach several times, we transform <code>Next</code> in
several steps as follows:</p>
<p>First, by substituting the body of <code>UpdateCelsius</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(fahrenheit'))
</code></pre>
<p>Second, by substituting the body of <code>Max</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= Fahrenheit2Celcius(fahrenheit')
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE Fahrenheit2Celcius(fahrenheit')
</code></pre>
<p>Third, by substituting the body of <code>Fahrenheit2Celcius</code> (twice):</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= (fahrenheit' - 32) * 10 / 18
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE (fahrenheit' - 32) * 10 / 18
</code></pre>
<p>You could notice that we applied beta reduction syntactically from top to
bottom, like peeling an onion. We could do it in another direction: First
starting with the application of <code>Fahrenheit2Celcius</code>. This actually does not
matter, as long as our goal is to produce a TLA+ expression that is free of
user-defined operators. For instance, <a href="https://apalache.informal.systems">Apalache</a> applies <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> and
<a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a> to remove user-defined operator and then translates the TLA+
expression to SMT.</p>
<h1><a class="header" href="#let-in-operator-definitions" id="let-in-operator-definitions">LET-IN operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#higher-order-operator-definitions" id="higher-order-operator-definitions">Higher-order operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#anonymous-operator-definitions" id="anonymous-operator-definitions">Anonymous operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#recursive-operator-definitions" id="recursive-operator-definitions">Recursive operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#local-operator-definitions" id="local-operator-definitions">Local operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#recursive-functions-1" id="recursive-functions-1">Recursive functions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#idiomatic-tla" id="idiomatic-tla">Idiomatic TLA+</a></h1>
<p><strong>Authors:</strong> Shon Feder, Igor Konnov + (who likes to contribute?)</p>
<p><em>This document is under construction.
If you like to contribute, open a pull request.</em></p>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>In this document, we collect specification idioms that aid us in writing TLA+
specifications that are:</p>
<ol>
<li>understood by distributed system engineers,</li>
<li>understood by verification engineers, and</li>
<li>understood by automatic analysis tools such as the Apalache model checker.</li>
</ol>
<p>If you believe, that the above points are contradictory when put together, it is
to some extent true. TLA+ is an extremely general specification language. As a
result, it is easy to write a short specification that leaves a human reader
puzzled . It is even easier to write a (syntactically correct) specification that
turns any program trying to reason about TLA+ to dust.</p>
<p>Nevertheless, we find TLA+ quite useful when writing concise specifications of
distributed protocols at <a href="https://informal.systems">Informal Systems</a>. Other specification languages --
especially, those designed for software verification -- would require us to
introduce unnecessary book-keeping details that would both obfuscate the
protocols and make their verification harder. However, we do not always need
<em>&quot;all the power of mathematics&quot;</em>, so we find it useful to introduce additional
structure in TLA+ specifications.</p>
<p>Below, we summarize the idioms that help us in maintaining that structure.  As
a bonus, these idioms usually aid the Apalache model checker in analyzing the
specifications. Our idioms are quite likely different from the original ideas
of <a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (the author of TLA+).
So it is useful to read Lamport's <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>. Importantly, these are
<em>idioms</em>, not rules set in stone. If you believe that one of those idioms
does not work for you in your specific setting, don't follow it.</p>
<p>If this is the first page where you encounter the word &quot;TLA+&quot;, we do not
recommend that you continue to read the material. It is better to start with <a href="http://lamport.azurewebsites.net/video/videos.html">The TLA+
Video Course</a> by Leslie
Lamport.  Once you have understood the basics and tried the language, it makes
sense to ask the question: &quot;How do I write a specification that other people
understand?&quot;.  We believe that many TLA+ users reinvent rules that are
similar to our idioms.  By providing you with a bit of guidance, we hope to
reduce your discomfort when learning more advanced TLA+.</p>
<h2><a class="header" href="#the-idioms" id="the-idioms">The idioms</a></h2>
<p><strong>Idiom 0:</strong>
<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the minimum</a> üîã</p>
<p><strong>Idiom 1:</strong> <a href="idiomatic/001assignments.html">Update state variables with assignments</a> üìÖ</p>
<p><strong>Idiom 2:</strong> <a href="idiomatic/002primes.html">Apply primes only to state variables</a> üìå</p>
<p><strong>Idiom 3:</strong> Isolate updates to VARIABLES üëª</p>
<p><strong>Idiom 4:</strong> Isolate non-determinism in actions üîÆ</p>
<p><strong>Idiom 5:</strong> Introduce pure operators üôà</p>
<p><strong>Idiom 6:</strong> Introduce a naming convention for operator parameters üõÇ</p>
<p><strong>Idiom 7:</strong> Use Boolean operators in actions, not <code>IF-THEN-ELSE</code> üôÖ</p>
<p><strong>Idiom 8:</strong> <code>CHOOSE</code> smart, prefer <code>\E</code> üíÇ‚Äç‚ôÇ</p>
<p><strong>Idiom 9:</strong> Do not over-structure üî¨</p>
<p><strong>Idiom 10:</strong> Do not over-modularize ü¶Ü</p>
<p><strong>Idiom 11:</strong> Separate normal paths from error paths. ‚ö°</p>
<p><strong>Idiom 12:</strong> Do you really need those nice recursive operators? üåÄ</p>
<p><strong>Idiom 13:</strong> Do you really need set cardinalities? üçï</p>
<p><strong>Idiom 14:</strong> Do you really need integers? üî¢</p>
<h1><a class="header" href="#idiom-0-keep-state-variables-to-the-minimum" id="idiom-0-keep-state-variables-to-the-minimum">Idiom 0: Keep state variables to the minimum</a></h1>
<p>In imperative programming, it is common to use mutable variable assignments liberally, but to exercise caution whenever mutable variables have a global scope. In TLA+, mutable variables are always global, so it is important to use them carefully and in a way that accurately reflects the global state of the system you are specifying.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p><em>A good TLA+ specification minimizes the computation state and makes it visible</em>.</p>
<p>TLA+ does not have special syntax for variable assignment.  For a good
reason. The power of TLA+ is in writing constraints on variables rather than in
writing detailed commands. If you have been writing in languages such as C, C++,
Java, Python, your first reflex would be to define a variable to store the
intermediate result of a complex computation.</p>
<p>In programming languages, we introduce temporary variables for several reasons:</p>
<ol>
<li>To avoid repetitive computations of the same expression,</li>
<li>To break down a large expression into a series of smaller expressions,</li>
<li>To make the code concise.</li>
</ol>
<p>Point 1 is a non-issue in TLA+, as it is mostly executed in the reader's brain,
and people are probably less efficient in caching expressions than computers.
Points 2 and 3 can be nicely addressed with LET-definitions in TLA+. Hence,
there is no need for auxiliary variables.</p>
<p>Usually, we should minimize the specification state, that is, the scope of the data
structures that are declared with <code>VARIABLES</code>. It does not mean that one variable
is always better than two. It means that what is stored in <code>VARIABLES</code> should be
absolutely necessary to describe the computations or the observed properties.</p>
<h2><a class="header" href="#advantages" id="advantages">Advantages</a></h2>
<p>By avoiding auxiliary state variables, we localize the updates to the state.
This improves specification readability. It also helps the tools, as large parts
of the specification become deterministic.</p>
<h2><a class="header" href="#disadvantages" id="disadvantages">Disadvantages</a></h2>
<p>Sometimes, we have to expose the internals of the computation. For instance,
if we want to closely monitor the values of the computed expressions, when using
the specification for model-based testing.</p>
<p>Sometimes, we have to break this idiom to make the specification more readable. Here is an example by Markus Kuppe. The specification of <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueueSplit.tla#L16-L51">BlockingQueue</a> that has one more variable is easier to read than <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueue.tla">the original specification</a> with a minimal number of variables.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Consider the following implementation of <a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble sort</a> in Python:</p>
<pre><code class="language-python">    my_list = [5, 4, 3, 8, 1]
    finished = False
    my_list_len = len(my_list)  # cache the length
    while not finished:
        finished = True
        if my_list_len &gt; 0:
            prev = my_list[0]       # save the first element to use in the loop
        for i in range(1, my_list_len):
            current = my_list[i]
            if prev &lt;= current:
                # save current for the next iteration
                prev = current
            else:
                # swap the elements
                my_list[i - 1] = current
                my_list[i] = prev
                finished = False
</code></pre>
<p>Notice that we have introduced three local variables to optimize the code:</p>
<ul>
<li><code>my_list_len</code> to cache the length of the list,</li>
<li><code>prev</code> to cache the previously accessed element of the list,
in order to minimize the number of list accesses,</li>
<li><code>current</code> to cache the iterated element of the list.</li>
</ul>
<p>In TLA+, one usually does not introduce local variables for the intermediate
results of the computation, but rather introduces variables to represent the
essential part of the algorithm state. (While we have spent some time on code
optimization, we might have missed the fact that our sorting algorithm is not
as good as <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a>.) In the above example, the essential variables are
<code>finished</code> and <code>my_list</code>.</p>
<p>Compare the above code to (a slightly more abstract) <a href="idiomatic/./example/bubble.tla">bubble sort in
TLA+</a>:</p>
<pre><code class="language-tla">EXTENDS Integers, Sequences

in_list == &lt;&lt;5, 4, 3, 8, 1&gt;&gt;
VARIABLES my_list, finished

Init ==
    /\ my_list = in_list
    /\ finished = FALSE

IsSorted(lst) ==
    \A i \in DOMAIN lst \ {1}:
        lst[i - 1] &lt;= lst[i]

WhenSorted ==
    /\ IsSorted(my_list)
    /\ finished' = TRUE
    /\ UNCHANGED my_list

WhenUnsorted ==
    /\ \E i \in DOMAIN my_list \ {1}:
        /\ my_list[i - 1] &gt; my_list[i]
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
    /\ finished' = FALSE

Next ==
    IF finished
    THEN UNCHANGED &lt;&lt;my_list, finished&gt;&gt;
    ELSE WhenSorted \/ WhenUnsorted

</code></pre>
<p>Our TLA+ code contains only two state variables: <code>my_list</code> and <code>finished</code>.
Other variables are introduced by quantifiers (e.g., <code>\E i \in ...</code>).
The state variables are not updated in the sense of programming languages.
Rather, one writes constraints over unprimed and primed versions, e.g.:</p>
<pre><code class="language-tla">        ...
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
</code></pre>
<p>Of course, one can introduce aliases for intermediate expressions, for instance,
by using let-definitions:</p>
<pre><code class="language-tla">        ...
        LET prev == my_list[i - 1]
            current == my_list[i]
        IN
        /\ prev &gt; current
        /\ my_list' = [my_list EXCEPT ![i - 1] = current, ![i] = prev]
</code></pre>
<p>However, the let-definitions are not variables, they are just aliases for more
complex expressions. Importantly, one cannot update the value of an expression
that is defined with a let-definition. In this sense, TLA+ is similar to
functional languages, where side effects are carefully avoided and minimized.</p>
<p>In contrast to functional languages, the value of TLA+ is not in computing
the result of a function application, but in producing sequences of states
(called behaviors). Hence, some parts of a useful TLA+ specification should have side effects to record the states.</p>
<h1><a class="header" href="#idiom-1-update-state-variables-with-assignments" id="idiom-1-update-state-variables-with-assignments">Idiom 1: Update state variables with assignments</a></h1>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The idiom &quot;<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the
minimum</a>&quot; tells us to store the minimum
necessary state variables. By following this idiom, we develop
the specification by writing constraints over the primed variables.</p>
<p>TLA+ comes with a great freedom of expressing constraints over variables.
While we love TLA+ for that freedom, we believe that constraints over primed
variables are sometimes confusing.
TLA+ uses the same glyph, <code>=</code> for three separate purposes: assignment, asserting equality, and binding variables. But these are very different operations and have different semantics.</p>
<h3><a class="header" href="#issue-1" id="issue-1">Issue 1</a></h3>
<p><strong>tl;dr:</strong> Use <code>:=</code> (supplied by the <code>Apalache.tla</code> module) instead of <code>=</code> for assignment.</p>
<p>Consider the expression:</p>
<pre><code class="language-tla">  x' = x + 1
</code></pre>
<p>It is all clear here. The value of <code>x</code> in the next states (there may be many)
is equal to <code>val(x)+1</code>, where <code>val(x)</code> is the value of <code>x</code> in the current
state.</p>
<p>Wait. Is it clear? What if that expression was just the first line of the following
expression:</p>
<pre><code class="language-tla">  x' = x + 1
    =&gt; x' = 3
</code></pre>
<p>This says, &quot;if <code>x'</code> is equal to <code>x + 1</code>, then assign the value of <code>3</code> to <code>x'</code> in the next state&quot;, which
implies that <code>x'</code> may receive a value from the set:</p>
<pre><code class="language-tla">  { 3 } \union { y \in Int: y /= val(x) + 1 }
</code></pre>
<p>But maybe the author of that specification just made a typo and never
meant to put the implication <code>=&gt;</code> in the first place. Actually, the intended
specification looks like follows:</p>
<pre><code class="language-tla">  x' = x + 1
    \/ x' = 3
</code></pre>
<p>We believe that it is helpful to label the expressions that intend to denote the
values of the state variables in the next state. Apalache introduces the infix
operator <code>:=</code> in the module <code>Apalache.tla</code> for that purpose:</p>
<pre><code class="language-tla">  x' := x + 1
    \/ x' := 3
</code></pre>
<p>Hence, it would be obvious in our motivating example that the author made a typo:</p>
<pre><code class="language-tla">  x' := x + 1
    =&gt; x' := 3
</code></pre>
<p>because the assignment <code>x' := x + 1</code> does not express a boolean value
and so cannot be the antecedent of the conditional.</p>
<h3><a class="header" href="#issue-2" id="issue-2">Issue 2</a></h3>
<p><strong>tl;dr:</strong> Use existential variables with the <code>:=</code> operator for non-deterministic assignment.</p>
<p>Another common use of primed variables is to select the next value of a variable
from a set:</p>
<pre><code class="language-tla">  x' \in { 1, 2, 3 }
</code></pre>
<p>This expression can be rewritten as an equivalent one:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' = y
</code></pre>
<p>Which one to choose? The first one is more concise. The second one highlights
the important effect, namely, non-deterministic choice of the next value of <code>x</code>.
When combined with the operator <code>:=</code>, the effect of non-deterministic choice is
clearly visible:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' := y
</code></pre>
<p>In fact, every constraint over primes can be translated into the existential form.
For instance, consider the expression:</p>
<pre><code class="language-tla">  x' * x' = 4
</code></pre>
<p>It can be written as:</p>
<pre><code class="language-tla">  \E y \in Int:
    /\ y * y = 4
    /\ x' := y
</code></pre>
<h2><a class="header" href="#advantages-1" id="advantages-1">Advantages</a></h2>
<ul>
<li>
<p>The reader clearly sees the writer's intention about the updates
to the primed variables.</p>
</li>
<li>
<p>Non-determinism is clearly isolated in existential choice: <code>\E y \in S: x' := y</code>.
If there is no existential choice, the assignment is deterministic.</p>
</li>
<li>
<p>When the existential form is used, the range of the values is clearly indicated.
This is in contrast to the negated form such as: <code>~(x' = 10)</code>.</p>
</li>
<li>
<p>TLC treats the expressions of the form <code>x' = e</code> and <code>x' \in S</code> as assignments,
as long as <code>x'</code> is not bound to a value.</p>
</li>
<li>
<p>Apalache uses assignments to decompose the specification into smaller pieces.
Although Apalache tries to find assignments automatically, it often has to choose
from several expressions, some of them may be more complex than the others. By using
the <code>:=</code> operator, Apalache gets unambiguous instructions about when assignment is taking
place</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-1" id="disadvantages-1">Disadvantages</a></h2>
<ul>
<li>Replacing <code>x' \in S</code> with <code>\E y \in S: x' := y</code> makes the specification a bit larger.</li>
</ul>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>The following example <a href="idiomatic/./example/deliver.tla">deliver.tla</a> demonstrates how
one can clearly mark assignments using the <code>:=</code> operator.</p>
<pre><code class="language-tla">------------------------------ MODULE deliver ----------------------------------
(*
 * A simple specification of two processes in the network: sender and receiver.
 * The sender sends messages in sequence. The receiver may receive the sent
 * messages out of order, but delivers them to the client in order.
 *
 * Igor Konnov, 2020
 *)
EXTENDS Integers, Apalache

VARIABLES
    sentSeqNo,      \* the sequence number of the next message to be sent
    sent,           \* the messages that are sent by the sender
    received,       \* the messages that are received by the receiver
    deliveredSeqNo  \* the sequence number of the last delivered message
(* We assign to the unprimed state variables to set their initial values. *)
Init ==
    /\ sentSeqNo := 0
    /\ sent := {}
    /\ received := {}
    /\ deliveredSeqNo := -1

(* Subsequent assignments are all to primed variables, designating changed values
   after state transition. *)
Send ==
    /\ sent' := sent \union {sentSeqNo}
    /\ sentSeqNo' := sentSeqNo + 1
    /\ UNCHANGED &lt;&lt;received, deliveredSeqNo&gt;&gt;

Receive ==
    (* We make the nonderministic assignment explicit, by use of existential quantification *)
    /\ \E msgs \in SUBSET (sent \ received):
        received' := received \union msgs
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, deliveredSeqNo&gt;&gt;

Deliver ==
    /\ (deliveredSeqNo + 1) \in received
    /\ deliveredSeqNo' := deliveredSeqNo + 1
        \* deliver the message with the sequence number deliveredSeqNo'
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, received&gt;&gt;

Next ==
    \/ Send
    \/ Receive
    \/ Deliver

Inv ==
    (deliveredSeqNo &gt;= 0) =&gt; deliveredSeqNo \in sent
================================================================================
</code></pre>
<h1><a class="header" href="#idiom-2-apply-primes-only-to-state-variables" id="idiom-2-apply-primes-only-to-state-variables">Idiom 2: Apply primes only to state variables</a></h1>
<p>(<em>Until you learn how prime actually works!</em>)</p>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>In many formal languages, the notation <code>x'</code> denotes the value that a variable
<code>x</code> has after the system has fired a transition. The reason for having both <code>x</code>
and <code>x'</code> is that the transitions are often described as relations over unprimed
and primed variables, e.g., <code>x' = x+1</code>. It is easy to extend this idea to
vectors of variables, but for simplicity we will use only one variable.</p>
<p>TLA+ goes further and declares prime (<code>'</code>) as an operator! This operator distributes over
any state variables in the scope of its application. For example, assume that we
evaluate a TLA+ expression <code>A</code> over <code>x</code> and <code>x'</code>, and <code>v[i]</code> and <code>v[i+1]</code> are
meant to be the values of <code>x</code> in the ith state and i+1-th state, respectively.
Then <code>x</code> is evaluated to <code>v[i]</code> and <code>x'</code> is evaluated to <code>v[i+1]</code>.  Naturally,
<code>x + 3</code> is evaluated to <code>v[i] + 3</code>, whereas <code>x' + 4</code> is evaluated to <code>v[i+1] + 4</code>. We can go further and evaluate <code>(x + 4)'</code>, which can be rewritten as <code>x' + 4</code>.</p>
<p>Intuitively, there is nothing wrong with the operator &quot;prime&quot;. However, you
have to understand this operator well, in order to use it right. For starters, check
the warning by Leslie Lamport in <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a> on page 82. The following
example illustrates the warning:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3 ------------------------------------
(* Model a system of three processes, each one equipped with a logical clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

\* a shortcut to refer to the clock of the process that is taking the step
MyClock == clocks[turn]
\* a shortcut to refer to the processes that are not taking the step
Others == DOMAIN clocks \ {turn}

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes (the section Example shows a better way)
    /\ \E f \in [1..3 -&gt; Int]:
        clocks' := f
    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<p>Did you spot a problem in the above example? If not, check these lines again:</p>
<pre><code class="language-tla">    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
</code></pre>
<p>The code does not match the comment. By writing <code>MyClock'</code>, we get
<code>(clocks[turn])'</code> that is equivalent to <code>clocks'[turn']</code>. So our constraint
says: Increment the clock of the process that is taking the next step.  By
looking at the next constraint, we can see that <code>Next</code> can never be evaluated
to true (a logician would say that <code>Next</code> is &quot;unsatisfiable&quot;):</p>
<pre><code class="language-tla">    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
</code></pre>
<p>Our intention was to make the specification easier to read, but instead we have
introduced a deadlock in the system. In a larger specification, this bug would be
much harder to find.</p>
<p>We recommend to follow this simple rule: <em>Apply primes only to state variables</em></p>
<p>Can we remove the &quot;prime&quot; operator altogether and agree to use <code>x</code> and <code>x'</code> as
names of the variables? Not really. More advanced features of TLA+ require this
operator.  In a nutshell, TLA+ is built around the idea of refinement, that is,
replacing an abstract specification with a more detailed one. Concretely, this
idea is implemented by module instances in TLA+. It often happens that
refinement requires us to replace a state variable of the abstract
specification with an operator of the detailed specification.  Voil√†. You have
to apply prime to an expression. For the details,
see Chapter 5 and pages 312-313 of <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>.</p>
<h2><a class="header" href="#advantages-2" id="advantages-2">Advantages</a></h2>
<ul>
<li>
<p>It is easy to see, whether the specification author intended to talk about
the variables in the next state or about the variable in the current state.</p>
</li>
<li>
<p>It is harder to make an unexpected substitution mistake, as in the above
example.</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-2" id="disadvantages-2">Disadvantages</a></h2>
<ul>
<li>Sometimes, the operator &quot;prime&quot; helps us in avoiding code duplication.
For instance, you can write a state invariant <code>Inv</code> and later evaluate it
against a next state by simply writing <code>Inv'</code>. However, you have to be
careful about propagation of primes in <code>Inv</code>.</li>
</ul>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<p>A better version of the <code>clocks</code> example applies prime only to state variables.
By doing so, we notice that the specification can be further simplified:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3_2 ----------------------------------
(* Model a system of three processes, each one equipped with a digital clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes
    /\ clocks' :=
        [p \in 1..3 |-&gt;
            IF p = turn THEN clocks[turn] + 1 ELSE clocks[p]]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<h1><a class="header" href="#adr-002-types-and-type-annotations" id="adr-002-types-and-type-annotations">ADR-002: types and type annotations</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Shon Feder, Igor Konnov, Jure Kukovec</td><td align="right">2</td></tr>
</tbody></table>
<p>This is a follow up of
<a href="https://github.com/informalsystems/apalache/blob/unstable/docs/internal/rfc/001rfc-types.md">RFC-001</a>, which discusses
plenty of alternative solutions. In this <strong>ADR-002</strong>, we fix one solution that seems to be most suitable. The
interchange format for the type inference tools will be discussed in a separate ADR.</p>
<ol>
<li>How to write types in TLA+ (Type System 1).</li>
<li>How to write type annotations (as a user).</li>
</ol>
<p>This document assumes that one can write a simple type checker that computes the types of all expressions based on the
annotations provided by the user. Our work-in-progress type checker is using these type annotations. The new type
checker can be called with <code>apalache typecheck</code> command. Note that the new type checker has not been integrated with the
model checker yet.</p>
<p>In contrast, the <a href="https://github.com/informalsystems/apalache/tree/types">type inference algorithm</a> by @Kukovec is fully
automatic and thus it eliminates the need for type annotations.
(Jure's algorithm is using Type System 1 too.) However, system engineers often want to write type annotations and
quickly check types when writing TLA+ specifications. This document is filling this gap.</p>
<h2><a class="header" href="#1-how-to-write-types-in-tla" id="1-how-to-write-types-in-tla">1. How to write types in TLA+</a></h2>
<h3><a class="header" href="#11-type-grammar-type-system-1-or-ts1" id="11-type-grammar-type-system-1-or-ts1">1.1. Type grammar (Type System 1, or TS1)</a></h3>
<p>We simply write types as strings that follow the type grammar:</p>
<pre><code>T ::= typeConst | typeVar | Bool | Int | Str | T -&gt; T | Set(T) | Seq(T) |
      &lt;&lt;T, ..., T&gt;&gt; | [h_1: T, ..., h_k: T] | (T, ..., T) =&gt; T | (T)
typeConst ::= &lt;an identifier that matches [A-Z_][A-Z0-9_]*&gt;
typeVar ::= &lt;a single letter from [a-z]&gt;
</code></pre>
<p>In this grammar, <code>h_1</code>,...,<code>h_k</code> are field names. The rule <code>T -&gt; T</code> defines a
function, while the rule <code>(T, ..., T) =&gt; T</code> defines an operator.  Importantly, a
multi-argument function always receives a tuple, e.g., <code>&lt;&lt;Int, Bool&gt;&gt; -&gt; Int</code>,
whereas a single-argument function receives the type of its argument, e.g., <code>Int -&gt; Int</code>.  An operator always has the types of its arguments inside <code>(...)</code>,
e.g., <code>(Int, Bool) =&gt; Int</code> and <code>() =&gt; Bool</code>. The arrow <code>-&gt;</code> is right-associative,
e.g., <code>A -&gt; B -&gt; C</code> is understood as <code>A -&gt; (B -&gt; C)</code>, which is consistent with
programming languages. If you like to change the priority of <code>-&gt;</code>, use parentheses, as usual.
For example, you may write <code>(A -&gt; B) -&gt; C</code>.</p>
<p>If a type <code>T</code> contains a type variable, e.g., <code>a</code>, then <code>T</code> is a
polymorphic type, in which <code>a</code> can be instantiated with a monotype (a
variable-free term). Type variables are useful for describing the types of
polymorphic operators. A type constant should be understood as a type we don't
know and we don't want to know, that is, an uninterpreted type. Type constants
are useful for fixing the types of CONSTANTS and using them later in a
specification. Two different type constants correspond to two different -- yet
uninterpreted -- types. If you know <a href="https://github.com/Z3Prover/z3">Microsoft
Z3</a>, a type constant can be understood as an
uninterpreted sort in SMT. Essentially, values of an uninterpreted type can
be only checked for equality.</p>
<p>Assume that notation <code>e &lt;: T</code> means that an expression <code>e</code> has type <code>T</code>.
(More precisely, <code>T</code> is a supertype of the type of <code>e</code>.)
The following examples demonstrate the use of the type grammar:</p>
<ul>
<li><code>x</code> is an integer: <code>x &lt;: &quot;Int&quot;</code>.</li>
<li><code>f</code> is a function from an integer to an integer: <code>f &lt;: &quot;Int -&gt; Int&quot;</code>.</li>
<li><code>f</code> is a function from a set of integers to a set of integers:
<code>f &lt;: &quot;Set(Int) -&gt; Set(Int)&quot;</code>.</li>
<li><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string: <code>r &lt;: &quot;[a: Int, b: Str]&quot;</code>.</li>
<li><code>F</code> is a set of functions from a tuple of integers to an integer:
<code>F &lt;: &quot;Set(&lt;&lt;Int, Int&gt;&gt; -&gt; Int)&quot;</code>.</li>
<li><code>Foo</code> is an operator of an integer and of a string that returns an integer:
<code>Foo &lt;: &quot;(Int, Str) =&gt; Int&quot;</code>.</li>
<li><code>Bar</code> is a higher-order operator that takes an operator that takes
an integer and a string and returns an integer, and returns a Boolean:
<code>Bar &lt;: &quot;((Int, Str) =&gt; Int) =&gt; Bool&quot;</code>.</li>
<li><code>Baz</code> is a polymorphic operator that takes two arguments of the same type
and returns a value of the type equal to the types of its arguments:
<code>Baz &lt;: &quot;(a, a) =&gt; a&quot;</code>.</li>
<li><code>Proc</code> and <code>Faulty</code> are sets of the same type:
<code>Proc &lt;: &quot;Set(PID)&quot;</code> and <code>Faulty &lt;: &quot;Set(PID)&quot;</code>.</li>
</ul>
<h3><a class="header" href="#12-discussion" id="12-discussion">1.2. Discussion</a></h3>
<p>Our type grammar presents a minimal type system that, in our understanding,
captures all interesting cases that occur in practice. Obviously, this type
system considers ill-typed some perfectly legal TLA+ values. For instance, we
cannot assign a reasonable type to <code>{1, TRUE}</code>. However, we can assign a
reasonable type to <code>{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1], [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}</code>, a pattern that often occurs in practice, e.g., see
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>.
The type of that set will be <code>Set([type: Str, bal: Int, val: Int])</code>, which is
probably not what you expected, but it is the best type we can actually compute
without having algebraic datatypes in TLA+. It also reminds the user that one
better tests the field <code>type</code> carefully.</p>
<p>Type System 1 is also very much in line with the <a href="https://dblp.org/search?q=Automatic+Verification+of+%7BTLA%7D+%2B+Proof+Obligations+with+%7BSMT%7D+Solvers">type system by Stephan Merz and Hernan Vanzetto</a>
, which is used internally by
<a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a> when translating proof obligations in SMT. We introduce
types for user-defined operators, on top of their types for TLA+ expressions that do not contain user-defined operators.</p>
<p>We expect that this type system will evolve in the future. That is why we call it <strong>Type System 1</strong>. Feel free to
suggest <strong>Type System 2</strong> :-)</p>
<p><strong>Note:</strong> For the above example of a set of records, we are considering to introduce union types. So the type of the set</p>
<pre><code class="language-tla">{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1],
 [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}
</code></pre>
<p>would be something like:</p>
<pre><code class="language-tla">Set([type |-&gt; &quot;1a&quot;], bal |-&gt; 1]
  + [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3])
</code></pre>
<p>The value of the field <code>type</code> would serve as a type tag. However, we would have to fix a set of patterns that turn a
union type into a precise record type. One such pattern is a set comprehension, e.g., <code>{ r \in S: r.type = &quot;1a&quot; }</code>. If
you have suggestions on this line of thought, please let us know.</p>
<h2><a class="header" href="#2-how-to-write-type-annotations-as-a-user" id="2-how-to-write-type-annotations-as-a-user">2. How to write type annotations (as a user)</a></h2>
<p>In the following, we discuss how to annotate different TLA+ declarations.</p>
<p><em>In the previous version of this document, we defined two operators:
<code>AssumeType(_, _)</code> and <code>_ ## _</code>. They are no longer needed as we have introduced [Code annotations][].</em></p>
<h3><a class="header" href="#21-annotating-constants-and-variables" id="21-annotating-constants-and-variables">2.1. Annotating CONSTANTS and VARIABLES</a></h3>
<p>Simply write an annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the declaration of a constant declaration or
a variable. See the following example:</p>
<pre><code class="language-tla">CONSTANT
  \* @type: Int;
  N,
  \* @type: Set(ID);
  Base

VARIABLE
  \* @type: ID;
  x,
  \* @type: Set(ID);
  S
</code></pre>
<p><strong>Why don't we use THEOREMs?</strong> It is tempting to declare the types of variables
as theorems. For example:</p>
<pre><code class="language-tla">THEOREM N &lt;: &quot;Int&quot;
</code></pre>
<p>However, this theorem must be proven. A <em>type inference engine</em> would be able
to infer the type of <code>N</code> and thus state such a theorem. However, with type
assumptions, the user merely states the variable types and the <em>type checker</em>
has a simple job of checking type consistency and finding the types of the
expressions.</p>
<h3><a class="header" href="#22-annotating-operators" id="22-annotating-operators">2.2. Annotating Operators</a></h3>
<p>Again, write a type annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the operator declaration. For example:</p>
<pre><code class="language-tla">\* @type: (a, Seq(a)) =&gt; Bool;
Mem(e, es) ==
    (e \in {es[i]: i \in DOMAIN es})
</code></pre>
<p>Higher-order operators are also easy to annotate:</p>
<pre><code class="language-tla">\* @type: ((a) =&gt; Bool, Seq(a)) =&gt; Int;
Find(Pred(_), es) ==
    IF \E i \in DOMAIN es: Pred(es[i])
    THEN CHOOSE i \in DOMAIN es: Pred(es[i])
    ELSE -1
</code></pre>
<p>The following definition declares a (global) recursive function, not an
operator. However, the annotation syntax is quite similar to that of the
operators (note though that we are using <code>-&gt;</code> instead of <code>=&gt;</code>):</p>
<pre><code class="language-tla">\* @type: Set(a) -&gt; Int;
Card[S \in T] ==
    IF S = {}
    THEN 0
    ELSE LET \* @type: a;
             \* we could also write: &quot;() =&gt; a&quot; instead of just &quot;a&quot;
             one_elem == (CHOOSE x \in S: TRUE)
         IN
         1 + Card[S \ {one_elem}]
</code></pre>
<p>In the definition of <code>Card</code>, we annotated the let-definition <code>one_elem</code> with its type, though any type checker should be
able to compute the type of
<code>one_elem</code> from its context. So the type of <code>one_elem</code> is there for clarification. According to our type grammar, the
type of <code>one_elem</code> should be
<code>() =&gt; a</code>, as <code>one_elem</code> is an operator. It is not obvious from the syntax:
TLA+ blends in nullary operators with other names. We have found that LET-definitions without arguments are so common,
so it is more convenient to write the shorter type annotation, that is, just <code>a</code>.</p>
<h3><a class="header" href="#23-dealing-with-bound-variables" id="23-dealing-with-bound-variables">2.3. Dealing with bound variables</a></h3>
<p>A number of TLA+ operators are defining bound variables. Following <a href="https://lamport.azurewebsites.net/tla/summary.pdf">TLA+
Summary</a>, we list these
operators here (we omit the unbounded quantifiers and temporal quantifiers):</p>
<ul>
<li><code>\A x \in S: P</code></li>
<li><code>\E x \in S: P</code></li>
<li><code>CHOOSE x: P</code></li>
<li><code>{x \in S: P}</code></li>
<li><code>{e: x \in S}</code></li>
<li><code>[x \in S |-&gt; e}</code></li>
</ul>
<p>We do not introduce any special annotation to support these operators. Indeed, they are all introducing bound variables
that range over sets. In most cases, the type checker should be able to extract the element type from a set expression.</p>
<p>However, there are a few pathological cases arising from empty collections. For example:</p>
<pre><code class="language-tla">/\ \E x \in {}: x &gt; 1
/\ f = [x \in {} |-&gt; 2]
/\ z \in DOMAIN &lt;&lt; &gt;&gt;
</code></pre>
<p>Similar typing issues occur in programming languages, e.g., Scala and Java. In these rare cases, you can write an
auxiliary LET-definition to specify the type of the empty collection:</p>
<pre><code class="language-tla">/\ LET \* @type: Set(Int);
       EmptyInts == {}
   IN
   \E x \in EmptyInts: x &gt; 1
/\ LET \* @type: Set(Str);
       EmptyStrings == {}
   IN
   f = [x \in EmptyStrings |-&gt; 2]
/\ LET \* @type: Seq(Int);
       EmptyIntSeq == {}
   IN
   z \in DOMAIN EmptyIntSeq
</code></pre>
<p>The type checker uses the type annotation to refine the type of an empty set
(or, of an empty sequence).</p>
<h2><a class="header" href="#3-example" id="3-example">3. Example</a></h2>
<p>As an example that contains non-trivial type information, we chose the
specification of <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">Cigarette
Smokers</a>
by @mryndzionek from <a href="https://github.com/tlaplus/Examples/tree/master/specifications">TLA+
Examples</a>.  In
this document, we focus on the type information and give a shorter version of
the specification. For detailed comments, check <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">the original
specification</a>.</p>
<pre><code class="language-tla">---------------------- MODULE CigaretteSmokersTyped --------------------------
(***************************************************************************)
(* A specification of the cigarette smokers problem, originally            *)
(* described in 1971 by Suhas Patil.                                       *)
(* https://en.wikipedia.org/wiki/Cigarette_smokers_problem                 *)
(*                                                                         *)
(* This specification has been extended with type annotations for the      *)
(* demonstration purposes. Some parts of the original specification are    *)
(* omitted for brevity.                                                    *)
(*                                                                         *)
(* The original specification by @mryndzionek can be found here:           *)
(* https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla *)
(***************************************************************************)

EXTENDS Integers, FiniteSets

CONSTANT
  \* @type: Set(INGREDIENT);
  Ingredients,
  \* @type: Set(Set(INGREDIENT));
  Offers

VARIABLE
  \* @type: INGREDIENT -&gt; [smoking: Bool];
  smokers,
  \* @type: Set(INGREDIENT);
  dealer

(* try to guess the types in the code below *)
ASSUME /\ Offers \subseteq (SUBSET Ingredients)
       /\ \A n \in Offers : Cardinality(n) = Cardinality(Ingredients) - 1

vars == &lt;&lt;smokers, dealer&gt;&gt;

(***************************************************************************)
(* 'smokers' is a function from the ingredient the smoker has              *)
(* infinite supply of, to a BOOLEAN flag signifying smoker's state         *)
(* (smoking/not smoking)                                                   *)
(* 'dealer' is an element of 'Offers', or an empty set                     *)
(***************************************************************************)
TypeOK == /\ smokers \in [Ingredients -&gt; [smoking: BOOLEAN]]
          /\ dealer  \in Offers \/ dealer = {}

\* @type: (Set(INGREDIENT), (INGREDIENT) =&gt; Bool) =&gt; INGREDIENT;
ChooseOne(S, P(_)) ==
    (CHOOSE x \in S : P(x) /\ \A y \in S : P(y) =&gt; y = x)

Init ==
    /\ smokers = [r \in Ingredients |-&gt; [smoking |-&gt; FALSE]]
    /\ dealer \in Offers

startSmoking ==
    /\ dealer /= {}
    /\ smokers' = [r \in Ingredients |-&gt;
                    [smoking |-&gt; {r} \cup dealer = Ingredients]]
    /\ dealer' = {}

stopSmoking ==
    /\ dealer = {}
        (* the type of LAMBDA should be inferred from the types
           of ChooseOne and Ingredients *)
    /\ LET r == ChooseOne(Ingredients, LAMBDA x : smokers[x].smoking)
       IN smokers' = [smokers EXCEPT ![r].smoking = FALSE]
    /\ dealer' \in Offers

Next ==
    startSmoking \/ stopSmoking

Spec ==
    Init /\ [][Next]_vars

FairSpec ==
    Spec /\ WF_vars(Next)

AtMostOne ==
    Cardinality({r \in Ingredients : smokers[r].smoking}) &lt;= 1
=============================================================================```

[Code annotations]: https://apalache.informal.systems/docs/adr/004adr-annotations.html
</code></pre>
<h1><a class="header" href="#adr-004-syntax-for-java-like-annotations-in-tla-comments" id="adr-004-syntax-for-java-like-annotations-in-tla-comments">ADR-004: Syntax for Java-like annotations in TLA+ comments</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">2</td></tr>
</tbody></table>
<p>This ADR documents our decision on using Java-like annotations in comments.
Our main motivation to have annotations is to simplify type annotations, as
presented in <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR-002</a>. Hence, in the following text, we are using
examples for type annotations. However, the annotations framework is not
restricted to types. Similar to Java and Scala, we can use annotations
to decorate operators with hints, which may aid the model checker.</p>
<h2><a class="header" href="#1-what-can-be-annotated" id="1-what-can-be-annotated">1. What can be annotated</a></h2>
<p>Annotations should be written in comments that are written in front of a
declaration. The following declarations are supported:</p>
<ol>
<li>Constant declarations, e.g., <code>CONSTANT N</code>.</li>
<li>Variable declarations, e.g., <code>VARIABLE x</code>.</li>
<li>Operator declarations, including:</li>
<li>Top-level operator declarations, e.g., <code>Foo(x) == e</code>.</li>
<li>Operators defined via LET-IN, e.g., <code>Foo(x) == LET Inner(y) == e IN f</code>.</li>
<li>Recursive operators, e.g., <code>RECURSIVE Fact(_) Fact(n) == ...</code></li>
<li>Recursive and non-recursive functions including:</li>
<li>Top-level functions, e.g., <code>foo[i \in Int] == e</code>.</li>
<li>Functions defined via LET-IN, e.g.,<code>Foo == LET foo[i \in Int] == e IN f</code></li>
</ol>
<p>For an example, see Section 3.</p>
<h2><a class="header" href="#2-annotations-syntax" id="2-annotations-syntax">2. Annotations syntax</a></h2>
<p>An annotation is a string that follows the grammar (question mark denotes
optional rules):</p>
<pre><code>Annotation  ::= '@' javaIdentifier ( '(' ArgList? ')' | ':' inlineArg ';' )?
ArgList     ::= (Arg) ( ',' Arg )*
Arg         ::= (string | integer | boolean)
inlineArg   ::= &lt;char sequence excluding ';'&gt;
string      ::= '&quot;' &lt;char sequence&gt; '&quot;'
integer     ::= '-'? [0-9]+
boolean     ::= ('false' | 'true')
</code></pre>
<p>Java Language Specification defines how a <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8">Java identifier</a> looks like.
The sequence <code>&lt;char sequence&gt;</code> is a sequence admitted by <a href="https://www.scala-lang.org/api/2.12.2/scala-parser-combinators/scala/util/parsing/combinator/JavaTokenParsers.html">JavaTokenParsers</a>:</p>
<ul>
<li>Any character except double quotes, control characters or backslash <code>\</code></li>
<li>A backslash followed by another backslash, a single or double quote,
or one of the letters <code>b</code>, <code>f</code>, <code>n</code>, <code>r</code> or <code>t</code></li>
<li><code>\</code> followed by u followed by four hexadecimal digits</li>
</ul>
<p><strong>Examples.</strong> The following strings are examples of syntactically correct
annotations:</p>
<ol>
<li><code>@tailrec</code></li>
<li><code>@type(&quot;(Int, Int) =&gt; Int&quot;)</code></li>
<li><code>@type: (Int, Int) =&gt; Int ;</code></li>
<li><code>@random(true)</code></li>
<li><code>@deprecated(&quot;Use operator Foo instead&quot;)</code></li>
<li><code>@range(0, 100)</code></li>
</ol>
<p>The above examples are just syntactically correct. Their meaning, if there is
any, is defined by the tool that is reading these annotations. Note that the
example 3 is not following the syntax of Java annotations. We have introduced
this format for one-argument annotations, especially, for type annotations.
Its purpose is to reduce the visual clutter in annotations that accept a string
as their only argument.</p>
<h2><a class="header" href="#3-an-annotated-specification" id="3-an-annotated-specification">3. An annotated specification</a></h2>
<p>The following specification shows how to write annotations, so they can be
correctly parsed by the SANY parser and Apalache. Note the location of comments
in front of: local operators, LET-definitions, and recursive operators.
Although these locations may seem to be suboptimal, this is how the SANY
parser locates comments that precede declarations.</p>
<pre><code class="language-tla">-------------------------- MODULE Annotations ---------------------------------
EXTENDS Integers

CONSTANT
  \* @type: Int;
  N

VARIABLE
  \* the single-argument annotation
  \* @type: Set(Int);
  set

\* @pure
\* using the Java annotations, a bit verbose:
\* @type(&quot; Int =&gt; Int &quot;)
Inc(n) == n + 1

\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1

A(n) ==
  LET \* @pure
      \* @type: Int =&gt; Int;
      Dec(x) == x + 1
  IN
  Dec(n)

RECURSIVE Fact(_)
\* @tailrec
\* @type: Int =&gt; Int;
Fact(n) ==
  IF n &lt;= 1 THEN 1 ELSE n * Fact(n - 1)

\* @tailrec
\* @type: Int -&gt; Int;
FactFun[n \in Int] ==
  IF n &lt;= 1 THEN 1 ELSE n * FactFun[n - 1]

===============================================================================
</code></pre>
<h2><a class="header" href="#4-implementation" id="4-implementation">4. Implementation</a></h2>
<p>The implementation of the annotation parser can be found in the class
<code>at.forsyte.apalache.io.annotations.AnnotationParser</code> of the module
<code>tla-import</code>, see <a href="https://github.com/informalsystems/apalache/blob/unstable/tla-import/src/main/scala/at/forsyte/apalache/io/annotations/AnnotationParser.scala">AnnotationParser</a>.</p>
<h2><a class="header" href="#5-discussion" id="5-discussion">5. Discussion</a></h2>
<p>Most likely, this topic does not deserve much discussion, as we are using
the pretty standard syntax of Java annotations. So we are following the
principle of the least surprise.</p>
<p>We also support the concise syntax for the annotations that accept a string as
a simple argument. For these annotations, we had to add the end marker ';'.
This is done because the SANY parser is pruning the linefeed character <code>\n</code>,
so it would be otherwise impossible to find the end of an annotation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
