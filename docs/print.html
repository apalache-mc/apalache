<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apalache Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="tutorials/entry-tutorial.html"><strong aria-hidden="true">2.</strong> Entry-level Model Checker Tutorial</a></li><li class="chapter-item expanded "><a href="tutorials/snowcat-tutorial.html"><strong aria-hidden="true">3.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded "><a href="tutorials/pluscal-tutorial.html"><strong aria-hidden="true">4.</strong> Checking Pluscal specifications</a></li><li class="chapter-item expanded "><a href="tutorials/trail-tips.html"><strong aria-hidden="true">5.</strong> Apalache trail tips: how to check your specs faster</a></li><li class="chapter-item expanded "><a href="tutorials/symbmc.html"><strong aria-hidden="true">6.</strong> Symbolic Model Checking</a></li><li class="chapter-item expanded "><a href="tutorials/temporal-properties.html"><strong aria-hidden="true">7.</strong> Specifying temporal properties and understanding counterexamples</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="HOWTOs/index.html"><strong aria-hidden="true">8.</strong> Overview</a></li><li class="chapter-item expanded "><a href="HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">9.</strong> How to write type annotations</a></li><li class="chapter-item expanded "><a href="HOWTOs/uninterpretedTypes.html"><strong aria-hidden="true">10.</strong> How to use uninterpreted types</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="apalache/index.html"><strong aria-hidden="true">11.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/installation/index.html"><strong aria-hidden="true">11.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/installation/jvm.html"><strong aria-hidden="true">11.1.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="apalache/installation/docker.html"><strong aria-hidden="true">11.1.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="apalache/installation/source.html"><strong aria-hidden="true">11.1.3.</strong> Build from Source</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/running.html"><strong aria-hidden="true">11.2.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="apalache/example.html"><strong aria-hidden="true">11.3.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="apalache/parameters.html"><strong aria-hidden="true">11.4.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="apalache/principles/index.html"><strong aria-hidden="true">11.5.</strong> Symbolic Model Checking with Apalache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/principles/assignments.html"><strong aria-hidden="true">11.5.1.</strong> Assignments and symbolic transitions</a></li><li class="chapter-item expanded "><a href="apalache/principles/folds.html"><strong aria-hidden="true">11.5.2.</strong> Folding sets and sequences</a></li><li class="chapter-item expanded "><a href="apalache/principles/invariants.html"><strong aria-hidden="true">11.5.3.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="apalache/principles/enumeration.html"><strong aria-hidden="true">11.5.4.</strong> Enumeration of counterexamples</a></li><li class="chapter-item expanded "><a href="apalache/principles/apalache-mod.html"><strong aria-hidden="true">11.5.5.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="apalache/principles/naturals.html"><strong aria-hidden="true">11.5.6.</strong> Naturals</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/config.html"><strong aria-hidden="true">11.6.</strong> Apalache global configuration file</a></li><li class="chapter-item expanded "><a href="apalache/statistics.html"><strong aria-hidden="true">11.7.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="apalache/profiling.html"><strong aria-hidden="true">11.8.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="apalache/theory.html"><strong aria-hidden="true">11.9.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/tlc-config.html"><strong aria-hidden="true">12.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="apalache/typechecker-snowcat.html"><strong aria-hidden="true">13.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="apalache/features.html"><strong aria-hidden="true">14.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="apalache/principles/recursive.html"><strong aria-hidden="true">15.</strong> Obsolete: Recursive operators and functions</a></li><li class="chapter-item expanded "><a href="apalache/known-issues.html"><strong aria-hidden="true">16.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="apalache/antipatterns.html"><strong aria-hidden="true">17.</strong> Antipatterns</a></li><li class="chapter-item expanded "><a href="apalache/preprocessing.html"><strong aria-hidden="true">18.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="apalache/tuning.html"><strong aria-hidden="true">19.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="apalache/assignments-in-depth.html"><strong aria-hidden="true">20.</strong> Assignments and Symbolic Transitions in Depth</a></li><li class="chapter-item expanded "><a href="apalache/kera.html"><strong aria-hidden="true">21.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="lang/index.html"><strong aria-hidden="true">22.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="lang/standard-operators.html"><strong aria-hidden="true">23.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/booleans.html"><strong aria-hidden="true">23.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="lang/control-and-nondeterminism.html"><strong aria-hidden="true">23.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="lang/conditionals.html"><strong aria-hidden="true">23.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="lang/integers.html"><strong aria-hidden="true">23.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="lang/sets.html"><strong aria-hidden="true">23.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="lang/logic.html"><strong aria-hidden="true">23.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="lang/functions.html"><strong aria-hidden="true">23.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="lang/records.html"><strong aria-hidden="true">23.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="lang/tuples.html"><strong aria-hidden="true">23.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="lang/sequences.html"><strong aria-hidden="true">23.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="lang/apalache-extensions.html"><strong aria-hidden="true">24.</strong> Apalache extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/apalache-operators.html"><strong aria-hidden="true">24.1.</strong> Apalache module</a></li><li class="chapter-item expanded "><a href="lang/variants.html"><strong aria-hidden="true">24.2.</strong> Variants</a></li><li class="chapter-item expanded "><a href="lang/option-types.html"><strong aria-hidden="true">24.3.</strong> Option types</a></li></ol></li><li class="chapter-item expanded "><a href="lang/user-operators.html"><strong aria-hidden="true">25.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/user/top-level-operators.html"><strong aria-hidden="true">25.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/let-in.html"><strong aria-hidden="true">25.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="lang/user/higher-order-operators.html"><strong aria-hidden="true">25.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="lang/user/lambdas.html"><strong aria-hidden="true">25.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/local-operators.html"><strong aria-hidden="true">25.5.</strong> Local operator definitions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="idiomatic/index.html"><strong aria-hidden="true">27.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">28.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="idiomatic/001assignments.html"><strong aria-hidden="true">29.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="idiomatic/002primes.html"><strong aria-hidden="true">30.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded "><a href="idiomatic/007if-then-else.html"><strong aria-hidden="true">31.</strong> Use Boolean operators in actions, not IF-THEN-ELSE</a></li><li class="chapter-item expanded "><a href="idiomatic/003record-sets.html"><strong aria-hidden="true">32.</strong> Avoid sets of mixed records</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="adr/001rfc-types.html"><strong aria-hidden="true">33.</strong> RFC 001: types and type annotations</a></li><li class="chapter-item expanded "><a href="adr/002adr-types.html"><strong aria-hidden="true">34.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="adr/003adr-trex.html"><strong aria-hidden="true">35.</strong> ADR-003: transition executor (TRex)</a></li><li class="chapter-item expanded "><a href="adr/004adr-annotations.html"><strong aria-hidden="true">36.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="adr/005adr-json.html"><strong aria-hidden="true">37.</strong> ADR-005: JSON Serialization Format</a></li><li class="chapter-item expanded "><a href="adr/006rfc-unit-testing.html"><strong aria-hidden="true">38.</strong> RFC-006: unit tests and property-based tests</a></li><li class="chapter-item expanded "><a href="adr/007adr-restructuring.html"><strong aria-hidden="true">39.</strong> ADR-007: restructuring</a></li><li class="chapter-item expanded "><a href="adr/008adr-exceptions.html"><strong aria-hidden="true">40.</strong> ADR-008: exceptions</a></li><li class="chapter-item expanded "><a href="adr/009adr-outputs.html"><strong aria-hidden="true">41.</strong> ADR-009: outputs</a></li><li class="chapter-item expanded "><a href="adr/010rfc-transition-explorer.html"><strong aria-hidden="true">42.</strong> RFC-010: Implementation of Transition Exploration Server</a></li><li class="chapter-item expanded "><a href="adr/011adr-smt-arrays.html"><strong aria-hidden="true">43.</strong> ADR-011: alternative SMT encoding using arrays</a></li><li class="chapter-item expanded "><a href="adr/012adr-adopt-adr-template.html"><strong aria-hidden="true">44.</strong> ADR-012: Adopt an ADR Template</a></li><li class="chapter-item expanded "><a href="adr/013adr-configuration.html"><strong aria-hidden="true">45.</strong> ADR-013: Configuration Management Component</a></li><li class="chapter-item expanded "><a href="adr/014adr-precise-records.html"><strong aria-hidden="true">46.</strong> ADR-014: Precise type inference for records and variants</a></li><li class="chapter-item expanded "><a href="adr/015adr-trace.html"><strong aria-hidden="true">47.</strong> ADR-015: ITF: informal trace format</a></li><li class="chapter-item expanded "><a href="adr/016adr-retla.html"><strong aria-hidden="true">48.</strong> ADR-016: ReTLA: Relational TLA</a></li><li class="chapter-item expanded "><a href="adr/017pdr-temporal.html"><strong aria-hidden="true">49.</strong> PDR-017: Checking temporal properties</a></li><li class="chapter-item expanded "><a href="adr/018adr-inlining.html"><strong aria-hidden="true">50.</strong> ADR-018: Inlining in Apalache</a></li><li class="chapter-item expanded "><a href="adr/019adr-harmonize-changelog.html"><strong aria-hidden="true">51.</strong> ADR-019: Harmonize changelog management</a></li><li class="chapter-item expanded "><a href="adr/020adr-arenas.html"><strong aria-hidden="true">52.</strong> ADR-020: Improving membership in arenas</a></li><li class="chapter-item expanded "><a href="adr/021rfc-prioritization.html"><strong aria-hidden="true">53.</strong> RFC-021: Prioritization of Work</a></li><li class="chapter-item expanded "><a href="adr/022adr-unification-of-configs-and-options.html"><strong aria-hidden="true">54.</strong> ADR-022: Unify Configuration Management and &quot;Pass Options&quot;</a></li><li class="chapter-item expanded "><a href="adr/023adr-trace-evaluation.html"><strong aria-hidden="true">55.</strong> ADR-023: Trace evaluation</a></li><li class="chapter-item expanded "><a href="adr/024adr-arena-pass.html"><strong aria-hidden="true">56.</strong> ADR-024: Arena computation isolation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>This book collects five related, but independent, sets of documentation:</p>
<ol>
<li><a href="./apalache/index.html">The Apalache User Manual</a></li>
<li><a href="./tutorials/index.html">Apalache Tutorials</a></li>
<li><a href="./HOWTOs/index.html">Apalache HOWTOs</a></li>
<li><a href="./lang/index.html">A TLA+ Language Reference Manual</a></li>
<li><a href="./idiomatic/index.html">Guidelines for Idiomatic TLA+</a></li>
</ol>
<h1><a class="header" href="#overview-1" id="overview-1">Overview</a></h1>
<ol>
<li><a href="tutorials/./entry-tutorial.html">Entry-level Tutorial on the Model Checker</a></li>
<li><a href="tutorials/./snowcat-tutorial.html">Tutorial on the Type Checker Snowcat</a></li>
<li><a href="tutorials/./trail-tips.html">Apalache trail tips: how to check your specs faster</a></li>
<li><a href="tutorials/./pluscal-tutorial.html">Checking Pluscal specifications</a></li>
<li><a href="tutorials/./symbmc.html">Symbolic Model Checking</a></li>
<li><a href="tutorials/./temporal-properties.html">Specifying temporal properties and understanding counterexamples</a></li>
</ol>
<h1><a class="header" href="#entry-level-tutorial-on-the-model-checker" id="entry-level-tutorial-on-the-model-checker">Entry-level Tutorial on the Model Checker</a></h1>
<p><strong>Difficulty: Blue trail – Easy</strong></p>
<p>In this tutorial, we show how to turn an implementation of binary search into a
TLA+ specification. This implementation is known to have an out-of-bounds
error, which once existed in Java, see <a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Nearly All Binary Searches and
Mergesorts are Broken</a> by Joshua Bloch (2006). Our goal is to write a
specification after this implementation, not to write a specification of an
abstract binary search algorithm. You can find such a specification and a proof
in <a href="http://lamport.azurewebsites.net/tla/proving-safety.pdf">Proving Safety Properties</a> and <a href="https://github.com/tlaplus/Examples/blob/master/specifications/LoopInvariance/BinarySearch.tla">Binary search with a TLAPS proof</a> by
<a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (2019).</p>
<p>This tutorial is written under the assumption that the reader does not have any
knowledge of TLA+ and Apalache. Since we are not diving into protocol and
algorithm specifications too quickly, this is a nice example to start with. We
demonstrate how to use Apalache to find errors that are caused by integer
overflow and the out-of-bounds error, which is caused by this overflow. We
also show that the same overflow error prevents the algorithm from terminating
in the number of steps that is expected from the binary search. Normally it is
expected that the binary search terminates in <code>log2(n)</code> steps, where <code>n</code> is the
length of the search interval.</p>
<p>Sometimes, we refer to the model checker TLC in this text. TLC is another
model checker for TLA+ and was introduced in the late 90s.  If you are new
to TLA+ and want to learn more about TLC, check the <a href="https://github.com/tlaplus/tlaplus/">TLC</a> project and the
<a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video Course</a> by Leslie Lamport. If you are an experienced TLC user,
you will find this tutorial helpful too, as it demonstrates the strong points
of Apalache.</p>
<h2><a class="header" href="#related-documents" id="related-documents">Related documents</a></h2>
<ul>
<li><a href="tutorials/./snowcat-tutorial.html">Tutorial on Snowcat</a> shows how to write type annotations for Apalache.</li>
<li><a href="https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html">TLA+ Cheatsheet in HTML</a> summarizes the common TLA+ constructs.  If you
prefer a printable version in pdf, check the <a href="https://lamport.azurewebsites.net/tla/summary-standalone.pdf">Summary of TLA+</a>.</li>
</ul>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>We assume that you have Apalache installed. If not, check the manual page on
<a href="tutorials/../apalache/installation/index.html">Apalache installation</a>. The minimal required version is 0.22.0.</p>
<p>We provide all source files referenced in this tutorial as a <a href="https://download-directory.github.io/?url=https://github.com/informalsystems/apalache/tree/main/test/tla/bin-search">ZIP archive</a>
download. We still recommend that you follow along typing the TLA+ examples
yourself.</p>
<h2><a class="header" href="#running-example-binary-search" id="running-example-binary-search">Running example: Binary search</a></h2>
<p>We are not going to explain the idea of binary search in this tutorial. If you
need more context on this, check the Wikipedia page on the <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary search
algorithm</a>. Let's jump straight into the Java code that is given in <a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Nearly All
Binary Searches and Mergesorts are Broken</a>:</p>
<pre><code class="language-java">1:     public static int binarySearch(int[] a, int key) {
2:         int low = 0;
3:         int high = a.length - 1;
4:
5:         while (low &lt;= high) {
6:             int mid = (low + high) / 2;
7:             int midVal = a[mid];
8:
9:             if (midVal &lt; key)
10:                 low = mid + 1
11:             else if (midVal &gt; key)
12:                 high = mid - 1;
13:             else
14:                 return mid; // key found
15:         }
16:         return -(low + 1);  // key not found.
17:     }
</code></pre>
<p>As was found by Joshua Bloch, the addition in line 6 may throw
an out of bounds exception at line 7, due to an integer overflow. This is because <code>low</code>
and <code>high</code> are signed integers, with a maximum value of <code>2^31 - 1</code>. 
However, the sum of two values, each smaller than <code>2^31-1</code>, may be greater than <code>2^31 -1</code>. If this  is the case, <code>low + high</code> can wrap into a negative number.</p>
<p>This bug was
<a href="https://groups.google.com/g/tlaplus/c/msLltIcexF4/m/qnABiKJmDgAJ">discussed</a>
in the TLA+ User Group in 2015. Let's see how TLA+ and Apalache can help us
here. A bit of warning: The final TLA+ specification will happen to be longer
than the 17 lines above. Don't get disappointed too fast. There are several
reasons for that:</p>
<ol>
<li>
<p>TLA+ is not tuned towards one particular class of algorithms, e.g.,
sequential algorithms.</p>
</li>
<li>
<p>Related to the previous point, TLA+ and Apalache are not tuned to C or Java
programs. A software model checker such as <a href="https://www.cprover.org/cbmc/">CBMC</a>, <a href="https://stainless.epfl.ch/">Stainless</a>, or
<a href="https://www.microsoft.com/en-us/research/project/q-program-verifier/">Coral</a> would probably accept a shorter program, and it would check it
faster. However, if you have a sledgehammer like TLA+, you don't have to learn
other languages.</p>
</li>
<li>
<p>We explicitly state the expected properties of the algorithm to be checked
by Apalache. In imperative languages, these properties are usually omitted or
written as plain-text comments.</p>
</li>
<li>
<p>We have to introduce a bit of boilerplate, to make Apalache work.</p>
</li>
</ol>
<h2><a class="header" href="#step-0-introducing-a-template-module" id="step-0-introducing-a-template-module">Step 0: Introducing a template module</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch0.tla">BinSearch0.tla</a>.</p>
<p>TLA+ is built around the concept of a state machine. The specified system
starts in a state that is picked from the set of its <em>initial states</em>. This
set of states is described with a predicate over states in TLA+. This predicate
is usually called <code>Init</code>. Further, the state machine makes a <em>transition</em> from
the current state to a successor state. These transitions are described with a
predicate over pairs of states <code>(current, successor)</code> in TLA+. This predicate
is usually called <code>Next</code>.</p>
<p>We start with the simplest possible specification of a single-state machine.
If we visualize it as a state diagram, it looks like follows:</p>
<p><img src="tutorials/./img/single.drawio.svg" alt="Tux, the Linux mascot" /></p>
<p>Let's open a new file called <code>BinSearch0.tla</code> and type a very minimal module
definition:</p>
<pre><code class="language-tla">--------------------------- MODULE BinSearch0 ---------------------------------
EXTENDS Integers, Sequences, Apalache

Init == TRUE

Next == TRUE

===============================================================================
</code></pre>
<p>This module does not yet specify any part of the binary search implementation. However, it contains a few important things:</p>
<ul>
<li>
<p>It imports constants and operators from three standard modules: <code>Integers</code>,
<code>Sequences</code>, and <code>Apalache</code>.</p>
</li>
<li>
<p>It declares the predicate <code>Init</code>. This predicate describes the initial
states of our state machine. Since we have not declared any variables, it
defines the single possible state.</p>
</li>
<li>
<p>It declares the predicate <code>Next</code>. This predicate describes the transitions
of our state machine. Again, there are no variables and <code>Next == TRUE</code>, so
this transition defines the entire set of states as reachable in a single
step.</p>
</li>
</ul>
<p>Now it is a good time to check that Apalache works. Run the following command:</p>
<pre><code class="language-sh">$ apalache-mc check BinSearch0.tla
</code></pre>
<p>The tool output is a bit verbose. Below, you can see the important lines of the
output:</p>
<pre><code>...
PASS #13: BoundedChecker
Step 0: picking a transition out of 1 transition(s)
Step 1: picking a transition out of 1 transition(s)
...
Step 10: picking a transition out of 1 transition(s)
The outcome is: NoError
Checker reports no error up to computation length 10
... 
</code></pre>
<p>We can see that Apalache runs without finding an error, as expected.</p>
<p>If you are curious, replace <code>TRUE</code> with <code>FALSE</code> in either <code>Init</code> or <code>Next</code>,
run Apalache again and observe what happens.</p>
<p>It is usually a good idea to start with a spec like <code>BinSearch0.tla</code>, to ensure
that the tools are working.</p>
<h2><a class="header" href="#step-1-introducing-specification-parameters" id="step-1-introducing-specification-parameters">Step 1: Introducing specification parameters</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch1.tla">BinSearch1.tla</a>.</p>
<p><em>Diffs</em>: <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch1.tla.patch">BinSearch1.tla.patch</a>.</p>
<p>The Java code of <code>binarySearch</code> accepts two parameters: an array of integers
called <code>a</code>, and an integer called <code>key</code>. Similar to these parameters, we introduce
two specification parameters (called <code>CONSTANTS</code> in TLA+):</p>
<ul>
<li>the input sequence <code>INPUT_SEQ</code>, and</li>
<li>the element to search for <code>INPUT_KEY</code>.</li>
</ul>
<pre><code class="language-tla">--------------------------- MODULE BinSearch1 ---------------------------------
EXTENDS Integers, Sequences, Apalache

CONSTANTS
    \* The input sequence.
    \*
    \* @type: Seq(Int);
    INPUT_SEQ,
    \* The key to search for.
    \*
    \* @type: Int;
    INPUT_KEY,
</code></pre>
<p>Importantly, the constants <code>INPUT_SEQ</code> and <code>INPUT_KEY</code> are prefixed with type
annotations in the comments:</p>
<ul>
<li><code>INPUT_SEQ</code> has the type <code>Seq(Int)</code>, that is, it is a sequence of integers (sequences in TLA+ are indexed), and</li>
<li><code>INPUT_KEY</code> has the type <code>Int</code>, that is, it is an integer.</li>
</ul>
<p>Recall that we wanted to specify signed and unsigned Java integers, which are
32 bit long. <em>TLA+ is not tuned towards any computer architecture.</em> Its integers
are mathematical integers: always signed and arbitrarily large (unbounded).
To model fixed bit-width integers, we introduce another constant <code>INT_WIDTH</code> of
type <code>Int</code>:</p>
<pre><code class="language-tla">    \* Bit-width of machine integers.
    \*
    \* @type: Int;
    INT_WIDTH
</code></pre>
<p>The benefit of defining the bit width as a parameter is that we can try
our specification for various bit widths of integers: 4-bit, 8-bit, 16-bit, 32-bit,
etc.  Similar to many programming languages, we introduce several constant
definitions (<code>a^b</code> is <code>a</code> taken to the power of <code>b</code>):</p>
<pre><code class="language-tla">\* the largest value of an unsigned integer
MAX_UINT == 2^INT_WIDTH
\* the largest value of a signed integer
MAX_INT  == 2^(INT_WIDTH - 1) - 1
\* the smallest value of a signed integer
MIN_INT  == -2^(INT_WIDTH - 1)

</code></pre>
<p>Note that these definitions do not constrain integers in any way. They are
simply convenient names for the constants that we will need in the
specification.</p>
<p>To make sure that the new specification does not contain syntax errors or
type errors, execute:</p>
<pre><code class="language-sh">$ apalache-mc check BinSearch1.tla
</code></pre>
<h2><a class="header" href="#step-2-specifying-the-base-case" id="step-2-specifying-the-base-case">Step 2: Specifying the base case</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch2.tla">BinSearch2.tla</a>.</p>
<p><em>Diffs</em>: <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch2.tla.patch">BinSearch2.tla.patch</a>.</p>
<p>We start with the simplest possible case that occurs in <code>binarySearch</code>. Namely,
we consider the case where <code>low &gt; high</code>, that is, <code>binarySearch</code> never enters
the loop.</p>
<p><strong>Introduce variables</strong>. To do that, we have to finally introduce some
variables. Obviously, we have to introduce variables <code>low</code> and <code>high</code>. This is
how we do it:</p>
<pre><code class="language-tla">VARIABLES
    \* The low end of the search interval (inclusive).
    \* @type: Int;
    low,
    \* The high end of the search interval (inclusive).
    \* @type: Int;
    high,
</code></pre>
<p>The variables <code>low</code> and <code>high</code> are called <em>state variables</em>. They define a state of our state machine. That is, they are never introduced and
never removed. Remember, TLA+ is not tuned towards any particular computer
architecture and thus it does not even have the notion of an execution stack.
You can think of <code>low</code> and <code>high</code> as being global variables. Yes, global
variables are generally frowned upon in programming languages. However, when dealing with a
specification, they are much easier to reason about than the execution stack.
We will demonstrate how to introduce local definitions later in this tutorial.</p>
<p>We introduce two additional variables, the purpose of which might be less obvious:</p>
<pre><code class="language-tla">    \* Did the algorithm terminate.
    \* @type: Bool;
    isTerminated,
    \* The result when terminated.
    \* @type: Int;
    returnValue
</code></pre>
<p>The variable <code>isTerminated</code> indicates whether our search has terminated. Why do
we even have to introduce it? Because, some computer systems are not designed
with termination in mind. For instance, such distributed systems as the
Internet and Bitcoin are designed to periodically serve incoming requests
instead of producing a single output for a single input.</p>
<p>If we want to specify the Internet or Bitcoin, do we
understand what it means for them to terminate?</p>
<p>The variable <code>returnValue</code> will contain the result of the binary search, when
the search terminates. Recall, there is no execution stack. Hence, we introduce
the variable <code>returnValue</code> right away. The downside is that we have to do
book-keeping for this variable.</p>
<p><strong>Initialize variables.</strong> Having introduced the variables, we have to
initialize them. That is, we want to specify lines 2-3 of the Java code:</p>
<pre><code class="language-java">1:     public static int binarySearch(int[] a, int key) {
2:         int low = 0;
3:         int high = a.length - 1;
           ...
17:    }
</code></pre>
<p>To this end, we change the body of the predicate <code>Init</code> to the following:</p>
<pre><code class="language-tla">Init ==
  low = 0 /\ high = Len(INPUT_SEQ) - 1 /\ isTerminated = FALSE /\ returnValue = 0
</code></pre>
<p>You probably have guessed, what the above line means. Maybe you are a bit
puzzled about the mountain-like operator <code>/\</code>. It is called <em>conjunction</em>,
which is usually written as <code>&amp;&amp;</code> or <code>and</code> in programming languages. The
important effect of the above expression is that every variable in the
left-hand side of <code>=</code> is required to have the value specified in the right-hand
side of <code>=</code><sup class="footnote-reference"><a href="#assignment-order">1</a></sup>.</p>
<p>As it is hard to fit many expressions in one line, TLA+ offers special syntax
for writing a big conjunction. Here is the standard way of writing <code>Init</code>
(indentation is important):</p>
<pre><code class="language-tla">\* Initialization step (lines 2-3)
Init ==
    /\ low = 0
    /\ high = Len(INPUT_SEQ) - 1
    /\ isTerminated = FALSE
    /\ returnValue = 0
</code></pre>
<p>The above lines do not deserve a lot of explanation. As you have probably guessed,
<code>Len(INPUT_SEQ)</code> computes the length of the input sequence.</p>
<div class="footnote-definition" id="assignment-order"><sup class="footnote-definition-label">1</sup>
<p>It is important to know that TLA+ does not impose any
particular order of evaluation for <code>/\</code>. However, both Apalache and TLC
evaluate some expressions of the form <code>x = e</code> in the initialization predicate
as assignments.  Hence, it is often a good idea to think about <code>/\</code> as being
evaluated from left to right.</p>
</div>
<p><strong>Update variables.</strong> Having done all the preparatory work, we are now ready to
specify the behavior in lines 5 and 16 of <code>binarySearch</code>.</p>
<pre><code class="language-java">1:     public static int binarySearch(int[] a, int key) {
2:         int low = 0;
3:         int high = a.length - 1;
4:
5:         while (low &lt;= high) {
            ...
15:        }
16:        return -(low + 1);  // key not found.
17:    }
</code></pre>
<p>To this end, we redefine <code>Next</code> as follows:</p>
<pre><code class="language-tla">\* Computation step (lines 5-16)
Next ==
    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14: not implemented yet
        UNCHANGED &lt;&lt;low, high, isTerminated, returnValue&gt;&gt;
      ELSE          \* line 16
        /\ isTerminated' = TRUE
        /\ returnValue' = -(low + 1)
        /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
</code></pre>
<p>Most likely, you have no problem reading this definition, except for the part
that includes <code>isTerminated'</code>, <code>returnValue'</code>, and <code>UNCHANGED</code>. Recall that a
transition predicate, like <code>Next</code>, specifies the relation between two states of
the state machine; the current state, the variables of which are referenced by
unprimed names, and the successor-state, the variables of which are referenced
by primed names.</p>
<p>The expression <code>isTerminated' = TRUE</code> means that only states where
<code>isTerminated</code> equals <code>TRUE</code> can be successors of the current state. In
general, <code>isTerminated'</code> could also depend on the value of <code>isTerminated</code>, but
here, it does not. Likewise, <code>returnValue' = -(low + 1)</code> means that
<code>returnValue</code> has the value <code>-(low + 1)</code> in the next state. The expression
<code>UNCHANGED &lt;&lt;low, high&gt;&gt;</code> is a convenient shortcut for writing <code>low' = low /\ high' = high</code>.  Readers unfamiliar with specification languages might question
the purpose of <code>UNCHANGED</code>, since in most programming languages variables only
change when they are explicitly changed.  However, a transition predicate, like
<code>Next</code>, establishes a relation between pairs of states.  If we were to omit
<code>UNCHANGED</code>, this would mean that we consider states in which <code>low</code> and <code>high</code>
have <em>completely arbitrary</em> values as valid successors.  This is clearly not
how Java code should behave.  To encode Java semantics, we must therefore
explicitly state that <code>low</code> and <code>high</code> do not change in this step.</p>
<p>It is important to understand that an expression like <code>returnValue' = -(low + 1)</code> <em>does not immediately update</em> the variable on the left-hand side. Hence,
<code>returnValue</code> still refers to the value in the state before evaluation of
<code>Next</code>, whereas <code>returnValue'</code> refers to the value in the state that is
computed after evaluation of <code>Next</code>. You can think of the effect of <code>x' = e</code>
being delayed until the whole predicate <code>Next</code> is evaluated.</p>
<h2><a class="header" href="#step-2b-basic-checks-for-the-base-case" id="step-2b-basic-checks-for-the-base-case">Step 2b: Basic checks for the base case</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch2.tla">BinSearch2.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC2_8.tla">MC2_8.tla</a>.</p>
<p>As we discussed, it is a good habit to periodically run the model checker, as you are writing
the specification. Even if it doesn't check much, you would be able to catch
the moment when the model checker slows down. This may give you a useful
hint about changing a few things before you have written too much code.</p>
<p>Let us check <code>BinSearch2.tla</code>:</p>
<pre><code class="language-sh">$ apalache-mc check BinSearch2.tla
</code></pre>
<p>If it is your first TLA+ specification, you may be surprised by this error:</p>
<pre><code>...
PASS #13: BoundedChecker
This error may show up when CONSTANTS are not initialized.
Check the manual: https://apalache.informal.systems/docs/apalache/parameters.html
Input error (see the manual): SubstRule: Variable INPUT_SEQ is not assigned a value
...
</code></pre>
<p>Apalache complains that we have declared several constants (<code>INPUT_SEQ</code>,
<code>INPUT_KEY</code>, and <code>INT_WIDTH</code>), but we have never defined them.</p>
<p><strong>Adding a model file.</strong> The standard approach in this case is either to fix
all constants, or to introduce another module that
fixes the parameters and instantiates the general specification. Although
Apalache supports <a href="tutorials/../apalache/parameters.html#tlc-configuration-file">TLC Configuration Files</a>, for the purpose of this tutorial,
we will stick to tool-agnostic TLA+ syntax.</p>
<p>To this end, we add a new file <code>MC2_8.tla</code> with the following contents:</p>
<pre><code class="language-tla">-------------------------- MODULE MC2_8 ---------------------------------------
\* an instance of BinSearch2 with all parameters fixed

\* fix 8 bits
INT_WIDTH == 8
\* the input sequence to try
\* @type: Seq(Int);
INPUT_SEQ == &lt;&lt; &gt;&gt;
\* the element to search for
INPUT_KEY == 10

\* introduce the variables to be used in BinSearch2
VARIABLES
    \* @type: Int;
    low,
    \* @type: Int;
    high,
    \* @type: Bool;
    isTerminated,
    \* @type: Int;
    returnValue

\* use an instance for the fixed constants
INSTANCE BinSearch2
===============================================================================
</code></pre>
<p>As you can see, we fix the values of all parameters. We are instantiating
the module <code>BinSearch2</code> with these fixed parameters. Since instantiation
requires all constants and variables to be defined, we copy the variables
definitions from <code>BinSearch2.tla</code>.</p>
<p>Since we are fixing the parameters with concrete values, <code>MC2_8.tla</code> looks very
much like a unit test. It's a good start for debugging a few things, but since
our program is entirely sequential, our specification is as good as a unit
test. Later in this tutorial we will show how to leverage Apalache to check
properties for all possible inputs (up to some bound).</p>
<p>Let us check <code>MC2_8.tla</code>:</p>
<pre><code class="language-sh">$ apalache-mc check MC2_8.tla
...
Checker reports no error up to computation length 10
</code></pre>
<p>This time Apalache has not complained. This is a good time to stop and think
about whether the model checker has told us anything interesting. Kind of. It
told us that it has not found any contradictions. But it did not tell us
anything interesting about our expectations. Because we have not set our
expectations yet!</p>
<h2><a class="header" href="#step-3-specifying-an-invariant-and-checking-it-for-the-base-case" id="step-3-specifying-an-invariant-and-checking-it-for-the-base-case">Step 3: Specifying an invariant and checking it for the base case</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch3.tla">BinSearch3.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC3_8.tla">MC3_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch3.tla.patch">BinSearch3.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC3_8.tla.patch">MC3_8.tla.patch</a>.</p>
<p>What do we expect from binary search? We can check the Java documentation,
e.g., <a href="https://github.com/openjdk/jdk/blob/d7f31d0d53bfec627edc83ceb75fc6202891e186/src/java.base/share/classes/java/util/Arrays.java#L1662-L1698">Arrays.java in OpenJDK</a>:</p>
<blockquote>
<p>...the return value will be &gt;= 0 if and only if the key is found.</p>
</blockquote>
<p>This property is actually quite easy to write in TLA+. First, we
introduce the property that we call <code>ReturnValueIsCorrect</code>:</p>
<pre><code class="language-tla">\* The property of particular interest is this one:
\*
\* &quot;Note that this guarantees that the return value will be &gt;= 0 if
\*  and only if the key is found.&quot;
ReturnValueIsCorrect ==
    LET MatchingIndices ==
        { i \in DOMAIN INPUT_SEQ: INPUT_SEQ[i] = INPUT_KEY }
    IN
    IF MatchingIndices /= {}
    THEN \* Indices in TLA+ start with 1, whereas the Java returnValue starts with 0
        returnValue + 1 \in MatchingIndices
    ELSE returnValue &lt; 0

</code></pre>
<p>Let us decompose this property into smaller pieces. First, we define the set
<code>MatchingIndices</code>:</p>
<pre><code class="language-tla">ReturnValueIsCorrect ==
    LET MatchingIndices ==
        { i \in DOMAIN INPUT_SEQ: INPUT_SEQ[i] = INPUT_KEY }
</code></pre>
<p>With this TLA+ expression we define a <em>local constant</em> called <code>MatchingIndices</code>
that is equal to the set of indices <code>i</code> in <code>INPUT_SEQ</code> so that the sequence
elements at these indices are equal to <code>INPUT_KEY</code>. If this syntax
is hard to parse for you, here is how we could write a similar definition in a
functional programming language (Scala):</p>
<pre><code class="language-scala">val MatchingIndices =
    INPUT_SEQ.indices.toSet.filter { i =&gt; INPUT_SEQ(i) == INPUT_KEY }
</code></pre>
<p>Since the
sequence indices in TLA+ start with 1, we require that <code>returnValue + 1</code>
belongs to <code>MatchingIndices</code> when <code>MatchingIndices</code> is non-empty. If
<code>MatchingIndices</code> is empty, we require <code>returnValue</code> to be negative.</p>
<p>We can check that the property <code>ReturnValueIsCorrect</code> is an <em>invariant</em>, that
is, it holds in every state that is reachable from the states specified by <code>Init</code>
via a sequence of transitions specified by <code>Next</code>:</p>
<pre><code class="language-sh">$ apalache-mc check --inv=ReturnValueIsCorrect MC3_8.tla
</code></pre>
<p>This property is violated in the initial state. To see why, check the file
<code>counterexample1.tla</code>.</p>
<p>Actually, we only expect this property to hold after the computation terminates,
that is, when <code>isTerminated</code> equals to <code>TRUE</code>. Hence, we add the following
invariant:</p>
<pre><code class="language-tla">\* What we expect from the search when it is finished.
Postcondition ==
    isTerminated =&gt; ReturnValueIsCorrect
</code></pre>
<p><strong>Digression: Boolean connectives.</strong> In the above code, the operator <code>=&gt;</code> is
the <a href="https://en.wikipedia.org/wiki/Material_conditional">Classical implication</a>. In general, <code>A =&gt; B</code> is equivalent to <code>IF A THEN B ELSE TRUE</code>. The implication <code>A =&gt; B</code> is also equivalent to the TLA+
expression <code>~A \/ B</code>, which one can read as &quot;not A holds, or B holds&quot;. The
operator <code>\/</code> is called <em>disjunction</em>. As a reminder, here is the standard
truth table for the Boolean connectives, which are no different from the
Boolean logic in TLA+:</p>
<table><thead><tr><th><code>A</code></th><th><code>B</code></th><th><code>~A</code></th><th><code>A \/ B</code></th><th><code>A /\ B</code></th><th><code>A =&gt; B</code></th></tr></thead><tbody>
<tr><td><code>FALSE</code></td><td><code>FALSE</code></td><td><code>TRUE</code></td><td><code>FALSE</code></td><td><code>FALSE</code></td><td><code>TRUE</code></td></tr>
<tr><td><code>FALSE</code></td><td><code>TRUE</code></td><td><code>TRUE</code></td><td><code>TRUE</code></td><td><code>FALSE</code></td><td><code>TRUE</code></td></tr>
<tr><td><code>TRUE</code></td><td><code>FALSE</code></td><td><code>FALSE</code></td><td><code>TRUE</code></td><td><code>FALSE</code></td><td><code>FALSE</code></td></tr>
<tr><td><code>TRUE</code></td><td><code>TRUE</code></td><td><code>FALSE</code></td><td><code>TRUE</code></td><td><code>TRUE</code></td><td><code>TRUE</code></td></tr>
</tbody></table>
<p><strong>Checking Postcondition.</strong>
Let us check <code>Postcondition</code> on <code>MC3_8.tla</code>:</p>
<pre><code class="language-sh">$ apalache-mc check --inv=Postcondition MC3_8.tla
</code></pre>
<p>This property holds true. However, it's a small win, as <code>MC3_8.tla</code> fixes all
parameters. Hence, we have checked the property just for one data point. In
Step 5, we will check <code>Postcondition</code> for all sequences admitted by <code>INT_WIDTH</code>.</p>
<h2><a class="header" href="#step-4-specifying-the-loop-with-a-caveat" id="step-4-specifying-the-loop-with-a-caveat">Step 4: Specifying the loop (with a caveat)</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch4.tla">BinSearch4.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC4_8.tla">MC4_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch4.tla.patch">BinSearch4.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC4_8.tla.patch">MC4_8.tla.patch</a>.</p>
<p>We specify the loop of <code>binarySearch</code> in TLA+ as follows:</p>
<pre><code class="language-tla">\* Computation step (lines 5-16)
Next ==
    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14
        LET mid == (low + high) \div 2 IN
        LET midVal == INPUT_SEQ[mid + 1] IN
          \//\ midVal &lt; INPUT_KEY \* lines 9-10
            /\ low' = mid + 1
            /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
          \//\ midVal &gt; INPUT_KEY \* lines 11-12
            /\ high' = mid -1
            /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
          \//\ midVal = INPUT_KEY \* lines 13-14
            /\ returnValue' = mid
            /\ isTerminated' = TRUE
            /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
      ELSE          \* line 16
        /\ isTerminated' = TRUE
        /\ returnValue' = -(low + 1)
        /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
    ELSE            \* isTerminated
      UNCHANGED &lt;&lt;low, high, returnValue, isTerminated&gt;&gt;
</code></pre>
<p>Let's start with these two definitions:</p>
<pre><code class="language-tla">        LET mid == (low + high) \div 2 IN
        LET midVal == INPUT_SEQ[mid + 1] IN
</code></pre>
<p>As you have probably guessed, we define two (local) values <code>mid</code> and <code>midVal</code>.
The value <code>mid</code> is the average of <code>low</code> and <code>high</code>. The operator <code>\div</code> is
simply integer division, which is usually written as <code>/</code> or <code>//</code> in programming
languages. The value <code>midVal</code> is the value at the location <code>mid + 1</code>. Since
the TLA+ sequence <code>INPUT_SEQ</code> has indices in the range <code>1..Len(INPUT_SEQ)</code>,
whereas we are computing zero-based indices, we are adjusting the index by one,
that is, we write <code>INPUT_SEQ[mid + 1]</code> instead of <code>INPUT_SEQ[mid]</code>.</p>
<p><em>Warning: The definitions of <code>mid</code> and <code>midVal</code> do not properly reflect the
Java code of <code>binarySearch</code>. We will fix them later. It is a good exercise
to stop here and think about the source of this imprecision.</em></p>
<p>The following lines look like ASCII graphics, but by now you should know
enough to read them:</p>
<pre><code class="language-tla">        LET mid == (low + high) \div 2 IN
        LET midVal == INPUT_SEQ[mid + 1] IN
          \//\ midVal &lt; INPUT_KEY \* lines 9-10
            /\ low' = mid + 1
            /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
          \//\ midVal &gt; INPUT_KEY \* lines 11-12
            /\ high' = mid -1
            /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
          \//\ midVal = INPUT_KEY \* lines 13-14
            /\ returnValue' = mid
            /\ isTerminated' = TRUE
            /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
</code></pre>
<p>These lines are the indented form of <code>\/</code> for three cases:</p>
<ul>
<li>when <code>midVal &lt; INPUT_KEY</code>, or</li>
<li>when <code>midVal &gt; INPUT_KEY</code>, or</li>
<li>when <code>midVal = INPUT_KEY</code>.</li>
</ul>
<p>We could write these expressions with <code>IF-THEN-ELSE</code> or even with the TLA+
operator <code>CASE</code> (see <a href="https://lamport.azurewebsites.net/tla/summary-standalone.pdf">Summary of TLA+</a>). However, we find the disjunctive
form to be the least cluttered, though unusual.</p>
<p>Now we can check the postcondition again:</p>
<pre><code class="language-sh">$ apalache-mc check --inv=Postcondition MC4_8.tla
</code></pre>
<p>The check goes through, but did it do much? Recall, that we fixed <code>INPUT_SEQ</code>
to be the empty sequence <code>&lt;&lt; &gt;&gt;</code> in <code>MC4_8.tla</code>. Hence, we never enter the loop
we have just specified.</p>
<p>Actually, Apalache gives us a hint that it never tries some of the
cases:</p>
<pre><code>...
PASS #13: BoundedChecker
State 0: Checking 1 state invariants
Step 0: picking a transition out of 1 transition(s)
Step 1: Transition #0 is disabled
Step 1: Transition #1 is disabled
Step 1: Transition #2 is disabled
Step 1: Transition #3 is disabled
State 1: Checking 1 state invariants
Step 1: picking a transition out of 1 transition(s)
Step 2: Transition #0 is disabled
Step 2: Transition #1 is disabled
Step 2: Transition #2 is disabled
Step 2: Transition #4 is disabled
Step 2: picking a transition out of 1 transition(s)
...
</code></pre>
<p><strong>Digression: symbolic transitions.</strong> Internally, Apalache decomposes the
predicates <code>Init</code> and <code>Next</code> into independent pieces like <code>Init == Init$0 \/ Init$1</code> and <code>Next == Next$0 \/ Next$1 \/ Next$2 \/ Next$3</code>. If you want to see
how it is done, run Apalache with the options <code>--write-intermediate</code> and <code>--run-dir</code>:</p>
<pre><code class="language-sh">$ apalache-mc check --inv=Postcondition --write-intermediate=1 --run-dir=out MC4_8.tla
</code></pre>
<p>Check the file <code>out/intermediate/XX_OutTransitionFinderPass.tla</code>, which contains the
preprocessed specification that has <code>Init</code> and <code>Next</code> decomposed. You can find
a detailed explanation in the section on <a href="tutorials/../apalache/assignments-in-depth.html">Assignments in Apalache</a>.</p>
<h2><a class="header" href="#step-5-checking-postcondition-for-plenty-of-inputs" id="step-5-checking-postcondition-for-plenty-of-inputs">Step 5: Checking Postcondition for plenty of inputs</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch5.tla">BinSearch5.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC5_8.tla">MC5_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch5.tla.patch">BinSearch5.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC5_8.tla.patch">MC5_8.tla.patch</a>.</p>
<p>In this step, we are going to check the invariant <code>Postcondition</code> for all
possible input sequences and all input keys (for a fixed bit-width).</p>
<p>Create the file <code>MC5_8.tla</code> with the following contents:</p>
<pre><code class="language-tla">-------------------------- MODULE MC5_8 ---------------------------------------
\* an instance of BinSearch5 with all parameters fixed
EXTENDS Apalache

\* fix 8 bits
INT_WIDTH == 8

\* We do not fix INT_SEQ and INPUT_KEY.
\* Instead, we reason about all sequences with ConstInit.

CONSTANTS
    \* The input sequence.
    \*
    \* @type: Seq(Int);
    INPUT_SEQ,
    \* The key to search for.
    \*
    \* @type: Int;
    INPUT_KEY

\* introduce the variables to be used in BinSearch5
VARIABLES
    \* @type: Int;
    low,
    \* @type: Int;
    high,
    \* @type: Bool;
    isTerminated,
    \* @type: Int;
    returnValue

\* use an instance for the fixed constants
INSTANCE BinSearch5

==================
</code></pre>
<p>Note that we introduced <code>INPUT_SEQ</code> and <code>INPUT_KEY</code> as parameters again. We
cannot check <code>MC5_8.tla</code> just like that. If we try to check <code>MC5_8.tla</code>,
Apalache would complain again about a value missing for <code>INPUT_SEQ</code>.</p>
<p>To check the invariant for all sequences, we will use two advanced features
of Apalache: <a href="tutorials/../apalache/parameters.html#constinit-predicate">ConstInit predicate</a> and <a href="tutorials/../lang/apalache-operators.html#value-generators">Value generators</a>.</p>
<p><strong>ConstInit.</strong> This idiom allows us to initialize <code>CONSTANTS</code> with a TLA+
formula. Let us introduce the following operator definition in <code>MC5_8.tla</code>:</p>
<pre><code class="language-tla">ConstInit ==
    /\ INPUT_KEY \in Int
    \* Seq(Int) is a set of all sequences that have integers as elements
    /\ INPUT_SEQ \in Seq(Int) 
</code></pre>
<p>This is straightforward definition. However, it does not work in Apalache:</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Postcondition MC5_8.tla
...
MC5_8.tla:39:22-39:29: unsupported expression: Seq(_) produces an infinite set of unbounded sequences.
Checker has found an error
...
</code></pre>
<p>The issue with our definition of <code>ConstInit</code> is that it requires the model
checker to reason about the infinite set of sequences, namely, <code>Seq(Int)</code>.
Interestingly, the model checking does not complain about the expression
<code>INPUT_KEY \in Int</code>. The reason is that this expression requires the model
checker to reason about one integer, though it ranges over the infinite set of
integers.</p>
<p><strong>Value generators.</strong> Fortunately, this problem can be easily circumvented by
using Apalache <a href="tutorials/../lang/apalache-operators.html#value-generators">Value generators</a><sup class="footnote-reference"><a href="#generators">2</a></sup>.</p>
<p>Let us rewrite <code>ConstInit</code> in <code>MC5_8.tla</code> as follows:</p>
<pre><code class="language-tla">ConstInit ==
    /\ INPUT_KEY = Gen(1)
    /\ INPUT_SEQ = Gen(MAX_INT)
</code></pre>
<p>In this new version, we use the Apalache operator <code>Gen</code> to:</p>
<ul>
<li>produce an unrestricted integer to be used as a value of <code>INPUT_KEY</code> and</li>
<li>produce a sequence of integers to be used as a value of <code>INPUT_SEQ</code>. This
sequence is unrestricted, except its length is bounded with <code>MAX_INT</code>,
which is exactly what we need in our case study.</li>
</ul>
<p>The operator <code>Gen</code> introduces a data structure of proper type whose size is
bounded with the argument of <code>Gen</code>. For instance, the type of <code>INPUT_SEQ</code> is
the sequence of integers, and thus <code>Gen(MAX_INT)</code> produces an unrestricted
sequence of up to <code>MAX_INT</code> elements. This sequence is bound to the name
<code>INPUT_SEQ</code>. For details, see <a href="tutorials/../lang/apalache-operators.html#value-generators">Value generators</a>. This lets Apalache check
all instances of the data structure, without enumerating the instances!</p>
<p>By doing so, we are able to check the specification for all the inputs, when we
fix the bit width. To quickly get feedback from Apalache, we fix <code>INT_WIDTH</code> to 8 in the model <code>MC5_8.tla</code>.</p>
<div class="footnote-definition" id="generators"><sup class="footnote-definition-label">2</sup>
<p>If you know property-based testing, e.g., <a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>,
Apalache generators are inspired by this idea. In contrast to property-based
testing, an Apalache generator is not randomly producing values. Rather,
Apalache simply introduces an unconstrained data structure (e.g., a set, a
function, or a sequence) of the proper type. Hence, Apalache is reasoning about
all possible instances of this data structure, instead of reasoning about a
small set of randomly chosen instances.</p>
</div>
<p>Let us check <code>Postcondition</code> again:</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Postcondition MC5_8.tla
...
State 2: state invariant 0 violated. Check the counterexample in: 
  /[a long path]/counterexample1.tla
...
</code></pre>
<p>Let us inspect the counterexample:</p>
<pre><code class="language-tla">---------------------------- MODULE counterexample ----------------------------  
EXTENDS MC5_8

(* Constant initialization state *)
ConstInit == INPUT_KEY = -1 /\ INPUT_SEQ = &lt;&lt;0, -1&gt;&gt;

(* Initial state *)
State0 ==
  INPUT_KEY = -1
    /\ INPUT_SEQ = &lt;&lt;0, -1&gt;&gt;
    /\ high = 1
    /\ isTerminated = FALSE
    /\ low = 0
    /\ returnValue = 0

(* Transition 1 to State1 *)
State1 ==
  INPUT_KEY = -1
    /\ INPUT_SEQ = &lt;&lt;0, -1&gt;&gt;
    /\ high = -1
    /\ isTerminated = FALSE
    /\ low = 0
    /\ returnValue = 0

(* Transition 3 to State2 *)
State2 ==
  INPUT_KEY = -1
    /\ INPUT_SEQ = &lt;&lt;0, -1&gt;&gt;
    /\ high = -1
    /\ isTerminated = TRUE
    /\ low = 0
    /\ returnValue = -1
...
</code></pre>
<p>Is it a real issue? It is, but it is not the issue of
the search, rather our invariant <code>Postcondition</code> is imprecise.</p>
<h2><a class="header" href="#step-5b-fixing-the-postcondition" id="step-5b-fixing-the-postcondition">Step 5b: Fixing the postcondition</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch5.tla">BinSearch5.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC5_8.tla">MC5_8.tla</a>.</p>
<p>If we check our source of truth, that is, the Java documentation in
<a href="https://github.com/openjdk/jdk/blob/d7f31d0d53bfec627edc83ceb75fc6202891e186/src/java.base/share/classes/java/util/Arrays.java#L1662-L1698">Arrays.java in OpenJDK</a>, we will see the following sentences:</p>
<pre><code>The range must be sorted (as by the {@link #sort(int[], int, int)} method)
prior to making this call. If it is not sorted, the results are undefined.
If the range contains multiple elements with the specified value, there is
no guarantee which one will be found.
</code></pre>
<p>It is quite easy to add this constraint <sup class="footnote-reference"><a href="#no-pre">3</a></sup>. This is where TLA+ starts to
shine:</p>
<pre><code class="language-tla">InputIsSorted ==
    \* The most straightforward way to specify sortedness
    \* is to use two quantifiers,
    \* but that would produce O(Len(INPUT_SEQ)^2) constraints.
    \* Here, we write it a bit smarter.
    \A i \in DOMAIN INPUT_SEQ:
        i + 1 \in DOMAIN INPUT_SEQ =&gt;
          INPUT_SEQ[i] &lt;= INPUT_SEQ[i + 1]

...

\* What we expect from the search when it is finished.
PostconditionSorted ==
    isTerminated =&gt; (~InputIsSorted \/ ReturnValueIsCorrect)
</code></pre>
<p>If we check <code>PostconditionSorted</code>, we do not get any error after 10 steps:</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=PostconditionSorted MC5_8.tla
...
The outcome is: NoError
Checker reports no error up to computation length 10
</code></pre>
<p>It takes some time to explore all executions of length up to 10 steps, for all
input sequences of length up to <code>2^7 - 1</code> arbitrary integers. If we think about
it, the model checker managed to crunch infinitely many numbers in several
hours. Not bad.</p>
<p><em>Exercise.</em> If you are impatient, you can check <code>PostconditionSorted</code> for the
configuration that has integer width of 4 bits. It takes only a few seconds to
explore all executions.</p>
<div class="footnote-definition" id="no-pre"><sup class="footnote-definition-label">3</sup>
<p>Instead of checking whether <code>INPUT_SEQ</code> is sorted in the
post-condition, we could restrict the constant <code>INPUT_SEQ</code> to be sorted in
every execution. That would effectively move this constraint into the
pre-condition of the search. Had we done that, we would not be able to observe
the behavior of the search on the unsorted inputs. An important property is
whether the search is terminating on all inputs.</p>
</div>
<h2><a class="header" href="#step-6-checking-termination-and-progress" id="step-6-checking-termination-and-progress">Step 6: Checking termination and progress</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch6.tla">BinSearch6.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC6_8.tla">MC6_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch6.tla.patch">BinSearch6.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC6_8.tla.patch">MC6_8.tla.patch</a>.</p>
<p>Actually, we do not need 10 steps to check termination for the case <code>INT_WIDTH = 8</code>. If you recall the complexity of the binary search, it needs
<code>ceil(log2(Len(INPUT_SEQ)))</code> steps to terminate.</p>
<p>To check this property, we add the number of steps as a variable in
<code>BinSearch6.tla</code> and in <code>MC6_8.tla</code>:</p>
<pre><code class="language-tla">VARIABLES
    ...
    \* The number of executed steps.
    \* @type: Int;
    nSteps
</code></pre>
<p>Also, we update <code>Init</code> and <code>Next</code> in <code>BinSearch6.tla</code> as follows:</p>
<pre><code class="language-tla">Init ==
    ...
    /\ nSteps = 0

Next ==
    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14
        /\ nSteps' = nSteps + 1
        /\ LET mid == (low + high) \div 2 IN
         ...
      ELSE          \* line 16
        /\ isTerminated' = TRUE
        /\ returnValue' = -(low + 1)
        /\ UNCHANGED &lt;&lt;low, high, nSteps&gt;&gt;
    ELSE            \* isTerminated
      UNCHANGED &lt;&lt;low, high, returnValue, isTerminated, nSteps&gt;&gt;
</code></pre>
<p>Having <code>nSteps</code>, we can write the <code>Termination</code> property:</p>
<pre><code class="language-tla">\* We know the exact number of steps to show termination.
Termination ==
    (nSteps &gt;= INT_WIDTH) =&gt; isTerminated
</code></pre>
<p>Let us check <code>Termination</code>:</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Termination MC6_8.tla
...
Checker reports no error up to computation length 10
It took me 0 days  0 hours  0 min 19 sec
</code></pre>
<p>Even if did not know precisely complexity of the binary search, we could
write a simpler property, which demonstrates progress of the search:</p>
<pre><code class="language-tla">Progress ==
    ~isTerminated' =&gt; (low' &gt; low \/ high' &lt; high)
</code></pre>
<p>It takes about 10 seconds to check <code>Progress</code> as well.</p>
<h2><a class="header" href="#step-7-fixed-width-integers" id="step-7-fixed-width-integers">Step 7: Fixed-width integers</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch7.tla">BinSearch7.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC7_8.tla">MC7_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch7.tla.patch">BinSearch7.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC7_8.tla.patch">MC7_8.tla.patch</a>.</p>
<p>Do you recall that our specification of the loop had a caveat? Let us have a
look at this piece of the specification again:</p>
<pre><code class="language-tla">    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14
        /\ nSteps' = nSteps + 1
        /\ LET mid == (low + high) \div 2 IN
           LET midVal == INPUT_SEQ[mid + 1] IN
            \//\ midVal &lt; INPUT_KEY \* lines 9-10
              /\ low' = mid + 1
              /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
            \//\ midVal &gt; INPUT_KEY \* lines 11-12
              /\ high' = mid -1
              /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
            \//\ midVal = INPUT_KEY \* lines 13-14
              /\ returnValue' = mid
              /\ isTerminated' = TRUE
              /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
</code></pre>
<p>You can see that all arithmetic operations are performed over TLA+ integers,
that is, unbounded integers. We have to implement fixed-width integers ourselves.
Fortunately, we do not have to implement the whole set of integer operators,
but only the addition over signed integers, which has a potential to overflow.
To this end, we have to recall how signed integers are represented in modern
computers, see <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two's complement</a>. Fortunately, we do not have to worry about
an efficient implementation of integer addition. We simply use addition over
unbounded integers to implement addition over fixed-width integers:</p>
<pre><code class="language-tla">\* Addition over fix-width integers.
IAdd(i, j) ==
    \* add two integers with unbounded arithmetic
    LET res == i + j IN
    IF MIN_INT &lt;= res /\ res &lt;= MAX_INT
    THEN res
    ELSE \* wrap the result over 2^INT_WIDTH (probably redundant)
        LET wrapped == res % MAX_UINT IN
        IF wrapped &lt;= MAX_INT
        THEN wrapped    \* a positive integer, return as is
        ELSE \* complement the value to represent it with an unbounded integer
          -(MAX_UINT - wrapped)
</code></pre>
<p>Having defined <code>IAdd</code>, we replace addition over unbounded integers with <code>IAdd</code>:</p>
<pre><code class="language-tla">Next ==
    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14
        /\ nSteps' = nSteps + 1
        /\ LET mid == IAdd(low, high) \div 2 IN
           LET midVal == INPUT_SEQ[mid + 1] IN
            \//\ midVal &lt; INPUT_KEY \* lines 9-10
              /\ low' = IAdd(mid, 1)
              /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
            \//\ midVal &gt; INPUT_KEY \* lines 11-12
              /\ high' = IAdd(mid, - 1)
              /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
            \//\ midVal = INPUT_KEY \* lines 13-14
              /\ returnValue' = mid
              /\ isTerminated' = TRUE
              /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
      ELSE          \* line 16
        ...
</code></pre>
<p>This finally gives us a specification that faithfully represents the Java code
of <code>binarySearch</code>. Now we can check all expected properties once again:</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=PostconditionSorted MC7_8.tla
...
State 2: state invariant 0 violated.
...
Total time: 2.786 sec
</code></pre>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Progress MC7_8.tla
...
State 1: action invariant 0 violated.
...
Total time: 2.935 sec
</code></pre>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Termination MC7_8.tla
...
State 8: state invariant 0 violated.
...
Total time: 39.540 sec
</code></pre>
<p>As we can see, all of our invariants are violated. They all demonstrate the
issue that is caused by the integer overflow!</p>
<h2><a class="header" href="#step-8-checking-the-boundaries" id="step-8-checking-the-boundaries">Step 8: Checking the boundaries</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch8.tla">BinSearch8.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC8_8.tla">MC8_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch8.tla.patch">BinSearch8.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC8_8.tla.patch">MC8_8.tla.patch</a>.</p>
<p>As we have seen in Step 7, the cause of all errors in <code>PostconditionSorted</code>,
<code>Termination</code>, and <code>Progress</code> is that the addition <code>low + high</code> overflows and
thus the expression <code>INPUT_SEQ[mid + 1]</code> accesses <code>INPUT_SEQ</code> outside of its
domain.</p>
<p>Why did Apalache not complain about access outside of the domain? Its behavior
is actually consistent with <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> (p. 302):</p>
<blockquote>
<p>A function <em>f</em> has a domain DOMAIN <em>f</em>, and the value of <em>f</em>[<em>v</em>] is
specified only if <em>v</em> is an element of DOMAIN <em>f</em>.</p>
</blockquote>
<p>Hence, Apalache returns some value of a proper type, if <code>v</code> is outside of
<code>DOMAIN f</code>. As we have seen in Step 7, such a value would usually show up in a
counterexample. In the future, Apalache will probably have an automatic check
for out-of-domain access. For the moment, we can write such a check as a state
invariant. By propagating the conditions from <code>INPUT_SEQ[mid + 1]</code> up in <code>Next</code>,
we construct the following invariant:</p>
<pre><code class="language-tla">\* Make sure that INPUT_SEQ is accessed within its bounds
InBounds ==
  LET mid == IAdd(low, high) \div 2 IN
  \* collect the conditions of IF-THEN-ELSE
  ~isTerminated =&gt;
    ((low &lt;= high) =&gt;
      (mid + 1) \in DOMAIN INPUT_SEQ)
</code></pre>
<p>Apalache finds a violation of this invariant in a few seconds:</p>
<pre><code>$ apalache-mc check --cinit=ConstInit --inv=InBounds MC8_8.tla
...
State 1: state invariant 0 violated.
...
Total time: 3.411 sec
</code></pre>
<p>If we check <code>counterexample1.tla</code>, it contains the following values for <code>low</code>
and <code>high</code>:</p>
<pre><code>State0 ==
    /\ high = 116
    /\ low = 0
    ...

State1 ==
    /\ high = 116
    /\ low = 59
    ...
</code></pre>
<p>In state 1, we have <code>low + high = 116 + 59 &gt; 2^7</code>. Since we have <code>INT_WIDTH = 8</code>, we have <code>IAdd(116, 59) = -81</code>.</p>
<h2><a class="header" href="#step-9-fixing-the-access-bug" id="step-9-fixing-the-access-bug">Step 9: Fixing the access bug</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch9.tla">BinSearch9.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC9_8.tla">MC9_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch9.tla.patch">BinSearch9.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC9_8.tla.patch">MC9_8.tla.patch</a>.</p>
<p>Let us apply the fix that was proposed by Joshua Bloch in <a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Nearly All Binary
Searches and Mergesorts are Broken</a>. Namely, we update this line of
<code>BinSearch8.tla</code>:</p>
<pre><code class="language-tla">        /\ LET mid == IAdd(low, high) \div 2 IN
           LET midVal == INPUT_SEQ[mid + 1] IN
</code></pre>
<p>The fix is as follows:</p>
<pre><code class="language-tla">        /\ LET mid == IAdd(low, IAdd(high, -low) \div 2) IN
           LET midVal == INPUT_SEQ[mid + 1] IN
</code></pre>
<p>We also update <code>InBounds</code> as follows:</p>
<pre><code class="language-tla">\* Make sure that INPUT_SEQ is accessed within its bounds
InBounds ==
  LET mid == IAdd(low, IAdd(high, -low) \div 2) IN
...
</code></pre>
<p>Now we check the four invariants: <code>InBounds</code>, <code>PostconditionSorted</code>,
<code>Termination</code>, and <code>Progress</code>.</p>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=InBounds MC9_8.tla
...
The outcome is: NoError
...
Total time: 76.352 sec
</code></pre>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Progress MC9_8.tla
...
The outcome is: NoError
...
Total time: 63.578 sec
</code></pre>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=Termination MC9_8.tla
...
The outcome is: NoError
...
Total time: 72.682 sec
</code></pre>
<pre><code class="language-sh">$ apalache-mc check --cinit=ConstInit --inv=PostconditionSorted MC9_8.tla
...
The outcome is: NoError
...
Total time: 2154.646 sec
</code></pre>
<p><em>Exercise:</em> It takes quite a bit of time to check <code>PostconditionSorted</code>.
Change <code>INT_WIDTH</code> to 6 and check all these invariants once again. Observe that
it takes Apalache significantly less time.</p>
<p><em>Exercise:</em> Change <code>INT_WIDTH</code> to 16 and check all these invariants once again.
Observe that it takes Apalache significantly more time.</p>
<h2><a class="header" href="#step-10-beautifying-the-specification" id="step-10-beautifying-the-specification">Step 10: Beautifying the specification</a></h2>
<p><em>Source files for this step</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch10.tla">BinSearch10.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC10_8.tla">MC10_8.tla</a>.</p>
<p><em>Diffs</em>:
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch10.tla.patch">BinSearch10.tla.patch</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC10_8.tla.patch">MC10_8.tla.patch</a>.</p>
<p>We have reached our goals: TLA+ and Apalache helped us in finding the access
bug and showing that its fix works. Now it is time to look back at the
specification and make it easier to read.</p>
<p>Let us have a look at our definition of <code>Next</code>:</p>
<pre><code class="language-tla">\* Computation step (lines 5-16)
Next ==
    IF ~isTerminated
    THEN IF low &lt;= high
      THEN          \* lines 6-14
        /\ nSteps' = nSteps + 1
        /\ LET mid == IAdd(low, IAdd(high, -low) \div 2) IN
           LET midVal == INPUT_SEQ[mid + 1] IN
            \//\ midVal &lt; INPUT_KEY \* lines 9-10
              /\ low' = IAdd(mid, 1)
              /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
            \//\ midVal &gt; INPUT_KEY \* lines 11-12
              /\ high' = IAdd(mid, - 1)
              /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
            \//\ midVal = INPUT_KEY \* lines 13-14
              /\ returnValue' = mid
              /\ isTerminated' = TRUE
              /\ UNCHANGED &lt;&lt;low, high&gt;&gt;
      ELSE          \* line 16
        /\ isTerminated' = TRUE
        /\ returnValue' = -(low + 1)
        /\ UNCHANGED &lt;&lt;low, high, nSteps&gt;&gt;
    ELSE            \* isTerminated
      UNCHANGED &lt;&lt;low, high, returnValue, isTerminated, nSteps&gt;&gt;
</code></pre>
<p><code>Next</code> contains a massive expression. We can decompose it nicely in smaller
pieces:</p>
<pre><code class="language-tla">\* loop iteration
LoopIteration ==
    /\ ~isTerminated
    /\ low &lt;= high      \* lines 6-14
    /\ nSteps' = nSteps + 1
    /\ LET mid == IAdd(low, IAdd(high, -low) \div 2) IN
       LET midVal == INPUT_SEQ[mid + 1] IN
          \//\ midVal &lt; INPUT_KEY \* lines 9-10
            /\ low' = IAdd(mid, 1)
            /\ UNCHANGED &lt;&lt;high, returnValue, isTerminated&gt;&gt;
          \//\ midVal &gt; INPUT_KEY \* lines 11-12
            /\ high' = IAdd(mid, - 1)
            /\ UNCHANGED &lt;&lt;low, returnValue, isTerminated&gt;&gt;
          \//\ midVal = INPUT_KEY \* lines 13-14
            /\ returnValue' = mid
            /\ isTerminated' = TRUE
            /\ UNCHANGED &lt;&lt;low, high&gt;&gt;

\* loop termination
LoopExit ==
    /\ ~isTerminated        \* line 16
    /\ low &gt; high
    /\ isTerminated' = TRUE
    /\ returnValue' = -(low + 1)
    /\ UNCHANGED &lt;&lt;low, high, nSteps&gt;&gt;

\* instead of terminating the computation, we keep variables unchanged
StutterOnTermination ==
    /\ isTerminated
    /\ UNCHANGED &lt;&lt;low, high, returnValue, isTerminated, nSteps&gt;&gt;

\* Computation step (lines 5-16)
Next ==
    \/ LoopIteration
    \/ LoopExit
    \/ StutterOnTermination
</code></pre>
<p>The definitions <code>LoopIteration</code>, <code>LoopExit</code>, and <code>StutterOnTermination</code> are
called actions in TLA+. It is usually a good idea to decompose a large <code>Next</code>
formula into actions. Normally, an action contains assignments to all primed
variables.</p>
<h2><a class="header" href="#discussion" id="discussion">Discussion</a></h2>
<p>The final specifications can be found in
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/BinSearch10.tla">BinSearch10.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bin-search/MC10_8.tla">MC10_8.tla</a>.</p>
<p>In this tutorial we have shown how to:</p>
<ul>
<li>Specify the behavior of a sequential algorithm (binary search).</li>
<li>Specify invariants that check safety and termination.</li>
<li>Take into account the specifics of a computer architecture (fixed bit
width).</li>
<li>Automatically find examples of simultaneous invariant violation.</li>
<li>Efficiently check the expected properties against our specification.</li>
</ul>
<p>We have written our specification for parameterized bit width. This lets us
check the invariants relatively quickly and get fast feedback from the model
checker. We chose a bit width of 8, a non-trivial value for which
Apalache terminates within reasonable time. Importantly, the specification
for the bit width of 32 stays the same; we only have to change <code>INT_WIDTH</code>. Of
course, Apalache reaches its limits when we set <code>INT_WIDTH</code> to 16 or 32. In
these cases, it has to reason about all sequences of length up to 32,767
elements or 2 Billion elements, respectively!</p>
<p>Apalache gives us a good idea whether the properties of our
binary search specification hold true. However, it does not give us an ultimate proof of correctness for
Java integers. If you need such a proof, you should probably use TLAPS. Check
the paper on <a href="http://lamport.azurewebsites.net/tla/proving-safety.pdf">Proving Safety Properties</a> by Leslie Lamport.</p>
<p>This tutorial is rather long. This is because we wanted to show the evolution
of a TLA+ specification, as we were writing it and checking it with Apalache.
There are many different styles of writing TLA+ specifications. One of our
goals was to demonstrate the incremental approach to specification writing. In
fact, this approach is not very different from incremental development of
programs in the spirit of <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a>. It took us 2-3 hours to
iteratively develop a specification that is similar to the one demonstrated in
this tutorial.</p>
<p>This tutorial touches upon the basics of TLA+ and Apalache. For instance, we
did not discuss non-determinism, as our specification is entirely
deterministic. We will demonstrate advanced features in future tutorials.</p>
<p>If you are experiencing a problem with Apalache, feel free to <a href="https://github.com/informalsystems/apalache/issues">open an issue</a>
or drop us a message on <a href="https://informal-systems.zulipchat.com/login/#narrow/stream/265309-apalache">Zulip chat</a>.</p>
<h1><a class="header" href="#tutorial-on-the-snowcat-type-checker" id="tutorial-on-the-snowcat-type-checker">Tutorial on the Snowcat❄🐱 Type Checker</a></h1>
<p><strong>Difficulty: Blue trail – Easy</strong></p>
<p><strong>Revision:</strong> August 24, 2022</p>
<p>In this tutorial, we introduce the Snowcat ❄ 🐱 type checker.  We
give concrete steps on running the type checker and annotating a specification
with types.</p>
<p>This tutorial uses Type System 1.2, which guarantees safe record access. To see
how to upgrade to Type System 1.2, check <a href="tutorials/../HOWTOs/howto-write-type-annotations.html#recipe9">Migrating to Type System 1.2</a>.</p>
<h2><a class="header" href="#related-documents-1" id="related-documents-1">Related documents</a></h2>
<ul>
<li><a href="tutorials/../adr/002adr-types.html">ADR002</a> that introduces Type Systems 1 and 1.2, used by Snowcat.</li>
<li>A more technical <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type annotations</a>.</li>
<li><a href="tutorials/../adr/004adr-annotations.html">ADR004</a> that introduces Java-like annotations in TLA+ comments.</li>
</ul>
<h2><a class="header" href="#setup-1" id="setup-1">Setup</a></h2>
<p>We assume that you have Apalache installed. If not, check the manual page on
<a href="tutorials/../apalache/installation/index.html">Apalache installation</a>. The minimal required version is 0.29.0.</p>
<h2><a class="header" href="#running-example-lamports-mutex" id="running-example-lamports-mutex">Running example: Lamport's mutex</a></h2>
<p>As a running example, we are using the specification of <a href="https://github.com/tlaplus/Examples/blob/master/specifications/lamport_mutex">Lamport's Mutex</a>
(written by <a href="https://members.loria.fr/Stephan.Merz/">Stephan Merz</a>). We recommend to reproduce the steps in this
tutorial. So, go ahead and download the specification file
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/lamport_mutex/LamportMutex.tla">LamportMutex.tla</a>. We will add type annotations to this file. Let's rename
<code>LamportMutex.tla</code> to <code>LamportMutexTyped.tla</code>.</p>
<h2><a class="header" href="#step-1-running-snowcat" id="step-1-running-snowcat">Step 1: Running Snowcat</a></h2>
<p>Before we start writing any type annotations, let's run the type checker and
see, whether it complains:</p>
<pre><code class="language-sh">$ apalache-mc typecheck LamportMutexTyped.tla
</code></pre>
<p>The tool output is a bit verbose. Below, you can see the important lines of the
output:</p>
<pre><code>...
PASS #1: TypeCheckerSnowcat
 &gt; Running Snowcat .::.                                           
Typing input error: Expected a type annotation for VARIABLE clock
... 
</code></pre>
<h2><a class="header" href="#step-2-annotating-variables-clock-req-ack-crit" id="step-2-annotating-variables-clock-req-ack-crit">Step 2: Annotating variables clock, req, ack, crit</a></h2>
<p>In Step 1, Snowcat complained about the name <code>clock</code>. The reason
for that is very simple: <code>clock</code> is declared as a variable, but Snowcat 
does not find a type annotation for it.</p>
<p>The comment next to the declaration of <code>clock</code> does not tell us precisely
what <code>clock</code> should be:</p>
<pre><code>  clock,    \* local clock of each process
</code></pre>
<p>Let's dig a bit further and check <code>TypeOK</code>, which is usually a good source of
type hints in untyped specifications:</p>
<pre><code class="language-tla">TypeOK ==
     (* clock[p] is the local clock of process p *)
  /\ clock \in [Proc -&gt; Clock]
     (* req[p][q] stores the clock associated with request from q received by p, 0 if none *)
  /\ req \in [Proc -&gt; [Proc -&gt; Nat]]
     (* ack[p] stores the processes that have ack'ed p's request *)
  /\ ack \in [Proc -&gt; SUBSET Proc]
     (* network[p][q]: queue of messages from p to q -- pairwise FIFO communication *)
  /\ network \in [Proc -&gt; [Proc -&gt; Seq(Message)]]
     (* set of processes in critical section: should be empty or singleton *)
  /\ crit \in SUBSET Proc
</code></pre>
<p>This is better, but we have to figure out the types of <code>Proc</code> and <code>Clock</code>.
Let's have a look at their definitions.</p>
<pre><code class="language-tla">Proc == 1 .. N
Clock == Nat \ {0}
</code></pre>
<p>From the definitions of <code>Proc</code> and <code>Clock</code>, it is clear that they are both
subsets of integers. We could annotate these two definitions with the type
<code>Set(Int)</code>, but this is not necessary, since Snowcat will infer these types
itself.</p>
<p>Together with <code>TypeOK</code>, this gives us enough information to annotate all but
one variable (we will annotate the variable <code>network</code> later):</p>
<pre><code class="language-tla">VARIABLES
  \* @type: Int -&gt; Int;
  clock,    \* local clock of each process
  \* @type: Int -&gt; (Int -&gt; Int);
  req,      \* requests received from processes (clock transmitted with request)
  \* @type: Int -&gt; Set(Int);
  ack,      \* acknowledgements received from processes
  \* @type: Set(Int);
  crit,     \* set of processes in critical section
</code></pre>
<p>In our type annotations:</p>
<ul>
<li>
<p><code>clock</code> belongs to the set <code>[Proc -&gt; Clock]</code>. Hence, it is a function of
integers to integers, that is, <code>Int -&gt; Int</code>.</p>
</li>
<li>
<p><code>req</code> belongs to the set <code>[Proc -&gt; [Proc -&gt; Nat]]</code>. Hence, it is a function
of integers to functions of integers to integers, that is, <code>Int -&gt; (Int -&gt; Int)</code>.</p>
</li>
<li>
<p><code>ack</code> belongs to the set <code>[Proc -&gt; SUBSET Proc]</code>. Hence, it is a function of
integers to sets of integers, that is, <code>Int -&gt; Set(Int)</code>.</p>
</li>
<li>
<p><code>crit</code> is a subset of <code>Proc</code>, so it is a set of integers, that is,
<code>Set(Int)</code>.</p>
</li>
</ul>
<p><strong>Note</strong>: We place the annotation for <code>clock</code> between the keyword <code>VARIABLES</code>
and <code>clock</code>, not before the keyword <code>VARIABLES</code>. Similarly, we added a type
annotation immediately above every other variable name.</p>
<p>We used the one-line TLA+ comment for <code>clock</code>:</p>
<pre><code class="language-tla">\* @type: Int -&gt; Int;
</code></pre>
<p>Alternatively, we could use the multi-line comment:</p>
<pre><code class="language-tla">(*
 Clock is a function of integers to integers.

 @type: Int -&gt; Int;
 *)
</code></pre>
<p><strong>Note</strong>: Importantly, every type annotation must end with a semi-colon <code>;</code>.</p>
<p>Let's run the type checker again:</p>
<pre><code class="language-sh">$ apalache-mc typecheck LamportMutexTyped.tla
...
Typing input error: Expected a type annotation for VARIABLE network
</code></pre>
<p>Not surprisingly, the type checker tells us that we still have to annotate the
variable <code>network</code>.</p>
<h2><a class="header" href="#step-3-annotating-the-variable-network" id="step-3-annotating-the-variable-network">Step 3: Annotating the variable network</a></h2>
<p>Let's have a look at the operator <code>TypeOK</code> again:</p>
<pre><code class="language-tla">TypeOK ==
     (* clock[p] is the local clock of process p *)
  /\ clock \in [Proc -&gt; Clock]
     (* req[p][q] stores the clock associated with request from q received by p, 0 if none *)
  /\ req \in [Proc -&gt; [Proc -&gt; Nat]]
     (* ack[p] stores the processes that have ack'ed p's request *)
  /\ ack \in [Proc -&gt; SUBSET Proc]
     (* network[p][q]: queue of messages from p to q -- pairwise FIFO communication *)
  /\ network \in [Proc -&gt; [Proc -&gt; Seq(Message)]]
     (* set of processes in critical section: should be empty or singleton *)
  /\ crit \in SUBSET Proc
</code></pre>
<p>From this we can see that <code>network</code> is a function of integers to a function of
integers to a sequence of messages. So its type should look like:</p>
<pre><code class="language-tla">Int -&gt; (Int -&gt; Seq(/* message type */))
</code></pre>
<p>But what is the message type? To find out, we have to continue our archaeology
trip and check the definition of <code>Message</code> and related operators:</p>
<pre><code class="language-tla">ReqMessage(c) == [type |-&gt; &quot;req&quot;, clock |-&gt; c]
AckMessage == [type |-&gt; &quot;ack&quot;, clock |-&gt; 0]
RelMessage == [type |-&gt; &quot;rel&quot;, clock |-&gt; 0]

Message == {AckMessage, RelMessage} \union {ReqMessage(c) : c \in Clock}
</code></pre>
<p>From these four definitions, we can see that <code>Messages</code> is a set of records
that have two fields: the field <code>type</code> that should be a string, and the field
<code>clock</code> that should be an integer. In Apalache, we write such a record type as:</p>
<pre><code class="language-tla">{ type: Str, clock: Int }
</code></pre>
<p>Hence, the type of <code>network</code> should be:</p>
<pre><code class="language-tla">Int -&gt; (Int -&gt; Seq({ type: Str, clock: Int }))
</code></pre>
<p>We could write it as above, but that type is a bit hard to read. Hence, we
split it into two parts: the type alias <code>message</code> that defines the type of
messages, and the type of <code>network</code> that refers to the type alias <code>message</code>.
This can be done in the following way:</p>
<pre><code class="language-tla">  \* @typeAlias: message = {
  \*     type: Str,
  \*     clock: Int
  \* };
  \* @type: Int -&gt; (Int -&gt; Seq($message));
  network   \* messages sent but not yet received
</code></pre>
<p><strong>Note:</strong> We are lucky that <code>ReqMessage</code>, <code>AckMessage</code>, and <code>RelMessage</code> are
producing records of the same shape. In some specifications, the shapes of
records differ, while these records should be added to the same set. This is a
bit problematic for the type checker, as it expects set elements to have the
same type. In this case, we have three options:</p>
<ul>
<li>
<p>Slightly rewrite the specification to homogenize records,</p>
</li>
<li>
<p>Partition the set of messages into several sets, see <a href="tutorials/../idiomatic/003record-sets.html">Idiom 15</a>, or</p>
</li>
<li>
<p>Use variants. This is a more advanced topic, see the
<a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type annotations</a>.</p>
</li>
</ul>
<p>Now we should run the type checker again:</p>
<pre><code class="language-sh">$ apalache-mc typecheck LamportMutexTyped.tla
...
Typing input error: Expected a type annotation for CONSTANT maxClock
</code></pre>
<p>The type checker is still not happy: We have not annotated <code>CONSTANTS</code>.</p>
<h2><a class="header" href="#step-4-annotating-constants" id="step-4-annotating-constants">Step 4: Annotating constants</a></h2>
<p>Now we have to figure out the types of the constants: <code>N</code> and <code>maxClock</code>.  This
is fairly easy, as these constants are accompanied by the two assumptions:</p>
<pre><code class="language-tla">ASSUME NType == N \in Nat
ASSUME maxClockType == maxClock \in Nat
</code></pre>
<p>From these assumptions, we can conclude that both <code>N</code> and <code>maxClock</code> are
integers. We add the type annotations:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Int;
    N,
    \* @type: Int;
    maxClock
</code></pre>
<p>Let's run the type checker once again:</p>
<pre><code class="language-sh">$ apalache-mc typecheck LamportMutexTyped.tla
...
 &gt; All expressions are typed
Type checker [OK]
</code></pre>
<p>Snowcat is happy, and so we are too!</p>
<h1><a class="header" href="#discussion-1" id="discussion-1">Discussion</a></h1>
<p>To see the complete code, check <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/LamportMutexTyped.tla">LamportMutexTyped.tla</a>. We have added seven
type annotations for 184 lines of code. Not bad.</p>
<p>It was relatively easy to figure out the types of constants and variables in
our example, though it required some exploration of the specification.</p>
<p><em>As a rule, you always have to annotate constants and variables with types</em>.</p>
<p>Hence, we did not have to run the type checker seven times to see the error
messages.  The type annotations are useful on its own, since we do not have to
traverse the spec to figure out the types of constants and states. Our more
engineering-oriented peers find these annotations to be quite important.</p>
<p>Sometimes, the type checker cannot find a unique type of an expression. This
usually happens when you declare an operator of a parameter that can be: a
function, a tuple, a record, or a sequence (or a subset of these four types
that has at least two elements). For instance, here is a definition from
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/GameOfLifeTyped.tla">GameOfLifeTyped.tla</a>:</p>
<pre><code class="language-tla">Pos ==
    { &lt;&lt;x, y&gt;&gt;: x, y \in 1..N }
</code></pre>
<p>Although it is absolutely clear that <code>x</code> and <code>y</code> have the type <code>Int</code>,
the type of <code>&lt;&lt;x, y&gt;&gt;</code> is ambiguous. This expression can either be
a tuple <code>&lt;&lt;Int, Int&gt;&gt;</code>, or a sequence <code>Seq(Int)</code>. In this case, we have to
help the type checker by annotating the operator definition:</p>
<pre><code class="language-tla">\* @type: () =&gt; Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<p>Since it is common to have operators that take no arguments, Snowcat supports
the following syntax sugar for operators without arguments:</p>
<pre><code class="language-tla">\* @type: Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>For more advanced type annotations, check the following examples:</p>
<ul>
<li><a href="https://github.com/informalsystems/apalache/blob/main/test/tla/CigaretteSmokersTyped.tla">CigaretteSmokersTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/main/test/tla/CarTalkPuzzleTyped.tla">CarTalkPuzzleTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/main/test/tla/QueensTyped.tla">QueensTyped.tla</a>.</li>
<li><a href="https://github.com/informalsystems/apalache/blob/main/test/tla/TwoPhaseTyped.tla">TwoPhaseTyped.tla</a>.</li>
</ul>
<p>We have not discussed type aliases, which are a more advanced feature of the
type checker. To learn about type aliases, see <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type
annotations</a>.</p>
<p>If you are experiencing a problem with Snowcat, feel free to <a href="https://github.com/informalsystems/apalache/issues">open an issue</a>
or drop us a message on <a href="https://informal-systems.zulipchat.com/login/#narrow/stream/265309-apalache">Zulip chat</a>.</p>
<h1><a class="header" href="#tutorial-on-checking-pluscal-specifications-with-apalache" id="tutorial-on-checking-pluscal-specifications-with-apalache">Tutorial on checking PlusCal specifications with Apalache</a></h1>
<p><strong>Difficulty: Blue trail – Easy</strong></p>
<p>In this short tutorial, we show how to annotate a <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Bakery-Boulangerie/Bakery.tla">PlusCal specification</a> of
the Bakery algorithm, to check it with Apalache. In particular, we check mutual
exclusion by <em>bounded model checking</em> (which considers only bounded executions).
Moreover, we automatically prove mutual exclusion for unbounded executions by
<em>induction</em>.</p>
<p>We only focus on the part
related to Apalache. If you want to understand the Bakery algorithm and its
specification, check the comments in the original <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Bakery-Boulangerie/Bakery.tla">PlusCal specification</a>.</p>
<h2><a class="header" href="#setup-2" id="setup-2">Setup</a></h2>
<p>We assume that you have Apalache installed. If not, check the manual page on
<a href="tutorials/../apalache/installation/index.html">Apalache installation</a>. The minimal required version is 0.22.0.</p>
<p>We provide all source files referenced in this tutorial as a <a href="https://download-directory.github.io/?url=https://github.com/informalsystems/apalache/tree/main/test/tla/bakery-pluscal">ZIP archive</a>
download. We still recommend that you follow along typing the TLA+ examples
yourself.</p>
<h2><a class="header" href="#running-example-bakery" id="running-example-bakery">Running example: Bakery</a></h2>
<p>We start with the <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Bakery-Boulangerie/Bakery.tla">PlusCal specification</a> of the <a href="https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm">Bakery algorithm</a>. This
specification has been checked with the model checker <a href="https://github.com/tlaplus/tlaplus/">TLC</a>.  Moreover,
<a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> has proved safety of this algorithm with the <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<h2><a class="header" href="#step-0-remove-the-tlaps-proof" id="step-0-remove-the-tlaps-proof">Step 0: Remove the TLAPS proof</a></h2>
<p>Since we are not interested in the TLAPS proof, we copy <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Bakery-Boulangerie/Bakery.tla">Bakery.tla</a> to
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bakery-pluscal/BakeryWoTlaps.tla">BakeryWoTlaps.tla</a> and modify it as follows:</p>
<ul>
<li>
<p>Remove <code>TLAPS</code> from the list of extended modules</p>
<pre><code class="language-tla">EXTENDS Naturals
</code></pre>
</li>
<li>
<p>Remove the theorem and its proof:</p>
<pre><code class="language-tla">THEOREM Spec =&gt; []MutualExclusion
...
</code></pre>
</li>
</ul>
<h2><a class="header" href="#step-1-add-a-module-with-type-annotations" id="step-1-add-a-module-with-type-annotations">Step 1: Add a module with type annotations</a></h2>
<p>Let us check the types of <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bakery-pluscal/BakeryWoTlaps.tla">BakeryWoTlaps.tla</a> with Apalache:</p>
<pre><code class="language-sh">$ apalache-mc typecheck BakeryWoTlaps.tla
...
Typing input error: Expected a type annotation for VARIABLE max
</code></pre>
<p>The type checker complains about missing type annotations. See the <a href="tutorials/./snowcat-tutorial.html">Tutorial on
Snowcat</a> for details. When we try to add type annotations to the variables,
we run into an issue. Indeed, the variables are declared with the PlusCal
syntax:</p>
<pre><code class="language-tla">--algorithm Bakery 
{ variables num = [i \in Procs |-&gt; 0], flag = [i \in Procs |-&gt; FALSE];
  fair process (p \in Procs)
    variables unchecked = {}, max = 0, nxt = 1 ;
</code></pre>
<p>The most straightforward approach would be to add type annotations directly in
the PlusCal code. As reported in <a href="https://github.com/informalsystems/apalache/issues/1412">Issue 1412</a>, this does not work as
expected, as the PlusCal translator erases the comments.</p>
<p>A simple solution is to add type annotations directly to the declarations in
the generated TLA+ code. However, this solution is fragile. If we change the
PlusCal code, our annotations will get overridden. We propose another solution
that is stable under modification of the PlusCal code. To this end, we
introduce a new module called <code>BakeryTyped.tla</code> with the following contents:</p>
<pre><code class="language-tla">-------------------------- MODULE BakeryTyped --------------------------------

CONSTANT
    \* @type: Int;
    N

VARIABLES
    \* @type: Int -&gt; Int;
    num,
    \* @type: Int -&gt; Bool;
    flag,
    \* @type: Int -&gt; Str;
    pc,
    \* @type: Int -&gt; Set(Int);
    unchecked,
    \* @type: Int -&gt; Int;
    max,
    \* @type: Int -&gt; Int;
    nxt

ConstInit4 ==
    N = 4

INSTANCE BakeryWoTlaps
==============================================================================

</code></pre>
<p>Due to the semantics of <code>INSTANCE</code>, the constants and variables declared in
<code>BakeryTyped.tla</code> substitute the constants and variables of
<code>BakeryWoTlaps.tla</code>. By doing so we effectively introduce type annotations.
Since we introduce a separate module, any changes in the PlusCal code do not
affect our type annotations.</p>
<p>Additionally, we add a constant initializer <code>ConstInit4</code>, which we will use
later. See the manual section about the <a href="tutorials/../apalache/parameters.html#constinit-predicate">ConstInit predicate</a> for a detailed
explanation.</p>
<h2><a class="header" href="#step-2-annotate-the-operator-prec" id="step-2-annotate-the-operator-prec">Step 2: Annotate the operator <code>\prec</code></a></h2>
<p>Let us run the type checker against <code>BakeryTyped.tla</code>:</p>
<pre><code class="language-sh">$ apalache-mc typecheck BakeryTyped.tla
...
[BakeryWoTlaps.tla:66:17-66:20]: Cannot apply a to the argument 1 in a[1].
...
</code></pre>
<p>The type checker complains about types of <code>a</code> and <code>b</code> in the operator <code>\prec</code>:</p>
<pre><code class="language-tla">a \prec b == \/ a[1] &lt; b[1]
             \/ (a[1] = b[1]) /\ (a[2] &lt; b[2])
</code></pre>
<p>The issue is that the type checker is not able to decide whether <code>a</code> and <code>b</code>
are functions, sequences, or tuples. We help the type checker by adding type
annotations to the operator <code>\preceq</code>.</p>
<pre><code class="language-tla">\* A type annotation introduced for Apalache:
\*
\* @type: (&lt;&lt;Int, Int&gt;&gt;, &lt;&lt;Int, Int&gt;&gt;) =&gt; Bool;
a \prec b == \/ a[1] &lt; b[1]
             \/ (a[1] = b[1]) /\ (a[2] &lt; b[2])
</code></pre>
<p>When we run the type checker once again, it computes all types without
any problem:</p>
<pre><code class="language-sh">$ apalache-mc typecheck BakeryTyped.tla
...
Type checker [OK]
</code></pre>
<p>Note that our annotation of <code>\preceq</code> would not get overwritten, when we update
the PlusCal code. This is because <code>\preceq</code> is defined in the TLA+ section.</p>
<h2><a class="header" href="#step-3-checking-mutual-exclusion-for-bounded-executions" id="step-3-checking-mutual-exclusion-for-bounded-executions">Step 3: Checking mutual exclusion for bounded executions</a></h2>
<p>Once we have annotations, we run Apalache to check the property of mutual
exclusion for four processes and executions of length up to 10 steps:</p>
<pre><code class="language-sh">$ apalache-mc apalache-mc check \
    --cinit=ConstInit4 --inv=MutualExclusion BakeryTyped.tla
...
It took me 0 days  0 hours 32 min  2 sec
</code></pre>
<p>Apalache reports no violation of <code>MutualExclusion</code>. This is a good start.
However, since Apalache only analyzes executions that make up to 10
transitions by default, this analysis is incomplete.</p>
<h2><a class="header" href="#step-4-checking-mutual-exclusion-for-unbounded-executions" id="step-4-checking-mutual-exclusion-for-unbounded-executions">Step 4: Checking mutual exclusion for unbounded executions</a></h2>
<p>To analyze executions of arbitrary length with Apalache, we can check an
inductive invariant. For details, see the section on <a href="https://apalache.informal.systems/docs/apalache/running.html#checking-an-inductive-invariant">Checking inductive
invariants</a>. The Bakery specification contains such an invariant written by
Leslie Lamport:</p>
<pre><code class="language-tla">(***************************************************************************)
(* Inv is the complete inductive invariant.                                *)
(***************************************************************************)  
Inv == /\ TypeOK 
       /\ \A i \in Procs : 
             /\ (pc[i] \in {&quot;e4&quot;, &quot;w1&quot;, &quot;w2&quot;, &quot;cs&quot;}) =&gt; (num[i] # 0)
             /\ (pc[i] \in {&quot;e2&quot;, &quot;e3&quot;}) =&gt; flag[i] 
             /\ (pc[i] = &quot;w2&quot;) =&gt; (nxt[i] # i)
             /\ pc[i] \in {(*&quot;e2&quot;,*) &quot;w1&quot;, &quot;w2&quot;} =&gt; i \notin unchecked[i]
             /\ (pc[i] \in {&quot;w1&quot;, &quot;w2&quot;}) =&gt;
                   \A j \in (Procs \ unchecked[i]) \ {i} : Before(i, j)
             /\ /\ (pc[i] = &quot;w2&quot;)
                /\ \/ (pc[nxt[i]] = &quot;e2&quot;) /\ (i \notin unchecked[nxt[i]])
                   \/ pc[nxt[i]] = &quot;e3&quot;
                =&gt; max[nxt[i]] &gt;= num[i]
             /\ (pc[i] = &quot;cs&quot;) =&gt; \A j \in Procs \ {i} : Before(i, j)

-----------------------------------------------------------------------------
</code></pre>
<p>To prove that <code>Inv</code> is an inductive invariant for <code>N = 4</code>, we run Apalache
twice. First, we check that the initial states satisfy the invariant <code>Inv</code>:</p>
<pre><code class="language-sh">$ apalache-mc apalache-mc check --cinit=ConstInit4 \
    --init=Init --inv=Inv --length=0 BakeryTyped.tla
...
The outcome is: NoError
It took me 0 days  0 hours  0 min  6 sec
</code></pre>
<p>Second, we check that for every state that satisfies <code>Inv</code>, the following
holds true: Its successors via <code>Next</code> satisfy <code>Inv</code> too. This is done as
follows:</p>
<pre><code class="language-sh">$ apalache-mc apalache-mc check --cinit=ConstInit4 \
    --init=Inv --inv=Inv --length=1 BakeryTyped.tla
...
The outcome is: NoError
It took me 0 days  0 hours  0 min 28 sec
</code></pre>
<p>Now we know that <code>Inv</code> is indeed an inductive invariant. Hence, we check
the property <code>MutualExclusion</code> against the states that satisfy <code>Inv</code>:</p>
<pre><code class="language-sh">$ apalache-mc apalache-mc check --cinit=ConstInit4 \
    --init=Inv --inv=MutualExclusion --length=0 BakeryTyped.tla
...
The outcome is: NoError
It took me 0 days  0 hours  0 min 9 sec
</code></pre>
<p>In particular, these three results allow us to conclude that <code>MutualExclusion</code>
holds for all states that are reachable from the initial states (satisfying
<code>Init</code>) via the available transitions (satisfying <code>Next</code>). Since we have fixed
the constant <code>N</code> with the predicate <code>ConstInit4</code>, this result holds true for <code>N = 4</code>. If you want to check <code>MutualExclusion</code> for other values of <code>N</code>, you can
define a predicate similar to <code>ConstInit4</code>. We cannot check the invariant for
all values of <code>N</code>, as this would require Apalache to reason about unbounded
sets and functions, which is currently not supported.</p>
<h2><a class="header" href="#dealing-with-the-define-block" id="dealing-with-the-define-block">Dealing with the define block</a></h2>
<p>PlusCal specifications may contain the special define-block. For example:</p>
<pre><code class="language-tla">---- MODULE CountersPluscal ----

(*
  Pluscal code inside TLA+ code.

--algorithm Counters {
  variable x = 0;

  define {
    \* This is TLA+ code inside the PlusCal code.
    IsPositive(x) == x &gt; 0
  }

  ...
}
*)
================================
</code></pre>
<p>Unfortunately, the PlusCal transpiler erases comments when translating PlusCal
code to TLA+. Hence, the simplest solution is to move the define-block outside
the PlusCal code. For example:</p>
<pre><code class="language-tla">---- MODULE CountersPluscal ----

\* @type: Int =&gt; Bool;
IsPositive(x) == x &gt; 0

(*
--algorithm Counters {
  variable x = 0;

  ...
}
*)
================================
</code></pre>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>The final specifications can be found in
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bakery-pluscal/BakeryTyped.tla">BakeryTyped.tla</a>
and
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/bakery-pluscal/BakeryWoTlaps.tla">BakeryWoTlaps.tla</a>.</p>
<p>In this tutorial we have shown how to:</p>
<ul>
<li>Annotate a PlusCal spec with types by introducing an additional TLA+ module.</li>
<li>Check safety of Bakery for bounded executions by bounded model checking (for
<code>N=4</code>).</li>
<li>Check safety of Bakery for unbounded executions by invariant checking (for
<code>N=4</code>).</li>
</ul>
<p>If you are experiencing a problem with Apalache, feel free to <a href="https://github.com/informalsystems/apalache/issues">open an issue</a>
or drop us a message on <a href="https://informal-systems.zulipchat.com/login/#narrow/stream/265309-apalache">Zulip chat</a>.</p>
<h2><a class="header" href="#further-reading-1" id="further-reading-1">Further reading</a></h2>
<ul>
<li><a href="tutorials/./entry-tutorial.html">Entry-level Tutorial on the Model Checker</a></li>
<li><a href="tutorials/./snowcat-tutorial.html">Tutorial on Snowcat</a> shows how to write type annotations for Apalache.</li>
<li><a href="https://mbt.informal.systems/docs/tla_basics_tutorials/tla+cheatsheet.html">TLA+ Cheatsheet in HTML</a> summarizes the common TLA+ constructs. If you
prefer a printable version in pdf, check the <a href="https://lamport.azurewebsites.net/tla/summary-standalone.pdf">Summary of TLA+</a>.</li>
</ul>
<h1><a class="header" href="#apalache-trail-tips-how-to-check-your-specs-faster" id="apalache-trail-tips-how-to-check-your-specs-faster">Apalache trail tips: how to check your specs faster</a></h1>
<p><strong>Difficulty: Red trail – Medium</strong></p>
<p>This tutorial collects tips and tricks that demonstrate the strong sides of
Apalache.</p>
<h2><a class="header" href="#tip-1-use-tla-constructs-instead-of-explicit-iteration" id="tip-1-use-tla-constructs-instead-of-explicit-iteration">Tip 1: Use TLA+ constructs instead of explicit iteration</a></h2>
<p><a name="fold-except"></a></p>
<p>The <a href="tutorials/../apalache/antipatterns.html#incremental-computation">Apalache
antipatterns</a> mention that
one should not use explicit iteration (e.g., <a href="tutorials/../apalache/principles/folds.html"><code>ApaFoldSet</code> and
<code>ApaFoldSeqLeft</code></a>), unless it is really needed. In
this tip, we present a concrete example that demonstrates how explicit
iteration slows down Apalache.</p>
<p>In our example, we model a system of processes from a set <code>Proc</code> that are
equipped with individual clocks. These clocks may be completely unsynchronized.
However, they get updated uniformly, that is, all clocks have the same speed.</p>
<p>Let's have a look at the first part of this specification:</p>
<pre><code class="language-tla">-------------------------- MODULE FoldExcept ----------------------------------
(*
 * This specification measures performance in the presence of an anti-pattern.
 *)

EXTENDS Integers, Apalache 

CONSTANT
    \* A fixed set of processes
    \*
    \* @type: Set(Str);
    Proc

VARIABLES
    \* Process clocks
    \*
    \* @type: Str -&gt; Int;
    clocks,
    \* Drift between pairs of clocks
    \*
    \* @type: &lt;&lt;Str, Str&gt;&gt; -&gt; Int;
    drift

</code></pre>
<p>As we can see, the constant <code>Proc</code> is a specification parameter. For instance,
it can be equal to <code>{ &quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot; }</code>. The variable <code>clocks</code> assigns a
clock value to each process from <code>Proc</code>, whereas the variable <code>drift</code> collects
the clock difference for each pair of processes from <code>Proc</code>. This relation
is easy to see in the predicate <code>Init</code>:</p>
<pre><code class="language-tla">Init ==
    /\ clocks \in [ Proc -&gt; Nat ]
    /\ drift = [ &lt;&lt;p, q&gt;&gt; \in Proc \X Proc |-&gt; clocks[p] - clocks[q] ]

</code></pre>
<p>Further, we write down a step of our system:</p>
<pre><code class="language-tla">\* Uniformly advance the clocks and update the drifts.
\* Constructing functions without iteration.
NextFast ==
    \E delta \in Nat \ { 0 }:
        /\ clocks' = [ p \in Proc |-&gt; clocks[p] + delta ]
        /\ drift' = [ &lt;&lt;p, q&gt;&gt; \in Proc \X Proc |-&gt; clocks'[p] - clocks'[q] ]

</code></pre>
<p>The transition predicate <code>NextFast</code> uniformly advances the clocks of all
processes by a non-negative number <code>delta</code>. Simultaneously, it updates the
clock differences in the function <code>drift</code>.</p>
<p>It is easy to see that <code>drift</code> actually does not change between the steps.  We
can formulate this observation as an <a href="tutorials/../apalache/principles/invariants.html#action-invariants">action
invariant</a>:</p>
<pre><code class="language-tla">\* Check that the clock drifts do not change
DriftInv ==
    \A p, q \in Proc:
        drift'[p, q] = drift[p, q]

</code></pre>
<p>Our version of <code>NextFast</code> is quite concise and it uses the good parts of
TLA+. However, new TLA+ users would probably write it differenty. Below you
can see the version that is more likely to be written by a specification
writer who has good experience in software engineering:</p>
<pre><code class="language-tla">\* Uniformly advance the clocks and update the drifts.
\* Constructing functions via explicit iteration. More like a program.
NextSlow ==
    \E delta \in Nat \ { 0 }:
        /\  LET \* @type: (Str -&gt; Int, Str) =&gt; (Str -&gt; Int);
                IncrementInLoop(clk, p) ==
                [ clk EXCEPT ![p] = @ + delta ]
            IN
            clocks' = ApaFoldSet(IncrementInLoop, clocks, Proc)
        /\  LET \* @type: (&lt;&lt;Str, Str&gt;&gt; -&gt; Int, &lt;&lt;Str, Str&gt;&gt;)
                \*          =&gt; &lt;&lt;Str, Str&gt;&gt; -&gt; Int;
                SubtractInLoop(dft, pair) ==
                LET p == pair[1]
                    q == pair[2]
                IN
                [ dft EXCEPT ![p, q] = clocks'[p] - clocks'[q] ]
            IN
            drift' = ApaFoldSet(SubtractInLoop, drift, Proc \X Proc)

</code></pre>
<p>The version <code>NextSlow</code> is less concise than <code>NextFast</code>, but it is probably easier to
read for a software engineer. Indeed, we update the variable <code>clocks</code> via
a set fold, which implements an iteration over the set of processes. What makes
it easier to understand for a software engineer is a local update in the
operator <code>IncrementInLoop</code>. Likewise, the variable <code>drift</code> is iteratively
updated with the operator <code>SubtractInLoop</code>.</p>
<p>If <code>ApaFoldSet</code> looks unfamiliar to you, check the page on <a href="tutorials/../apalache/principles/folds.html">folding sets and
sequences</a>.</p>
<p>Although <code>NextSlow</code> may look more familiar, it is significantly harder for
Apalache to check than <code>NextFast</code>. To see the difference, we measure
performance of Apalache for several sizes of <code>Proc</code>: 3, 5, 7, and 10. We do
this by running Apalache for the values of <code>N</code> equal to 3, 5, 7, 10.  To this
end we define several model files called <code>MC_FoldExcept${N}.tla</code> for
<code>N=3,5,7,10</code>. For instance, <code>MC_FoldExcept3.tla</code> looks as follows:</p>
<pre><code class="language-tla">--------------------- MODULE MC_FoldExcept3 ---------------------------------

Proc == { &quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot; }

VARIABLES
    \* Process clocks
    \*
    \* @type: Str -&gt; Int;
    clocks,
    \* Drift between pairs of clocks
    \*
    \* @type: &lt;&lt;Str, Str&gt;&gt; -&gt; Int;
    drift

INSTANCE FoldExcept    

==============================================================================
</code></pre>
<p>We run Apalache for different instances of <code>N</code>:</p>
<pre><code class="language-sh">apalache-mc check --next=NextSlow --inv=DriftInv MC_FoldExcept${N}.tla
apalache-mc check --next=NextFast --inv=DriftInv MC_FoldExcept${N}.tla
</code></pre>
<p>The plot below shows the running times for the versions <code>NextSlow</code> and
<code>NextFast</code>:</p>
<p><img src="tutorials/./img/times.png" alt="Running times" /></p>
<p>The plot speaks for itself. The version <code>NextFast</code> is dramatically faster than
<code>NextSlow</code> for an increasing number of processes. Interestingly, <code>NextFast</code> is
also more concise. In principle, both <code>NextFast</code> and <code>NextSlow</code> describe the
same behavior. However, <code>NextFast</code> looks higher-level: It looks like it
computes <code>clocks</code> and <code>drifts</code> in parallel, whereas <code>NextSlow</code> computes
these functions in a loop (though the order of iteration is unknown). Actually,
whether these functions are computed sequentially or in parallel is irrelevant
for our specification, as both <code>NextFast</code> and <code>NextSlow</code> describe a <em>single
step</em> of our system! We can view <code>NextSlow</code> as an implementation of <code>NextFast</code>,
as <code>NextSlow</code> contains a bit more computation details.</p>
<p>From the performance angle, the above plot may seem counterintuitive to
software engineers. Indeed, we are simply updating an array-like data structure
in a loop. Normally, it should not be computationally expensive. However,
behind the scenes, Apalache is producing constraints about all function
elements for each iteration. Intuitively, you can think of it as being <em>fully
copied at every iteration</em>, instead of one element being updated. From this
perspective, the iteration in <code>NextSlow</code> should clearly be less efficient.</p>
<h1><a class="header" href="#symbolic-model-checking" id="symbolic-model-checking">Symbolic Model Checking</a></h1>
<p>This brief introduction to symbolic model checking discusses the following:</p>
<ol>
<li>State-spaces and transition systems</li>
<li>What is a symbolic state?</li>
<li>What are symbolic traces?</li>
<li>How do I interpret Apalache counterexamples?</li>
</ol>
<p>A glossary of notation and definitions can be found <a href="tutorials/symbmc.html#notation-and-definitions">below</a></p>
<h2><a class="header" href="#on-state-spaces-and-transition-systems" id="on-state-spaces-and-transition-systems">On state-spaces and transition systems</a></h2>
<p>A TLA+ specification defines a triple \((S,S_0,\to)\), called a <em>transition system</em>. \(S\) is the <em>state space</em>, \(S_0\) is the set of initial states \(\left(S_0 \subseteq S\right)\), and \(\to\) is the transition relation, a subset of \(S^2\).</p>
<h3><a class="header" href="#state-spaces" id="state-spaces">State spaces</a></h3>
<p>The structure of a single state depends on the number of variables a specification declares. For example, if a specification declares </p>
<pre><code class="language-tla">VARIABLE A1, A2, A3, ..., Ak
</code></pre>
<p>then a <em>state</em> is a mapping \([A_1 \mapsto a_1, \dots, A_k \mapsto a_k]\), where \(a_i\) represents the value of the variable <code>Ai</code>, for each \(i = 1,\dots,k\). Here, we represent TLA+ variable names as unique formal symbols, where, for example the TLA+ variable <code>A1</code> is represented by the formal symbol \(A_1\). By convention, we will use markdown-syntax to refer to objects in TLA+ specifications, and latex notation otherwise.
The state space \(S\) is then the set of all such mappings, i.e. the set of all possible combinations of values that variables may hold.
For brevity, whenever the specification defines exactly one variable, we will treat a state as a single value \(a_1\) instead of the mapping \([A_1 \mapsto a_1]\).</p>
<p>In untyped TLA+, one can think of \(S\) as \(U^{\{A_1,\dots, A_k\}}\), that is, the set of all mappings, which assign a value in \(U\), the universe of all TLA+ values, to each symbol. This set is naturally isomorphic to \(U^k\). In typed TLA+, such as in Apalache, where variable declarations look like:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: T1;
  A1, 
  ..., 
  \* @type: Tk;
  Ak
</code></pre>
<p>\(S\) is additionally restricted, such that for all \(s \in S\) each symbol \(A_i\) maps to a value \(s(A_i) \in V_i\), where \(Vi \subset U\) is the set of all values, which hold the type \(T_i\), for each \(i = 1,\dots,k\).
For example, in the specification with</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Bool;
  A1, 
  \* @type: Bool;
  A2
</code></pre>
<p>The state space is \(\mathbb{B}^{\{x,y\}}\) when considering types, since each variable can hold one of two boolean values. In the untyped setting, the state space is infinite, and contains states where, for example, \(A1\) maps to <code>[z \in 1..5 |-&gt; &quot;a&quot;]</code> and \(A2\) maps to  <code>CHOOSE p \in {}: TRUE</code>.</p>
<p>As Apalache enforces a type system,the remainder of this document will assume the typed setting.
This assumption does not change any of the definitions. 
We will also assume that every specification declares an initial-state predicate <code>Init</code>, a transition-predicate <code>Next</code> and an invariant <code>Inv</code> (if not specified, assumed to be <code>TRUE</code>).
For simplicity, we will also assume that the specification if free of constants, resp. that all of the constants have been initialized.</p>
<h3><a class="header" href="#initial-states" id="initial-states">Initial states</a></h3>
<p>The second component, \(S_0\), the set of all initial states, is derived from \(S\) and <code>Init</code>. 
The initial state predicate is a Boolean formula, in which specification-variables appear as free logic variables. 
The operator <code>Init</code> characterizes a predicate \(P_{S_0} \in \mathbb{B}^S\) in the following way: given a state \(s \in S\), the formula obtained by replacing all occurrences of variable names <code>Ai</code> in <code>Init</code> with the values \(s(A_i)\) is a Boolean formula with no free variables (in a well-typed, parseable specification), which evaluates to either <code>TRUE</code> or <code>FALSE</code>. We say \(P_{S_0}(s)\) is the evaluation of this formula.
By the subset-predicate equivalence, we identify the predicate \(P_{S_0}\) with a subset \(S_0\) of \(S\): \(S_0 = \{ s \in S\mid P_{S_0}(s) = TRUE \}\). </p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 3..5 /\ y = 2 
</code></pre>
<p>we see that \(S = \mathbb{Z}^{\{x,y\}}\) and \(S_0 = \{ [x \mapsto 3, y \mapsto 2], [x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2] \}\).</p>
<h3><a class="header" href="#transitions" id="transitions">Transitions</a></h3>
<p>Similar to \(S_0\), \(\to\) is derived from \(S\) and <code>Next</code>. If \(S_0\) is a single-argument predicate \(S_0 \in \mathbb{B}^S\), then \(\to\) is a relation \(\to \in \mathbb{B}^{S^2}\). 
\(\to(s_1,s_2)\) is the evaluation of the formula obtained by replacing all occurrences of variable names <code>Ai</code> in <code>Next</code> with the values \(s_1(A_i)\), and all occurrences of <code>Ai'</code> with \(s_2(A_i)\).
By the same principle of subset-predicate equivalence, we can treat \(\to\) as a subset of \(S^2\).
As mentioned in the notation section, it is generally more convenient to use the infix notation
\(s_1 \to s_2\) over \(\to(s_1, s_2)\). We say that a state \(s_2\) is a <em>successor</em> of the state \(s_1\) if \(s_1 \to s_2\). </p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 3..5 /\ y = 2 

Next == x' \in { x, x + 1 } /\ UNCHANGED y
</code></pre>
<p>One can deduce, for any state \([x \mapsto a, y \mapsto b] \in S\), that it has two successors: \([x \mapsto a + 1, y \mapsto b]\) and \([x \mapsto a, y \mapsto b]\) because the following relations hold \([x \mapsto a, y \mapsto b] \to [x \mapsto a + 1, y \mapsto b]\) and \( [x \mapsto a, y \mapsto b] \to [x \mapsto a, y \mapsto b] \).</p>
<p>Lastly, we define traces in the following way:
A <em>trace</em> of length \(k\) is simply a sequence of states \(s_0,\dots, s_k \in S\), such that \(s_0 \in S_0\) and \(s_i \to s_{i+1}\) for all \(i\in \{0,\dots,k-1\}\). 
This definition naturally extends to <em>inifinite traces</em>.</p>
<p>For example, the above specification admits the following traces of length 2 (among others):
\[
[x \mapsto 3, y \mapsto 2], [x \mapsto 3, y \mapsto 2], [x \mapsto 3, y \mapsto 2]
\]
\[
[x \mapsto 3, y \mapsto 2], [x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2]
\]
\[
[x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2], [x \mapsto 5, y \mapsto 2]
\]</p>
<h3><a class="header" href="#reachable-states" id="reachable-states">Reachable states</a></h3>
<p>Using the above definitions, we can define the set of states reachable in exactly \(k\)-steps, for \(k \in \mathbb{N}\), denoted by \(R(k)\). We define \(R(0) = S_0\) and for each \(k \in \mathbb{N}\),
\[
R(k+1) := \{ t \in S \mid \exists s \in R(k) \ .\ s \to t \}
\]</p>
<p>Similarly, we can define the set of states reachable in <em>at most</em> \(k\)-steps, denoted \(r(k)\), for \(k \in \mathbb{N}\) by
\[
r(k) := \bigcup_{i=0}^k R(i)
\]</p>
<p>Finally, we define the set of all <em>reachable</em> states, \(R\), as the (infinite) union of all \(R(k)\), over \(k \in \mathbb{N}\):
\[
R := \bigcup_{k \in \mathbb{N}} R(k)
\]</p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 1..3 /\ y = 2

Next == x' = x + 1 /\ UNCHANGED y
</code></pre>
<p>we can deduce: </p>
<p>\begin{align}
R(0) &amp;= r(0) = S_0 = \{[x\mapsto 1, y\mapsto 2],[x\mapsto 2, y\mapsto 2],[x\mapsto 3, y\mapsto 2]\} \\
\\
R(1) &amp;= \{[x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2]\} \\
r(1) &amp;= \{[x\mapsto 1, y\mapsto 2], [x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2]\} \\
\\
R(2) &amp;= \{[x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2], [x\mapsto 5, y\mapsto 2]\} \\
r(2) &amp;= \{[x\mapsto 1, y\mapsto 2], [x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2], [x\mapsto 5, y\mapsto 2]\}
\end{align}</p>
<p>and so on. We can express this compactly as:
\begin{align}
[x\mapsto a, y \mapsto b] \in R(i) &amp;\iff i+1 \le a \le i + 3 \land b = 2 \\
[x\mapsto a, y \mapsto b] \in r(i) &amp;\iff 1 \le a \le i + 3 \land b = 2 \\
[x\mapsto a, y \mapsto b] \in R &amp;\iff 1 \le a \land b = 2
\end{align}</p>
<h3><a class="header" href="#finite-diameters" id="finite-diameters">Finite diameters</a></h3>
<p>We say that a transition system has a <em>finite diameter</em>, if there exists a \(k \in N\), such that \(R = r(k)\).</p>
<p>If such an integer exists then the smallest integer \(k\), for which this holds true, is the <em>diameter</em> of the transition system.
In other words, if the transition system \((S,S_0,\to)\) has a finite diameter of \(k\), any state that is reachable from a state in \(S_0\), is reachable in at most \(k\) transitions. The example above clearly does not have a finite diameter, since \(R\) is infinite, but \(r(k)\) is finite for each \(k\).</p>
<p>However, the spec</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 0 

Next == x' = (x + 1) % 7
</code></pre>
<p>has a finite diameter (more specifically, a diameter of 6), because:</p>
<ol>
<li>\(R = \{0,1,\dots,6\}\) (the set of remainders modulo 7), since those are the only values <code>x'</code>, which is defined as a <code>% 7</code> expression, can take. </li>
<li>for any \(k = 0,\dots,5\), it is the case that \(r(k) = \{0,\dots,k\} \ne R\), so the diameter is not in \(\{1,\dots,5\}\)</li>
<li>for any \(k \ge 6\), \(r(k) = r(6) = R\)</li>
</ol>
<h3><a class="header" href="#invariants" id="invariants">Invariants</a></h3>
<p>Much like <code>Init</code>, an invariant operator <code>Inv</code> defines a predicate. However, it is not, in general, the case that <code>Inv</code> defines a predicate over <code>S</code>. There are different cases we can consider, discussed in more detail <a href="tutorials/../apalache/principles/invariants.html">here</a>. For the purposes of this document, we focus on <em>state invariants</em>, i.e. operators which use only unprimed variables and no temporal- or trace- operators. A state invariant operator <code>Inv</code> defines a predicate \(I\) over \(S\).
We say that the \(I\) is an <em>invariant</em> in the transition system, if \(R \subseteq I\), that is, for every reachable state \(s_r \in R\), \(I(s_r)\) holds true. If \(R \setminus I\) is nonempty (i.e., there exists a state \(s_r \in R\), such that \(\neg I(s_r)\)), we refer to elements of \(R \setminus I\) as <em>witnesses</em> to invariant violation.</p>
<h3><a class="header" href="#goals-of-model-checking" id="goals-of-model-checking">Goals of model checking</a></h3>
<p>The goal of model checking is to determine whether or not \(R \setminus I\) contains a witness. 
The goal of bounded model checking is to determine, given a bound \(k\), whether or not \(r(k) \setminus I\) contains a witness.</p>
<p>In a transition system with a bounded diameter, one can use bounded model checking to solve the general model checking problem, since \(R \setminus I\) is equivalent to \(r(k) \setminus I\) for a sufficiently large \(k\). In general, if the system does not have a bounded diameter, failing to find a witness in \(r(k) \setminus I\) cannot be used to reason about the absence of witnesses in \(R \setminus I\)! </p>
<h2><a class="header" href="#explicit-state-model-checking" id="explicit-state-model-checking">Explicit-state model checking</a></h2>
<p>The idea behind explicit-state model checking is to simply perform the following algorithm (in pseudocode, \(\leftarrow\) represents assignment):</p>
<p>Compute \(S_0\) and set \(Visited \leftarrow \emptyset, ToVisit \leftarrow S_0\)</p>
<ol>
<li>
<p>While \(ToVisit \ne \emptyset\), pick some \(s \in ToVisit\): 
1. If \(\neg I(s)\) then terminate, since a witness is found.
1. If \(I(s)\) then compute \(Successors(s) = \{ t \in S\mid s \to t \}\). Set
\begin{align}
Visited &amp;\leftarrow Visited \cup \{s\}\\
ToVisit &amp;\leftarrow (ToVisit \cup Successors(s)) \setminus Visited
\end{align}</p>
</li>
<li>
<p>If \(ToVisit = \emptyset\) terminate. \(R = Visited\) and \(I\) is an invariant.</p>
</li>
</ol>
<p>While simple to describe, there are several limitations of this approach in practice.
The first limitation is the absence of a termination guarantee. More specifically, this algorithm terminates if and only if \(R\) is finite. For example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 0
Next == x' = x + 1
</code></pre>
<p>defines a states space, for which \(R = \mathbb{N}\), so the above algorithm never terminates.
Further, in the general case it is difficult or impossible to compute \(S_0\) or the set \(Successors(s)\) defined in the algorithm. 
As an example, consider the following specification:</p>
<pre><code class="language-tla">VARIABLE x

Successor(n) == IF n % 2 = 0 THEN n \div 2 ELSE 3*n + 1 

RECURSIVE kIter(_,_)
kIter(a,k) == IF k &lt;= 0 THEN a ELSE Successor(kIter(a, k-1))

ReachesOne(a) == \E n \in Nat: kIter(a,n) = 1

Init == x \in { n \in Nat: ~ReachesOne(n) }
</code></pre>
<p>The specification encodes the <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz conjecture</a>, so computing \(S_0\) is equivalent to proving or disproving the conjecture, which remains an open problem at present. 
It is therefore unreasonable to expect any model checker to be able to accept such input, despite the fact that the condition is easily describable in first-order logic.</p>
<p>A similar problem can occur in computing \(Successors(s)\); the relation between variables <code>Ai</code> (\(s(A_i)\)) and <code>Ai'</code> (\(s_2(A_i)\)) may be given by means of an implicit function or uncomputable expression.
Therefore, most tools impose the following constraints, which make computing \(S_0\) and \(Successors(s)\) possible without any sort of specialized solver:
The specification must have the shape</p>
<pre><code class="language-tla">VARIABLE A1,...,Ak

Init == /\ A1 \in F1()
        /\ A2 \in F2(A1)
        ...
        /\ Ak \in Fk(A1,...,A{k-1})

Next == /\ CondN(A1,...,Ak)
        /\ A1' \in G1(A1,...,Ak)
        /\ A2' \in G2(A1,...,Ak, A1')
        ...
        /\ Ak' \in Gk(A1,...,Ak, A1',...,A{k-1}')
</code></pre>
<p>or some equivalent form, in which variable values in a state can be iteratively computed, one at a time, by means of an explicit formula, which uses only variables computed so far.
For instance,</p>
<pre><code class="language-tla">VARIABLE x,y

Init == /\ x \in 1..0
        /\ y \in { k \in 1..10, k &gt; x }

Next == \/ /\ x &gt; 5
           /\ x' = x - 1
           /\ y' = x' + 1
        \/ /\ x &lt;= 5
           /\ y' = 5 - x
           /\ x' = x + y'
</code></pre>
<p>allows one to compute both \(S_0\) as well as \(Successors(s)\), for any \(s\), by traversing the conjunctions in the syntax-imposed order. </p>
<p>However, even in a situation where states are computable, and \(R\) is finite, the size of \(R\) itself might be an issue in practice. We can create very compact specifications with large state-space sizes:</p>
<pre><code class="language-tla">VARIABLE A1,...,Ak

Init == /\ A1 = 0
        ...
        /\ Ak = 0
Next == \/ /\ A1' = (A1 + 1) % C
           /\ UNCHANGED &lt;&lt;A2,...,Ak&gt;&gt;
        \/ /\ A2' = (A2 + 1) % C
           /\ UNCHANGED &lt;&lt;A1,A3,...,Ak&gt;&gt;
        ...
        \/ /\ Ak' = (Ak + 1) % C
           /\ UNCHANGED &lt;&lt;A1,...,A{k-1}&gt;&gt;

</code></pre>
<p>This specification will have \(C^k\) distinct states, despite its rather simplistic behavior.</p>
<h2><a class="header" href="#explicit-state-bounded-model-checking" id="explicit-state-bounded-model-checking">Explicit-state bounded model checking</a></h2>
<p>Adapting the general explicit-state approach to bounded model checking is trivial, and therefore not particularly interesting. Assume a bound \(k \in \mathbb{N}\) on the length of the traces considered. </p>
<p>Compute \(S_0\) and set \(Visited \leftarrow \emptyset, ToVisit \leftarrow \{ (s,0)\mid s \in S_0 \}\)</p>
<ol>
<li>
<p>While \(ToVisit \ne \emptyset\), pick some \((s,j) \in ToVisit\): </p>
<ol>
<li>If \(\neg I(s)\) then terminate, since a witness is found.</li>
<li>If \(I(s)\) then:
\begin{align}
Visited &amp;\leftarrow Visited \cup \{(s,j)\} \\
ToVisit &amp;\leftarrow (ToVisit \cup T) \setminus Visited
\end{align}
where \( T \) equals \(\{(t,j+1)\mid t \in Successors(s)\}\) if \(j &lt; k\) and \(\emptyset\) otherwise</li>
</ol>
</li>
<li>
<p>If \(ToVisit = \emptyset\) terminate. \(r(k) = \{v \mid \exists j \in \mathbb{N} \ .\ (v,j) \in Visited\}\) and \(I\) holds in all states reachable in at most \(k\) steps.</p>
</li>
</ol>
<p>A real implementation would, for efficiency reasons, avoid entering the same state via traces of different length, but the basic idea would remain unchanged.
Bounding the execution length guarantees termination of the algorithm if \(S_0\) is finite and each state has finitely many successors w.r.t. \(\to\), even if the state space is unbounded in general.
However, this comes at a cost of guarantees: while bounded model checking might still find an invariant violation if it can occur within the bound \(k\), it will fail if the shortest possible trace, on which the invariant is violated has a length greater than \(k\).</p>
<p>If the system has a finite diameter, bounded model checking is equivalent to model checking, as long as \(k\) exceeds the diameter.</p>
<h2><a class="header" href="#symbolic-bounded-model-checking" id="symbolic-bounded-model-checking">Symbolic bounded model checking</a></h2>
<p>For a given \(k \in \mathbb{N}\), we want to find a way to determine if \(r(k) \setminus I\) is empty, without testing every single state in \(r(k)\) like in the explicit-state approach.</p>
<p>The key insight behind symbolic model checking is the following: it is often the case that the size of the reachable state space is large, not because of the properties of the specification, but simply because of the constants or sets involved.</p>
<p>Consider the example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 1
Next1 == x' \in 1..9
Next2 == x' \in 1..999999999999

Inv == x &lt; 5
</code></pre>
<p>The sets of reachable states defined by each <code>Next</code> have sizes proportional to the upper bounds of the ranges used. However, to find a violation of the invariant, one merely needs to identify a state \(s\) in which, for example, \(s(x) = 7\), which belongs to both sets. 
It is not necessary, or efficient, to loop over elements in the range and test each one against <code>Inv</code> to find a violation. Depending on the logic fragment <code>Inv</code> belongs to, there usually exist strategies for finding such violations much faster.</p>
<p>From this perspective, if, for some \(k\), we succeeded in finding a predicate \(P\) over \(S\), such that:</p>
<ul>
<li>\(P\) belongs to a logic fragment, for which optimizations exist</li>
<li>\(P\) has a witness iff a state reachable in at most \(k\) steps violates \(I\): \(\left(\exists s \in S \ .\ P(s)\right) \iff r(k) \setminus I \ne \emptyset\)</li>
</ul>
<p>we can use specialized techniques within the logical fragment to evaluate \(P\) and find a witness to the violation of \(I\), or else conclude that \(r(k) \subseteq I\).</p>
<p>To do this, it is sufficient to find a predicate \(P_R^l\) encoding \(R(l)\), for each \(l \in \{0,\dots,k\}\), since:
\begin{align}
s \in r(l) \iff&amp; \lor s \in R(0) \\
&amp;\lor s \in R(1) \\
&amp;\dots \\
&amp;\lor s \in R(l)
\end{align}</p>
<p>How does one encode \(P_R^0\)?
\[
s \in R(0) \iff s \in S_0 \iff P_{S_0}(s)
\]</p>
<p>so \(P_R^0(s) = P_{S_0}(s)\). What about \(P_R^1\)?
\begin{align}
s \in R(1) &amp;\iff s \in \{ t \in S \mid \exists s_0 \in R(0) \ .\ s_0 \to t \} \\
&amp;\iff \exists s_0 \in R(0) \ .\ s_0 \to s \\
&amp;\iff \exists s_0 \in S \ .\ P_R^0(s_0) \land s_0 \to s
\end{align}
so \(P_R^1(s) := \exists s_0 \in S \ .\ P_R^0(s_0) \land s_0 \to s\)</p>
<p>continuing this way, we can determine
\[
P_R^k(s) := \exists s_{k-1} \in S \ .\ P_R^{k-1}(s_{k-1}) \land s_{k-1} \to s
\]
Which can be expanded to
\[
Pk(s) = \exists s_0,\dots,s_{k-1} \in S \ .\ P_{S_0}(s_0) \land s_0 \to s_1 \land s_1 \to s_2 \land \dots \land s_{k-1} \to s
\]</p>
<p>Then, the formula describing invariant violation in exactly \(k\) steps, \(\exists s_k \in R(k) \setminus I\), becomes
\[
\exists s_0,\dots,s_k \in S \ .\ P_{S_0}(s_0) \land \neg I(s_k) \land \bigwedge_{i=0}^{k-1} s_i \to s_{i+1}
\]</p>
<p>The challenge in designing a symbolic model checker is determining, given TLA+ operators <code>Init</code>, <code>Next</code> and <code>Inv</code>, the encodings of \(P_{S_0}, \to, I\) as formulas in logcis supported by external solvers, for example SMT.</p>
<h3><a class="header" href="#symbolic-states" id="symbolic-states">Symbolic states</a></h3>
<p>In an explicit approach, the basic unit of computation is a single state \(s \in S\). However, as demonstrated above, symbolic approaches deal with logical formulas. Recall that a state formula, such as <code>Init</code> is actually a predicate over \(S\), and a predicate is equivalent to a subset of \(S\).</p>
<p>Predicates tend to not distinguish between certain concrete states. For instance, the formula
\(x &lt; 3\) is equally false for both \(x = 7\) and \(x = 70000000\). It is useful to characterize all of the states, in which a predicate evaluates to the same value. This is because we will define symbolic states in terms of equivalence relations:
A predicate \(P\) over \(S\) naturally defines an equivalence relation \(\circledcirc_P\): For \(a,b \in S\), we say that \(a \circledcirc_P b\) holds if \(P(a) = P(b)\).
Proving that this relation satisfies the criteria for an equivalence relation is left as an exercise to the reader.
This equivalence relation has only two distinct equivalence classes, since \(P(s)\) can only be <code>TRUE</code> or <code>FALSE</code>.
We can therefore think of predicates in the following way: Each predicate \(P\) slices the 
set \(S\) into two disjoint subsets, i.e. the equivalence classes of \(\circledcirc_P\).
An equivalent formulation of the above is saying that each predicate \(P\) defines a quotient space \(S / \circledcirc_P\), of size \(2\).</p>
<p>Recall that we have expressed the set of states \(R(l)\) with the predicate \(P_R^l\), for each \(l \in \{0,\dots,k\}\). By the above, \(P_R^l\) defines an equivalence relation \(\circledcirc_{P_R^l}\) on \(S\), and consequently, two equivalence classes. 
For notational clarity, we use \(\circledcirc^l\) instead of \(\circledcirc_{P_R^l}\). 
Each concrete state \(s \in S\) belongs to exactly one equivalence class \(\lbrack s \rbrack_{ \circledcirc^l} \in S / \circledcirc^l\).</p>
<p>The states in \(R(l)\) correspond to the equivalence class in which \(P_R^l\) holds true (i.e. \(s \in R(l) \iff \lbrack s \rbrack_{\circledcirc^l} = \{t \in S \mid P_R^l(t) = TRUE\}\)), and the ones in \(S \setminus R(l)\) correspond to the equivalence class in which \(P_R^l\) is false (i.e. \(s \notin R(l) \iff \lbrack s \rbrack_{\circledcirc^l} = \{t \in S \mid P_R^l(t) = FALSE\}\)).</p>
<p>We define symbolic states in the following way: Given a predicate \(P\) over \(S\), a <em>symbolic state</em> with respect to \(P\) is an element of \(S / \circledcirc_P\), where \(\circledcirc_P\) is the equivalence relation derived from \(P\) (i.e. \(a \circledcirc_P b \iff P(a) = P(b)\)). 
Recall the subset-predicate equivalence: in this context, a symbolic state, w.r.t. \(P\) is equivalent to a predicate, specifically, either \(P\) or \(\neg P\).</p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y


Init == x = 1 /\ y = 1 
Next == x' \in 1..5 /\ y \in {0,1}
</code></pre>
<p>and the predicate \(P(s) = s(x) &lt; 3\), the symbolic states are 
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land a &lt; 3 \}
\]
and
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land a \ge 3 \}
\]</p>
<p>while the symbolic states w.r.t. \(R(0)\) are 
\[
\{ [x \mapsto 1, y \mapsto 1] \}
\]
and
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land ( a \ne 1 \lor b \ne 1 )\}
\]</p>
<p>If we only care about characterizing invariant violations, the above techniques are sufficient. However, specification invariants are often composed of multiple smaller, independent invariants. 
For feedback purposes, it can be beneficial to identify, whenever an invariant violation occurs, the precise sub-invariant that is the cause. 
Suppose we are given an invariant \(s(x) &gt; 0 \land s(y) &gt; 0\). 
The information whether a reachable state has just \(s(x) \le 0\), just \(s(y) \le 0\), or both can help determine problems at the design level. </p>
<p>More generally: often, a predicate \(P\) is constructed as a conjunction of other predicates, e.g. \(P(s) \iff p_1(s) \land \dots \land p_m(s)\). A violation of \(P\) means a violation of (at least) one of \(p_1,\dots,p_m\), but knowing which one enables additional analysis.</p>
<p>A collection of predicates \(p_1,\dots,p_m\) over \(S\) define an equivalence relation \(\circledcirc\lbrack p_1,\dots,p_m\rbrack\)in the following way:
For \(a,b \in S\), we say that \( a \circledcirc\lbrack p_1,\dots,p_m\rbrack\ b\) holds if \(p_1(a) = p_1(b) \land \dots \land p_m(a) = p_m(b)\). Clearly, \(\circledcirc\lbrack p_1\rbrack = \circledcirc_{p_1}\).</p>
<p>Since a predicate can only evaluate to one of two values, there exist only two equivalence classes for \(\circledcirc_P\), i.e. only two symbolic states w.r.t. \(P\): one is the set of all states for which \(P\) is <code>TRUE</code>, and the other is the set of all values for which \(P\) is <code>FALSE</code>. 
In this sense, \(S / \circledcirc_P\) is isomorphic to the set \(\mathbb{B}\).
In the case of \(\circledcirc\lbrack p_1,\dots,p_m\rbrack\), there are \(2^m\) different \(m\)-tuples with values from \(\mathbb{B}\), so \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\) is isomorphic to \(\mathbb{B}^m\) . </p>
<p>What is the relation between \(\circledcirc\lbrack p_1,\dots,p_m\rbrack\) and \(\circledcirc_P\), where \(P(s) = p_1(s) \land \dots \land p_m(s)\)?
Clearly, \(P(s) = TRUE \iff p_1(s) = \dots = p_m(s) = TRUE\). 
Consequently, there is one equivalence class in \(S / \circledcirc_P\), that is equal to
\[
C_1 = \{ s \in S \mid P(s) = TRUE \}
\]
and one equivalence class in \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\) that is equal to
\[
C_2 = \{ s \in S \mid p_1(s) = TRUE \land \dots \land p_m(s) = TRUE \}
\]</p>
<p>They are one and the same, i.e. \(C_1 = C_2\). The difference is, that splitting \(P\) into \(m\) components \(p_1,\dots,p_m\) splits the other (unique) equivalence class \(C \in \{ c \in S / \circledcirc_P \mid c \ne C_1 \}\) into \(2^m - 1\) parts, which are the equivalence classes in \(\{ c \in S/\circledcirc\lbrack p_1,\dots,p_m\rbrack \mid c \ne C_2 \}\).</p>
<p>Consequently, we can also define symbolic states with respect to a set of predicates \(p_1,\dots,p_m\), implicitly conjoined, as elements of \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\).
Similarly, by the subset-predicate equivalence, a symbolic state, w.r.t. \(p_1,\dots,p_m\) can be viewed as one of
\begin{align}
p_1(s) \land p_2(s) \land \dots \land p_m(s)                  \qquad&amp;= P(s) \\
\neg p_1(s) \land p_2(s) \land \dots \land p_m(s)                 \qquad&amp; | \\
p_1(s) \land \neg p_2(s) \land \dots \land p_m(s)                 \qquad&amp;  | \\
\dots                                             \qquad&amp;   |&gt; \text{(as a disjunction)} = \neg P(s) \\
\neg p_1(s) \land \neg p_2(s) \land \dots \land \neg p_{m-1}(s) \land p_m(s)  \qquad&amp; | \\
\neg p_1(s) \land \neg p_2(s) \land \dots \land \neg p_{m-1}(s) \land \neg p_m(s) \qquad&amp; | \\
\end{align}</p>
<p>For example, take \(p_1(s) = s \in R(k)\) and \(p_2(s) = \neg I(s)\). With respect to \(p_1(s) \land p_2(s)\), there are two symbolic states: one corresponds to the set of all states which are both reachable and in which the invariant is violated, while the other corresponds to the set of all states, which are either not reachable, or in which the invariant holds.
Conversely, with respect to \(p_1,p_2\), there are four symbolic states: one corresponds to states which are both reachable and violate the invariant, one corresponds to states which are reachable, but which do not violate the invariant, one corresponds to states which are not reachable, but violate the invariant and the last one corresponds to states which are neither reachable, nor violate the invariant.</p>
<h3><a class="header" href="#symbolic-traces" id="symbolic-traces">Symbolic traces</a></h3>
<p>Having defined symbolic states, what is then the meaning of a symbolic trace?
Recall, a trace of length \(k\) is simply a sequence of reachable states 
\(s_0,\dots, s_k \in S\), such that \(s_0 \in S_0\) and \(s_i \to s_{i+1}\). 
In the symbolic setting, a <em>symbolic trace</em> is a sequence of symbolic states \(C_0,\dots,C_k \subseteq S\), such that 
\[
C_0 \in S / \circledcirc^0 \land \dots \land  C_k \in S / \circledcirc^k
\]</p>
<p>and, for each \(i = 0,\dots,k\), it is the case that \(C_i = \{ s \in S \mid P_R^i(s) = TRUE\}\).
In other words, a symbolic trace is the unique sequence of symbolic states, which correspond to the set of explicit states evaluating to <code>TRUE</code> under each of \(P_R^0,\dots,P_R^k\) respectively.</p>
<p>Recall that \(P_R^{i+1}(s_{i+1})\) was defined as \(\exists s_i \in S \ .\ P_R^i(s_i) \land s_i \to s_{i+1}\).
While, in the explicit case, we needed to enforce the condition \(s_i \to s_{i+1}\), in the symbolic case this is already a part of the predicate definition.</p>
<p>For example, consider:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x \in {0,1}
Next == x' = x + 1
</code></pre>
<p>a trace of length 2 would be one of \(0,1,2\) or \(1,2,3\). A symbolic trace would be the sequence
\[
\{0,1\}, \{1,2\}, \{2,3\}
\]</p>
<p>In the case of symbolic states, we were particularly interested in symbolic states with respect to predicates that encoded reachability. </p>
<p>Unlike the case of invariants, where we considered conjunctions of sub-invariants, the most interesting scenario w.r.t. traces is when a transition relation is presented as a disjunction of transitions, i.e. when 
\begin{align}
s_1 \to s_2 \iff&amp; \lor t_1(s_1,s_2)\\
&amp; \lor t_2(s_1,s_2)\\
&amp; \dots \\
&amp; \lor t_m(s_1,s_2)
\end{align}</p>
<p>At the specification level, this is usually the case when one can nondeterministically choose to perform one of \(m\) actions, and each \(t_1,\dots,t_m\) is an encoding of one such action, which, like \(\to\), translates to a binary predicate over \(S\). </p>
<p>Instead of a single trace \(C_1, \dots, C_k\), where states in \(C_{i+1}\) are reachable from states in \(C_i\) via \(\to\), we want to separate sets of states reachable by each \(t_i\) individually.</p>
<p>Recall that symbolic traces are sequences of symbolic states, implicitly related by \(\to\), since \(R\) is defined in terms of \(\to\). 
We define a symbolic trace decomposition by \(t_1,\dots,t_m\), in the following way: 
If \(t_1,\dots,t_m\) are relations, such that \(s_1 \to s_2 \iff \bigvee_{i=1}^m t_i(s_1,s_2)\), the decomposition of a symbolic trace \(X_0,\dots,X_k\) of length \(k\) w.r.t. \(t_1,\dots,t_m\) is a set \(
D = \{
Y(\tau) \mid \tau \in \{1,\dots,m\}^{\{1,\dots, k\}}
\}
\) , such that: </p>
<ul>
<li>\(Y(\tau)\) is a <em>partial symbolic trace</em> of length k: \(Y_0(\tau) = X_0, Y_1(\tau),\dots, Y_k(\tau)\)</li>
<li>For each \(i = 0,\dots,k-1\), \(Y_{i+1}\) is the set of all states reachable from \(Y_i\) by the transition fragment \(t_j\), where \(j = \tau(i+1)\):
\[
Y_{i+1}(\tau) = \{ s_{i+1} \in X_{i+1} \mid \exists s_i \in Y_i(\tau) \ .\ t_{\tau(i+1)}(s_i,s_{i+1}) \}
\]</li>
</ul>
<p>An interesting property to observe is that, for each \(i=1,\dots,k\), the sets
\(Y_i(\tau)\), over all possible \(\tau\), form a decomposition of \(X_i\). Concretely:
\[
X_i = \bigcup \left\{ Y_i(\tau)\mid \tau \in \{1,\dots,m\}^{\{1,\dots, k\}} \right\}
\]</p>
<p>Less obvious is the fact that, the larger the index \(i\), the finer this decomposition becomes.
Consider \(i=1\). Since \(Y_0\) is fixed, there are as many different \(Y_1(\tau)\) components as there are possible values of \(\tau(1)\), i.e. \(m\). As \(Y_2\) depends on \(Y_1\), there are as many different components as there are pairs \((\tau(1),\tau(2))\), i.e. \(m^2\), and so on until \(k\), where there are \(m^k\) possible \(Y_k(\tau)\) sets. 
In practice, however, many of these sets are empty.</p>
<p>Let us look at an example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

A1 == /\ x &gt; 4
      /\ x' = x - 1

A2 == /\ x &lt; 7
      /\ x' = x + 1

A3 == x' = x

A4 == /\ x = 1
      /\ x' = 10

Init == x \in 1..10
Next == \/ A1
        \/ A2
        \/ A3
        \/ A4
</code></pre>
<p>The \(\to\) predicate can be decomposed into:
\begin{align}
t_1(s_1,s_2) &amp;= s_1(x) &gt; 4 \land s_2(x) = s_1(x) - 1 \\
t_2(s_1,s_2) &amp;= s_1(x) &lt; 7 \land s_2(x) = s_1(x) + 1 \\
t_3(s_1,s_2) &amp;= s_2(x) = s_1(x) \\
t_4(s_1,s_2) &amp;= s_1(x) = 1 \land s_2(x) = 10 \\
\end{align}</p>
<p>Suppose we fix the length of the trace \(k = 2\).
Without considering the decomposition, the symbolic trace is equal to 
\[
X_0 = \{1,\dots,10\}, X_1 = \{1,\dots,10\}, X_2 = \{1,\dots,10\}
\]</p>
<p>Under the decomposition, we have \(m^k = 4^2 = 16\) candidates for \(\tau\). Let us look at \(\tau_1\), for which \(\tau_1(1) = 1, \tau_1(2) = 2\), representing an execution where the action <code>A1</code> is followed by the action <code>A2</code>.
If \(Y_0(\tau_1),Y_1(\tau_1),Y_2(\tau_1)\) is a partial trace (i.e. one of the elements in the decomposition \(D\)), then:</p>
<ul>
<li>
<p>\(Y_1(\tau_1) = \{ b \in X_1 \mid \exists a \in Y_0(\tau_1) \ .\ t_{\tau_1(1)}(a,b)\}\) which means
\[
Y_1(\tau_1) = \{ b \in \{1,\dots,10\} \mid \exists a \in \{1,\dots,10\} \ .\ a &gt; 4 \land b = a - 1 \}
= \{4,\dots,9\}
\]</p>
</li>
<li>
<p>\(Y_2(\tau_1) = \{ b \in X_2 \mid \exists a \in Y_1(\tau_1)\ .\ t_{\tau_1(2)}(a,b)\}\) which means
\[
Y_2(\tau_1) = \{ b \in \{1,\dots,10\} \mid \exists a \in \{4,\dots,9\} \ .\ a &lt; 7 \land b = a + 1 \}
= \{5,\dots,7\}
\]</p>
</li>
</ul>
<p>so the partial trace, corresponding to the sequence of actions <code>Init,A1,A2</code> is 
\[
\{1,\dots,10\}, \{4,\dots,9\}, \{5,\dots,7\}
\]</p>
<p>In fact, we can draw a table, representing partial traces corresponding to sequences of actions:</p>
<table><thead><tr><th>Sequence of actions (after <code>Init</code>)</th><th>Partial trace (without \(Y_0\))</th></tr></thead><tbody>
<tr><td>A1, A1</td><td>\(\{4, \dots, 9\}, \{4, \dots, 8\}\)</td></tr>
<tr><td>A1, A2</td><td>\(\{4, \dots, 9\}, \{5, \dots, 7\}\)</td></tr>
<tr><td>A1, A3</td><td>\(\{4, \dots, 9\}, \{4, \dots, 9\}\)</td></tr>
<tr><td>A1, A4</td><td>\(\{4, \dots, 9\}, \emptyset\)</td></tr>
<tr><td>A2, A1</td><td>\(\{2, \dots, 7\}, \{4, \dots, 6\}\)</td></tr>
<tr><td>A2, A2</td><td>\(\{2, \dots, 7\}, \{3, \dots, 7\}\)</td></tr>
<tr><td>A2, A3</td><td>\(\{2, \dots, 7\}, \{2, \dots, 7\}\)</td></tr>
<tr><td>A2, A4</td><td>\(\{2, \dots, 7\}, \emptyset\)</td></tr>
<tr><td>A3, A1</td><td>\(\{1, \dots, 10\}, \{4, \dots, 9\}\)</td></tr>
<tr><td>A3, A2</td><td>\(\{1, \dots, 10\}, \{2, \dots, 7\}\)</td></tr>
<tr><td>A3, A3</td><td>\(\{1, \dots, 10\}, \{1, \dots, 10\}\)</td></tr>
<tr><td>A3, A4</td><td>\(\{1, \dots, 10\}, \{10\}\)</td></tr>
<tr><td>A4, A1</td><td>\(\{10\}, \{9\}\)</td></tr>
<tr><td>A4, A2</td><td>\(\{10\}, \emptyset\)</td></tr>
<tr><td>A4, A3</td><td>\(\{10\}, \{10\}\)</td></tr>
<tr><td>A4, A4</td><td>\(\{10\}, \emptyset\)</td></tr>
</tbody></table>
<p>Clearly, the elements in every column (representing the various \(Y_i(\tau)\)), add up to \(X_i = \{1,\dots,10\}\). Also noticeable is the fact that some actions disable others, represented by the fact that some \(Y_2(\tau)\) sets are empty. For example, the action <code>A2</code> disables <code>A4</code>, because after <code>A2</code>, <code>x</code> cannot hold the value \(1\), which is a precondition for <code>A4</code>.</p>
<h3><a class="header" href="#counterexamples-in-apalache" id="counterexamples-in-apalache">Counterexamples in Apalache</a></h3>
<p>Finally, we can interpret Apalache counterexamples in the context of the above definitions. Given an invariant \(I\), a transition system \((S, S_0, \to)\) and an upper bound on executions \(k\), Apalache first finds predicates \(t_1,\dots,t_m\) partitioning \(\to\). Then, it encodes a symbolic trace \(X_0,\dots,X_k\) and its decomposition \(D\). A counterexample in Apalache defines an explicit trace \(s_0,s_1,\dots,s_l \in S\) for some \(l \le k\), as well as a sequence \(t_{\tau(1)}, \dots, t_{\tau(l)}\) (in the comments). The predicate sequence defines a partial trace (of length \(l\))
\(Y_0(\tau),\dots,Y_l(\tau)\) and \(s_0,\dots,s_l\) are chosen such that \(s_i \in Y_i(\tau)\).</p>
<p>Take the following specification and counterexample, for \(k = 10\):</p>
<pre><code class="language-tla">---------- MODULE example ----------

EXTENDS Integers

VARIABLE
  \* @type: Int;
  x

A == /\ x = 1
     /\ x' = x + 1
B == /\ x &gt; 1
     /\ x' = x + 1

Init == x = 1
Next == \/ A
        \/ B
Inv == x &lt; 3 

====================

---------------------------- MODULE counterexample ----------------------------

EXTENDS test

(* Constant initialization state *)
ConstInit == TRUE

(* Initial state *)
State0 == x = 1

(* Transition 0 to State1 *)
State1 == x = 2

(* Transition 1 to State2 *)
State2 == x = 3

(* The following formula holds true in the last state and violates the invariant *)
InvariantViolation == x &gt;= 3

================================================================================
</code></pre>
<p>We can see that, even though \(k=10\), we found a violation in \(l=2\) steps.
Each <code>State{i}</code> represents one of \(s_0,\dots,s_l\), by explicitly defining variable values in that state (e.g. <code>x = 1 /\ y = 2 /\ z = &quot;A&quot;</code>). 
The comment <code>(* Transition X to StateY *)</code> outlines which \(t_1,\dots,t_m\) was used to reach \(s_{i+1}\) from \(s_i\) (0-indexed). 
The shape of \(t_i\) can be found by looking at the file <code>XX_OutTransitionFinderPass.tla</code>, and will be named <code>Next_si_i</code>.
In the above case, <code>Transition 0</code> refers to the one representing <code>A</code> and <code>Transition 1</code> refers to the one representing <code>B</code>. 
<code>InvariantViolation</code> is the negation of the invariant <code>Inv</code>, and it will hold in <code>State{l}</code> (in this case, <code>x &lt; 3</code> does not hold in <code>State2</code>, where <code>x = 3</code>).</p>
<h2><a class="header" href="#notation-and-definitions" id="notation-and-definitions">Notation and definitions</a></h2>
<p>We use the following definitions and conventions:</p>
<ul>
<li>Common sets: We use the notation \(\mathbb{Z}\) to refer to the set of all integers, \(\mathbb{B}\) to refer to the set of Booleans \(\{TRUE,FALSE\}\), and \(\mathbb{N}\) to refer to the set of all naturals, i.e. \(\mathbb{N} = \{z \in \mathbb{Z}\mid z \ge 0\}\).</li>
<li>Function sets: We denote by \(B^A\) the set of all functions from \(A\) to \(B\), i.e. \(f \in B^A \iff f\colon A \to B\).</li>
<li>Powersets: We denote by \(2^A\) the set of all subsets of a set \(A\), i.e. 
\(B \subseteq A \iff B \in 2^A\)</li>
<li>Isomorphisms: Sets \( A \) and \(B\) are called isomorphic, if there exists a bijective function
\(b\in B^A\).</li>
<li>Predicates: Given a set \(T\), a <em>predicate</em> over \(T\) is a function \(P \in \mathbb{B}^T\), that is, a function \(P\), such that \(P(t) \in \mathbb{B}\) for each \(t \in T\).</li>
<li>Relations: Predicates over \(A \times B\) are called <em>relations</em>. A relation \(R\) over \(T \times T\) is an <em>equivalence relation</em>, if the following holds:
<ul>
<li>For all \(t \in T\), it is the case that \(R(t,t)\) (reflexivity).</li>
<li>For all \(s,t \in T\), \(R(s,t)\) holds if and only if \(R(t,s)\) holds (symmetry).</li>
<li>For all \(r,s,t \in T\), \(R(r,s) \land R(s,t)\) implies \(R(r,t)\) (transititvity).</li>
</ul>
</li>
<li>Equivalence classes: An equivalence relation \(R\) over \(T \times T\) defines a function \(E \in (2^T)^T\), such that, for each \(t \in T\), \(E(t) = \{ s \in T\mid R(t,s) \}\). \(E(t)\) is called the <em>equivalence class</em> of \(t\) for \(R\), denoted as \(\lbrack t\rbrack_R\).</li>
<li>Quotient space: An equivalence relation \(R\) over \(T \times T\) defines a <em>quotient space</em>, denoted \(T / R\), such that \(T / R = \{ \lbrack t\rbrack_R \mid t \in T \} \subseteq 2^T\).</li>
<li>Subset-predicate equivalence: For any set \(T\), there exists a natural isomorphism between
\(\mathbb{B}^T\) and \(2^T\) (implied by the similarity in notation): Each predicate \(P \in \mathbb{B}^T\) corresponds to the set \(\{ t \in T \mid P(t) = TRUE\} \in 2^T\). For this reason, predicates are often directly identified with the subset they are equivalent to, and we write \(P \subseteq T\) for brevity.</li>
<li>Infix notation: Given a relation \(R \in \mathbb{B}^{A\times B}\), we commonly write \(a\  R\  b\) instead of \(R(a,b)\) (e.g. \(a &gt; b\) instead of \(&gt;(a,b)\)).</li>
<li>Cartesian product: Given a set \(T\), we use \(T^2\) to refer to \(T \times T\). \(T^k\), for \(k &gt; 2\) is defined similarly.</li>
</ul>
<h1><a class="header" href="#temporal-properties-and-counterexamples" id="temporal-properties-and-counterexamples">Temporal properties and counterexamples</a></h1>
<p><strong>Difficulty: Red trail – Medium</strong></p>
<p><strong>Author:</strong> Philip Offtermatt, 2022</p>
<p>In this tutorial, we will show how Apalache can be used to decide temporal
properties that are more general than invariants.
This tutorial will be most useful to you if you have a basic understanding of
linear temporal logic, e.g. the semantics of <code>&lt;&gt;</code> and <code>[]</code> operators.
See a writeup of temporal operators <a href="https://learntla.com/temporal-logic/operators/">here</a>.</p>
<p>Further, we assume you are familiar with TLA+, but expert knowledge is not necessary.</p>
<p>As a running example, the tutorial uses a simple example specification, modelling a
devious nondeterministic traffic light.</p>
<h2><a class="header" href="#specifying-temporal-properties" id="specifying-temporal-properties">Specifying temporal properties</a></h2>
<p>The traffic light has two main components: A lamp which can be either red or green,
and a button which can be pushed to request the traffic light to become green.
Consequently, there are two variables:
the current state of the light (either green or red),
and whether the button has been pushed that requests the traffic light to switch from red to green.</p>
<p>The full specification of the traffic light is here:
<a href="tutorials/TrafficLight.tla">TrafficLight.tla</a>.<br />
But don't worry - we will dissect the spec in the following.</p>
<p>In the TLA specification, we declare two variables:</p>
<pre><code class="language-tla">VARIABLES 
    \* If true, the traffic light is green. If false, it is red.
    \* @type: Bool;
    isGreen,

    \* If true, the button has been pushed to request the light to become green, but the light has
    \* not become green since then.
    \* If false, the light has become green since the button has last been pushed
    \* or the button has never been pushed.
    \* @type: Bool;
    requestedGreen
</code></pre>
<p>Initially, the light is red and green has not yet been requested:</p>
<pre><code class="language-tla">\* The light is initially red, and the button was not pressed.
Init ==
    /\ isGreen = FALSE
    /\ requestedGreen = FALSE
</code></pre>
<p>We have three possible actions: </p>
<ol>
<li>The traffic light can switch from red to green, </li>
<li>The traffic light can switch from green to red, or</li>
<li>The button can be pushed, thus requesting that the traffic light becomes green.</li>
</ol>
<pre><code class="language-tla">(* ---------------------- *)
(* requesting green light *)
\* The switch to green can only be requested when the light is not green, and
\* the switch has not *already* been requested since the light last turned green.
RequestGreen_Guard ==
    /\ ~isGreen
    /\ ~requestedGreen

RequestGreen_Effect == 
    /\ requestedGreen' = TRUE
    /\ UNCHANGED &lt;&lt; isGreen &gt;&gt;

RequestGreen ==
    RequestGreen_Guard /\ RequestGreen_Effect

(* ---------------------- *)
(* switching to red light *)
\* The light can switch to red at any time if it is currently green.
SwitchToRed_Guard == isGreen

SwitchToRed_Effect ==
    /\ isGreen' = FALSE
    /\ UNCHANGED &lt;&lt; requestedGreen &gt;&gt;

SwitchToRed ==
    SwitchToRed_Guard /\ SwitchToRed_Effect

(* ------------------------ *)
(* switching to green light *)
\* The light can switch to green if it is currently red, and
\* the button to request the switch to green has been pressed.
SwitchToGreen_Guard == 
    /\ ~isGreen
    /\ requestedGreen

SwitchToGreen_Effect ==
    /\ isGreen' = TRUE
    /\ requestedGreen' = FALSE

SwitchToGreen ==
    SwitchToGreen_Guard /\ SwitchToGreen_Effect

Next ==
    \/ RequestGreen
    \/ SwitchToRed
    \/ SwitchToGreen
</code></pre>
<p>In the interest of simplicity, we'll assume that
the button cannot be pushed when green is already requested, and
that similarly it's not possible to push the button when the light is
already green.</p>
<p>Now, we are ready to specify the properties that we are interested in.
For example, when green is requested, at some point afterwards the light should actually turn green.
We can write the property like this:</p>
<pre><code class="language-tla">RequestWillBeFulfilled ==
    [](requestedGreen =&gt; &lt;&gt;isGreen)
</code></pre>
<p>Intuitively, the property says: 
&quot;Check that at all points in time ([]),
if right now, <code>RequestGreen</code> is true, 
then at some future point in time, <code>IsGreen</code> is true.&quot;</p>
<p>Let's run Apalache to check this property:</p>
<pre><code class="language-tla">apalache-mc check --temporal=RequestWillBeFulfilled TrafficLight.tla
</code></pre>
<pre><code>...
The outcome is: NoError       
Checker reports no error up to computation length 10
It took me 0 days  0 hours  0 min  2 sec
Total time: 2.276 sec
EXITCODE: OK
</code></pre>
<p>This is because our traffic watch is actually 
deterministic: 
If it is red and green has not been requested,
the only enabled action is <code>RequestGreen</code>.
If it is red and green has been requested,
only <code>SwitchToGreen</code> is enabled.
And finally, if the light is green,
only <code>SwitchToRed</code> is enabled.</p>
<p>However, we want to make our traffic light more devious.
We will allow the model to stutter, that is,
just let time pass and take no action.</p>
<p>We can write a new next predicate that explicitly allows
stuttering like this:</p>
<pre><code class="language-tla">\* @type: &lt;&lt;Bool, Bool&gt;&gt;;
vars == &lt;&lt; isGreen, requestedGreen &gt;&gt;

StutteringNext ==
    [Next]_vars
</code></pre>
<p>Recall that <code>[Next]_vars</code> is shorthand for <code>Next \/ UNCHANGED vars</code>. Now, let us try to verify the property once again,
using the modified next predicate:</p>
<pre><code>apalache-mc check --next=StutteringNext \
    --temporal=RequestWillBeFulfilled TrafficLight.tla
</code></pre>
<pre><code>Step 2: picking a transition out of 3 transition(s)               I@18:04:16.132
State 3: Checking 1 state invariants                              I@18:04:16.150
State 3: Checking 1 state invariants                              I@18:04:16.164
State 3: Checking 1 state invariants                              I@18:04:16.175
State 3: Checking 1 state invariants                              I@18:04:16.186
Check an example state in: /home/user/apalache/docs/src/tutorials/_apalache-out/TrafficLight.tla/2022-05-30T18-04-13_3349613574715319837/counterexample1.tla, /home/user/apalache/docs/src/tutorials/_apalache-out/TrafficLight.tla/2022-05-30T18-04-13_3349613574715319837/MC1.out, /home/user/apalache/docs/src/tutorials/_apalache-out/TrafficLight.tla/2022-05-30T18-04-13_3349613574715319837/counterexample1.json, /home/user/apalache/docs/src/tutorials/_apalache-out/TrafficLight.tla/2022-05-30T18-04-13_3349613574715319837/counterexample1.itf.json E@18:04:16.346
State 3: state invariant 0 violated.                              E@18:04:16.346
Found 1 error(s)                                                  I@18:04:16.347
The outcome is: Error                                             I@18:04:16.353
Checker has found an error                                        I@18:04:16.354
It took me 0 days  0 hours  0 min  2 sec                          I@18:04:16.354
Total time: 2.542 sec                                             I@18:04:16.354
</code></pre>
<p>This time, we get a counterexample.
Let's take a look at <code>/home/user/apalache/docs/src/tutorials/_apalache-out/TrafficLight.tla/2022-05-30T18-04-13_3349613574715319837/counterexample1.tla</code>.</p>
<p>Let's first focus on the initial state.</p>
<pre><code class="language-tla">(* Initial state *)
(* State0 ==
  RequestWillBeFulfilled_init = FALSE
    /\ __loop_InLoop = FALSE
    /\ __loop_☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ __loop_requestedGreen ⇒ ♢isGreen = TRUE
    /\ __loop_♢isGreen = FALSE
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = TRUE
    /\ requestedGreen ⇒ ♢isGreen = TRUE
    /\ ♢isGreen = FALSE
    /\ ♢isGreen_unroll = FALSE
    /\ isGreen = FALSE
    /\ requestedGreen = FALSE *)
State0 ==
  RequestWillBeFulfilled_init = FALSE
    /\ __loop_InLoop = FALSE
    /\ __loop___temporal_t_1 = FALSE
    /\ __loop___temporal_t_2 = TRUE
    /\ __loop___temporal_t_3 = FALSE
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
    /\ __temporal_t_1 = FALSE
    /\ __temporal_t_1_unroll = TRUE
    /\ __temporal_t_2 = TRUE
    /\ __temporal_t_3 = FALSE
    /\ __temporal_t_3_unroll = FALSE
    /\ isGreen = FALSE
    /\ requestedGreen = FALSE
</code></pre>
<p>Two things are notable:</p>
<ol>
<li>The initial state formula appears twice, once as a comment and once in TLA+.</li>
<li>There are way more variables than the two variables we specified.</li>
</ol>
<p>The comment and the TLA+ specification express the same state, but in the comment, some variable names from the encoding have been replaced
with more human-readable names.
For example, there is a variable called <code>☐(requestedGreen ⇒ ♢isGreen)</code> in the comment,
which is called <code>__temporal_t_1</code> in TLA+.
In the following, let's focus on the content of the comment, since it's easier to understand what's going on.</p>
<p>There are many additional variables in the counterexample because to check temporal formulas, Apalache uses an
encoding that transforms temporal properties to invariants.
If you are interested in the technical details, the encoding is described in sections 3.2 and 4 of <a href="https://lmcs.episciences.org/2236">Biere et al.</a>.
However, to understand the counterexample, you don't need to go into the technical details of the encoding.
We'll go explain the counterexample in the following.</p>
<p>We will talk about traces in the following.
You can find more information about (symbolic) traces <a href="tutorials//tutorials/symbmc.html?highlight=trace#symbolic-traces">here</a>.
For the purpose of this tutorial, however, it will be enough to think of a trace as a sequence of states
that were encountered by Apalache, and that demonstrate a violation of the property that is checked.</p>
<h2><a class="header" href="#counterexamples-encode-lassos" id="counterexamples-encode-lassos">Counterexamples encode lassos</a></h2>
<p>First, it's important to know that for finite-state systems, counterexamples to temporal properties are traces ending in a loop,
which we'll call lassos in the following. If you want to learn more about why this is the case,
have a look at the book on <a href="https://mitpress.mit.edu/books/model-checking-second-edition">model checking</a>.</p>
<p>A loop is a partial trace that starts and ends with the same state. 
A lasso is made up of two parts: A prefix, followed by a loop.
It describes a possible infinite execution: first it goes through the prefix, and then repeats the loop forever.</p>
<p>For example, what is a trace that is a counterexample to the property <code>♢isGreen</code>?
It's an execution that loops without ever finding a state that satisfies <code>isGreen</code>.
For example, a counterexample trace might visually look like this:</p>
<p><img src="tutorials/img/looping_trace.png" alt="A counterexample trace for the property &lt;&gt;isGreen" /></p>
<p>In contrast, as long as the model checking engine has not found a lasso, there may still exist some future state satisfying <code>isGreen</code>.</p>
<h2><a class="header" href="#utilizing-auxiliary-variables-to-find-lassos" id="utilizing-auxiliary-variables-to-find-lassos">Utilizing auxiliary variables to find lassos</a></h2>
<p>The encoding for temporal properties involves lots of auxiliary variables.
While some can be very helpful to understand counterexamples,
many are mostly noise.</p>
<p>Let's first understand how Apalache can identify lassos using auxiliary variables.
The auxiliary variable <code>__loop_InLoop</code> is true in exactly the states belonging to the loop.
Additionally, at the first state of the loop, i.e., when <code>__loop_InLoop</code> switches from false to true,
we store the valuation of each variable in a shadow copy whose name is prefixed by <code>__loop_</code>.
Before the first state of the loop, the <code>__loop_</code> carry arbitrary values.
In our example, it looks like this:</p>
<pre><code class="language-tla">(* State0 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
    ...
    /\ isGreen = FALSE
    /\ requestedGreen = FALSE *)

(* State1 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
    ...
    /\ isGreen = FALSE
    /\ requestedGreen = TRUE *)

(* State2 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
    ...
    /\ isGreen = FALSE
    /\ requestedGreen = TRUE *)

(* State3 ==
    ...
    /\ __loop_InLoop = TRUE
    ...
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = TRUE
    ...
    /\ isGreen = FALSE
    /\ requestedGreen = TRUE *)
</code></pre>
<p>So, initially, <code>isGreen</code> and <code>requestedGreen</code> are both false.
Further, <code>__loop_InLoop</code> is false, and the copies of <code>isGreen</code> and <code>requestedGreen</code>, which are called
<code>__loop_isGreen</code> and <code>__loop_requestedGreen</code>, are equal to the values of <code>isGreen</code> and <code>requestedGreen</code>.</p>
<p>From state 0 to state 1, <code>requestedGreen</code> changes from false to true.
From state 1 to state 2, the system stutters, and the valuation of model variables remains unchanged.
Finally, in state 3 <code>__loop_InLoop</code> is set to true, which means that
the loop starts in state 2, and the trace from state 3 onward is inside the loop.
However, since state 3 is the last state, this means simply that the trace loops in state 2.
Since the loop starts, the copies of the system variables are also set to the values of the variables in state 2,
so <code> __loop_isGreen = FALSE</code> and <code>__loop_requestedGreen = TRUE</code>.</p>
<p>The lasso in this case can be visualized like this:</p>
<p><img src="tutorials/img/counterexample.png" alt="A counterexample trace for the property [](requestedGreen =&gt; &lt;&gt;isGreen)" /></p>
<p>It is also clear why this trace violates the property:
<code>requestedGreen</code> holds in state 1, but <code>isGreen</code> never holds,
so in state 1 the property <code>requestedGreen =&gt; &lt;&gt;isGreen</code> is violated.</p>
<h2><a class="header" href="#auxiliary-variables-encode-evaluations-of-subformulas-along-the-trace" id="auxiliary-variables-encode-evaluations-of-subformulas-along-the-trace">Auxiliary variables encode evaluations of subformulas along the trace</a></h2>
<p>Next, let us discuss the other auxiliary variables that are introduced by Apalache to check the temporal property.
These extra variables correspond to parts of the temporal property we want to check.
These are the following variables with their valuations in the initial state:</p>
<pre><code class="language-tla">(* State0 ==
  RequestWillBeFulfilled_init = FALSE
    ...
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = TRUE
    /\ requestedGreen ⇒ ♢isGreen = TRUE
    /\ ♢isGreen = FALSE
    /\ ♢isGreen_unroll = FALSE
    ...
</code></pre>
<p>There are three groups of variables: </p>
<ul>
<li>Variables that look like formulas, e.g. <code>☐(requestedGreen ⇒ ♢isGreen)</code></li>
<li>Variables that look like formulas and end with <code>_unroll</code>,
e.g. <code>☐(requestedGreen ⇒ ♢isGreen)_unroll</code></li>
<li>The variable <code>RequestWillBeFulfilled_init</code>.</li>
</ul>
<p>Let's focus on the non-<code>_unroll</code> variables that look like formulas
first.</p>
<p>Recall that the temporal property we want to check is <code>[](requestedGreen =&gt; &lt;&gt;isGreen)</code>.
That's also the name of one of the variables: The value of the variable 
<code>☐(requestedGreen ⇒ ♢isGreen)</code> tells us whether starting in the current state, the
formula <code>[](requestedGreen =&gt; &lt;&gt;isGreen)</code> holds. Since we are looking at a counterexample to this formula, it is not
surprising that the formula does not hold in the initial state of the counterexample.</p>
<p>Similarly, the variable <code>requestedGreen ⇒ ♢isGreen</code> tells us whether
the property <code>requestedGreen ⇒ ♢isGreen</code> holds at the current state.
It might be surprising to see that the property holds
but recall that in state 0, <code>requestedGreen = FALSE</code>, so the implication is satisfied.
Finally, we have the variable <code>♢isGreen</code>, which is false, telling
us that along the execution, <code>isGreen</code> will never be true.</p>
<p>You might already have noticed the pattern of which formulas appear as variables.
Take our property <code>[](requestedGreen =&gt; &lt;&gt;isGreen)</code>.
The syntax tree of this formula looks like this:</p>
<p><img src="tutorials/img/syntaxtree.png" alt="The syntax tree for the formula [](requestedGreen =&gt; &lt;&gt;isGreen)" /></p>
<p>For each node of the syntax tree where the formula contains a temporal operator,
there is an auxiliary variable. 
For example, there would be auxiliary variables for the formulas <code>[]isGreen</code>
and <code>(&lt;&gt;isGreen) /\ ([]requestedGreen)</code>, but not for the formula <code>isGreen /\ requestedGreen</code>.</p>
<p>As mentioned before, the value of 
an auxiliary variable in a state tells us whether from that state, the corresponding subformula is true.
In this particular example, the formulas that correspond to variables in the encoding are filled with orange in the syntax tree.</p>
<p>What about the <code>_unroll</code> variables? There is one <code>_unroll</code> variable for each immediate application of a temporal operator in the formula.
For example, <code>☐(requestedGreen ⇒ ♢isGreen)_unroll</code> is the unroll-variable for the
leading box operator. </p>
<p>To illustrate why these are necessary, consider the formula
<code>[]isGreen</code>. To decide whether this formula holds in the last state of the loop, the algorithm needs to know whether
<code>isGreen</code> holds in all states of the loop. So it needs to store this information when it traverses the loop.
That's why there is an extra variable, which stores whether <code>isGreen</code> holds on all states of the loop, and Apalache can access this information when it explores the last state of the loop.
Similarly, the unroll-variable <code>♢isGreen_unroll</code> holds true
if there is a state on the loop such that <code>isGreen</code> is true.</p>
<p>Let us take a look at the valuations of <code>☐(requestedGreen ⇒ ♢isGreen)_unroll</code> along our counterexample to see this.</p>
<pre><code class="language-tla">(* State0 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = TRUE
    ...

(* State1 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = TRUE
    ...

(* State2 ==
    ...
    /\ __loop_InLoop = FALSE
    ...
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = TRUE
    ...

(* State3 ==
    ...
    /\ __loop_InLoop = TRUE
    ...
    /\ ☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ ☐(requestedGreen ⇒ ♢isGreen)_unroll = FALSE
    ...
</code></pre>
<p>So in the last state, <code>☐(requestedGreen ⇒ ♢isGreen)_unroll</code>
is not true, since <code>☐(requestedGreen ⇒ ♢isGreen)</code>
does not hold in state 2, which is on the loop.</p>
<p>Similar to the <code>__loop_</code> copies for model variables,
we also introduce copies for all (temporal) subformulas, e.g., <code>__loop_☐(requestedGreen ⇒ ♢isGreen)</code> for <code>☐(requestedGreen ⇒ ♢isGreen)</code>.
These fulfill the same function as the <code>__loop_</code> copies for the
original variables of the model, i.e., retaining the state of variables from the first state of the loop, e.g.,</p>
<pre><code class="language-tla">(* State0 ==
    ...
    /\ __loop_☐(requestedGreen ⇒ ♢isGreen) = FALSE
    /\ __loop_requestedGreen ⇒ ♢isGreen = TRUE
    /\ __loop_♢isGreen = FALSE
    /\ __loop_isGreen = FALSE
    /\ __loop_requestedGreen = FALSE
</code></pre>
<p>Finally, let's discuss <code>RequestWillBeFulfilled_init</code>.
This variable is an artifact of the translation for temporal properties.
Intuitively, in any state, the variable will be true if the variable encoding the formula <code>RequestWillBeFulfilled</code>
is true in the first state.
A trace is a counterexample if <code>RequestWillBeFulfilled</code> is false in the first state, so <code>RequestWillBeFulfilled_init</code> is false,
and a loop satisfying requirements on the auxiliary variables is found.</p>
<h2><a class="header" href="#further-reading-2" id="further-reading-2">Further reading</a></h2>
<p>In this tutorial, we learned how to specify temporal properties
in Apalache, and how to read counterexamples for such properties.</p>
<p>If you want to dive deeper into the
encoding, it is formally explained in sections 3.2 and 4 of
<a href="https://lmcs.episciences.org/2236">Biere et al.</a>. To understand why this encoding was chosen,
you can read the <a href="tutorials/../adr/017pdr-temporal.html">ADR on temporal properties</a>.
Finally, if you want to go into the nitty-gritty details and see
the encoding in action,
you can look at the intermediate TLA specifying the encoding.</p>
<p>Run</p>
<pre><code>apalache-mc check --next=StutteringNext \
    --write-intermediate=yes --temporal=RequestWillBeFulfilled TrafficLight.tla
</code></pre>
<p>You will get intermediate output in a folder named like
<code>_apalache_out/TrafficLight/TIMESTAMP/intermediate/</code>.
There, take a look at <code>0X_OutTemporalPass.tla</code>.</p>
<h1><a class="header" href="#overview-2" id="overview-2">Overview</a></h1>
<ol>
<li><a href="HOWTOs/./howto-write-type-annotations.html">How to write type annotations</a></li>
</ol>
<h1><a class="header" href="#how-to-write-type-annotations" id="how-to-write-type-annotations">How to write type annotations</a></h1>
<p><strong>Revision:</strong> August 24, 2022</p>
<p><strong>Important updates:</strong></p>
<ul>
<li>
<p>Version 0.29.0: The new syntax for records and variants is enabled by
default (previously, enabled with <code>--features=rows</code>). For the transition
period, the old type syntax can be activated with <code>--features=no-rows</code>.
See <a href="HOWTOs/howto-write-type-annotations.html#recipe9">Recipe 9</a> on transitioning to Type System 1.2.</p>
</li>
<li>
<p>Version 0.25.10: This HOWTO introduces new syntax for type aliases. See
<a href="HOWTOs/../adr/002adr-types.html#defTypeAlias">Type Aliases</a> in ADR-002.</p>
</li>
<li>
<p>Version 0.25.9: This HOWTO introduces new syntax for record types and
variants, which is currently under testing. This syntax is activated via the
option <code>--features=rows</code>. See <a href="HOWTOs/../adr/002adr-types.html#ts12">Type System 1.2</a>
in ADR-002.</p>
</li>
<li>
<p>Version 0.23.1: The example specification uses recursive operators, which
were removed in version 0.23.1.</p>
</li>
<li>
<p>Version 0.15.0: This HOWTO discusses how to write type annotations for the type checker
<a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a>, which is used in Apalache since version 0.15.0 (introduced in
2021).</p>
</li>
</ul>
<p>This HOWTO gives you concrete steps to extend TLA+ specifications with type
annotations. You can find the detailed syntax of type annotations in
<a href="HOWTOs/../adr/002adr-types.html">ADR002</a>. The first rule of writing type annotations:</p>
<p><em>Do not to write any annotations at all, until the type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> is
asking you to write a type annotation.</em></p>
<p>Of course, there must be an exception to this rule. You have to write type
annotations for CONSTANTS and VARIABLES. This is because Snowcat infers types
of declarations in isolation instead of analyzing the whole specification.
The good news is that the type checker finds the types of many operators
automatically. </p>
<h2><a class="header" href="#recipe-1-annotating-variables" id="recipe-1-annotating-variables">Recipe 1: Annotating variables</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla">HourClock.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">---------------------- MODULE HourClock ----------------------
\* This is a local copy of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla
EXTENDS Naturals
VARIABLE
    \* @type: Int;
    hr

HCini  ==  hr \in (1 .. 12)
HCnxt  ==  hr' = IF hr # 12 THEN hr + 1 ELSE 1
HC  ==  HCini /\ [][HCnxt]_hr

TypeOK == hr \in (1 .. 12)
--------------------------------------------------------------
THEOREM  HC =&gt; []HCini
==============================================================
</code></pre>
<p>Without thinking much about the types, run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck HourClock.tla
</code></pre>
<p>The type checker complains about not knowing the type of the variable <code>hr</code>:</p>
<pre><code>...
Typing input error: Expected a type annotation for VARIABLE hr
...
</code></pre>
<p>Annotate the type of variable <code>hr</code> as below. Note carefully that the type
annotation should be <em>between</em> the keyword <code>VARIABLE</code> and the variable name.
This is because variable declarations may declare several variables at once.
In this case, you have to write one type annotation per name.</p>
<pre><code class="language-tla">VARIABLE
  \* @type: Int;
  hr
</code></pre>
<p>Run the type checker again. You should see the following message:</p>
<pre><code>...
 &gt; Running Snowcat .::.
 &gt; Your types are purrfect!
 &gt; All expressions are typed
...
</code></pre>
<p><a id="recipe2"></a></p>
<h2><a class="header" href="#recipe-2-annotating-constants" id="recipe-2-annotating-constants">Recipe 2: Annotating constants</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla">Channel.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">
-------------------------- MODULE Channel -----------------------------
\* This is a typed version of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla
EXTENDS Naturals
CONSTANT Data
VARIABLE chan 

TypeInvariant  ==  chan \in [val : Data,  rdy : {0, 1},  ack : {0, 1}]
-----------------------------------------------------------------------
Init  ==  /\ TypeInvariant
          /\ chan.ack = chan.rdy 

Send(d) ==  /\ chan.rdy = chan.ack
            /\ chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]

Rcv     ==  /\ chan.rdy # chan.ack
            /\ chan' = [chan EXCEPT !.ack = 1 - @]

Next  ==  (\E d \in Data : Send(d)) \/ Rcv

Spec  ==  Init /\ [][Next]_chan
-----------------------------------------------------------------------
THEOREM Spec =&gt; []TypeInvariant
=======================================================================

</code></pre>
<p>Run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck Channel.tla
</code></pre>
<p>The type checker does not know the type of the variable <code>chan</code>:</p>
<pre><code>Typing input error: Expected a type annotation for VARIABLE chan
</code></pre>
<p>According to <code>TypeInvariant</code>, the variable <code>chan</code> is a record that has three
fields: <code>val</code>, <code>rdy</code>, and <code>ack</code>. The field <code>val</code> ranges over a set <code>Data</code>,
which is actually defined as <code>CONSTANT</code>. In principle, we can annotate the
constant <code>Data</code> with a set of any type, e.g., <code>Set(Int)</code> or <code>Set(BOOLEAN)</code>.
Since the specification is not using any operators over <code>Data</code> except equality,
we can use an <em>uninterpreted type</em> as a type for set elements, e.g.,
we can define <code>Data</code> to have the type <code>Set(DATUM)</code>. Uninterpreted types are
always written in CAPITALS. Now we can annotate <code>Data</code> and <code>chan</code> as follows:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(DATUM);
    Data
VARIABLE
    \* @type: { val: DATUM, rdy: Int, ack: Int };
    chan 
</code></pre>
<p>Note carefully that the type annotation should be <em>between</em> the keyword
<code>CONSTANT</code> and the constant name. This is because constant declarations may
declare several constants at once. In this case, you have to write one type
annotation per name.</p>
<p>Have a look at the type of <code>chan</code>:</p>
<pre><code>\* @type: { val: DATUM, rdy: Int, ack: Int };
</code></pre>
<p>The type of <code>chan</code> is a record that has three fields: field <code>val</code> of type
<code>DATUM</code>, field <code>rdy</code> of type <code>Int</code>, field <code>ack</code> of type <code>Int</code>. The record type syntax is similar to dictionary syntax from programming languages (e.g. Python). We made it different
from TLA+'s syntax for records <code>[ val |-&gt; v, rdy |-&gt; r, ack |-&gt; a ]</code>
and record sets <code>[ val: V, rdy: R, ack: A ]</code>, to avoid confusion between
types and values.</p>
<p>Run the type checker again. You should see the following message:</p>
<pre><code>$ apalache-mc typecheck ChannelTyped.tla
...
&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed 
</code></pre>
<h2><a class="header" href="#recipe-3-annotating-operators" id="recipe-3-annotating-operators">Recipe 3: Annotating operators</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CarTalkPuzzle/CarTalkPuzzle.tla">CarTalkPuzzle.tla</a> from the repository of TLA+
examples. This example has 160 lines of code, so we do not inline it here.
By running the type checker as in previous sections, you should figure out
that the constants <code>N</code> and <code>P</code> should be annotated with the type <code>Int</code>.
Annotate <code>N</code> and <code>P</code> with <code>Int</code> and run the type checker:</p>
<pre><code class="language-sh">$ apalache-mc typecheck CarTalkPuzzle.tla
</code></pre>
<p>Now you should see the following error:</p>
<pre><code>[CarTalkPuzzle.tla:52:32-52:35]: Cannot apply f to the argument x() in f[x()].
[CarTalkPuzzle.tla:50:1-52:53]: Error when computing the type of Sum
</code></pre>
<p>Although the error message may look confusing, the reason is simple: The type
checker cannot figure out whether the operator <code>Sum</code> expects a sequence
or a function of integers as its first parameter. By looking carefully at
the definition of <code>Sum</code>, we can see that it expects: (1) a function from
integers to integers as its first parameter, (2) a set of integers
as its second parameter, and (3) an integer as a result. Hence, we annotate
<code>Sum</code> as follows:</p>
<pre><code class="language-tla">RECURSIVE Sum(_,_)
\* type: (Int -&gt; Int, Set(Int)) =&gt; Int;
Sum(f,S) ==
    ...
</code></pre>
<p>Note that the annotation has to be written between <code>RECURSIVE Sum(_, _)</code> and
the definition of <code>Sum</code>. This might change later, see <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> at tlaplus.</p>
<p>After providing the type checker with the annotation for <code>Sum</code>, we get one
more type error:</p>
<pre><code>[CarTalkPuzzle.tla:160:23-160:26]: Cannot apply B to the argument x in B[x].
[CarTalkPuzzle.tla:160:7-160:37]: Error when computing the type of Image
</code></pre>
<p>This time the type checker cannot choose between two options for the second
parameter of <code>Image</code>: It could be a function, or a sequence. We help the
type checker by writing that the second parameter should be a function
of integers to integers, that is, <code>Int -&gt; Int</code>:</p>
<pre><code class="language-tla">      \* @type: (Set(Int), Int -&gt; Int) =&gt; Set(Int);
      Image(S, B) == {B[x] : x \in S}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code>...
&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed 
...
</code></pre>
<p><a id="recipe4"></a></p>
<h2><a class="header" href="#recipe-4-using-variants-in-heterogenous-sets" id="recipe-4-using-variants-in-heterogenous-sets">Recipe 4: Using variants in heterogenous sets</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> from the repository of TLA+ examples (you
will also need <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TCommit.tla">TCommit.tla</a>, which is imported by TwoPhase.tla). This
example has 176 lines of code, so we do not inline it here.</p>
<p>As you probably expected, the type checker complains about not knowing
the types of constants and variables. As for constant <code>RM</code>, we opt for using
an uninterpreted type that we call <code>RM</code>. That is:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(RM);
    RM \* The set of resource managers
</code></pre>
<p>By looking at the spec, it is easy to guess the types of the variables
<code>rmState</code>, <code>tmState</code>, and <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: RM -&gt; Str;
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
  \* @type: Str;
  tmState,       \* The state of the transaction manager.
  \* @type: Set(RM);
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<p>The type of the variable <code>msgs</code> is less obvious. We can check the original
(untyped) definitions of <code>TPTypeOK</code> and <code>Message</code> to get an idea about the
type of <code>msgs</code>:</p>
<pre><code class="language-tla">Message ==
  ({[type |-&gt; t, rm |-&gt; r]: t \in {&quot;Prepared&quot;}, r \in RM }
   \union
   {[type |-&gt; t] : t \in {&quot;Commit&quot;, &quot;Abort&quot;}})

TPTypeOK ==
  ...
  /\ msgs \in SUBSET Message
</code></pre>
<p>From these (untyped) definitions, you can see that <code>msgs</code> is a set that
contains records of two types: <code>{ type: Str }</code> and <code>{ type: Str, rm: RM }</code>.
This seems to be problematic, as we have to mix in two records types in a
single set, which requires us to specify its only type.</p>
<p>To this end, we have to use the <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Variants.tla">Variants module</a>, which is distributed with
Apalache. For reference, check the <a href="HOWTOs/../lang/variants.html">Chapter on variants</a>. First, we declare a
type alias for the type of messages in a separate file called
<code>TwoPhaseTyped_typedefs.tla</code>:</p>
<pre><code class="language-tla">----------------------- MODULE TwoPhaseTyped_typedefs ----------------
(*
 @typeAlias: message = Commit(NIL) | Abort(NIL) | Prepared(RM);
 *)
TwoPhaseTyped_aliases == TRUE

======================================================================
</code></pre>
<p>Usually, we place type aliases in a separate file for when we have
to use the same type alias in different specifications, e.g., the specification
and its instance for model checking.</p>
<p>With the type alias <code>MESSAGE</code>, we specify that a message is a variant type,
that is, it can represent three kinds of different values:</p>
<ul>
<li>
<p>A value tagged with <code>Commit</code>. Since we do not require the variant to carry
any value here, we simply declare that the value has the uninterpreted type
<code>NIL</code>. This is simply a convention, we could use any type in this case.</p>
</li>
<li>
<p>A value tagged with <code>Abort</code>. Similar to <code>Commit</code>, we are using the <code>NIL</code>
type.</p>
</li>
<li>
<p>A value tagged with <code>Prepared</code>. In this case, the value is of importance.
We are using the value <code>RM</code>, that is, the (uninterpreted) type of a resource
manager.</p>
</li>
</ul>
<p>Once we have specified the variant type, we introduce three constructors,
one per variant option:</p>
<pre><code class="language-tla">\* @type: $message;
MkCommit == Variant(&quot;Commit&quot;, &quot;0_OF_NIL&quot;)

\* @type: $message;
MkAbort == Variant(&quot;Abort&quot;, &quot;0_OF_NIL&quot;)

\* @type: RM =&gt; $message;
MkPrepared(rm) == Variant(&quot;Prepared&quot;, rm)
</code></pre>
<p>Since the values carried by the <code>Commit</code> and <code>Abort</code> messages are not
important, we use the uninterpeted value <code>&quot;0_OF_NIL&quot;</code>. This is merely a
convention. We could use any value of type <code>NIL</code>. Importantly, the operators
<code>MkAbort</code>, <code>MkCommit</code>, and <code>MkPrepared</code> all produce values of type <code>MESSAGE</code>,
which makes it possible to add them to a single set of messages.</p>
<p>Now it should be clear how to specify the type of the variable <code>msgs</code>:</p>
<pre><code class="language-tla">  \* @type: Set($message);
  msgs
</code></pre>
<p>We run the type checker once again:</p>
<pre><code class="language-sh">$ apalache-mc typecheck TwoPhaseTyped.tla
...
 &gt; All expressions are typed
Type checker [OK]
</code></pre>
<p>As you can see, variants require quite a bit of boilerplate. If you can simply
introduce a set of records of the same type, this is usually a simpler
solution. For instance, we could partition <code>msgs</code> into three subsets: the
subset of <code>Commit</code> messages, the subset of <code>Abort</code> messages, and the subset of
<code>Prepared</code> messages. See the discussion in <a href="HOWTOs/../idiomatic/003record-sets.html">Idiom 15</a>.</p>
<p><a id="funAsSeq"></a></p>
<h2><a class="header" href="#recipe-5-functions-as-sequences" id="recipe-5-functions-as-sequences">Recipe 5: functions as sequences</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/N-Queens/Queens.tla">Queens.tla</a> from the repository of TLA+ examples.  It has
85 lines of code, so we do not include it here. Similar to the previous
sections, we annotate constants and variables:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Int;
    N              \** number of queens and size of the board
...
VARIABLES
    \* @type: Set(Seq(Int));
    todo,
    \* @type: Set(Seq(Int));
    sols
</code></pre>
<p>After having inspected the type errors reported by Snowcat, we annotate the
operators <code>Attacks</code>, <code>IsSolution</code>, and <code>vars</code> as follows:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j) ==
  ...

\* @type: Seq(Int) =&gt; Bool;
IsSolution(queens) ==
  ...

\* @type: &lt;&lt;Set(Seq(Int)), Set(Seq(Int))&gt;&gt;;
vars == &lt;&lt;todo,sols&gt;&gt;
</code></pre>
<p>Now we run the type checker and receive the following type error:</p>
<pre><code>[Queens.tla:35:44-35:61]: The operator IsSolution of type ((Seq(Int)) =&gt; Bool) is applied to arguments of incompatible types in IsSolution(queens):
Argument queens should have type Seq(Int) but has type (Int -&gt; Int). E@11:07:53.285
[Queens.tla:35:1-35:63]: Error when computing the type of Solutions
</code></pre>
<p>Let's have a closer look at the problematic operator definition of <code>Solutions</code>:</p>
<pre><code class="language-tla">Solutions ==
    { queens \in [1..N -&gt; 1..N]: IsSolution(queens) }
</code></pre>
<p>This looks interesting: <code>IsSolution</code> expects a sequence, whereas
<code>Solutions</code> produces a set of functions. This is obviously not a
problem in untyped TLA+. In fact, it is a well-known idiom: Construct a
function by using the function set operator, and then apply sequence operators to it.
In Apalache we have to explicitly write that a function should be reinterpreted
as a sequence.  To this end, we have to use the operator <code>FunAsSeq</code> from the
module <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Apalache.tla">Apalache.tla</a>. Hence, we add <code>Apalache</code> to the <code>EXTENDS</code> clause and
apply the operator <code>FunAsSeq</code> as follows:</p>
<pre><code class="language-tla">EXTENDS Naturals, Sequences, Apalache
...
Solutions ==
  LET Queens == { FunAsSeq(queens, N, N): queens \in  [1..N -&gt; 1..N] } IN
  {queens \in Queens : IsSolution(queens)}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code>&gt; Running Snowcat .::.
&gt; Your types are purrfect!
&gt; All expressions are typed
</code></pre>
<p><a id="typeAliases"></a></p>
<h2><a class="header" href="#recipe-6-type-aliases" id="recipe-6-type-aliases">Recipe 6: type aliases</a></h2>
<p>Type aliases can be used to provide a concise label for complex types, or to
clarify the intended meaning of a simple types in the given context. </p>
<p>Type aliases are declared with the <code>@typeAlias</code> annotation, as follows:</p>
<pre><code class="language-tla">\* @typeAlias: aliasNameInCamelCase = &lt;type&gt;;
</code></pre>
<p>For example, suppose we have annotated some constants as follows:</p>
<pre><code class="language-tla">CONSTANTS
    \* @type: Set(PERSON);
    Missionaries,
    \* @type: Set(PERSON);
    Cannibals 
</code></pre>
<p>If we continue annotating other declarations in the specification, we will see
that the type <code>Set(PERSON)</code> is used frequently. Type aliases let us provide a 
shortcut.</p>
<p>By convention, we introduce all type aliases by annotating an operator called
<code>&lt;PREFIX&gt;_typedefs</code>, where the <code>&lt;PREFIX&gt;</code> is replaced with a unique prefix to
prevent name clashes across different modules. Typically <code>&lt;PREFIX&gt;</code> is just the
module name. For the <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/MissionariesAndCannibalsTyped.tla">MissionariesAndCannibalsTyped.tla</a> example, we have:</p>
<pre><code class="language-tla">\* @typeAlias: persons = Set(PERSON);
MissionariesAndCannibals_typedefs = TRUE
</code></pre>
<p>Having defined the type alias, we can use it in other definitions anywhere else 
in the file:</p>
<pre><code class="language-tla">CONSTANTS
    \* @type: $persons;
    Missionaries,
    \* @type: $persons;
    Cannibals 

VARIABLES
    \* @type: Str;
    bank_of_boat,
    \* @type: Str -&gt; $persons;
    who_is_on_bank 
</code></pre>
<p>Surely, we did not gain much by writing <code>$persons</code> instead of <code>Set(PERSON)</code>.
But if your specification has complex types (e.g., records), aliases may help
you in minimizing the burden of specification maintenance. If you add one
more field to the record type, it suffices to change the definition of the type
alias, instead of changing the record type everywhere.</p>
<p>For more details on the design and usage, see <a href="HOWTOs/../adr/002adr-types.html#defTypeAlias">Type Aliases</a> in ADR-002.</p>
<h2><a class="header" href="#recipe-7-multi-line-annotations" id="recipe-7-multi-line-annotations">Recipe 7: Multi-line annotations</a></h2>
<p>A type annotation may span over multiple lines. You may use both the <code>(* ... *)</code> syntax as well as the single-line syntax <code>\* ...</code>. All three examples below
are accepted by the parser:</p>
<pre><code class="language-tla">VARIABLES
   (*
    @type: Int
            =&gt; Bool;
    *)           
    f,
    \* @type:
    \*       Int
    \*          =&gt; Bool;
    g,
    \* @type(&quot;Int
    \*          =&gt; Bool
    \*       &quot;)
    h
</code></pre>
<p>Note that the parser removes the leading strings <code>&quot;    \*&quot;</code> from the annotations,
similar to how multi-line strings are treated in modern programming languages.</p>
<h2><a class="header" href="#recipe-8-comments-in-annotations" id="recipe-8-comments-in-annotations">Recipe 8: Comments in annotations</a></h2>
<p>Sometimes, it helps to document the meaning of type components. Consider the following
example from <a href="HOWTOs/howto-write-type-annotations.html#funAsSeq">Recipe 5</a>:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j)
</code></pre>
<p>If you think that an explanation of the arguments would help, you can do that as follows:</p>
<pre><code class="language-tla">(*
  @type:
    (
      // the column of an n-th queen, for n in the sequence domain
      Seq(Int),
      // the index (line number) of the first queen
      Int,
      // the index (line number) of the second queen
      Int
    ) =&gt; Bool;
*)
Attacks(queens,i,j)
</code></pre>
<p>You don't have to do that, but if you feel that types can also help you in documenting
your specification, you have this option.</p>
<p><a id="recipe9"></a></p>
<h2><a class="header" href="#recipe-9-migrate-from-type-system-1-to-type-system-12" id="recipe-9-migrate-from-type-system-1-to-type-system-12">Recipe 9: Migrate from Type System 1 to Type System 1.2</a></h2>
<p>As explained in <a href="HOWTOs/../adr/002adr-types.html">ADR002</a>, <a href="HOWTOs/../adr/002adr-types.html#ts12">Type System 1.2</a> (TS1.2) differs from <a href="HOWTOs/../adr/002adr-types.html#ts1">Type
System 1</a> (TS1) as follows:</p>
<ul>
<li>
<p>TS1 allows one to mix records of varying domains, as long as the records
agree on the types of the common fields. Hence, record access is not
enforced by the type checker and thus is error-prone.</p>
</li>
<li>
<p>TS1 is using the syntax <code>[ field_n: T_1, ..., field_n: T_n ]</code>, which is
sometimes confused with the TLA+ expression <code>[ field_n: e_1, ..., field_n: e_n ]</code>.</p>
</li>
<li>
<p>TS1.2 is using the syntax <code>{ field_n: T_1, ..., field_n: T_n }</code>
for record types and the syntax <code>Tag_1(T_1) | ... | Tag_n(T_n)</code>
for variant types.</p>
</li>
<li>
<p>TS1.2 differentiates between records of different domains and does not allow
the specification writer to mix them. As a result, TS1.2 can catch incorrect
record access. Instead of mixing records, TS1.2 allows one to mix
<a href="HOWTOs/../lang/variants.html">Variants</a>.</p>
</li>
<li>
<p>TS1.2 supports <a href="https://en.wikipedia.org/wiki/Row_polymorphism">Row polymorphism</a> and thus lets the user write type
annotations over records and variants, whose shape is only
partially-defined.  For example, <code>{ foo: Int, bar: Bool, a }</code> defines a
record type that has at least two fields (that is, <code>foo</code> of type <code>Int</code> and
<code>bar</code> of type <code>Bool</code>), but may have more fields, which are captured with the
row variable <code>a</code>.</p>
</li>
</ul>
<h3><a class="header" href="#case-1-plain-records" id="case-1-plain-records">Case 1: plain records</a></h3>
<p>Many specifications are using plain records. For instance, they do not assign
records of different domains to the same variable. Nor do they mix records of
different domains in the same set. Plenty of specifications fall into this
class.</p>
<p>For example, check <a href="HOWTOs/howto-write-type-annotations.html#recipe2">Recipe 2</a>. In this recipe, the variable <code>chan</code> is
always carrying a record with the domain <code>{ &quot;val&quot;, &quot;rdy&quot;, &quot;ack&quot; }</code>.</p>
<p>In this case, all you have to do is to replace the old record types of the form
<code>[ field_n: T_1, ..., field_n: T_n ]</code> with the new record types of the form <code>{ field_n: T_1, ..., field_n: T_n }</code>. That is, replace <code>[</code> and <code>]</code> with <code>{</code> and
<code>}</code>, respectively.</p>
<h3><a class="header" href="#case-2-mixed-records" id="case-2-mixed-records">Case 2: mixed records</a></h3>
<p>Some specifications are using mixed records, which are similar to unions in C.</p>
<p>For example, check <a href="HOWTOs/howto-write-type-annotations.html#recipe4">Recipe 4</a>. In this recipe, the variable
<code>tmPrepared</code> is a set that contains records of different domains. For instance,
<code>tmPrepared</code> may be equal to:</p>
<pre><code class="language-tla">{ [ type |-&gt; &quot;Commit&quot; ], [ type |-&gt; &quot;Prepared&quot;, rm |-&gt; &quot;0_OF_RM&quot; ] }
</code></pre>
<p>In this case, you have two choices:</p>
<ul>
<li>
<p>Partition the single variable into multiple variables, see <a href="HOWTOs/../idiomatic/003record-sets.html">Idiom 15</a>.</p>
</li>
<li>
<p>Introduce variant types, see <a href="HOWTOs/howto-write-type-annotations.html#recipe4">Recipe 4</a>.</p>
</li>
</ul>
<h2><a class="header" href="#known-issues" id="known-issues">Known issues</a></h2>
<h3><a class="header" href="#annotations-of-local-operators" id="annotations-of-local-operators">Annotations of LOCAL operators</a></h3>
<p>In contrast to all other cases, a local operator definition does require
a type annotation before the keyword <code>LOCAL</code>, not after it. For example:</p>
<pre><code class="language-tla">\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1
</code></pre>
<p>This may change later, when the tlaplus <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> is resolved.</p>
<h1><a class="header" href="#how-to-use-uninterpreted-types" id="how-to-use-uninterpreted-types">How to use uninterpreted types</a></h1>
<p>This HOWTO explains what uninterpreted types are in the context of Apalache's type system, outlined in <a href="HOWTOs/../adr/002adr-types.html">ADR002</a>, and where/how to use them.</p>
<h2><a class="header" href="#what-are-uninterpreted-types" id="what-are-uninterpreted-types">What are uninterpreted types?</a></h2>
<p>It is often the case, when writing specifications, that inputs (<code>CONSTANTS</code>) describe a collection of values, where the only relevant property is that all of the values are considered unique. For instance, <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> defines </p>
<pre><code class="language-tla">CONSTANT RM \* The set of resource managers
</code></pre>
<p>however, for the purposes of specification analysis, it does not matter if we instantiate 
<code>RM = 1..3</code> or <code>RM = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code>, because the only operators applied to elements of <code>RM</code> are polymorphic in the type of the elements of <code>RM</code>.</p>
<p>For this reason, Apalache supports a special kind of type annotation: uninterpreted types. 
The type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> makes sure that a value belonging to an uninterpreted type is only ever passed to polymorphic operators, and, importantly, that it is never compared to a value of any other type. </p>
<h2><a class="header" href="#when-to-use-uninterpreted-types" id="when-to-use-uninterpreted-types">When to use uninterpreted types?</a></h2>
<p>For efficiency reasons, you should use uninterpreted types whenever a <code>CONSTANT</code> or value represents (an element of) a collection of unique identifiers, the precise value of which does not influence the properties of the specification.</p>
<p>On the other hand, if, for example, the order of values matters, identifiers should likely be <code>1..N</code> and hold type <code>Int</code> instead of an uninterpreted type, since <code>Int</code> values can be passed to the non-polymorphic <code>&lt;,&gt;,&gt;=,&lt;=</code> operators.</p>
<h2><a class="header" href="#how-to-annotate-uninterpreted-types" id="how-to-annotate-uninterpreted-types">How to annotate uninterpreted types</a></h2>
<p>Following <a href="HOWTOs/../adr/002adr-types.html">ADR002</a>, an annotation with an uninterpreted type looks exactly like an annotation with a type alias:</p>
<pre><code class="language-tla">\* @type: UTNAME;
</code></pre>
<p>where <code>UTNAME</code> matches the pattern <code>[A-Z_][A-Z0-9_]*</code>, and is not a type alias defined elsewhere.</p>
<h2><a class="header" href="#how-to-introduce-values-belonging-to-an-uninterpreted-type" id="how-to-introduce-values-belonging-to-an-uninterpreted-type">How to introduce values belonging to an uninterpreted type</a></h2>
<p>Apalache uses the following convention-based naming scheme for values of uninterpreted types:</p>
<pre><code class="language-tla">&quot;identifier_OF_TYPENAME&quot;
</code></pre>
<p>where:</p>
<ul>
<li><code>TYPENAME</code> is the uninterpreted type to which this value belongs, matching the pattern <code>[A-Z_][A-Z0-9_]*</code>, and</li>
<li><code>identifier</code> is a unique identifier within the uninterpreted type, matching the pattern <code>[a-zA-Z0-9_]+</code>.</li>
</ul>
<p>Example: <code>&quot;1_OF_UT&quot;</code> is a value belonging to the uninterpreted type <code>UT</code>, as is <code>&quot;2_OF_UT&quot;</code>. These two values are distinct by definition. On the contrary,
<code>&quot;1_OF_ut&quot;</code> does <em>not</em> meet the criteria for a value belonging to an uninterpreted type ( lowercase <code>ut</code> is not a valid identifier for an uninterpreted type), so it is treated as a string value.</p>
<p><strong>Note</strong>: Values matching the pattern <code>&quot;FRESH[0-9]+_OF_TYPENAME&quot;</code> are reserved for internal use, to allow Apalache to construct fresh values.</p>
<h2><a class="header" href="#uninterpreted-types-str-and-comparisons" id="uninterpreted-types-str-and-comparisons">Uninterpreted types, <code>Str</code>, and comparisons</a></h2>
<p>Importantly, while both strings and values belonging to uninterpreted types are introduced using the <code>&quot;...&quot;</code> notation, they are treated as having distinct, incomparable types.
Examples:</p>
<ul>
<li>The following expression is type-incorrect:
<pre><code class="language-tla">&quot;abc&quot; = &quot;bc_OF_A&quot; \* Cannot compare values of types Str and A
</code></pre>
</li>
<li>The following expression is type-incorrect:
<pre><code class="language-tla">&quot;1_OF_A&quot; = &quot;1_OF_B&quot; \* Cannot compare values of types A and B
</code></pre>
</li>
<li>The following expressions are type-correct:
<pre><code class="language-tla">\* Can compare 2 values of type A. 
&quot;1_OF_A&quot; = &quot;2_OF_A&quot; \* = FALSE, identifiers are different
&quot;1_OF_A&quot; = &quot;1_OF_A&quot; \* = TRUE, identifiers are the same
</code></pre>
</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Apalache is a symbolic model checker for the <a href="https://en.wikipedia.org/wiki/Specification_language">specification language</a>
<a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+</a>. As such, it is a recent alternative to the explicit-state model
checker <a href="https://lamport.azurewebsites.net/tla/tools.html?unhideBut=hide-tlc&amp;unhideDiv=tlc">TLC</a>.</p>
<h2><a class="header" href="#apalache-vs-tlc" id="apalache-vs-tlc">Apalache vs. TLC</a></h2>
<p>Whereas TLC enumerates the states produced by the behaviors of a TLA+
specification, Apalache translates the verification problem to a set of logical
constraints. These constraints are solved by an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a>, for example,
by <a href="https://github.com/Z3Prover/z3">Microsoft Z3</a>. That is, Apalache operates on formulas (i.e.,
<em>symbolically</em>), not by enumerating states one by one (i.e., <em>state
enumeration</em>).</p>
<h3><a class="header" href="#shall-i-use-apalache-or-tlc" id="shall-i-use-apalache-or-tlc">Shall I use Apalache or TLC?</a></h3>
<p>Depending on the specification you wrote, either TLC or Apalache may be more
efficient in checking it. While TLC is a mature tool, Apalache is still
experimental, so be prepared to use the command-line and to help us discover
bugs.</p>
<h2><a class="header" href="#assumptions" id="assumptions">Assumptions</a></h2>
<p>Apalache is working under the following assumptions:</p>
<ol>
<li>As in TLC, all specification parameters are fixed and finite, i.e., the
system state is initialized with integers, finite sets, and functions of
finite domains and co-domains.</li>
<li>As in TLC, all data structures evaluated during an execution are finite,
e.g., a system specification cannot operate on the set of all integers.</li>
<li>Only finite executions of bounded length are analyzed.</li>
</ol>
<h2><a class="header" href="#conventions" id="conventions">Conventions</a></h2>
<p>Throughout this manual, we use the following conventions:</p>
<ul>
<li><code>APALACHE_HOME</code> is used as shorthand for the path to a local copy of the
Apalache source code.</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>There are three ways to run Apalache:</p>
<ol>
<li><a href="apalache/installation/./jvm.html">Prebuilt package</a>: download a prebuilt package and run it in the JVM.</li>
<li><a href="apalache/installation/./docker.html">Docker</a>: download and run a Docker image.</li>
<li><a href="apalache/installation/./source.html">Build from source</a>: build Apalache from sources and run the compiled package.</li>
</ol>
<p>If you just want to try the tool, we recommend using the <a href="apalache/installation/./jvm.html">prebuilt
package</a>.</p>
<h2><a class="header" href="#system-requirements" id="system-requirements">System requirements</a></h2>
<p><strong>Memory</strong>: Apalache uses Microsoft Z3 as a backend SMT solver, and the required
memory largely depends on Z3. We recommend to allocate at least 4GB of memory
for the tool.</p>
<h1><a class="header" href="#prebuilt-packages" id="prebuilt-packages">Prebuilt Packages</a></h1>
<p>You need to download and install a Java Virtual Machine first. 
We recommend version 17 of the <a href="https://adoptium.net/">Eclipse Temurin</a> or <a href="https://www.azul.com/downloads/?version=java-17-lts&amp;package=jdk#download-openjdk">Zulu</a> builds of OpenJDK.</p>
<p>Once you have installed Java, download the <a href="https://github.com/informalsystems/apalache/releases">latest
release</a> and unpack into
a directory of your choice. Depending on your OS, you have two options.</p>
<p><em>Option 1: Linux, macOS.</em> You can run the script <code>./bin/apalache-mc</code>, or,
better, add the <code>./bin</code> directory to your <code>PATH</code> and run <code>apalache-mc</code>.</p>
<p><em>Option 2: Windows.</em> You have to run Java directly with</p>
<pre><code>java.exe -jar ./lib/apalache.jar &lt;args&gt;
</code></pre>
<p>The arguments <code>&lt;args&gt;</code> are explained in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
<p>If you would like to contribute a command-line script for running Apalache in
Windows, please <a href="https://github.com/informalsystems/apalache/blob/main/CONTRIBUTING.md#making-a-pull-request">open a pull
request</a>.</p>
<h1><a class="header" href="#using-a-docker-image" id="using-a-docker-image">Using a docker image</a></h1>
<p><strong>We publish Docker images for every release</strong> 😎</p>
<p><strong>NOTE</strong>: Running Apalache through a docker application image complicates
configuration of the tool considerably. Unless you have a pressing need to use
the docker image, we recommend using one of our <a href="apalache/installation/./jvm.html">prebuilt releases</a>.</p>
<p><a href="https://www.docker.com/">Docker</a> lets you to run the Apalache tool from inside
an isolated container.  The only dependency required to run Apalache is the a
suitable JVM, and the container supplies this. However, you must already have
<a href="https://docs.docker.com/get-docker/">docker installed</a>.</p>
<p>To get the latest Apalache image, issue the command:</p>
<pre><code class="language-bash">docker pull ghcr.io/informalsystems/apalache
</code></pre>
<h2><a class="header" href="#running-the-docker-image" id="running-the-docker-image">Running the docker image</a></h2>
<p>To run an Apalache image, issue the command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache ghcr.io/informalsystems/apalache &lt;args&gt;
</code></pre>
<p>The following docker parameters are used:</p>
<ul>
<li>
<p><code>--rm</code> to remove the container on exit</p>
</li>
<li>
<p><code>-v &lt;your-spec-directory&gt;:/var/apalache</code> bind-mounts <code>&lt;your-spec-directory&gt;</code> into
<code>/var/apalache</code> in the container. <strong>This is necessary for
Apalache to access your specification and the modules it
extends.</strong>
From the user perspective, it works as if Apalache was
executing in <code>&lt;your-spec-directory&gt;</code>.
In particular the tool logs are written in that directory.</p>
<p>When using SELinux, you might have to use the modified form of <code>-v</code> option:
<code>-v &lt;your-spec-directory&gt;:/var/apalache:z</code></p>
</li>
<li>
<p><code>informalsystems/apalache</code> is the APALACHE docker image name. By default, the <code>latest</code> stable
version is used; you can also refer to a specific tool version, e.g., <code>informalsystems/apalache:0.6.0</code> or <code>informalsystems/apalache:main</code></p>
</li>
<li>
<p><code>&lt;args&gt;</code> are the tool arguments as described in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
</li>
</ul>
<p>We provide a convenience wrapper for this docker command in
<code>script/run-docker.sh</code>. Assuming you've downloaded the Apalache source code into
a directory located at <code>APALACHE_HOME</code>, you can run the <code>latest</code> image via the
script by running:</p>
<pre><code class="language-bash">$ $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<p>To specify a different image, set <code>APALACHE_TAG</code> like so:</p>
<pre><code class="language-bash">$ APALACHE_TAG=foo $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<h2><a class="header" href="#setting-an-alias" id="setting-an-alias">Setting an alias</a></h2>
<p>If you are running Apalache on Linux 🐧 or MacOS
🍏, you can define this handy alias in your rc file, which runs
Apalache in docker while sharing the working directory:</p>
<pre><code class="language-bash">
###### using the latest stable

$ alias apalache='docker run --rm -v $(pwd):/var/apalache ghcr.io/informalsystems/apalache'

###### using the latest main

$ alias apalache='docker run --rm -v $(pwd):/var/apalache ghcr.io/informalsystems/apalache:main'
</code></pre>
<h2><a class="header" href="#using-the-development-branch-of-apalache" id="using-the-development-branch-of-apalache">Using the development branch of Apalache</a></h2>
<p>The development of Apalache proceeds at a quick pace and we cut releases weekly.
Please refer to the <a href="https://github.com/informalsystems/apalache/blob/main/CHANGES.md">changelog</a> and the <a href="https://github.com/informalsystems/apalache/blob/main/docs/src/apalache/index.md">manual</a> on the <code>main</code> development
branch for a report of the newest features. Since we cut releases weekly, you
should have access to all the latest features in the last week by using the
<code>latest</code> tag. However, if you wish to use the very latest developments as they
are added throughout the week, you can run the image with the <code>main</code> tag: just
type <code>ghcr.io/informalsystems/apalache:main</code> instead of
<code>ghcr.io/informalsystems/apalache</code> everywhere.</p>
<p>Do not forget to pull the docker image from time to time:</p>
<pre><code class="language-bash">docker pull ghcr.io/informalsystems/apalache:main
</code></pre>
<p>Run it with the following command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache ghcr.io/informalsystems/apalache:main &lt;args&gt;
</code></pre>
<p>To create an alias pointing to the <code>main</code> version:</p>
<pre><code class="language-bash">$ alias apalache='docker run --rm -v $(pwd):/var/apalache ghcr.io/informalsystems/apalache:main'
</code></pre>
<h2><a class="header" href="#building-an-image" id="building-an-image">Building an image</a></h2>
<p>For an end user there is no need to build an Apalache image. If you like to
produce a modified docker image, take into account that it will take about 30
minutes for the image to get built, due to compilation times of Microsoft Z3. To
build a docker image of Apalache, issue the following command in
<code>$APALACHE_HOME</code>:</p>
<pre><code class="language-bash">$ docker image build -t apalache:0.7.0 .
</code></pre>
<h1><a class="header" href="#building-from-source" id="building-from-source">Building from source</a></h1>
<ol>
<li>Install <code>git</code>.</li>
<li>Install the <a href="https://adoptium.net/">Eclipse Temurin</a> or <a href="https://www.azul.com/downloads/?version=java-17-lts&amp;package=jdk#download-openjdk">Zulu</a> builds of OpenJDK 17.
<ul>
<li>Apalache currently requires Scala 2.13.8, see <a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">this table of compatible JDK versions</a>.</li>
<li>We recommend OpenJDK 17, the latest LTS release.</li>
</ul>
</li>
<li>Install <a href="https://www.scala-sbt.org/1.x/docs/Setup.html">sbt</a>.
<ul>
<li>On Debian Linux or Ubuntu, <a href="https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Linux.html#Ubuntu+and+other+Debian-based+distributions">follow this guide</a></li>
<li>On Arch: <code>sudo pacman -Syu sbt</code></li>
<li>On macOS / Homebrew: <code>brew install sbt</code></li>
</ul>
</li>
<li>Clone the git repository: <code>git clone https://github.com/informalsystems/apalache.git</code>.</li>
<li>Change into the project directory: <code>cd apalache</code>.</li>
<li>Install <a href="https://direnv.net/">direnv</a> and run <code>direnv allow</code>, or use <a href="https://github.com/informalsystems/apalache/blob/main/CONTRIBUTING.md#environment">another way to set up the shell environment</a>.</li>
<li>To build and package Apalache for development purposes, run <code>make</code>.
<ul>
<li>To skip running the tests, you can run <code>make package</code>.</li>
</ul>
</li>
<li>To build and package Apalache for releases and end-user distribution, run
<code>make dist</code>.</li>
<li>The distribution package will be built to
<code>./target/universal/apalache-&lt;VERSION&gt;</code>, and you can move this wherever you'd
like, and ensure that the <code>&lt;dist-package-location&gt;/bin</code> directory is added to
your <code>PATH</code>.</li>
</ol>
<h2><a class="header" href="#running-from-within-the-apalache-repo" id="running-from-within-the-apalache-repo">Running from within the Apalache repo</a></h2>
<p>If you prefer to keep the built package inside of the Apalache source
repository, you have three options after running <code>make</code>:</p>
<ul>
<li>Add the <code>./bin</code> directory in the source repository to your <code>PATH</code>, which will
make <code>apalche-mc</code> available.</li>
<li>Install <a href="https://direnv.net/">direnv</a> and run <code>direnv allow</code>, which will put <code>apalche-mc</code> in your
path when you are inside of the Apalache repo directory.</li>
<li>Run <code>./bin/apalache-mc</code> directly.</li>
</ul>
<h1><a class="header" href="#running-the-tool" id="running-the-tool">Running the Tool</a></h1>
<p><strong>Opt-in statistics programme</strong>: if you opt-in for statistics collection (off by default), then every run of Apalache
will submit anonymized statistics to
<code>tlapl.us</code>. See the details in <a href="apalache/./statistics.html">TLA+ Anonymized Execution Statistics</a>.</p>
<p>Apalache supports several modes of execution. You can run it with the <code>--help</code> option,
to see the complete list of modes and their invocation commands:</p>
<pre><code class="language-bash">$ apalache-mc --help
</code></pre>
<p>The most important commands are as follows:</p>
<ul>
<li>
<p><code>parse</code> reads a TLA+ specification with the SANY parser and flattens it by
instantiating all modules. It terminates successfully, if there are no parse
errors. The input specification to <code>parse</code> may be given in standard TLA+ format, or in the <a href="apalache/../adr/005adr-json.html">JSON serialization
format</a>, while the outputs are produced in both formats.</p>
</li>
<li>
<p><code>typecheck</code> performs all of the operations of <code>parse</code> and additionally runs the type checker Snowcat to infer
the types of all expressions in the parsed specification. It terminates successfully, if there are no type errors.</p>
</li>
<li>
<p><code>simulate</code> performs all of the operations of <code>typecheck</code> and additionally runs the model checker in simulation mode, which <em>randomly</em> picks a sequence of <a href="https://apalache.informal.systems/docs/apalache/assignments-in-depth.html#slices">actions</a> and checks the invariants for the subset of all executions which only admit actions in the selected order. 
It terminates successfully, if there are no invariant violations. 
This command usually checks randomized symbolic runs much faster than the <code>check</code> command.</p>
</li>
<li>
<p><code>check</code> performs all of the operations of <code>typecheck</code> and then runs the model checker in bounded model checking mode, which checks invariants for <em>all executions</em>, the length of which does not exceed the value specified by the <code>--length</code> parameter. 
It terminates successfully, if there are no invariant violations.</p>
</li>
<li>
<p><code>test</code> performs all of the operations of <code>check</code> in a mode that is designed to <a href="https://apalache.informal.systems/docs/adr/006rfc-unit-testing.html#32-testing-actions">test a single action</a>.</p>
</li>
</ul>
<h2><a class="header" href="#1-model-checker-and-simulator-command-line-parameters" id="1-model-checker-and-simulator-command-line-parameters">1. Model checker and simulator command-line parameters</a></h2>
<h3><a class="header" href="#11-model-checker-command-line-parameters" id="11-model-checker-command-line-parameters">1.1. Model checker command-line parameters</a></h3>
<p>The model checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache-mc check [--config=filename] [--init=Init] [--cinit=ConstInit] \
    [--next=Next] [--inv=Inv1,...,Invn] [--length=10] \
    [--temporal=TemporalProp1,...,TemporalPropn] \
    [--algo=(incremental|offline)] \
    [--discard-disabled] [--no-deadlock] \
    [--tuning-options-file=filename] [--tuning-options=key1=val1:...:keyn=valn] \
    [--smt-encoding=(oopsla19|arrays)] \
    [--out-dir=./path/to/dir] \
    [--write-intermediate=(true|false)] \
    [--config-file=./path/to/file] \
    [--profiling=false] \
    [--output-traces=false] \
    &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>
<p>General parameters:</p>
<ul>
<li><code>--config</code> specifies the <a href="apalache/./tlc-config.html">TLC configuration file</a></li>
<li><code>--init</code> specifies the initialization predicate, <em><code>Init</code> by default</em></li>
<li><code>--next</code> specifies the transition predicate, <em><code>Next</code> by default</em></li>
<li><code>--cinit</code> specifies the constant initialization predicate, <em>optional</em></li>
<li><code>--inv</code> specifies the invariants to check, as a comma separated list, <em>optional</em></li>
<li><code>--length</code> specifies the maximal number of <code>Next</code> steps, <em>10 by default</em></li>
<li><code>--temporal</code> specifies the temporal properties to check, as a comma
separated list, <em>optional</em></li>
</ul>
</li>
<li>
<p>Advanced parameters:</p>
<ul>
<li><code>--algo</code> lets you to choose the search algorithm: <code>incremental</code> is using the incremental SMT solver, <code>offline</code> is
using the non-incremental
(offline) SMT solver</li>
<li><code>--smt-encoding</code> lets you choose how the SMT instances are encoded: <code>oopsla19</code> (default) uses QF_UFNIA, and
<code>arrays</code> (experimental) and <code>funArrays</code> (experimental) use SMT arrays with extensionality. This parameter can also
be set via the <code>SMT_ENCODING</code> environment variable. See the <a href="apalache/../adr/011adr-smt-arrays.html">alternative SMT encoding using arrays</a> for details.</li>
<li><code>--discard-disabled</code> does a pre-check on transitions and discard the disabled ones at every step. If you know that
many transitions are always enabled, set it to false. Sometimes, this pre-check may be slower than checking the
invariant. Default: true.</li>
<li><code>--max-error &lt;n&gt;</code> instructs the search to stop after <code>n</code> errors, see <a href="apalache/./principles/enumeration.html">Enumeration of counterexamples</a>. Default: 1.</li>
<li><code>--view &lt;name&gt;</code> sets the state view to <code>&lt;name&gt;</code>, see <a href="apalache/./principles/enumeration.html">Enumeration of counterexamples</a>.</li>
<li><code>--no-deadlock</code> disables deadlock-checking, when <code>--discard-disabled=false</code> is on. When <code>--discard-disabled=true</code>,
deadlocks are found in any case.</li>
<li><code>--tuning-options-file</code> specifies a properties file that stores options for
<a href="apalache/tuning.html">fine tuning</a></li>
<li><code>--tuning-options</code> can pass and/or override these <a href="apalache/tuning.html">fine tuning</a>
options on the command line</li>
<li><code>--out-dir</code> set location for outputting any generated logs or artifacts,
<em><code>./_apalache-out</code> by default</em></li>
<li><code>--write-intermediate</code> if <code>true</code>, then additional output is generated. See
<a href="apalache/running.html#detailed-output">Detailed output</a>. <em><code>false</code> by default</em></li>
<li><code>--run-dir=DIRECTORY</code> write all outputs directly into the specified
<code>DIRECTORY</code></li>
<li><code>--config-file</code> a file to use for loading configuration parameters. This
will prevent Apalache from looking for any local <code>.apalache.cfg</code> file.</li>
<li><code>--profiling</code> (Bool): This flag governs the creation of <code>profile-rules.txt</code>
used in <a href="apalache/profiling.html">profiling</a>. The file is only created if <code>profiling</code>
is set to <code>True</code>.  Setting <code>profiling</code> to <code>False</code> is incompatible with the
<code>--smtprof</code> flag. The default is <code>False</code>.</li>
<li><code>--output-traces</code>: save an example trace for each symbolic run, default: <code>false</code></li>
</ul>
</li>
</ul>
<p>Options passed with <code>--tuning-options</code> have priority over options passed with <code>--tuning-options-file</code>.</p>
<p>If an initialization predicate, transition predicate, or invariant is specified both in the configuration file, and on
the command line, the command line parameters take precedence over those in the configuration file.</p>
<p>In case conflicting arguments are passed for the same parameter, the following precedence order is followed:</p>
<ol>
<li>Command-line value</li>
<li>Environment variable value</li>
<li>Configuration file value</li>
</ol>
<h3><a class="header" href="#12-simulator-command-line-parameters" id="12-simulator-command-line-parameters">1.2. Simulator command-line parameters</a></h3>
<p>The simulator can be run as follows:</p>
<pre><code class="language-bash">$ apalache-mc simulate
    [all-checker-options] [--max-run=NUM] &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>
<p>Special parameters:</p>
<ul>
<li><code>--max-run=NUM</code>: but produce up to <code>NUM</code> simulation runs (unless <code>--max-error</code> errors have been found), default: <code>100</code></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#13-supplying-jvm-arguments" id="13-supplying-jvm-arguments">1.3. Supplying JVM arguments</a></h3>
<p>You can supply JVM argument to be used when running Apalache by setting the
environment variable <code>JVM_ARGS</code>. For example, to change the JVM heap size from
the default (<code>4096m</code>) to <code>1G</code> invoke Apalache as follows:</p>
<pre><code class="language-sh">JVM_ARGS=&quot;-Xmx1G&quot; apalache-mc &lt;args&gt;
</code></pre>
<p>If you are running Apalache via docker directly (instead of using the script in
<code>$APALACHE_HOME/script/run-docker.sh</code>), you'll also need to expose the
environment variable to the docker container:</p>
<pre><code class="language-sh">$ JVM_ARGS=&quot;-Xmx1G&quot; docker run -e JVM_ARGS --rm -v &lt;your-spec-directory&gt;:/var/apalache ghcr.io/informalsystems/apalache &lt;args&gt;
</code></pre>
<p>To track memory usage with: <code>jcmd &lt;pid&gt; VM.native_memory summary</code>, you can set</p>
<pre><code>JVM_ARGS=&quot;-XX:NativeMemoryTracking=summary&quot;
</code></pre>
<h3><a class="header" href="#14-bounded-model-checking" id="14-bounded-model-checking">1.4. Bounded model checking</a></h3>
<p>By default, Apalache performs <em>bounded model checking</em>, that is, it encodes a
symbolic execution of length <code>k</code> and a violation of a state invariant in SMT:</p>
<pre><code class="language-tla">/\ Init[v_0/v]
/\ Next[v_0/v, v_1/v'] /\ Next[v_1/v, v_2/v'] /\ ... /\ Next[v_{k-1}/v, v_k/v']
/\ ~Inv[v_0/v] \/ ~Inv[v_1/v] \/ ... \/ ~Inv[v_k/v]
</code></pre>
<p>Here an expression <code>Inv[v_i/v]</code> means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the
state <code>i</code>. Likewise, <code>Next[v_i/v,v_{i+1}/v']</code>
means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the state <code>i</code>, whereas the state
variables <code>v'</code> are replaced with their copies
<code>v_{i+1}</code> for the state <code>i+1</code>.</p>
<p><strong>Bounded model checking is an incomplete technique</strong>. If Apalache finds a bug
in this symbolic execution (by querying z3), then it reports a counterexample.
Otherwise, it reports that no bug was found up to the given length. If a bug
needs a long execution to get revealed, bounded model checking may miss it!</p>
<h3><a class="header" href="#15-checking-an-inductive-invariant" id="15-checking-an-inductive-invariant">1.5. Checking an inductive invariant</a></h3>
<p>To check executions of arbitrary lengths, one usually finds a formula that satisfies the two following properties:</p>
<pre><code class="language-tla">/\ Init =&gt; TypeOK /\ IndInv
/\ TypeOK /\ IndInv /\ Next =&gt; TypeOK' /\ IndInv'
</code></pre>
<p>In normal words: (1) The initial states satisfy the constraint <code>TypeOK /\ IndInv</code>, and (2) whenever the specification makes a step when starting in a state that satisfies <code>TypeOK /\ IndInv</code>, it
ends up in a state that again satisfies <code>TypeOK /\ IndInv</code>.</p>
<p>Note that we usually check <code>IndInv</code> in conjunction with <code>TypeOK</code>, as we have to constrain the variable values. In
the <code>y2k</code> example, our inductive invariant is actually constraing the variables. In fact, such an inductive invariant is
usually called <code>TypeOK</code>.</p>
<p>To check an inductive invariant <code>IndInv</code> in Apalache, you run two commands that check the above two formulas:</p>
<ul>
<li>
<p><strong>IndInit</strong>: Check that the initial states satisfy <code>IndInv</code>:</p>
<pre><code class="language-bash">$ apalache-mc check --init=Init --inv=IndInv --length=0 &lt;myspec&gt;.tla
</code></pre>
</li>
<li>
<p><strong>IndNext</strong>: Check that <code>Next</code> does not drive us outside of <code>IndInv</code>:</p>
<pre><code class="language-bash">$ apalache-mc check --init=IndInv --inv=IndInv --length=1 &lt;myspec&gt;.tla
</code></pre>
</li>
</ul>
<p>Usually, you look for an inductive invariant to check a safety predicate. For
example, if you have found an inductive invariant <code>IndInv</code> and want to check a
safety predicate <code>Safety</code>, you have to run Apalache once again:</p>
<ul>
<li>
<p><strong>IndProp</strong>: Check that all states captured with <code>IndInv</code> satisfy the predicate <code>Safety</code>:</p>
<pre><code class="language-bash">$ apalache-mc check --init=IndInv --inv=Safety --length=0 &lt;myspec&gt;.tla
</code></pre>
</li>
</ul>
<p>It may happen that your inductive invariant <code>IndInv</code> is too weak and it
violates <code>Safety</code>. In this case, you would have to add additional constraints to <code>IndInv</code>.
Then you would have to check the queries IndInit, IndNext, and IndProp again.</p>
<h2><a class="header" href="#2-examples" id="2-examples">2. Examples</a></h2>
<h3><a class="header" href="#21-checking-safety-up-to-20-steps" id="21-checking-safety-up-to-20-steps">2.1. Checking safety up to 20 steps</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache-mc check --length=20 --inv=Safety y2k_override.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. If <code>Safety</code> is not violated, your spec
might still have a bug that requires a computation longer than 20 steps to manifest.</p>
<h3><a class="header" href="#22-checking-an-inductive-invariant" id="22-checking-an-inductive-invariant">2.2. Checking an inductive invariant:</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache-mc check --length=0 --init=Init --inv=Inv y2k_override.tla
$ apalache-mc check --length=1 --init=Inv  --inv=Inv y2k_override.tla
</code></pre>
<p>The first call to apalache checks, whether the initial states satisfy the invariant. The second call to apalache checks,
whether a single specification step satisfies the invariant, when starting in a state that satisfies the invariant. (
That is why these invariants are called inductive.)</p>
<h3><a class="header" href="#23-using-a-constant-initializer" id="23-using-a-constant-initializer">2.3. Using a constant initializer:</a></h3>
<pre><code class="language-bash">$ cd test/tla
apalache-mc check --cinit=ConstInit --length=20 --inv=Safety y2k_cinit.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. The constants are initialized with the
predicate
<code>ConstInit</code>, defined in <code>y2k_cinit.tla</code> as:</p>
<pre><code class="language-tla">ConstInit == BIRTH_YEAR \in 0..99 /\ LICENSE_AGE \in 10..99
</code></pre>
<p>In this case, Apalache finds a safety violation, e.g., for
<code>BIRTH_YEAR=89</code> and <code>LICENSE_AGE=10</code>. A complete counterexample is printed in <code>counterexample.tla</code>.</p>
<p>The final lines in the file clearly indicate the state that violates the invariant:</p>
<pre><code class="language-tla">State14 ==
/\ BIRTH_YEAR = 89
/\ LICENSE_AGE = 10
/\ hasLicense = TRUE
/\ year = 0

(* The following formula holds true in the last state and violates the invariant *)

InvariantViolation == hasLicense /\ year - BIRTH_YEAR &lt; LICENSE_AGE
</code></pre>
<p><a name="lookup"></a></p>
<h2><a class="header" href="#3-module-lookup" id="3-module-lookup">3. Module lookup</a></h2>
<p>Apalache uses <a href="https://lamport.azurewebsites.net/tla/tools.html">the SANY parser</a>, which is the standard parser of TLC
and the TLA+ Toolbox. By default, SANY is looking for modules (in this order) in</p>
<ol>
<li>The current working directory.</li>
<li>The directory containing the main TLA+ file passed on the CLI.</li>
<li>A small Apalache standard library (bundled from <code>$APALACHE_HOME/src/tla</code>).</li>
<li>The Java package <code>tla2sany.StandardModules</code> (usually provided by the <code>tla2tools.jar</code> that is included in the Java
classpath).</li>
</ol>
<p><strong>Note:</strong> To let TLA+ Toolbox and TLC know about the Apalache modules, include
<code>$APALACHE_HOME/src/tla</code> in the lookup directories, as explained by Markus Kuppe for
the <a href="https://github.com/tlaplus/CommunityModules">TLA+ Community Modules</a>.</p>
<p><a name="detailed"></a></p>
<h2><a class="header" href="#4-detailed-output" id="4-detailed-output">4. Detailed output</a></h2>
<p>The location for detailed output is determined by the value of the <code>out-dir</code>
parameter, which specifies the path to a directory into which all Apalache
runs write their outputs (see <a href="apalache/config.html">configuration instructions</a>).</p>
<p>Each run will produce a unique subdirectory inside its &quot;namespace&quot;, derived from
the file name of the specification, using the following convention
<code>yyyy-MM-ddTHH-mm-ss_&lt;UNIQUEID&gt;</code>.</p>
<p>For an example, consider using the default location of the <code>run-dir</code> for a run of
Apalache on a spec named <code>test.tla</code>. This will create a directory structuring matching following pattern:</p>
<pre><code>./_apalache-out/
└── test.tla
    └── 2021-11-05T22-54-55_810261790529975561
</code></pre>
<p>The default value for the <code>out-dir</code> is the <code>_apalache-out</code> directory in the
current working directly. The subdirectory <code>test.tla</code> is derived from the name
of the spec on which the tool was run, and the run-specific subdirectory
<code>2021-11-05T22-54-55_810261790529975561</code> gives a unique location to write the
all the outputs produced by the run.</p>
<p>The tool only writes important messages on stdout, but a detailed log can be
found in the <code>detailed.log</code> in the run-specific subdirectory.</p>
<p>The directory also includes a file <code>run.txt</code>, reporting the command line
arguments used during the run.</p>
<p>Additionally, if the parameter <code>write-intermediate</code> is set to <code>true</code> (see
<a href="apalache/config.html">configuration instructions</a>) each pass of the model checker produces
intermediate TLA+ files in the run-specific subdirectory:</p>
<ul>
<li>File <code>out-parser.tla</code> is produced as a result of parsing and importing into the intermediate representation, Apalache
TLA IR.</li>
<li>File <code>out-config.tla</code> is produced as a result of substituting CONSTANTS, as described
in <a href="apalache/./parameters.html">Setting up specification parameters</a>.</li>
<li>File <code>out-inline.tla</code> is produced as a result of inlining operator definitions and <code>LET-IN</code> definitions.</li>
<li>File <code>out-priming.tla</code> is produced as a result of replacing constants and variables in <code>ConstInit</code> and <code>Init</code> with
their primed versions.</li>
<li>File <code>out-vcgen.tla</code> is produced as a result of extracting verification conditions, e.g., invariants to check.</li>
<li>File <code>out-prepro.tla</code> is produced as a result of running all preprocessing steps.</li>
<li>File <code>out-transition.tla</code> is produced as a result of finding assignments and symbolic transitions.</li>
<li>File <code>out-opt.tla</code> is produced as a result of expression optimizations.</li>
<li>File <code>out-analysis.tla</code> is produced as a result of analysis, e.g., marking Skolemizable expressions and expressions to
be expanded.</li>
</ul>
<p><a name="parsing"></a></p>
<h2><a class="header" href="#5-parsing-and-pretty-printing" id="5-parsing-and-pretty-printing">5. Parsing and pretty-printing</a></h2>
<p>If you'd like to check that your TLA+ specification is syntactically correct, without running the model checker, you can
run the following command:</p>
<pre><code class="language-bash">$ apalache-mc parse &lt;myspec&gt;.tla
</code></pre>
<p>In this case, Apalache performs the following steps:</p>
<ol>
<li>
<p>It parses the specification with <a href="https://lamport.azurewebsites.net/tla/tools.html">SANY</a>.</p>
</li>
<li>
<p>It translates SANY semantic nodes
into <a href="https://github.com/informalsystems/apalache/blob/master/tlair/src/main/scala/at/forsyte/apalache/tla/lir/package.scala">Apalache IR</a>
.</p>
</li>
<li>
<p>If the <code>--write-intermediate</code> flag is given, it pretty-prints the IR into
the output directory (see <a href="apalache/running.html#detailed">Detailed output</a>).</p>
</li>
</ol>
<p>You can also write output to a specified location by using the <code>--output</code> flag.
E.g.,</p>
<pre><code class="language-bash">$ apalache-mc parse --output=result.json &lt;myspec&gt;.tla
</code></pre>
<p>will write the IR to the file <code>result.json</code>.</p>
<p>reads a TLA+ specification with the SANY parser and flattens it by</p>
<h1><a class="header" href="#an-example-tla-specification" id="an-example-tla-specification">An example TLA+ specification</a></h1>
<p>We introduce a TLA+ specification that we use to discuss features of Apalache in
the following sections. Its source code can be found in
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a>:</p>
<pre><code class="language-tla">-------------------------------- MODULE y2k --------------------------------
(*
 * A simple specification of a year counter that is subject to the Y2K problem.
 * In this specification, a registration office keeps records of birthdays and
 * issues driver's licenses. As usual, a person may get a license, if they
 * reached a certain age, e.g., age of 18. The software engineers never thought
 * of their program being used until the next century, so they stored the year
 * of birth using only two digits (who would blame them, the magnetic tapes
 * were expensive!). The new millenium came with new bugs.
 *
 * This is a made up example, not reflecting any real code.
 * To learn more about Y2K, check: https://en.wikipedia.org/wiki/Year_2000_problem
 *
 * Igor Konnov, January 2020
 *)

EXTENDS Integers
 
CONSTANT
    \* @type: Int;
    BIRTH_YEAR, \* the year to start with, between 0 and 99
    \* @type: Int;
    LICENSE_AGE    \* the minimum age to obtain a license
         
ASSUME(BIRTH_YEAR \in 0..99)              
ASSUME(LICENSE_AGE \in 1..99)              
 
VARIABLE
    \* @type: Int;
    year,
    \* @type: Bool;
    hasLicense

Age == year - BIRTH_YEAR 

Init ==
    /\ year = BIRTH_YEAR
    /\ hasLicense = FALSE
    
NewYear ==
    /\ year' = (year + 1) % 100 \* the programmers decided to use two digits
    /\ UNCHANGED hasLicense
    
IssueLicense ==
    /\ Age &gt;= LICENSE_AGE
    /\ hasLicense' = TRUE
    /\ UNCHANGED year
    
Next ==
    \/ NewYear
    \/ IssueLicense

\* The somewhat &quot;obvious&quot; invariant, which is violated    
Safety ==
    hasLicense =&gt; (Age &gt;= LICENSE_AGE)
</code></pre>
<h1><a class="header" href="#setting-up-specification-parameters" id="setting-up-specification-parameters">Setting up specification parameters</a></h1>
<p>Similar to TLC, Apalache requires the specification parameters to be restricted
to finite values. In contrast to TLC, there is a way to initialize parameters
by writing a symbolic constraint, see <a href="apalache/parameters.html#ConstInit">Section 5.3</a>.</p>
<h2><a class="header" href="#using-instance" id="using-instance">Using INSTANCE</a></h2>
<p>You can set the specification parameters, using the standard <code>INSTANCE</code>
expression of TLA+. For instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/y2k_instance.tla"><code>y2k_instance.tla</code></a>,
which instantiates <code>y2k.tla</code>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_instance ----------------------------
(*
 * Another way to instantiate constants for apalache is to
 * use INSTANCE.
 *)
 
VARIABLE
    \* @type: Int;
    year,
    \* @type: Bool;
    hasLicense

INSTANCE y2k WITH BIRTH_YEAR &lt;- 80, LICENSE_AGE &lt;- 18

=============================================================================
</code></pre>
<p>The downside of this approach is that you have to declare the variables of the
extended specification. This is easy with only two variables, but can quickly
become unwieldy.</p>
<h2><a class="header" href="#convention-over-configuration" id="convention-over-configuration">Convention over configuration</a></h2>
<p>Alternatively, you can extend the base module and use overrides:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_override ----------------------------
(*
 * One way to instantiate constants for apalache is to use the OVERRIDE prefix. 
 *)
 
EXTENDS y2k

OVERRIDE_BIRTH_YEAR == 80
OVERRIDE_LICENSE_AGE == 18

=============================================================================
</code></pre>
<p><a name="ConstInit"></a></p>
<h2><a class="header" href="#constinit-predicate" id="constinit-predicate">ConstInit predicate</a></h2>
<p>This approach is similar to the <code>Init</code> operator, but applied to the
constants. We define a special operator, e.g., called <code>ConstInit</code>. For
instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/y2k_cinit.tla"><code>y2k_cinit.tla</code></a>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_cinit ----------------------------
(*
 * Another way to instantiate constants for apalache is give it constraints
 * on the constants.
 *)
 
EXTENDS y2k

ConstInit ==
    /\ BIRTH_YEAR \in 0..99
    /\ LICENSE_AGE \in 10..99

=============================================================================
</code></pre>
<p>To use <code>ConstInit</code>, pass it as the argument to <code>apalache-mc</code>. For instance, for
<code>y2k_cinit</code>, we would run the model checker as follows:</p>
<pre><code class="language-tla">$ cd $APALACHE_HOME/test/tla
$ apalache-mc check --inv=Safety \
  --length=20 --cinit=ConstInit y2k_cinit.tla
</code></pre>
<h3><a class="header" href="#parameterized-initialization" id="parameterized-initialization">Parameterized initialization</a></h3>
<p>As a bonus of this approach, Apalache allows one to check a specification over a
bounded set of parameters. For example:</p>
<pre><code class="language-tla">CONSTANT N, Values

ConstInit ==
  /\ N \in 3..10
  /\ Values \in SUBSET 0..4
  /\ Values /= {}
</code></pre>
<p>The model checker will try the instances for all the combinations of
the parameters specified in <code>ConstInit</code>, that is, in our example, it will
consider <code>N \in 3..10</code> and all non-empty value sets that are subsets of <code>0..4</code>.</p>
<h3><a class="header" href="#limitation" id="limitation">Limitation</a></h3>
<p><code>ConstInit</code> should be a conjunction of assignments and possibly of additional
constraints on the constants. For instance, you should not write <code>N = 10 \/ N = 20</code>. However, you can write <code>N \in {10, 20}</code>.</p>
<h2><a class="header" href="#tlc-configuration-file" id="tlc-configuration-file">TLC configuration file</a></h2>
<p>We support configuring Apalache via TLC configuration files; these files are
produced automatically by TLA Toolbox, for example. TLC configuration files
allow one to specify which initialization predicate and transition predicate to
employ, which invariants to check, as well as to initialize specification
parameters. Some features of the TLC configuration files are not supported yet.
Check the manual page on <a href="apalache/./tlc-config.html">&quot;Syntax of TLC Configuration Files&quot;</a>.</p>
<p><strong>Behavior in versions &gt;=0.25.0:</strong></p>
<p>Apalache never loads a TLC configuration file, unless a filename is passed
via the option <code>--config=&lt;filename&gt;</code>. If a filename is passed but the file
does not exist, Apalache reports an error.</p>
<p><strong>Behavior in versions &lt;0.25.0:</strong></p>
<p>If you are checking a file <code>&lt;myspec&gt;.tla</code>, and the file <code>&lt;myspec&gt;.cfg</code> exists in
the same directory, it will be picked up by Apalache automatically. You can also
explicitly specify which configuration file to use via the <code>--config</code> option.</p>
<h1><a class="header" href="#principles-of-symbolic-model-checking-with-apalache" id="principles-of-symbolic-model-checking-with-apalache">Principles of Symbolic Model Checking with Apalache</a></h1>
<p>In order to take advantage of Apalache's symbolic model checking, there are a
few principles one must bear in mind when writing TLA.</p>
<p>Note that Apalache requires type annotations.  Check the <a href="apalache/principles/../tutorials/snowcat-tutorial.html">Snowcat
tutorial</a> and <a href="apalache/principles/../HOWTOs/howto-write-type-annotations.html">HOWTO on
annotations</a>.</p>
<p>Topics:</p>
<ul>
<li><a href="apalache/principles/./assignments.html">Assignments and symbolic transitions</a></li>
<li><a href="apalache/principles/./folds.html">Folding sets and sequences</a></li>
<li><a href="apalache/principles/./principles/invariants.html">Invariants: State, Action, Trace</a></li>
<li><a href="apalache/principles/./principles/enumeration.html">Enumeration of counterexamples</a></li>
<li><a href="apalache/principles/./apalache/principles/apalache-mod.html">The Apalache Module</a></li>
<li><a href="apalache/principles/./naturals.html">Naturals module</a></li>
</ul>
<p><a name="assignments"></a>
<a name="symbolicTransitions"></a></p>
<h2><a class="header" href="#assignments-and-symbolic-transitions" id="assignments-and-symbolic-transitions">Assignments and symbolic transitions</a></h2>
<p>Let us go back to the example
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a>
and run <code>apalache-mc</code> against
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/y2k_override.tla"><code>test/tla/y2k_override.tla</code></a>
while instructing Apalache to write intermediate output files:</p>
<pre><code class="language-console">$ apalache-mc check --write-intermediate=true y2k_override.tla
</code></pre>
<p>We can check the detailed output of the <code>TransitionFinderPass</code> in the file
<code>_apalache-out/y2k_override.tla/&lt;timestamp&gt;/intermediate/&lt;pass&gt;_OutTransitionFinderPass.tla</code>, where
<code>&lt;timestamp&gt;</code> looks like <code>2021-12-01T12-07-41_1998641578103809179</code>, and <code>&lt;pass&gt;</code> is a two-digit number like <code>08</code>:</p>
<pre><code class="language-tla">--------------------------- MODULE 09_OutTransition ---------------------------

EXTENDS Integers, Sequences, FiniteSets, TLC, Apalache

VARIABLE
  (*
    @type: Int;
  *)
  year

VARIABLE
  (*
    @type: Bool;
  *)
  hasLicense

(*
  @type: (() =&gt; Bool);
*)
ASSUME(80 \in 0 .. 99)

(*
  @type: (() =&gt; Bool);
*)
ASSUME(18 \in 1 .. 99)

(*
  @type: (() =&gt; Bool);
*)
Init_si_0000 == year' := 80 /\ hasLicense' := FALSE

(*
  @type: (() =&gt; Bool);
*)
Next_si_0000 == year' := ((year + 1) % 100) /\ hasLicense' := hasLicense

(*
  @type: (() =&gt; Bool);
*)
Next_si_0001 == year - 80 &gt;= 18 /\ hasLicense' := TRUE /\ year' := year

================================================================================
</code></pre>
<p>As you can see, the model checker did two things:</p>
<ol>
<li>It has translated several expressions that look like <code>x' = e</code> into <code>x' := e</code>.
For instance, you can see <code>year' := 80</code> and <code>hasLicense' := FALSE</code> in
<code>Init_si_0000</code>. We call these expressions <strong>assignments</strong>.</li>
<li>It has factored the operator <code>Next</code> into two operators <code>Next_si_0000</code> and <code>Next_si_0001</code>.
We call these operators <strong>symbolic transitions</strong>.</li>
</ol>
<p>Pure TLA+ does not have the notions of assignments and symbolic
transitions.  However, TLC sometimes treats expressions <code>x' = e</code> and <code>x' \in S</code>
as if they were assigning a value to the variable <code>x'</code>. TLC does so
dynamically, during the breadth-first search. Apalache looks statically for assignments
among the expressions <code>x' = e</code> and <code>x' \in S</code>.</p>
<p>When factoring out operators into symbolic transitions, Apalache splits the
action operators <code>Init</code> and <code>Next</code> into disjunctions (e.g., <code>A_0 \/ ... \/ A_n</code>),
represented in the concrete syntax as a sequence of operator definitions of the
form</p>
<pre><code class="language-tla">A$0 == ...
...
A$n == ...
</code></pre>
<p>The main contract between the assignments and symbolic transitions is as
follows:</p>
<blockquote>
<p>For every variable <code>x</code> declared with <code>VARIABLE</code>, there is exactly one
assignment of the form <code>x' := e</code> in every symbolic transition <code>A_n</code>.</p>
</blockquote>
<p>If Apalache cannot find expressions with the above properties, it fails.
Consider the example
<a href="https://github.com/informalsystems/apalache/blob/main/test/tla/Assignments20200309.tla"><code>test/tla/Assignments20200309.tla</code></a>:</p>
<pre><code class="language-tla">----- MODULE Assignments20200309 -----
VARIABLE
    \* @type: Int;
    a

\* this specification fails, as it has no expression
\* that can be treated as an assignment
Init == TRUE
Next == a' = a
Inv == FALSE
===============
</code></pre>
<p>Run the checker with:</p>
<pre><code class="language-bash">apalache-mc check Assignments20200309.tla
</code></pre>
<p>Apalache reports an error as follows:</p>
<pre><code class="language-console">...
PASS #9: TransitionFinderPass
To understand the error, [check the
manual](https://apalache.informal.systems/docs/apalache/principles/assignments.html):
Assignment error: No assignments found for: a
It took me 0 days  0 hours  0 min  1 sec
Total time: 1.88 sec
EXITCODE: ERROR (255)
</code></pre>
<h3><a class="header" href="#more-details" id="more-details">More details</a></h3>
<p><strong>Check <a href="apalache/principles/../assignments-in-depth.html">Assignments and Symbolic Transitions in
Depth</a>.</strong></p>
<h2><a class="header" href="#folding-sets-and-sequences" id="folding-sets-and-sequences">Folding Sets and Sequences</a></h2>
<p><strong>Folds are an efficient replacement for recursive operators and functions.</strong></p>
<p>Apalache natively implements two operators users might be familiar with from the <a href="https://github.com/tlaplus/CommunityModules">community modules</a> or functional programming. Those operators are <code>ApaFoldSet</code> and <code>ApaFoldSeqLeft</code>. This brief introduction to fold operators highlights the following:</p>
<ol>
<li>What are the semantics of fold operators?</li>
<li>How do I use these operators in Apalache?</li>
<li>Should I use folding or recursion?</li>
<li>Examples of common operators defined with folds</li>
</ol>
<h3><a class="header" href="#syntax" id="syntax">Syntax</a></h3>
<p>The syntax of the fold operators is as follows:</p>
<pre><code class="language-tla">\* @type: ( (a, b) =&gt; a, a, Set(b) ) =&gt; a;
ApaFoldSet( operator, base, set )

\* @type: ( (a, b) =&gt; a, a, Seq(b) ) =&gt; a;
ApaFoldSeqLeft( operator, base, seq )
</code></pre>
<h3><a class="header" href="#semantics-of-fold-operators" id="semantics-of-fold-operators">Semantics of fold operators</a></h3>
<p>Folding refers to iterative application of a binary operator over a collection. Given an operator <code>Op</code>, a base value <code>b</code> and a collection of values <code>C</code>, the definition of folding <code>Op</code> over <code>C</code> starting with <code>b</code> depends on the type of the collection <code>C</code>.</p>
<h4><a class="header" href="#semantics-of-apafoldseqleft" id="semantics-of-apafoldseqleft">Semantics of <code>ApaFoldSeqLeft</code></a></h4>
<p>In the case of folding over sequences, <code>C</code> is a sequence <code>&lt;&lt;a_1, ..., a_n&gt;&gt;</code>. Then, <code>ApaFoldSeqLeft( Op, b, C )</code> is defined as follows:</p>
<ol>
<li>If <code>C</code> is empty, then <code>ApaFoldSeqLeft( Op, b, &lt;&lt;&gt;&gt; ) = b</code>, regardless of <code>Op</code></li>
<li>If <code>C</code> is nonempty, we establish a recursive relation between folding over <code>C</code> and folding over <code>Tail(C)</code> in the following way: <code>ApaFoldSeqLeft( Op, b, C ) = ApaFoldSeqLeft( Op, Op(b, Head(C)), Tail(C) )</code>.</li>
</ol>
<h4><a class="header" href="#semantics-of-apafoldset" id="semantics-of-apafoldset">Semantics of <code>ApaFoldSet</code></a></h4>
<p>In the case of folding over sets, <code>C</code> is a set <code>{a_1, ..., a_n}</code>. Then, <code>ApaFoldSet( Op, b, C )</code> is defined as follows:</p>
<ol>
<li>If <code>C</code> is empty, then <code>ApaFoldSet( Op, b, {} ) = b</code>, regardless of <code>Op</code></li>
<li>If <code>C</code> is nonempty, we establish a recursive relation between folding over <code>C</code> and folding over some subset of <code>C</code> in the following way: <code>ApaFoldSet( Op, b, C ) = ApaFoldSet( Op, Op(b, x), C \ {x} )</code>, where <code>x</code> is some arbitrary member of <code>C</code> (e.g. <code>x = CHOOSE y \in C: TRUE</code>). Note that Apalache does not guarantee a deterministic choice of <code>x</code>, unlike what using  <code>CHOOSE</code> would imply.</li>
</ol>
<p>Note that the above are definitions of a <em>left fold</em> in the literature. Apalache does not implement a right fold.</p>
<p>For example, if <code>C</code> is the sequence <code>&lt;&lt;x,y,z&gt;&gt;</code>, the result is equal to <code>Op( Op( Op(b, x), y), z)</code>. If <code>C = {x,y}</code>, the result is either <code>Op( Op(b, x), y)</code> or <code>Op( Op(b, y), x)</code>. Because the order of elements selected from a set is not predefined, users should be careful, as the result is only uniquely defined in the case that the operator is both associative (<code>Op(Op(a,b),c) = Op(a,Op(b,c))</code>) and commutative (<code>Op(a,b) = Op(b,a)</code>). </p>
<p>For example, consider the operator <code>Op(p,q) == 2 * p + q</code>, which is noncommutative, and the set <code>S = {1,2,3}</code>. The value of <code>ApaFoldSet(Op, 0, S)</code> depends on the order in which Apalache selects elements from S:</p>
<table><thead><tr><th>Order</th><th>ApaFoldSet value</th></tr></thead><tbody>
<tr><td>1 -&gt; 2 -&gt; 3</td><td>11</td></tr>
<tr><td>1 -&gt; 3 -&gt; 2</td><td>12</td></tr>
<tr><td>2 -&gt; 1 -&gt; 3</td><td>13</td></tr>
<tr><td>2 -&gt; 3 -&gt; 1</td><td>15</td></tr>
<tr><td>3 -&gt; 1 -&gt; 2</td><td>16</td></tr>
<tr><td>3 -&gt; 2 -&gt; 1</td><td>17</td></tr>
</tbody></table>
<p>Because Apalache does not guarantee deterministic choice in the order of iteration, users should treat all of the above results as possible outcomes.</p>
<h3><a class="header" href="#using-fold-operators-in-apalache" id="using-fold-operators-in-apalache">Using fold operators in Apalache</a></h3>
<p>As shown by the type signature, Apalache permits a very general form of folding, where the types of the collection elements and the type of the base element/return-type of the operator do not have to match. Again, we urge users to exercise caution when using <code>ApaFoldSet</code> with an operator, for which the types <code>a</code> and <code>b</code> are different, as such operators cannot be commutative or associative, and therefore the result is not guaranteed to be unique and predictable. </p>
<p>The other component of note is <code>operator</code>, the <em>name</em> (not definition) of some binary operator, which is available in this context. The following are examples of valid uses of folds:</p>
<pre><code class="language-tla">PlusOne(p,q) == p + q + 1
X == ApaFoldSet( PlusOne, 0, {1,2,3} ) \* X = 9 

X == LET Count(p,q) == p + 1 IN ApaFoldSeqLeft( Count, 0, &lt;&lt;1,2,3&gt;&gt; ) \* X = 3
</code></pre>
<p>while these next examples are considered invalid:</p>
<pre><code class="language-tla">\* LAMBDAS in folds are not supported by Apalache
\* Define a LET-IN operator Plus(p,q) == p + q instead
X == ApaFoldSet( LAMBDA p,q: p + q, 0, {1,2,3} ) 

\* Built-in operators cannot be called by name in Apalache
\* Define a LET-IN operator Plus(p,q) == p + q instead
X == ApaFoldSet( + , 0, {1,2,3} )
</code></pre>
<p>Local LET definitions can also be used as closures:</p>
<pre><code>A(x) == LET PlusX(p,q) == p + q + x IN ApaFoldSeqLeft( PlusX, 0, &lt;&lt;1,2,3&gt;&gt; )

X == A(1) \* X = 9
</code></pre>
<h3><a class="header" href="#folding-vs-recursion" id="folding-vs-recursion">Folding VS recursion</a></h3>
<p>While TLA+ allows users to write arbitrary recursive operators, they are, in our experience, mostly used to implement collection traversals. Consider the following implementations of a <code>Max</code> operator, which returns the largest element of a sequence:</p>
<pre><code class="language-tla">\* Max(&lt;&lt;&gt;&gt;) = -inf, but integers are unbounded in TLA+, 
\* so there is no natural minimum like MIN_INT in programming languages
CONSTANT negInf 

RECURSIVE MaxRec(_)
MaxRec(seq) == IF seq = &lt;&lt;&gt;&gt;
               THEN negInf
               ELSE LET tailMax == MaxRec(Tail(seq))
                    IN IF tailMax &gt; Head(seq)
                       THEN tailMax
                       ELSE Head(seq)

MaxFold(seq) == LET Max(p,q) == IF p &gt; q THEN p ELSE q
                IN ApaFoldSeqLeft( Max, negInf, seq )
</code></pre>
<p>The first advantage of the fold implementation, we feel, is that it is much more clear and concise. It also does not require a termination condition, unlike the recursive case.
One inherent problem of using recursive operators with a symbolic encoding, is the inability to estimate termination.
While it may be immediately obvious to a human, that <code>MaxRec</code> terminates after no more than <code>Len(seq)</code> steps, automatic termination analysis is, in general, a rather complex and incomplete form of static analysis.
Apalache addresses this by finitely unrolling recursive operators and requires users to provide unroll limits (<code>UNROLL_LIMIT_MaxRec == ...</code>), which serve as a static upper bound to the number of recursive re-entries, because in general, recursive operators may take an unpredictable number of steps (e.g. computing the <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz sequence</a>) or never terminate at all.
Consider a minor adaptation of the above example, where the author made a mistake in implementing the operator:</p>
<pre><code class="language-tla">RECURSIVE MaxRec(_)
MaxRec(seq) == IF seq = &lt;&lt;&gt;&gt;
               THEN negInf
               ELSE LET tailMax == MaxRec( seq ) \* forgot Tail!
                    IN IF tailMax &gt; Head(seq)
                       THEN tailMax
                       ELSE Head(seq)
</code></pre>
<p>Now, <code>MaxRec</code> never terminates, but spotting this error might not be trivial at a glance. This is where we believe folds hold the second advantage: <code>ApaFoldSet</code> and <code>ApaFoldSeqLeft</code> <em>always terminate</em> in <code>Cardinality(set)</code> or <code>Len(seq)</code> steps, and each step is simple to describe, as it consists of a single operator application.</p>
<p>In fact, the vast majority of the traditionally recursive operators can be equivalently rewritten as folds, for example:</p>
<pre><code class="language-tla">RECURSIVE Cardinality(_)
Cardinality(set) == IF set = {}
                    THEN 0
                    ELSE LET x == CHOOSE y \in set: TRUE
                         IN 1 + Cardinality( set \ {x} )

CardinalityFold(set) == LET Count(p,q) == p + 1 \* the value of q, the set element, is irrelevant
                        IN ApaFoldSet( Count, 0, set )
</code></pre>
<p>Notice that, in the case of sets, picking an arbitrary element <code>x</code>, to remove from the set at each step, utilizes the <code>CHOOSE</code> operator. This is a common trait shared by many operators that implement recursion over sets. 
Since the introduction of folds, the use of <code>CHOOSE</code> in Apalache is heavily discouraged as it is both inefficient, as well as nondeterministic (unlike how <code>CHOOSE</code> is defined in TLA+ literature). For details, see the discussion in <a href="https://github.com/informalsystems/apalache/issues/841">issue 841</a>.</p>
<p>So the third advantage of using folds is the  ability to, almost always, avoid using the <code>CHOOSE</code> operator.</p>
<p>The downside of folding, compared to general recursion, is the inability to express non-primitively recursive functions.
For instance, one cannot define the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a>, as a fold. We find that in most specifications, this is not something the users would want to implement anyway, so in practice, we believe it is almost always better to use fold over recursive functions.</p>
<h3><a class="header" href="#folding-vs-quantification-and-choose" id="folding-vs-quantification-and-choose">Folding VS quantification and <code>CHOOSE</code></a></h3>
<p>Often, folding can be used to select a value from a collection, which could alternatively be described by a predicate and selected with <code>CHOOSE</code>. Let us revisit the <code>MaxFold</code> example:</p>
<pre><code class="language-tla">MaxFold(seq) == LET Max(p,q) == IF p &gt; q THEN p ELSE q
                IN ApaFoldSeqLeft( Max, negInf, seq )
</code></pre>
<p>The fold-less case could, instead of using recursion, compute the maximum as follows:</p>
<pre><code class="language-tla">MaxChoose(seq) == 
  LET Range == {seq[i] : i \in DOMAIN seq} 
  IN CHOOSE m \in Range : \A n \in Range : m &gt;= n
</code></pre>
<p>The predicate-based approach might result in a more compact specification, but that is because specifications have no notion of execution or complexity. Automatic verification tools, such as Apalache, the job of which includes finding witnesses to predicates, can work much faster with the fold approach. The reason is that <em>evaluating</em> <code>CHOOSE x \in S : \A y \in S: P(x,y)</code> is quadratic in the size of <code>S</code> (in a symbolic approach this is w.r.t. the number of constraints). For each candidate <code>x</code>, the entire set <code>S</code> must be tested for <code>P(x,_)</code>. On the other hand, the fold approach is linear in the size of <code>S</code>, since each element is visited exactly once. </p>
<p>In addition, the fold approach admits no undefined behavior. If, in the above example, <code>seq</code> was an empty sequence, the value of the computed maximum depends on the value of <code>CHOOSE x \in {}: TRUE</code>, which is undefined in TLA+, while the fold-based approach allows the user to determine behavior in that scenario (via the initial value).</p>
<p>Our general advice is to use folds over <code>CHOOSE</code> with quantified predicates wherever possible, if you're willing accept a very minor increase in specification size in exchange for a decrease in Apalache execution time, or, if you wish to avoid <code>CHOOSE</code> over empty sets resulting in undefined behavior.</p>
<h3><a class="header" href="#examples-the-versatility-of-folds" id="examples-the-versatility-of-folds">Examples: The versatility of folds</a></h3>
<p>Here we give some examples of common operators, implemented using folds:</p>
<pre><code class="language-tla">----- MODULE FoldDefined -----

EXTENDS Apalache

\*  Sum of all values of a set of integers
Sum(set) == LET Plus(p,q) == p + q IN ApaFoldSet( Plus, 0, set )

\*  Re-implementation of UNION setOfSets
BigUnion(setOfSets) == LET Union(p,q) == p \union q IN ApaFoldSet( Union, {}, setOfSets )

\*  Re-implementation of SelectSeq
SelectSeq(seq, Test(_)) == LET CondAppend(s,e) == IF Test(e) THEN Append(s, e) ELSE s
                           IN ApaFoldSeqLeft( CondAppend, &lt;&lt;&gt;&gt;, seq )

\*  Quantify the elements in S matching the predicate P
Quantify(S, P(_)) == LET CondCount(p,q) == p + IF P(q) THEN 1 ELSE 0
                     IN ApaFoldSet( CondCount, 0, S )

\* The set of all values in seq
Range(seq) == LET AddToSet(S, e) == S \union {e}
              IN LET Range == ApaFoldSeqLeft( AddToSet, {}, seq )

\* Finds the the value that appears most often in a sequence. Returns elIfEmpty for empty sequences
Mode(seq, elIfEmpty) == LET ExtRange == Range(seq) \union {elIfEmpty}
                        IN LET CountElem(countersAndCurrentMode, e) ==
                             LET counters == countersAndCurrentMode[1]
                                 currentMode == countersAndCurrentMode[2]
                             IN LET newCounters == [ counters EXCEPT ![e] == counters[e] + 1 ]
                                IN IF newCounters[e] &gt; newCounters[currentMode]
                                   THEN &lt;&lt; newCounters, e &gt;&gt;
                                   ELSE &lt;&lt; newCounters, currentMode &gt;&gt;
                           IN ApaFoldSeqLeft( CountElem, &lt;&lt;[ x \in ExtRange |-&gt; 0 ], elIfEmpty &gt;&gt;, seq )[2]

\* Returns TRUE iff fn is injective
IsInjective(fn) == 
  LET SeenBefore( seenAndResult, e ) == 
    IF fn[e] \in seenAndResult[1]
    THEN [ seenAndResult EXCEPT ![2] = FALSE ]
    ELSE [ seenAndResult EXCEPT ![1] = seenAndResult[1] \union {fn[e]} ]
  IN ApaFoldSet( SeenBefore, &lt;&lt; {}, TRUE &gt;&gt;, DOMAIN fn )[2]

================================
</code></pre>
<p>For the sake of comparison, we rewrite the above operators using recursion, <code>CHOOSE</code> or quantification:</p>
<pre><code class="language-tla">----- MODULE NonFoldDefined -----

EXTENDS Apalache

RECURSIVE Sum(_)
Sum(S) == IF S = {} 
          THEN 0
          ELSE LET x == CHOOSE y \in S : TRUE
               IN  x + Sum(S \ {x})

RECURSIVE BigUnion(_)
BigUnion(setOfSets) == IF setOfSets = {} 
                       THEN {}
                       ELSE LET S == CHOOSE x \in setOfSets : TRUE
                            IN  S \union BigUnion(setOfSets \ {x})

RECURSIVE SelectSeq(_,_)
SelectSeq(seq, Test(_)) == IF seq = &lt;&lt;&gt;&gt;
                           THEN &lt;&lt;&gt;&gt;
                           ELSE LET tail == SelectSeq(Tail(seq), Test)
                                IN IF Test( Head(seq) )
                                   THEN &lt;&lt;Head(seq)&gt;&gt; \o tail
                                   ELSE tail

RECURSIVE Quantify(_,_)
Quantify(S, P(_)) == IF S = {} 
                     THEN 0
                     ELSE LET x == CHOOSE y \in S : TRUE
                          IN (IF P(x) THEN 1 ELSE 0) + Quantify(S \ {x}, P) 

RECURSIVE Range(_)
Range(seq) == IF seq = &lt;&lt;&gt;&gt;
              THEN {}
              ELSE {Head(seq)} \union Range(Tail(seq))

Mode(seq, elIfEmpty) == IF seq = &lt;&lt;&gt;&gt;
                        THEN elIfEmpty 
                        ELSE LET numOf(p) == Quantify( DOMAIN seq, LAMBDA q: q = p )
                             IN CHOOSE x \in Range(seq): \A y \in Range(seq) : numOf(x) &gt;= numOf(y)

IsInjective(fn) == \A a,b \in DOMAIN fn : fn[a] = fn[b] =&gt; a = b

================================
</code></pre>
<p>In most cases, recursive operators are much more verbose, and the operators using <code>CHOOSE</code> and/or quantification mask double iteration (and thus have quadratic complexity). 
For instance, the evaluation of the fold-less <code>IsInjective</code> operator actually requires the traversal of all domain pairs, instead of the single domain traversal with fold.
In particular, <code>Mode</code>, the most verbose among the fold-defined operators, is still very readable (most LET-IN operators are introduced to improve readability, at the cost of verbosity) and quite efficient, as its complexity is linear w.r.t. the length of the sequence (the mode could also be computed directly, without a sub-call to <code>Range</code>, but the example would be more difficult to read), unlike the variant with <code>CHOOSE</code> and <code>\A</code>, which is quadratic.</p>
<h1><a class="header" href="#invariants-state-action-and-trace" id="invariants-state-action-and-trace">Invariants: state, action, and trace</a></h1>
<p>Until recently, Apalache only supported checking of state invariants. A state
invariant is a predicate over state variables and constants. State invariants
are, by far, the most common ones. Recently, we have added support for action
invariants and trace invariants. <a href="https://www.hillelwayne.com/post/action-properties/">Action properties</a> were highlighted by Hillel
Wayne; they can be checked with action invariants. Trace invariants let us
reason about finite executions.</p>
<h2><a class="header" href="#state-invariants" id="state-invariants">State invariants</a></h2>
<p>You have probably seen state invariants before. Consider the following specification.</p>
<pre><code class="language-tla">---------------------------- MODULE Invariants --------------------------------
EXTENDS Integers, Sequences, FiniteSets

VARIABLES
    \* @typeAlias: set = Set(Int);
    \* @typeAlias: state = { In: $set, Done: $set, Out: $set };
    \* @type: $set;
    In,
    \* @type: $set;
    Done,
    \* @type: $set;
    Out

\* @type: &lt;&lt;$set, $set, $set&gt;&gt;;
vars == &lt;&lt;In, Done, Out&gt;&gt;

Init ==
    /\ \E S \in SUBSET (1..5):
        /\ Cardinality(S) &gt; 2
        /\ In = S
    /\ Done = {}
    /\ Out = {}

Next ==
    \/ \E x \in In:
        /\ In' = In \ { x }
        /\ Done' = Done \union { x }
        /\ Out' = Out \union { 2 * x }
    \/ In = {} /\ UNCHANGED vars

\* state invariants that reason about individual states

StateInv ==
    Done \intersect In = {}

BuggyStateInv ==
    Done \subseteq In

</code></pre>
<p>We let you guess what this specification is doing. As for its properties, it contains
two state invariants:</p>
<ul>
<li>Predicate <code>StateInv</code> that states <code>Done \intersect In = {}</code>, and</li>
<li>Predicate <code>BuggyStateInv</code> that states <code>Done \subseteq In</code>.</li>
</ul>
<p>We call these predicates state invariants, as we expect them to hold in
every state of an execution. To check, whether these invariants hold true,
we run Apalache as follows:</p>
<pre><code class="language-sh">$ apalache check --inv=StateInv Invariants.tla
...
Checker reports no error up to computation length 10
...
$ apalache check --inv=BuggyStateInv Invariants.tla
...
State 1: state invariant 0 violated. Check the counterexample in: counterexample.tla, MC.out, counterexample.json
...
</code></pre>
<p><em>The standard footprint: By default, Apalache checks executions of length up
to 10 steps.</em></p>
<h2><a class="header" href="#action-invariants" id="action-invariants">Action invariants</a></h2>
<p>Let's have a look at two other predicates in <code>Invariants.tla</code>:</p>
<pre><code class="language-tla">\* action invariants that reason about transitions (consecutive pairs of states)

ActionInv ==
    \/ In = {}
    \/ \E x \in Done':
        Done' = Done \union { x }

BuggyActionInv ==
    Cardinality(In') = Cardinality(In) + 1

</code></pre>
<p>Can you see a difference between <code>ActionInv</code> &amp; <code>BuggyActionInv</code> and <code>StateInv</code>
&amp; <code>BuggyStateInv</code>?</p>
<p>You have probably noticed that <code>ActionInv</code> as well as <code>BuggyActionInv</code> use
unprimed variables and primed variables. So they let us reason about two
consecutive states of an execution. They are handy for checking specification
progress. Similar to state invariants, we can check, whether action invariants
hold true by running Apalache as follows:</p>
<pre><code class="language-sh">$ apalache check --inv=ActionInv Invariants.tla
...
Checker reports no error up to computation length 10
...
$ apalache check --inv=BuggyActionInv Invariants.tla
...
State 0: action invariant 0 violated. Check the counterexample in: counterexample.tla, MC.out, counterexample.json
...
</code></pre>
<p>There is no typo in the CLI arguments above: You pass action invariants the same way
as you pass state invariants. Preprocessing in Apalache is clever enough to figure out,
what kind of invariant it is dealing with.</p>
<p><a name="traceInv"></a></p>
<h2><a class="header" href="#trace-invariants" id="trace-invariants">Trace invariants</a></h2>
<p>Let's have a look at the following two predicates in <code>Invariants.tla</code>:</p>
<pre><code class="language-tla">\* trace invariants that reason about executions

\* @type: Seq($state) =&gt; Bool;
TraceInv(hist) ==
    \/ hist[Len(hist)].In /= {}
    \* note that we are using the last state in the history and the first one
    \/ { 2 * x: x \in hist[1].In } = hist[Len(hist)].Out

\* @type: Seq($state) =&gt; Bool;
BuggyTraceInv(hist) ==
    \/ hist[Len(hist)].In /= {}
    \* note that we are using the last state in the history and the first one
    \/ { 3 * x: x \in hist[1].In } = hist[Len(hist)].Out

</code></pre>
<p>These predicates are quite different from state invariants and action
invariants.  Both <code>TraceInv</code> and <code>BuggyTraceInv</code> accept the parameter <code>hist</code>,
which store the execution history as a sequence of records. Having the
execution history, you can check plenty of interesting properties. For
instance, you can check, whether the result of an execution somehow matches the
input values.</p>
<pre><code class="language-sh">$ apalache check --inv=TraceInv Invariants.tla
...
Checker reports no error up to computation length 10
...
$ apalache check --inv=BuggyTraceInv Invariants.tla
...
State 3: trace invariant 0 violated. Check the counterexample in: counterexample.tla, MC.out, counterexample.json
...
</code></pre>
<p>Trace invariants are quite powerful. You can write down temporal properties as
trace invariants. However, we recommend to use trace invariants for testing, as
they are too powerful. For verification, you should use temporal properties.</p>
<h1><a class="header" href="#enumerating-counterexamples" id="enumerating-counterexamples">Enumerating counterexamples</a></h1>
<p>By default, Apalache stops whenever it finds a property violation. This is true
for the commands that are explained in the Section on <a href="apalache/principles/./running.html">Running the
Tool</a>. Sometimes, we want to produce multiple counterexamples;
for instance, to generate multiple tests.</p>
<p>Consider the following TLA+ specification:</p>
<pre><code class="language-tla">---- MODULE View2 ----
EXTENDS Integers
VARIABLES
    \* @type: Int;
    x

Init ==
  x = 0

A ==
  x' = x + 1

B ==
  x' = x - 1

C ==
  x' = x

Next ==
  A \/ B \/ C

Inv ==
  x = 0

</code></pre>
<p>We can run Apalache to check the state invariant <code>Inv</code>:</p>
<pre><code class="language-sh">$ apalache check --inv=Inv View2.tla
</code></pre>
<p>Apalache quickly finds a counterexample that looks like this:</p>
<pre><code class="language-tla">...
(* Initial state *)
State0 == x = 0

(* Transition 0 to State1 *)
State1 == x = 1
...
</code></pre>
<p><strong>Producing multiple counterexamples.</strong>
If we want to see more examples of invariant violation, we can ask Apalache to
produce up to 50 counterexamples:</p>
<pre><code class="language-sh">$ apalache check --inv=Inv --max-error=50 View2.tla
...
Found 20 error(s)
...
</code></pre>
<p>Whenever the model checker finds an invariant violation, it reports a
counterexample to the current symbolic execution and proceeds with the next action.
For instance, if the symbolic execution <code>Init \cdot A \cdot A</code> has a concrete
execution that violates the invariant <code>Inv</code>, the model checker would print this
execution and proceed with the symbolic execution <code>Init \cdot A \cdot B</code>.  That
is why the model checker stops after producing 20 counterexamples.</p>
<p>The option <code>--max-error</code> is similar to the option <code>--continue</code> in TLC, see <a href="https://lamport.azurewebsites.net/tla/tlc-options.html?back-link=tools.html">TLC
options</a>. However, the space of counterexamples in Apalache may be infinite,
e.g., when we have integer variables, so <code>--max-error</code> requires an upper bound
on the number of counterexamples.</p>
<p><strong>Partitioning counterexamples with view abstraction.</strong>
Some of the produced counterexamples are not really interesting. For
instance, <code>counterexample5.tla</code> looks like follows:</p>
<pre><code class="language-tla">(* Initial state *)
State0 == x = 0

(* Transition 1 to State1 *)
State1 == x = -1

(* Transition 1 to State2 *)
State2 == x = -2

(* Transition 0 to State3 *)
State3 == x = -1
</code></pre>
<p>Obviously, the invariant is violated in <code>State1</code> already, so states <code>State2</code>
and <code>State3</code> are not informative. We could write a <a href="apalache/principles/./invariants.html#traceInv">trace
invariant</a> to enforce invariant violation only in the
last state. Alternatively, the model checker could enforce the constraint that
the invariant holds true in the intermediate states. As invariants usually
produce complex constraints and slow down the model checker, we leave the
choice to the user.</p>
<p>Usually, the specification author has a good idea of how to partition states
into interesting equivalence classes. We let you specify this partitiong by declaring
a view abstraction, similar to the <code>VIEW</code> configuration option in TLC.
Basically, two states are considered to be similar, if they have the same view.</p>
<p>In our example, we compute the state view with the operator <code>View1</code>:</p>
<pre><code class="language-tla">\* @type: &lt;&lt;Bool, Bool&gt;&gt;;
View1 ==
  &lt;&lt;x &lt; 0, x &gt; 0&gt;&gt;
</code></pre>
<p>Hence, the states with <code>x = 1</code> and <code>x = 25</code> are similar, because their view has the
same value <code>&lt;&lt;FALSE, TRUE&gt;&gt;</code>. We can also define the view of an execution, simply
as a sequence of views of the execution states.</p>
<p>Now we can ask Apalache to produce up to 50 counterexamples again. This time we
tell it to avoid the executions that start with the view of an execution that
produced an error earlier:</p>
<pre><code class="language-sh">$ apalache check --inv=Inv --max-error=50 --view=View1 View2.tla
...
Found 20 error(s)
...
</code></pre>
<p>Now <code>counterexample5.tla</code> is more informative:</p>
<pre><code class="language-tla">(* Initial state *)
State0 == x = 0

(* Transition 2 to State1 *)
State1 == x = 0

(* Transition 2 to State2 *)
State2 == x = 0

(* Transition 0 to State3 *)
State3 == x = 1
</code></pre>
<p>Moreover, <code>counterexample6.tla</code> is intuitively a mirror version of <code>counterexample5.tla</code>:</p>
<pre><code class="language-tla">(* Initial state *)
State0 == x = 0

(* Transition 2 to State1 *)
State1 == x = 0

(* Transition 2 to State2 *)
State2 == x = 0

(* Transition 0 to State3 *)
State3 == x = -1
</code></pre>
<p>By the choice of the view, we have partitioned the states into three
equivalence classes: <code>x &lt; 0</code>, <code>x = 0</code>, and <code>x &gt; 0</code>. It is often useful to write
a view as a tuple of predicates. However, you can write arbitrary TLA+ expressions.
A view is just a mapping from state variables to the set of values that can be
computed by the view expressions.</p>
<p>We are using this technique in model-based testing.  If you have found another
interesting application of this technique, please let us know!</p>
<h1><a class="header" href="#the-apalache-module" id="the-apalache-module">The Apalache Module</a></h1>
<p>Similar to the <code>TLC</code> module, we provide a module called <code>Apalache</code>, which can be found in <a href="https://github.com/informalsystems/apalache/tree/main/src/tla/Apalache.tla">Apalache.tla</a>. Many of
the operators in that module are used internally by Apalache, when rewriting a TLA+ specification. It is useful
to read the comments to the operators defined in <a href="https://github.com/informalsystems/apalache/tree/main/src/tla/Apalache.tla">Apalache.tla</a>, as they will help you in understanding
the <a href="apalache/principles/./running.html#detailed">detailed output</a> produced by the tool.</p>
<p>See the detailed description of the <a href="https://apalache.informal.systems/docs/lang/apalache-operators.html">Apalache operators</a>.</p>
<h3><a class="header" href="#naturals" id="naturals">Naturals</a></h3>
<p>If you look carefully at the <a href="apalache/principles/../HOWTOs/howto-write-type-annotations.html">HOWTO on
annotations</a>, you will find that
there is no designated type for naturals. Indeed, one can just use the type
<code>Int</code>, whenever a natural number is required. If we introduced a special type
for naturals, that would cause a lot of confusion for the type checker. What
would be the type of the literal <code>42</code>? That depends on, whether you extend
<code>Naturals</code> or <code>Integers</code>. And if you extend <code>Naturals</code> and later somebody else
extends your module and also <code>Integers</code>, should be the type of <code>42</code> be an
integer?</p>
<p>Apalache still allows you to extend <code>Naturals</code>. However, it will treat all
number-like literals as integers. This is consistent with the view that the
naturals are a subset of the integers, and the integers are a subset of the
reals.  Classically, one would not define subtraction for naturals. However,
the module <code>Naturals</code> defines binary minus, which can easily drive a variable
outside of <code>Nat</code>. For instance, see the following example:</p>
<pre><code class="language-tla">----------------------------- MODULE NatCounter ------------------------
EXTENDS Naturals

VARIABLE
    \* @type: Int;
    x

Init == x = 3

\* a natural counter can go below zero, and this is expected behavior
Next == x' = x - 1

Inv == x &gt;= 0
========================================================================
</code></pre>
<p>Given that you will need the value <code>Int</code> for a type annotation, it probably
does not make a lot of sense to extend <code>Naturals</code> in your own specifications,
as you will have to extend <code>Integers</code> for the type annotation too.</p>
<h1><a class="header" href="#apalache-configuration" id="apalache-configuration">Apalache configuration</a></h1>
<p>Apalache supports configuration of some parameters governing its behavior.</p>
<p>Application configuration is loaded from the following four sources:</p>
<ol>
<li>Command line arguments</li>
<li>Environment variables</li>
<li>A local configuration file</li>
<li>The global configuration file</li>
</ol>
<p>The order of precedence of the sources follows their numbering: i.e., and any
configuration set in an earlier numbered source overrides a configuration set in
a later numbered source.</p>
<h2><a class="header" href="#command-line-arguments-and-environment-variables" id="command-line-arguments-and-environment-variables">Command line arguments and environment variables</a></h2>
<p>To view the available command line arguments, run Apalache with the <code>--help</code>
flag and consult the section on <a href="apalache/./running.html">Running the Tool</a> for more
details.</p>
<p><em>Some</em> parameters configurable via the command line are also configurable via environment
variables. These parameters are noted in the CLI's inline help. If a parameter
is configured both through a CLI argument and an environment variable, then the
CLI argument always takes precedence. </p>
<h2><a class="header" href="#configuration-files" id="configuration-files">Configuration files</a></h2>
<h3><a class="header" href="#file-format-and-supported-parameters" id="file-format-and-supported-parameters">File format and supported parameters</a></h3>
<p>Local configuration files support JSON and the JSON superset
<a href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON</a>.</p>
<p>Here's an example of a valid configuration for commonly used
parameters, along with their default values:</p>
<pre><code class="language-yaml">common  {
    # Directory in which to write all log files and records of each run
    out-dir = &quot;${PWD}/_apalache-out&quot;

    # Whether or not to write additional files, that report on intermediate
    # processing steps
    write-intermediate = false

    # Whether or not to write general profiling data into the `out-dir`
    profiling = false

    # Fixed directory into which generated files are written (absent by default)
    # run-dir = ~/my-run-dir
}
</code></pre>
<p>A <code>~</code> found at the beginning of a file path will expanded into the value set for
the user's home directory.</p>
<p>Details on the effect of these parameters can be found in <a href="apalache/./running.html">Running the
Tool</a>.</p>
<h3><a class="header" href="#local-configuration-file" id="local-configuration-file">Local configuration file</a></h3>
<p>You can specify a local configuration file explicitly via the <code>config-file</code>
command line argument. If this is not provided, then Apalache will look for the
nearest <code>.apalache.cfg</code> file, beginning in the current working directory and
searching up through its parents.</p>
<p>Parameters configured in the local configuration file will be overridden by
values set via CLI arguments or environment variables, and will override
parameters configured via the global configuration file.</p>
<h3><a class="header" href="#global-configuration-file" id="global-configuration-file">Global configuration file</a></h3>
<p>The final fallback for configuration parameters is the global configuration file
named <code>$HOME/.tlaplus/apalache.cfg</code>.</p>
<h1><a class="header" href="#tla-anonymized-execution-statistics" id="tla-anonymized-execution-statistics">TLA+ Anonymized Execution Statistics</a></h1>
<p>Apalache participates in the optional <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a> along
with <a href="http://lamport.azurewebsites.net/tla/toolbox.html">TLA+ Toolbox</a>, TLC (which is part of the Toolbox), and <a href="https://marketplace.visualstudio.com/items?itemName=alygin.vscode-tlaplus">Visual Studio
Code Plugin for TLA+</a>.</p>
<p>The statistics collection is <strong>never enabled by default</strong>. You have to <strong>opt-in</strong>
for the programme either in TLA+ Toolbox, or in Apalache. When statistics
collection is enabled by the user, it is submitted to <code>tlapl.us</code> via the
util.<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.java">ExecutionStatisticsCollector</a>, which is part of <code>tla2tools.jar</code>. Apalache
accesses this class in at.forsyte.apalache.tla.<a href="https://github.com/informalsystems/apalache/blob/main/mod-tool/src/main/scala/at/forsyte/apalache/tla/Tool.scala">Tool</a>.</p>
<p>As explained in <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a>, if you never create the file
<code>$HOME/.tlaplus/esc.txt</code>, then the statistics is not submitted to <code>tlapl.us</code>.
If you opt-in for the programme and later remove the file, then the statistics
will not be submitted too.</p>
<h2><a class="header" href="#why-do-we-ask-you-to-help-us" id="why-do-we-ask-you-to-help-us">Why do we ask you to help us</a></h2>
<p>There are several reasons:</p>
<ul>
<li>
<p>Although our project is open source, developing Apalache is our main job.
We are grateful to <a href="https://informal.systems">Informal Systems</a> for supporting us and to <a href="https://www.tuwien.at/">TU Wien</a>,
<a href="https://www.wwtf.at/index.php?lang=EN">Vienna Science and Technology Fund</a>, and <a href="https://www.inria.fr/en/centre-inria-nancy-grand-est">Inria Nancy/LORIA</a>, who
supported us in the past.  It is easier to convince our decision makers to
continue the development, if we have clear feedback on how many people
<strong>use and need Apalache</strong>.</p>
</li>
<li>
<p>We would like to know which features you are using most, so we can focus on
them.</p>
</li>
<li>
<p>We would like to know which operating systems and Java versions need care
and better be included in automated test suites.</p>
</li>
</ul>
<h2><a class="header" href="#how-to-opt-in-and-opt-out" id="how-to-opt-in-and-opt-out">How to opt-in and opt-out</a></h2>
<p>To opt-in in the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=true
</code></pre>
<p>As a result of this command, a random identifier is written in
<code>$HOME/.tlaplus/esc.txt</code>. This identifier is used by the execution statistics
code.</p>
<p>To opt-out from the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=false
</code></pre>
<h2><a class="header" href="#what-exactly-is-submitted-to-tlaplus" id="what-exactly-is-submitted-to-tlaplus">What exactly is submitted to tlapl.us</a></h2>
<p>You can check the daily log at <a href="https://exec-stats.tlapl.us/">exec-stats.tlapl.us</a>.</p>
<p>The following data is submitted for each run, if you have opted in:</p>
<ul>
<li>Total number of CPU cores and cores assigned
(the latter is 1 for now, but will change soon)</li>
<li>Java heap memory size (in Megabytes)</li>
<li>Apalache version (semantic version + build)</li>
<li>Command mode: <code>parse</code>, <code>check</code>, or <code>typecheck</code></li>
<li>Name, version, and architecture of the OS</li>
<li>Vendor, version, and architecture of JVM</li>
<li>Timestamp + salt (a random number to make time less precise)</li>
<li>An installation ID that is stored in <code>$HOME/.tlaplus/esc.txt</code></li>
</ul>
<h1><a class="header" href="#profiling-your-specification" id="profiling-your-specification">Profiling Your Specification</a></h1>
<p><strong>Warning:</strong> Profiling only works in the incremental SMT mode, that is, when the model checker is run
with <code>--algo=incremental</code>, or without the option
<code>--algo</code> specified.</p>
<p>As Apalache translates the TLA+ specification to SMT, it often defeats our intuition about the standard bottlenecks that
one learns about when running TLC. For instance, whereas TLC needs a lot of time to compute the initial states for the
following specification, Apalache can check the executions of length up to ten steps in seconds:</p>
<pre><code class="language-tla">---------------------------- MODULE powerset ----------------------------
EXTENDS Integers
VARIABLE S

Init ==
    /\ S \in SUBSET (1..50)
    /\ 3 \notin S

Next ==
    \/ \E x \in S:
        S' = S \ {x}
    \/ UNCHANGED S

Inv ==
    3 \notin S
=========================================================================
</code></pre>
<p>Apalache has its own bottlenecks. As it's using the SMT solver z3,
we cannot precisely profile your TLA+ specification. However, we can profile
the number of SMT variables and constraints that Apalache produces for different
parts of your specification. To activate this profiling mode, use the option
<code>--smtprof</code>:</p>
<pre><code class="language-sh">apalache check --smtprof powerset.tla
</code></pre>
<p>The profiling data is written in the file <code>profile.csv</code> in the <a href="apalache/./running.html#detailed">run
directory</a>:</p>
<pre><code># weight,nCells,nConsts,nSmtExprs,location
4424,2180,2076,28460,powerset.tla:11:5-13:18
4098,2020,1969,12000,powerset.tla:12:9-12:20
4098,2020,1969,12000,powerset.tla:12:14-12:20
...
</code></pre>
<p>The meaning of the columns is as follows:</p>
<ul>
<li>
<p><code>weight</code> is the weight of the expression.
Currently it is computed as <code>nCells + nConsts + sqrt(nSmtExprs)</code>.
We may change this formula in the future.</p>
</li>
<li>
<p><code>nCells</code> is the number of arena cells that are created during the translation.
Intuitively, the cells are used to keep the potential shapes of the data structures
that are captured by the expression.</p>
</li>
<li>
<p><code>nConsts</code> is the number of SMT constants that are produced by the translator.</p>
</li>
<li>
<p><code>nSmtExprs</code> is the number of SMT expressions that are produced by the translator.
We also include all subexpressions, when counting this metric.</p>
</li>
<li>
<p><code>location</code> is the location in the source code where the expression
was found, indicated by the file name correlated with a range of <code>line:column</code> pairs.</p>
</li>
</ul>
<p>To visualize the profiling data, you can use the script <code>script/heatmap.py</code>:</p>
<pre><code class="language-sh">$APALACHE_HOME/script/heatmap.py profile.csv heatmap.html
</code></pre>
<p>The produced file <code>heatmap.html</code> looks as follows:</p>
<p><img src="apalache/./img/profiler2.png" alt="Here you should see a heatmap" title="A heatmap" /></p>
<p>The heatmap may give you an idea about the expression that are hard for Apalache.
The following picture highlights one part of the Raft specification that produces
a lot of constraints:</p>
<p><img src="apalache/./img/profiler.png" alt="Here you should see a heatmap" title="A heatmap of Raft" /></p>
<h1><a class="header" href="#five-minutes-of-theory" id="five-minutes-of-theory">Five minutes of theory</a></h1>
<p><strong>You can safely skip this section</strong></p>
<p>Given a TLA+ specification, with all parameters fixed, our model checker
performs the following steps:</p>
<ol>
<li>
<p>It automatically extracts symbolic transitions from the specification. This
allows us to partition the action <code>Next</code> into a disjunction of simpler actions
<code>A_1, ..., A_n</code>.</p>
</li>
<li>
<p>Apalache translates operators <code>Init</code> and <code>A_1, ..., A_n</code> to SMT formulas.
This allows us to explore bounded executions with an SMT solver (we are using
<a href="https://github.com/Z3Prover/z3">Microsoft's Z3</a>). For instance, a sequence of
<code>k</code> steps <code>s_0, s_1, ..., s_k</code>, all of which execute action <code>A_1</code>, is encoded
as a formula <code>Run(k)</code> that looks as follows:</p>
</li>
</ol>
<pre><code class="language-tla">[[Init(s_0)]] /\ [[A_1(s_0, s_1)]] /\ ... /\ [[A_1(s_(k-1), s_k)]]
</code></pre>
<p>To find an execution of length <code>k</code> that violates an invariant <code>Inv</code>, the tool
adds the following constraint to the formula <code>Run(k)</code>:</p>
<pre><code class="language-tla">[[~Inv(s_0)]] \/ ... \/ [[~Inv(s_k)]]
</code></pre>
<p>Here, <code>[[_]]</code> is the translator from TLA+ to SMT. Importantly, the values for
the states <code>s_0</code>, ..., <code>s_k</code> are not enumerated as in TLC, but have to be found
by the SMT solver.</p>
<p>If you would like to learn more about theory behind Apalache, check the <a href="https://dl.acm.org/doi/10.1145/3360549">paper
delivered at OOPSLA19</a>.</p>
<h1><a class="header" href="#syntax-of-tlc-configuration-files" id="syntax-of-tlc-configuration-files">Syntax of TLC Configuration Files</a></h1>
<p><strong>Author:</strong> Igor Konnov, 2020</p>
<p>To see how Apalache can use TLC configuration files, check the page
on <a href="apalache/./parameters.html#tlc-configuration-file">Specification Parameters</a>
and <a href="apalache/./running.html">Running the Tool</a>.</p>
<p>This file presents the syntax of
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a> configuration files
in <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> and
comments on the treatment of its sections in
<a href="https://github.com/informalsystems/apalache">Apalache</a>. A detailed discussion
on using the config files with TLC can be found in Leslie Lamport's
<a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>,
Chapter 14 and in
<a href="https://lamport.azurewebsites.net/tla/current-tools.pdf">Current Versions of the TLA+ Tools</a>.
In particular, the TLA+ specification of TLC configuration files
is given in Section 14.7.1. The standard parser can be found in
<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/tlc2/tool/impl/ModelConfig.java"><code>tlc2.tool.impl.ModelConfig</code></a>.
As the configuration files have simple syntax, we implement our own parser in
Apalache.</p>
<pre><code class="language-ebnf">// The configuration file is a non-empty sequence of configuration options.
config ::=
    options+

// Possible options, in no particular order, all of them are optional.
// Apalache expects Init after Next, or Next after Init.
options ::=
    Init
  | Next
  | Specification
  | Constants
  | Invariants
  | Properties
  | StateConstraints
  | ActionConstraints
  | Symmetry
  | View
  | Alias
  | Postcondition
  | CheckDeadlock

// Set the initialization predicate (over unprimed variables), e.g., Init.
Init ::=
    &quot;INIT&quot; ident

// Set the next predicate (over unprimed and primed variables), e.g., Next.
Next ::=
    &quot;NEXT&quot; ident

// Set the specification predicate, e.g., Spec.
// A specification predicate usually looks like Init /\ [][Next]_vars /\ ...
Specification ::=
    &quot;SPECIFICATION&quot; ident

// Set the constants to specific values or substitute them with other names.
Constants ::=
    (&quot;CONSTANT&quot; | &quot;CONSTANTS&quot;) (replacement | assignment)*

// Replace the constant in the left-hand side
// with the identifier in the right-hand side.
replacement ::=
    ident &quot;&lt;-&quot; ident

// Replace the constant in the left-hand side
// with the constant expression in the right-hand side.
assignment ::=
    ident &quot;=&quot; constExpr

// A constant expression that may appear in
// the right-hand side of an assignment.
constExpr ::=
    modelValue
  | integer
  | string
  | boolean
  | &quot;{&quot; &quot;}&quot;
  | &quot;{&quot; constExpr (&quot;,&quot; constExpr)* &quot;}&quot;

// The name of a model value, see Section 14.5.3 of Specifying Systems.
// A model value is essentially an uninterpreted constant.
// All model values are distinct from one another. Moreover, they are
// not equal to other values such as integers, strings, sets, etc.
// Apalache treats model values as strings, which it declares as
// uninterpreted constants in SMT.
modelValue ::= ident

// An integer (no bit-width assumed)
integer ::=
      &lt;string matching regex [0-9]+&gt;
    | &quot;-&quot; &lt;string matching regex [0-9]+&gt;

// A string, starts and ends with quotes,
// a restricted set of characters is allowed (pre-UTF8 era, Paxon scripts?)
string ::=
    '&quot;' &lt;string matching regex [a-zA-Z0-9_~!@#\$%^&amp;*-+=|(){}[\],:;`'&lt;&gt;.?/ ]*&gt; '&quot;'

// A Boolean literal
boolean ::= &quot;FALSE&quot; | &quot;TRUE&quot;

// Set an invariant (over unprimed variables) to be checked against
// every reachable state.
Invariants ::=
    (&quot;INVARIANT&quot; | &quot;INVARIANTS&quot;) ident*

// Set a temporal property to be checked against the initial states.
// Temporal properties reason about finite or infinite computations,
// which are called behaviors in TLA+. Importantly, the computations
// originate from the initial states.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Properties ::=
    (&quot;PROPERTY&quot; | &quot;PROPERTIES&quot;) ident*

// Set a state predicate (over unprimed variables)
// that restricts the state space to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
StateConstraints ::=
    (&quot;CONSTRAINT&quot; | &quot;CONSTRAINTS&quot;) ident*

// Set an action predicate (over unprimed and primed variables)
// that restricts the transitions to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
ActionConstraints ::=
    (&quot;ACTION_CONSTRAINT&quot; | &quot;ACTION_CONSTRAINTS&quot;) ident*

// Set the name of an operator that produces a set of permutations
// for symmetry reduction.
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Symmetry ::=
    &quot;SYMMETRY&quot; ident

// Set the name of an operator that produces a state view
// (some form of abstraction).
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
View ::=
    &quot;VIEW&quot; ident

// Whether the tools should check for deadlocks.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
CheckDeadlock ::=
    &quot;CHECK_DEADLOCK&quot; (&quot;FALSE&quot; | &quot;TRUE&quot;)

// Recent feature: https://lamport.azurewebsites.net/tla/current-tools.pdf
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Postcondition ::=
    &quot;POSTCONDITION&quot; ident

// Very recent feature: https://github.com/tlaplus/tlaplus/issues/485
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Alias ::=
    &quot;ALIAS&quot; ident

// A TLA+ identifier, must be different from the above keywords.
ident ::=
    &lt;string matching regex [a-zA-Z_]([a-zA-Z0-9_])*&gt;

</code></pre>
<h2><a class="header" href="#the-new-type-checker-snowcat" id="the-new-type-checker-snowcat">The new type checker Snowcat</a></h2>
<p><strong>WARNING:</strong> Snowcat is our type checker starting with Apalache version 0.15.0.
If you are using Apalache prior to version 0.15.0, check the chapter on
<a href="apalache/./types-and-annotations.html">old type annotations</a>.</p>
<hr />
<h3><a class="header" href="#how-to-write-type-annotations-1" id="how-to-write-type-annotations-1">How to write type annotations</a></h3>
<p>Check the <a href="apalache/../HOWTOs/howto-write-type-annotations.html">HOWTO</a>.  You can find
detailed syntax of type annotations in <a href="apalache/../adr/002adr-types.html">ADR002</a>. </p>
<h3><a class="header" href="#how-to-run-the-type-checker" id="how-to-run-the-type-checker">How to run the type checker</a></h3>
<p>The type checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache typecheck [--infer-poly=&lt;bool&gt;] &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>General parameters:
<ul>
<li><code>--infer-poly</code> controls whether the type checker should infer polymorphic
types. As many specs do not need polymorphism, you can set this option
to <code>false</code>. The default value is <code>true</code>.</li>
</ul>
</li>
</ul>
<p>There is not much to explain about running the tool. When it successfully finds
the types of all expressions, it reports:</p>
<pre><code> &gt; Running Snowcat .::..
 &gt; Your types are great!
  ...
Type checker [OK]
</code></pre>
<p>When the type checker finds an error, it explains the error like that:</p>
<pre><code> &gt; Running Snowcat .::.
[QueensTyped.tla:42:44-42:61]: Mismatch in argument types. Expected: (Seq(Int)) =&gt; Bool
[QueensTyped.tla:42:14-42:63]: Error when computing the type of Solutions
 &gt; Snowcat asks you to fix the types. Meow.
Type checker [FAILED]
</code></pre>
<p>Here is the list of the TLA+ language features that are currently supported by Apalache, following the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of TLA+</a>.</p>
<h2><a class="header" href="#safety-vs-liveness" id="safety-vs-liveness">Safety vs. Liveness</a></h2>
<p>At the moment, Apalache is able to check state invariants, action invariants,
temporal properties, trace invariants, as well as inductive invariants. (See the <a href="https://apalache.informal.systems/docs/apalache/principles/invariants.html">page on
invariants</a> in
the manual.) To check liveness/temporal properties, we employ a <a href="https://www.sciencedirect.com/science/article/pii/S1571066104804109?via%3Dihub">liveness-to-safety</a> transformation.</p>
<h2><a class="header" href="#language" id="language">Language</a></h2>
<h3><a class="header" href="#module-level-constructs" id="module-level-constructs">Module-Level constructs</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>EXTENDS module</code></td><td align="center">✔</td><td align="center">-</td><td>A few standard modules are not supported yet (Bags)</td></tr>
<tr><td><code>CONSTANTS C1, C2</code></td><td align="center">✔</td><td align="center">-</td><td>Either define a <code>ConstInit</code> operator to initialize the constants, use a <code>.cfg</code> file, or declare operators instead of constants, e.g., C1 == 111</td></tr>
<tr><td><code>VARIABLES x, y, z</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>ASSUME P</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Parsed, but not propagated to the solver</td></tr>
<tr><td><code>F(x1, ..., x_n) == exp</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Every application of <code>F</code> is replaced with its body. <a href="apalache/./principles/recursive.html">Recursive operators</a> not supported after 0.23.1. From 0.16.1 and later, for better performance and UX, use <code>ApaFoldSet</code> and <code>ApaFoldSeqLeft</code>.</td></tr>
<tr><td><code>f[x ∈ S] == exp</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td><a href="apalache/./principles/recursive.html">Recursive functions</a> not supported after 0.23.1. From 0.16.1 and later, for better performance and UX, use <code>ApaFoldSet</code> and <code>ApaFoldSeqLeft</code>.</td></tr>
<tr><td><code>INSTANCE M WITH ...</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>No special treatment for <code>~&gt;</code>, <code>\cdot</code>, <code>ENABLED</code></td></tr>
<tr><td><code>N(x1, ..., x_n) == INSTANCE M WITH...</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Parameterized instances are not supported</td></tr>
<tr><td><code>THEOREM P</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Parsed but not used</td></tr>
<tr><td><code>LOCAL def</code></td><td align="center">✔</td><td align="center">-</td><td>Replaced with local LET-IN definitions</td></tr>
</tbody></table>
<h3><a class="header" href="#the-constant-operators" id="the-constant-operators">The constant operators</a></h3>
<h4><a class="header" href="#logic" id="logic">Logic</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>/\</code>, <code>\/</code>, <code>~</code>, <code>=&gt;</code>, <code>&lt;=&gt;</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>TRUE</code>, <code>FALSE</code>, <code>BOOLEAN</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>\A x \in S: p</code>, <code>\E x \in S : p</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>CHOOSE x \in S : p</code></td><td align="center">✖</td><td align="center">-</td><td>Partial support prior to version 0.16.1. From 0.16.1 and later, use <code>Some</code>, <code>ApaFoldSet</code>, or <code>ApaFoldSeqLeft</code>. See <a href="https://github.com/informalsystems/apalache/issues/841">#841</a>.</td></tr>
<tr><td><code>CHOOSE x : x \notin S</code></td><td align="center">✖</td><td align="center">-</td><td>Not supported. You can use records or a default value such as -1.</td></tr>
<tr><td><code>\A x : p, \E x : p</code></td><td align="center">✖</td><td align="center">-</td><td>Use bounded quantifiers</td></tr>
<tr><td><code>CHOOSE x : p</code></td><td align="center">✖</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#sets" id="sets">Sets</a></h4>
<p><strong>Note:</strong> only finite sets are supported. Additionally, existential
quantification over <code>Int</code> and <code>Nat</code> is supported, as soon as it can be
replaced with a constant.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>=</code>, <code>/=</code>, <code>\in</code>, <code>\notin</code>, <code>\intersect</code>, <code>\union</code>, <code>\subseteq</code>, <code>\</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e_1, ..., e_n}</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>{x \in S : p}</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e : x \in S}</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>SUBSET S</code></td><td align="center">✔</td><td align="center">-</td><td>Sometimes, the powersets are expanded</td></tr>
<tr><td><code>UNION S</code></td><td align="center">✔</td><td align="center">-</td><td>Provided that S is expanded</td></tr>
</tbody></table>
<h4><a class="header" href="#functions" id="functions">Functions</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>f[e]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>DOMAIN f</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ x \in S ↦ e]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ S -&gt; T ]</code></td><td align="center">✔</td><td align="center">-</td><td>Supported, provided the function can be interpreted symbolically</td></tr>
<tr><td><code>[ f EXCEPT ![e1] = e2 ]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#records" id="records">Records</a></h4>
<p><em>Use <a href="https://apalache.informal.systems/docs/tutorials/snowcat-tutorial.html">type
annotations</a>
to help the model checker in finding the right types.</em> Note that our type
system distinguishes records from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e.h</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>r[e]</code></td><td align="center">✔/✖</td><td align="center">-</td><td>Provided that <code>e</code> is a constant expression.</td></tr>
<tr><td><code>[ h1 ↦ e1, ..., h_n ↦ e_n]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ h1 : S1, ..., h_n : S_n]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ r EXCEPT !.h = e]</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#tuples" id="tuples">Tuples</a></h4>
<p><em>Use <a href="https://apalache.informal.systems/docs/tutorials/snowcat-tutorial.html">type
annotations</a>
to help the model checker in finding the right types.</em> Note that our type
system distinguishes records from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e[i]</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
<tr><td><code>&lt;&lt; e1, ..., e_n &gt;&gt;</code></td><td align="center">✔</td><td align="center">-</td><td>Use a <a href="https://apalache.informal.systems/docs/tutorials/snowcat-tutorial.html">type annotation</a> to distinguish between a tuple and a sequence.</td></tr>
<tr><td><code>S1 \X ... \X S_n</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ t EXCEPT ![i] = e]</code></td><td align="center">✔/✖</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
</tbody></table>
<h4><a class="header" href="#strings-and-numbers" id="strings-and-numbers">Strings and numbers</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&quot;c1...c_n&quot;</code></td><td align="center">✔</td><td align="center">-</td><td>A string is always mapped to a unique uninterpreted constant</td></tr>
<tr><td><code>STRING</code></td><td align="center">✖</td><td align="center">-</td><td>It is an infinite set. We cannot handle infinite sets.</td></tr>
<tr><td><code>d1...d_n</code></td><td align="center">✔</td><td align="center">-</td><td>As long as the SMT solver (Z3) accepts that large number</td></tr>
<tr><td><code>d1...d_n.d_n+1...d_m</code></td><td align="center">✖</td><td align="center">-</td><td>Technical issue. We will implement it upon a user request.</td></tr>
</tbody></table>
<h4><a class="header" href="#miscellaneous-constructs" id="miscellaneous-constructs">Miscellaneous Constructs</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IF p THEN e1 ELSE e2</code></td><td align="center">✔</td><td align="center">-</td><td>Provided that both e1 and e2 have the same type</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n [] OTHER -&gt; e</code></td><td align="center">✔</td><td align="center">-</td><td>Provided that <code>e1, ..., e_n, e</code> have the same type</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n</code></td><td align="center">✔</td><td align="center">-</td><td>Provided that <code>e1, ..., e_n</code> have the same type</td></tr>
<tr><td><code>LET d1 == e1 ... d_n == e_n IN e</code></td><td align="center">✔</td><td align="center"></td><td>All applications of <code>d1</code>, ..., <code>d_n</code> are replaced with the expressions <code>e1</code>, ... <code>e_n</code> respectively. LET-definitions without arguments are kept in place.</td></tr>
<tr><td>multi-line <code>/\</code> and <code>\/</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-action-operators" id="the-action-operators">The Action Operators</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e'</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>[A]_e</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>&lt; A &gt;_e</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>ENABLED A</code></td><td align="center">✖</td><td align="center">-</td><td>Has to be specified manually</td></tr>
<tr><td><code>UNCHANGED &lt;&lt;e_1, ..., e_k&gt;&gt;</code></td><td align="center">✔</td><td align="center">-</td><td>Always replaced with <code>e_1' = e_1 /\ ... /\ e_k' = e_k</code></td></tr>
<tr><td><code>A ∙ B</code></td><td align="center">✖</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-temporal-operators" id="the-temporal-operators">The Temporal Operators</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>[]F</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>&lt;&gt;F</code></td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>WF_e(A)</code></td><td align="center">✖</td><td align="center">-</td><td>Has to be specified manually (see ENABLED)</td></tr>
<tr><td><code>SF_e(A)</code></td><td align="center">✖</td><td align="center">-</td><td>Has to be specified manually (see ENABLED)</td></tr>
<tr><td><code>F ~&gt; G</code></td><td align="center">✔</td><td align="center">-</td><td>Always replaced with <code>[](F =&gt; &lt;&gt;G)</code></td></tr>
<tr><td><code>F -+-&gt; G</code></td><td align="center">✖</td><td align="center">-</td><td></td></tr>
<tr><td><code>\EE x: F</code></td><td align="center">✖</td><td align="center">-</td><td></td></tr>
<tr><td><code>\AA x: F</code></td><td align="center">✖</td><td align="center">-</td><td></td></tr>
</tbody></table>
<p>The model checker assumes that the specification has the form <code>Init /\ [][Next]_e</code>. Other than that, temporal operators 
may only appear in temporal properties, not in e.g. actions.</p>
<h2><a class="header" href="#standard-modules" id="standard-modules">Standard modules</a></h2>
<h3><a class="header" href="#integers-and-naturals" id="integers-and-naturals">Integers and Naturals</a></h3>
<p>For the moment, the model checker does not differentiate between integers and naturals. They are all translated as integers in SMT.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td align="center">✔</td><td align="center">-</td><td>These operators are translated into integer arithmetic of the SMT solver. Linear integer arithmetic is preferred.</td></tr>
<tr><td><code>\div</code>, <code>%</code></td><td align="center">✔</td><td align="center">-</td><td>Integer division and modulo</td></tr>
<tr><td><code>a^b</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Provided a and b are constant expressions</td></tr>
<tr><td><code>a..b</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Sometimes, <code>a..b</code> needs a constant upper bound on the range.  When Apalache complains, use <code>{x \in A..B : a &lt;= x /\ x &lt;= b}</code>, provided that <code>A</code> and <code>B</code> are constant expressions.</td></tr>
<tr><td><code>Int</code>, <code>Nat</code></td><td align="center">✔ / ✖</td><td align="center">-</td><td>Supported in <code>\E x \in Nat: p</code> and <code>\E x \in Int: p</code>, if the expression is not located under <code>\A</code> and <code>~</code>. We also support assignments like <code>f' \in [S -&gt; Int]</code> and tests <code>f \in [S -&gt; Nat]</code></td></tr>
<tr><td><code>/</code></td><td align="center">✖</td><td align="center">-</td><td>Real division, not supported</td></tr>
</tbody></table>
<h3><a class="header" href="#sequences" id="sequences">Sequences</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;...&gt;&gt;</code></td><td align="center">✔</td><td align="center"></td><td>Often needs a <a href="https://apalache.informal.systems/docs/tutorials/snowcat-tutorial.html">type annotation</a>.</td></tr>
<tr><td><code>Head</code>, <code>Tail</code>, <code>Len``, </code>SubSeq<code>, </code>Append<code>, </code>\o<code>, </code>f[e]`</td><td align="center">✔</td><td align="center">-</td><td></td></tr>
<tr><td><code>EXCEPT</code></td><td align="center">✔</td><td align="center"></td><td></td></tr>
<tr><td><code>SelectSeq</code></td><td align="center">✔</td><td align="center">-</td><td>Not as efficient, as it could be, see <a href="https://github.com/informalsystems/apalache/issues/1350">#1350</a>.</td></tr>
<tr><td><code>Seq(S)</code></td><td align="center">✖</td><td align="center">-</td><td>Use <code>Gen</code> of Apalache to produce bounded sequences</td></tr>
</tbody></table>
<h3><a class="header" href="#finitesets" id="finitesets">FiniteSets</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IsFinite</code></td><td align="center">✔</td><td align="center">-</td><td>Always returns true, as all the supported sets are finite</td></tr>
<tr><td><code>Cardinality</code></td><td align="center">✔</td><td align="center">-</td><td>Try to avoid it, as <code>Cardinality(S)</code> produces <code>O(n^2)</code> constraints in SMT for cardinality <code>n</code></td></tr>
</tbody></table>
<h3><a class="header" href="#tlc" id="tlc">TLC</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>a :&gt; b</code></td><td align="center">✔</td><td align="center">-</td><td>A singleton function <code>&lt;&lt;a, b&gt;&gt;</code></td></tr>
<tr><td><code>f @@ g</code></td><td align="center">✔</td><td align="center">-</td><td>Extends function <code>f</code> with the domain and values of function <code>g</code> but keeps the values of <code>f</code> where domains overlap</td></tr>
<tr><td>Other operators</td><td align="center"></td><td align="center"></td><td>Dummy definitions for spec compatibility</td></tr>
</tbody></table>
<h3><a class="header" href="#reals" id="reals">Reals</a></h3>
<p>Not supported, not a priority</p>
<p><a name="recursion"></a></p>
<h2><a class="header" href="#recursive-operators-and-functions" id="recursive-operators-and-functions">Recursive operators and functions</a></h2>
<p>While TLA+ allows the use of recursive operators and functions, we have decided to no longer support them in Apalache from version <code>0.23.1</code> onward, and suggest the use of fold operators, described in <a href="apalache/principles/./folds.html">Folding sets and sequences</a> instead: </p>
<pre><code class="language-tla"> * Similar to Skolem, this has to be done carefully. Apalache automatically
 * places this hint by static analysis.
 *)
ConstCardinality(__cardExpr) == __cardExpr

(**

    THEN __v
    ELSE LET __w == CHOOSE __x \in __S: TRUE IN
         LET __T == __S \ {__w} IN
         ApaFoldSet(__Op, __Op(__v,__w), __T)
</code></pre>
<p>These operators are treated by Apalache in a more efficient manner than
recursive operators. They always take at most <code>|S|</code> or <code>Len(seq)</code> steps to evaluate and require no additional annotations.</p>
<p>Note that the remainder of this section discusses only recursive operators, for brevity. Recursive functions share the same issues.</p>
<h3><a class="header" href="#the-problem-with-recursive-operators" id="the-problem-with-recursive-operators">The problem with recursive operators</a></h3>
<p>In the preprocessing phase, Apalache replaces every application of a user-defined operator with its body. We call this process &quot;operator inlining&quot;.
This obviously cannot be done for recursive operators, since the process would never terminate. Additionally, even if inlining wasn't problematic, we would still face the following issues when attempting to construct a symbolic encoding: </p>
<ol>
<li>
<p>A recursive operator may be non-terminating (although a non-terminating
operator is useless in TLA+);</p>
</li>
<li>
<p>A terminating call to an operator may take an unpredictable number of iterations.</p>
</li>
</ol>
<p>A note on (2): In practice, when one fixes specification parameters (that is,
<code>CONSTANTS</code>), it is sometimes possible to find a bound on the number of operator iterations. For instance, consider the following specification:</p>
<pre><code class="language-tla">--------- MODULE Rec6 -----------------
EXTENDS Integers

N == 5

VARIABLES
    \* @type: Set(Int);
    set,
    \* @type: Int;
    count

RECURSIVE Sum(_)

Sum(S) ==
  IF S = {}
  THEN 0
  ELSE LET x == CHOOSE y \in S: TRUE IN
    x + Sum(S \ {x})

UNROLL_DEFAULT_Sum == 0
UNROLL_TIMES_Sum == N

Init ==
  /\ set = {}
  /\ count = 0

Next ==
  \E x \in (1..N) \ set:
    /\ count' = count + x
    /\ set' = set \union {x}

Inv == count = Sum(set)
=======================================    

</code></pre>
<p>It is clear that the expression <code>Sum(S)</code> requires <code>Cardinality(S)</code> steps of recursive computation. Moreover, as the unspecified invariant <code>set \subseteq 1..N</code> always holds for this specification, every call <code>Sum(set)</code> requires up to <code>N</code> recursive steps.</p>
<h3><a class="header" href="#the-previously-supported-approach" id="the-previously-supported-approach">The previously supported approach</a></h3>
<p>Previously, when it was possible to find an upper bound on the number of iterations of an operator <code>Op</code>, such as <code>N</code> for <code>Sum</code> in the example above, Apalache would unroll the recursive operator up to this bound. 
Two additional operators, <code>UNROLL_DEFAULT_Op</code> and <code>UNROLL_TIMES_Op</code>, were required, for instance:</p>
<pre><code class="language-tla">UNROLL_DEFAULT_Sum == 0
UNROLL_TIMES_Sum == N
</code></pre>
<p>With the operators <code>UNROLL_DEFAULT_Op</code> and <code>UNROLL_TIMES_Op</code>, 
Apalache would internally replace the definition of <code>Op</code> with an operator <code>OpInternal</code>, that had the following property:</p>
<ol>
<li><code>OpInternal</code> was non-recursive</li>
<li>If computing <code>Op(x)</code> required a recursion stack of depth at most <code>UNROLL_TIMES_Op</code>, then <code>OpInternal(x) = Op(x)</code></li>
<li>Otherwise, <code>OpInternal(x)</code> would return the value, which would have been produced by the computation of <code>Op(x)</code>, if all applications of <code>Op</code> while the recursion stack height was <code>UNROLL_TIMES_Op</code> returned <code>UNROLL_DEFAULT_Op</code> instead of the value produced by another recursive call to <code>Op</code></li>
</ol>
<p>Unsurprisingly, (3) caused a lot of confusion, particularly w.r.t. the meaning of the value <code>UNROLL_DEFAULT_Op</code>. Consider the following example:</p>
<pre><code class="language-tla">RECURSIVE Max(_)
Max(S) == 
  IF S = {}
  THEN 0
  ELSE 
    LET x == CHOOSE v \in S: TRUE IN
    LET maxRest == Max(S \ {x}) 
    IN IF x &lt; maxRest THEN maxRest ELSE x

</code></pre>
<p>As computing <code>Max(S)</code> requires <code>|S|</code> recursive calls, there is no static upper bound to the recursion stack height that works for all set sizes. Therefore, if one wanted to use this operator in Apalache, one would have to guess (or externally compute) a value <code>N</code>, such that, <em>in the particular specification</em>, <code>Max</code> would never be called on an argument, the cardinality of which exceeded <code>N</code>, e.g.</p>
<pre><code class="language-tla">UNROLL_TIMES_Max = 2
</code></pre>
<p>In this case, Apalache would produce something equivalent to</p>
<pre><code class="language-tla">MaxInternal(S) ==
  IF S = {}
  THEN 0
  ELSE 
    LET x1 == CHOOSE v \in S: TRUE IN
    LET maxRest1 == 
      IF S \ {x1} = {}
      THEN 0
      ELSE 
        LET x2 == CHOOSE v \in S \ {x1}: TRUE IN
        LET maxRest2 == 
          IF S \ {x1, x2}  = {}
          THEN 0
          ELSE 
            LET x3 == CHOOSE v \in S \ {x1, x2}: TRUE IN
            LET maxRest3 == UNROLL_DEFAULT_Max 
            IN IF x3 &lt; maxRest3 THEN maxRest3 ELSE x3
        IN IF x2 &lt; maxRest2 THEN maxRest2 ELSE x2
    IN IF x1 &lt; maxRest1 THEN maxRest1 ELSE x1
</code></pre>
<p>In this case, <code>MaxInternal({1,42}) = 42 = Max({1,42})</code>, by property (2) as expected, but <code>MaxInternal(1..10)</code> can be any one of 
<code>3..10 \union {UNROLL_DEFAULT_Max}</code> (depending on the value of 
<code>UNROLL_DEFAULT_Max</code> and the order in which elements are selected by <code>CHOOSE</code>), by property (3).</p>
<p>So how does one select a sensible value for <code>UNROLL_DEFAULT_Op</code>? The problem is, one generally cannot. 
In the <code>Max</code> case, one could pick a &quot;very large&quot; <code>N</code> and then assume that <code>Max</code> computation has &quot;failed&quot; (exceeded the <code>UNROLL_TIMES_Max</code> recursion limit) if the result was ever equal to <code>N</code>, though &quot;very large&quot; is of course subjective and gives absolutely no guarantees that <code>Max</code> won't be called on a set containing some element <code>M &gt; N</code>.</p>
<p>As the recursion becomes more complex (e.g. non-primitive or non-tail), attempting to implement a sort of &quot;monitor&quot; via default values quickly becomes impractical, if not impossible.</p>
<p>Fundamentally though, it is very easy to accidentally either introduce spurious invariant violations, or hide actual invariant violations by doing this. For instance, in a specification with </p>
<pre><code class="language-tla">UNROLL_DEFAULT_Max = 42
UNROLL_TIMES_Max = 2

Inv == \A n \in 10..20: Max(1..n) = 42
</code></pre>
<p>Apalache could &quot;prove&quot; <code>Inv</code> holds, as it would rewrite this <code>Inv</code> to </p>
<pre><code>\A n \in 10..20: MaxInternal(1..n) = 99
</code></pre>
<p>and <code>MaxInternal(1..n)</code> evaluates to <code>99</code> for all <code>n \in 3..99</code> (and might still evaluate to <code>99</code> for <code>n &gt; 99</code>, based on the <code>CHOOSE</code> order), despite the fact that <code>Max(1..n) = n</code> in the mathematical sense.</p>
<p>Consider now the much simpler alternative:</p>
<pre><code class="language-tla">NonRecursiveMax(S) == 
  LET Max2(a,b) == IF a &lt; b THEN b ELSE a IN
  ApaFoldSet(Max2, 0, S) 
</code></pre>
<p>In this case, the user doesn't have to think about defaults (aside from the empty-set case), or recursion, as <code>ApaFoldSet</code> ensures <code>|S|</code>-step &quot;iteration&quot;. As an additional benefit, one also doesn't need to use <code>CHOOSE</code> to select elements this way.</p>
<p>So ultimately, the reasons for abandoning support for recursive operators boils down to the following:</p>
<ul>
<li><strong>In the vast majority of cases, equivalent functionality can be achieved by using <code>ApaFoldSet</code> or <code>ApaFoldSeqLeft</code></strong></li>
<li><code>UNROLL_TIMES_Op</code> is hard to determine, or doesn't exist statically,</li>
<li><code>UNROLL_DEFAULT_Op</code> is hard to determine,</li>
<li>Apalache doesn't have runtime evaluation of recursion, so it can't natively determine when a call to a recursive <code>Op</code> would have required more than <code>UNROLL_TIMES_Op</code> steps</li>
<li>The use of recursive operators produces unpredictable results, particularly when used in invariants</li>
</ul>
<h1><a class="header" href="#known-issues-1" id="known-issues-1">Known issues</a></h1>
<p>This page collects known issues that were reported by the users.</p>
<h2><a class="header" href="#deadlock-detection" id="deadlock-detection">Deadlock detection</a></h2>
<p>Deadlock detection is imprecise. It may report false negatives, see <a href="https://github.com/informalsystems/apalache/issues/711">Issue
711</a>.</p>
<p><strong>Affected versions:</strong> &lt;= 0.15.x</p>
<p><strong>Planned fix:</strong> <a href="https://github.com/informalsystems/apalache/issues/712">Issue 712</a></p>
<h2><a class="header" href="#updating-records-with-excess-fields" id="updating-records-with-excess-fields">Updating records with excess fields</a></h2>
<p>Given a record with a type declaration specifying <code>n</code> fields, if that record is
given more than <code>n</code> fields and the specification includes an <code>EXCEPT</code> expression
that updates the record, Apalache may be unable to check the specification.</p>
<p>In the following example, the variable <code>m</code> is given the type of a record with
<code>1</code> field (namely <code>a</code>), but it is then assigned to a record with <code>2</code> fields
(namely <code>a</code> and <code>foo</code>).</p>
<pre><code class="language-tla">VARIABLE
  \* @type: [a: Int];
  m

Init == m = [a |-&gt; 0, foo |-&gt; TRUE]

Next ==
   \/ m' = m
   \/ m' = [m EXCEPT !.a = 0]
</code></pre>
<p>Given the current (unsound) typing discipline Apalache uses for records, this
specification is not considered incorrectly typed. However, due to the update
using <code>EXCEPT</code> in the <code>Next</code> operator, the specification cannot be checked.</p>
<p><strong>Affected versions:</strong> &lt;= 0.15.x</p>
<p><strong>Planned fix:</strong> <a href="https://github.com/informalsystems/apalache/issues/401">Issue 401</a></p>
<h3><a class="header" href="#workaround" id="workaround">Workaround</a></h3>
<p>Add the <code>foo</code> field to the variable's type signature:</p>
<pre><code class="language-tla">VARIABLE
  \* @type: [a: Int, foo: Bool];
  m

Init == m = [a |-&gt; 0, foo |-&gt; TRUE]

Next ==
   \/ m' = m
   \/ m' = [m EXCEPT !.a = 0]
</code></pre>
<h2><a class="header" href="#integer-ranges-with-non-constant-bounds" id="integer-ranges-with-non-constant-bounds">Integer ranges with non-constant bounds</a></h2>
<p>When using an integer range <code>a..b</code>, where <code>a</code> or <code>b</code> aren't constant (or cannot be simplified to a constant), the current encoding fails (see <a href="https://github.com/informalsystems/apalache/issues/425">Issue 425</a>):</p>
<pre><code class="language-tla">---------- MODULE Example ----------

EXTENDS Integers

VARIABLE 
  \* @type: Int;
  x

\* @type: (Int) =&gt; Set(Int);
1to(n) == 1..n

Init == x = 1

Next == x' = x + 1

Inv == 1 \in { m: a \in 1to(x) }
====================
</code></pre>
<p><strong>Affected versions:</strong> All</p>
<p><strong>Planned fix:</strong> Not in the near future</p>
<h3><a class="header" href="#workaround-1" id="workaround-1">Workaround</a></h3>
<p>Pick constant bounds <code>Nmin</code> and <code>Nmax</code>, such that <code>Nmin &lt;= a &lt;= b &lt;= Nmax</code>, then use</p>
<pre><code class="language-tla">range(a,b) == { x \in Nmin..Nmax: a &lt;= x /\ x &lt;= b }
</code></pre>
<p>instead of <code>a..b</code>.</p>
<h2><a class="header" href="#using-seqs" id="using-seqs">Using Seq(S)</a></h2>
<p>The operator <code>Seq(S)</code> produces an infinite set of unbounded sequences. Hence, Apalache is not able to do anything about
this set. Consider the following snippet:</p>
<pre><code class="language-tla">  \E s \in Seq({ 1, 2, 3 }):
     seq' = s
</code></pre>
<p><strong>Affected versions:</strong> All</p>
<p><strong>Planned fix:</strong> Not in the near future</p>
<h3><a class="header" href="#workaround-2" id="workaround-2">Workaround</a></h3>
<p>If you know an upper bound on the length of sequences you need, which is often the case when checking one model, you can
work around this issue by using
<a href="https://github.com/informalsystems/apalache/blob/0bf827c521d3992f39e085cc98ff114bfa0b1721/src/tla/Apalache.tla#L31-L39">Apalache.Gen</a>:</p>
<pre><code class="language-tla">EXTENDS Apalache
...
  LET s == Gen(10) IN
  /\ \A i \in DOMAIN s:
      s[i] \in { 1, 2, 3 }
  /\ seq' = s
</code></pre>
<p>In the above example, we instruct Apalache to introduce an unrestricted sequence that contains up to 10 elements; this
is done with <code>Gen</code>. We further restrict the sequence to contain the elements of <code>{ 1, 2, 3 }</code>.</p>
<p>However, note that our workaround only works for bounded sequences, whereas
<code>Seq({ 1, 2, 3 })</code> is the set of all sequences whose elements come from <code>{ 1, 2, 3 }</code>.</p>
<h1><a class="header" href="#antipatterns" id="antipatterns">Antipatterns</a></h1>
<p>This page collects known antipaterns (APs) when writing TLA+ for Apalache. In this context, APs are syntactic forms or specification approaches that, for one reason or another, have particularly slow/complex encodings for the target model checker. For a pattern to be an AP, there must exist a known, equivalent, efficient pattern. </p>
<p>Often, APs arise from a user's past experiences with writing TLA+ for TLC, or from a direct translation of imperative OOP code into TLA+, as those follow a different paradigm, and therefore entail different cost evaluation of which expressions are slow/complex and which are not.</p>
<h2><a class="header" href="#choose-based-recursion" id="choose-based-recursion"><code>CHOOSE</code>-based recursion</a></h2>
<p>Often, operators that represent operations over sets have the following shape:</p>
<pre><code class="language-tla">RECURSIVE F(_)
F(S) == 
  IF S == {}
  THEN v
  ELSE 
    LET e == CHOOSE x \in S: TRUE
    IN G(F( S \ {e} ), e )
</code></pre>
<p>For example, one can implement <code>min/max</code> operators this way:</p>
<pre><code class="language-tla">RECURSIVE min(_)
min(S) == 
  IF S == {}
  THEN Infinity
  ELSE 
    LET e == CHOOSE x \in S: TRUE
    IN LET minOther == min( S \ {e} )
    IN IF e &lt; minOther THEN e ELSE minOther 
</code></pre>
<p>Apalache dislikes the use of the above, for several reasons. Firstly, since the operator is <code>RECURSIVE</code>, Apalache does not support it after version 0.23.1. In earlier versions Apalache requires a predefined upper bound on unrolling, which means that the user must know, ahead of time, what the largest <code>|S|</code> is, for any set <code>S</code>, to which this operator is ever applied. 
In addition, computing <code>F</code> for a set <code>S</code> of size <code>n = |S|</code> requires <code>n</code> encodings of a <code>CHOOSE</code> operation, which can be considerably expensive in Apalache.
Lastly, Apalache also needs to encode all of the the <code>n</code> intermediate sets, <code>S \ {e1}</code>, <code>(S \ {e1}) \ {e2}</code>, <code>((S \ {e1}) \ {e2}) \ {e3}</code>, and so on.</p>
<p>The AP above can be replaced by a very simple pattern:</p>
<pre><code class="language-tla">F(S) == ApaFoldSet( G, v, S )
</code></pre>
<p><code>ApaFoldSet</code> (and <code>ApaFoldSeqLeft</code>) were introduced precisely for these scenarios, and should be used over <code>RECURSIVE + CHOOSE</code> in most cases.</p>
<h2><a class="header" href="#incremental-computation" id="incremental-computation">Incremental computation</a></h2>
<p>Often, users introduce an expression <code>Y</code>, which is derived from another expression <code>X</code> (<code>Y == F(X)</code>, for some <code>F</code>). Instead of defining <code>Y</code> directly, in terms of the properties it possesses,  it is possible to define all the intermediate steps of transforming <code>X</code> into <code>Y</code>: &quot;<code>X</code> is slightly changed into <code>X1</code> (e.g. by adding one element to a set, or via <code>EXCEPT</code>), which is changed into <code>X2</code>, etc. until <code>Xn = Y</code>&quot;. Doing this in Apalache is almost always a bad idea, if a direct characterization of <code>Y</code> exists.</p>
<p>Concretely, the following constructs are APs:</p>
<ol>
<li>Incremental <code>EXCEPT</code></li>
</ol>
<pre><code class="language-tla">G ==
  LET F(g, x) == [g EXCEPT ![x] = A(x)]
  IN ApaFoldSet(F, f, S)
</code></pre>
<ol start="2">
<li>Incremental <code>\union</code></li>
</ol>
<pre><code class="language-tla">R ==
  LET F(T, e) == T \union {A(e)}
  IN ApaFoldSet(F, S0, S)
</code></pre>
<ol start="3">
<li>Chained <code>@@/:&gt;</code></li>
</ol>
<pre><code class="language-tla">f == ( k1 :&gt; A(k1) ) @@ ( k2 :&gt; A(k2) ) @@ ... @@ ( kn :&gt; A(kn) ) 
</code></pre>
<p>For example:</p>
<pre><code class="language-tla">f == [ x \in 1..20 |-&gt; 0 ]
Y == 
  LET F(g, x) == [g EXCEPT ![x] = x * x]
  IN ApaFoldSet(F, f, 7..12 )
</code></pre>
<p>TLC likes these sorts of operations, because it manipulates programming-language objects in its own implementation.
This makes it easy to construct temporary mutable objects, manipulate them (e.g. via for-loops) and garbage-collect them after they stop being useful.
For constraint-based approaches, like Apalache, the story is different. Not only are these intermediate steps not directly useful (since Apalache is not modeling TLA+ expressions as objects in Sacala), they actually hurt performance, since they can generate a significant amount of constraints, which are all about describing data structures (e.g. two functions being almost equal, except at one point).
Essentially, Apalache is spending its resources not on state-space exploration, but on in-state value computation, which is not its strong suit.
Below we show how to rewrite these APs.</p>
<ol>
<li>Incremental <code>EXCEPT</code>: Replace</li>
</ol>
<pre><code class="language-tla">G ==
  LET F(g, x) == [g EXCEPT ![x] = A(x)]
  IN ApaFoldSet(F, f, S)
</code></pre>
<p>with</p>
<pre><code class="language-tla">G == 
[ x \in DOMAIN f |-&gt;
  IF x \in S
  THEN A(x)
  ELSE f[x]
]
</code></pre>
<ol start="2">
<li>Incremental <code>\union</code>: Replace</li>
</ol>
<pre><code class="language-tla">R ==
  LET F(T, e) == T \union {A(e)}
  IN ApaFoldSet(F, S0, S)
</code></pre>
<p>with</p>
<pre><code class="language-tla">R == S0 \union { A(e): e \in S }
</code></pre>
<ol start="3">
<li>Iterated <code>@@/:&gt;</code>: Replace</li>
</ol>
<pre><code class="language-tla">f == ( k1 :&gt; A(k1) ) @@ ( k2 :&gt; A(k2) ) @@ ... @@ ( kn :&gt; A(kn) ) 
</code></pre>
<p>with</p>
<pre><code class="language-tla">f == [ k \in {k1,...,kn} |-&gt; A(k) ]
</code></pre>
<h1><a class="header" href="#preprocessing-in-apalache" id="preprocessing-in-apalache">Preprocessing in APALACHE</a></h1>
<p>Before translating a specification into SMT, <code>apalache</code> performs a number of
preprocessing steps:</p>
<ul>
<li><code>Inliner</code>: 
<ul>
<li>replaces every call to a user-defined operator with the operator's body</li>
<li>replaces every call to a let-in defined operator of arity at least 1 with the operator's body</li>
</ul>
</li>
<li><code>PrimingPass</code>: adds primes to variables in <code>Init</code> and <code>ConstInit</code> (required by <code>TransitionPass</code>)</li>
<li><code>VCGen</code>: extracts verification conditions from the invariant candidate.</li>
<li><code>Desugarer</code>: removes syntactic sugar like short-hand expressions in <code>EXCEPT</code>.</li>
<li><code>Normalizer</code>: rewrites all expressions in <a href="https://en.wikipedia.org/wiki/Negation_normal_form">negation-normal form</a>.</li>
<li><code>Keramelizer</code>: translates TLA+ expressions into the kernel language <a href="apalache/./kera.html">KerA</a>.</li>
<li><code>ExprOptimizer</code>: statically computes select expressions (e.g. record field access from a known record)</li>
<li><code>ConstSimplifier</code>: propagates constants</li>
</ul>
<h2><a class="header" href="#keramelizer" id="keramelizer">Keramelizer</a></h2>
<p>Keramelizer rewrites TLA+ expressions into <a href="apalache/./kera.html">KerA</a>. For many TLA+ expressions
this translation is clear, however, some expressions cannot be easily translated. Below
we discuss such expressions and the decisions that we have made.</p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li>Leslie Lamport. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers.
Addison-Wesley Professional, 2004. <a name="spec2004"></a></li>
</ul>
<h1><a class="header" href="#parameters-for-fine-tuning" id="parameters-for-fine-tuning">Parameters for fine tuning</a></h1>
<p>The parameters for fine tuning can be passed to the checker in a properties
file.  Its name is given with the command-line option <code>--tuning-options-file=my.properties</code>.
This file supports variable substitution, e.g., <code>${x}</code> is replaced with the
value of <code>x</code>, if it was previously declared.</p>
<p>Alternatively, you can pass the tuning options right in the command-line by
passing the option <code>--tuning-options</code> that has the following format:</p>
<pre><code>```
--tuning-options=key1=val1
--tuning-options=key1=val1:key2=val2
...
```
</code></pre>
<p>The following options are supported:</p>
<h2><a class="header" href="#randomization" id="randomization">Randomization</a></h2>
<p><code>smt.randomSeed=&lt;int&gt;</code> passes the random seed to <code>z3</code> (via <code>z3</code>'s parameters
<code>sat.random_seed</code> and <code>smt.random_seed</code>).</p>
<h2><a class="header" href="#timeouts" id="timeouts">Timeouts</a></h2>
<p><code>search.smt.timeout=&lt;seconds&gt;</code> defines the timeout to the SMT solver in seconds.
The default value is <code>0</code>, which stands for the unbounded timeout.  For instance,
the timeout is used in the following cases: checking if a transition is enabled,
checking an invariant, checking for deadlocks. If the solver times out, it
reports 'UNKNOWN', and the model checker reports a runtime error.</p>
<h2><a class="header" href="#invariant-mode" id="invariant-mode">Invariant mode</a></h2>
<p><code>search.invariant.mode=(before|after)</code> defines the moment when the invariant is
checked. In the <code>after</code> mode, all transitions are first translated, one of them
is picked non-deterministically and then the invariant is checked. Although this
mode reduces the number of SMT queries, it usually requires more memory than the
<code>before</code> mode. In the <code>before</code> mode, the invariant is checked for every enabled
transition independently. The <code>before</code> mode may drastically reduce memory
consumption, but it may take longer than the <code>after</code> mode, provided that
Apalache has enough memory. The default mode is <code>before</code>.</p>
<h2><a class="header" href="#guided-search" id="guided-search">Guided search</a></h2>
<h3><a class="header" href="#preliminaries" id="preliminaries">Preliminaries</a></h3>
<p>In the following, step 0 corresponds to the initialization with <code>Init</code>, step 1 is the first step with <code>Next</code>, etc.</p>
<h3><a class="header" href="#transition-filter" id="transition-filter">Transition filter</a></h3>
<p><code>search.transitionFilter=&lt;regex&gt;</code>. Restrict the choice of symbolic transitions
at every step with a regular expression. The regular expression should recognize
words of the form <code>s-&gt;t</code>, where <code>s</code> is a step number and <code>t</code> is a transition
number.</p>
<p>For instance,
<code>search.transitionFilter=(0-&gt;0|1-&gt;5|2-&gt;(2|3)|[3-9]-&gt;.*|[1-9][0-9]+-&gt;.*)</code>
requires to start with the 0th transition, continue with the 5th transition,
then execute either the 2nd or the 3rd transition and after that execute
arbitrary transitions until the <code>length.</code></p>
<p>Note that there is no direct correspondence between the transition numbers and
the actions in the TLA+ spec. To find the numbers, run Apalache with
<code>--write-intermediate=true</code> and check the transition numbers in
<code>_apalache-out/&lt;MySpec&gt;.tla/*/intermediate/XX_OutTransitionFinderPass.tla</code>: the
0th transition is called <code>Next_si_0000</code>, the 1st transition is called
<code>Next_si_0001</code>, etc.</p>
<h3><a class="header" href="#invariant-filter" id="invariant-filter">Invariant filter</a></h3>
<p><code>search.invariantFilter=&lt;regex&gt;</code>. Check the invariant only at the steps that
satisfy the regular expression. The regular expression should recognize words of
the form <code>s-&gt;ki</code>, where <code>s</code> is a step number, <code>k</code> is an invariant kind (<a href="apalache/../apalache/principles/invariants.html">&quot;state&quot;
or &quot;action&quot;</a>), and <code>i</code> is an invariant number.</p>
<p>For instance, <code>search.invariantFilter=10-&gt;.*|15-&gt;state0|20-&gt;action1</code> tells the
model checker to check</p>
<ul>
<li>all invariants only <em>after</em> exactly 10 steps have been made,</li>
<li>the <em>first</em> state invariant only after exactly 15 steps, and</li>
<li>the <em>second</em> action invariant after exactly 20 steps.</li>
</ul>
<p><a href="apalache/../apalache/principles/invariants.html#trace-invariants">Trace invariants</a> are checked regardless of this filter.</p>
<p>Note that there is no direct correspondence between invariant numbers and the
operators in a TLA+ spec. Rather, the numbers refer to <em>verification conditions</em>
(i.e., broken up parts of a TLA+ invariant operator). To find these numbers, run
Apalache with <code>--write-intermediate=true</code> and check the invariant numbers in
<code>_apalache-out/&lt;MySpec&gt;.tla/*/intermediate/XX_OutVCGen.tla</code>. The 0th state
invariant is called <code>VCInv_si_0</code>, the 1st state invariant is called
<code>VCInv_si_1</code>, and so on. For action invariants, the declarations are named
<code>VCActionInv_si_0</code>, <code>VCActionInv_si_1</code> etc.</p>
<p>This option is useful, e.g., for checking consensus algorithms,
where the decision cannot be revoked. So instead of checking the invariant
after each step, we can do that after the algorithm has made a good number of
steps.
You can also use this option to check different parts of an invariant on
different machines to speed up turnaround time.</p>
<h2><a class="header" href="#translation-to-smt" id="translation-to-smt">Translation to SMT</a></h2>
<h3><a class="header" href="#short-circuiting" id="short-circuiting">Short circuiting</a></h3>
<p><code>rewriter.shortCircuit=(false|true)</code>. When <code>rewriter.shortCircuit=true</code>, <code>A \/ B</code> and <code>A /\ B</code> are translated to SMT as if-then-else expressions, e.g., <code>(ite A true B)</code>. Otherwise, disjunctions and conjunctions are directly translated to
<code>(or ...)</code> and <code>(and ...)</code> respectively. By default,
<code>rewriter.shortCircuit=false</code>.</p>
<h1><a class="header" href="#assignments-in-apalache" id="assignments-in-apalache">Assignments in Apalache</a></h1>
<p>Any run of Apalache requires an operator name as the value for the parameter
<code>--next</code> (by default, this value is <code>&quot;Next&quot;</code>). We refer to this operator as the
<em>transition operator</em> (or <em>transition predicate</em>).</p>
<h2><a class="header" href="#actions-slices-and-minimal-actions" id="actions-slices-and-minimal-actions">Actions, Slices and Minimal Actions</a></h2>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>In TLA+, an <em>action</em> is any Boolean-valued expression or operator, that
contains primed variables (e.g. <code>Next</code>). For the sake of this definition,
assume <code>UNCHANGED x</code> is just syntactic sugar for <code>x' = x</code>.  Intuitively,
actions are used to define the values of state variables after a transition,
for example:</p>
<pre><code class="language-tla">VARIABLE x
...

Next == x' = x + 1
</code></pre>
<p>The state transition described by <code>Next</code> is fairly obvious; if <code>x</code> has the
value of <code>4</code> in the current state, it will have the value of <code>5</code> in any
successor state.  This brings us to the first natural requirement by Apalache:
<em>the transition operator must be an action.</em></p>
<h3><a class="header" href="#successor-state-encodings" id="successor-state-encodings">Successor State Encodings</a></h3>
<p>Unfortunately, the notion of an action is too broad to be a sufficient
requirement for the transition operator.  Consider this slight modification of
the above example:</p>
<pre><code class="language-tla">VARIABLE x, y (* new variable *)
...

Next == x' = x + 1
</code></pre>
<p>Just as in the first example, the expression <code>x' = x + 1</code> is, by definition, an
action.  However, since the second example defines a state variable <code>y</code>, this
action is no longer a sufficient description of a relation between a current
state and a successor state; it does not determine a successor value <code>y'</code>.
This brings us to the second requirement: <em>the transition operator must allow
Apalache to directly encode the relation between two successive states.</em> This
captures two sub-requirements: firstly, we disallow transition operators which
fail to specify the value of one or more variables in the successor states,
like the one in the example above. Secondly, we also disallow transition
operators where the value of a successor state variable is determined only by
implicit equations. Consider the following two cases:</p>
<pre><code class="language-tla">VARIABLE y
...

A == y' = 1
B == y' * y' - 2 * y' + 1 = 0
</code></pre>
<p>Using some basic math, we see that action <code>B</code> can be equivalently written as
<code>(y' - 1)*(y' - 1) = 0</code>, so it describes the exact same successor state, in
which the new value of <code>y</code> is <code>1</code>.  What makes it different from action <code>A</code> is
the fact that this is far from immediately obvious from the syntax.  The fact
that there happened to be a closed-form solution for which gave us an integer
value for <code>y'</code>, is a lucky coincidence, as <code>B</code> could have been, for example,
<code>y' * y' + 1 = 0</code>, with no real roots.  To avoid cases like this, we require
that transition operators explicitly declare the values of state variables in
successor states.</p>
<p>We call syntactic forms, which explicitly represent successor state values,
<em>assignment candidates</em>. An assignment candidate for <code>x</code> is a TLA+ expression
that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Apalache.tla">Apalache.tla</a>)</li>
</ul>
<p>So to reformulate the second requirement: the transition operator must contain
at least one assignment candidate for each variable declared in the
specification.</p>
<h3><a class="header" href="#control-flow-minimal-and-compound-actions" id="control-flow-minimal-and-compound-actions">Control Flow: Minimal and Compound Actions</a></h3>
<p>When writing non-trivial specifications, authors often end up with something
similar to the following:</p>
<pre><code class="language-tla">EventA == ...
EventB == ...
...

Next == \/ EventA
        \/ EventB
</code></pre>
<p>Specifically, <code>EventA</code> and <code>EventB</code> often represent mutually exclusive
possibilities of execution.  Just like before, the basic definition of an
action is not sufficient to explain the relation of <code>EventA</code> or <code>EventB</code> and
<code>Next</code>; if <code>EventA</code> is an action and <code>EventB</code> is an action, then <code>Next</code> is also
an action.  To more accurately describe this scenario, we observe that the
operator or ( <code>\/</code>) sometimes serves as a kind of parallel composition operator
(<code>||</code>) in process algebra - it connects two (or more) actions into a larger
one.</p>
<p>There are only two operators in TLA+ that could be considered control-flow
operators in this way, the or (<code>\/</code>) operator and the if-then-else operator.
We distinguish their uses as action- and as value operators:</p>
<pre><code class="language-tla">
A == x = 1 \/ x = 2 (* arguments are not actions *)
B == x' = 1 \/ x' = 2 (* arguments are actions *)
</code></pre>
<p>Simply put, if all arguments to an operator <code>\/</code> are actions, then that
operator is an action-or, otherwise it is a value-or. Similarly, if both the
<code>THEN _</code> and <code>ELSE _</code> subexpressions of if-then-else are actions, it is an
action-ITE, otherwise it is a value-ITE (in particular, a value-ITE can be
non-Boolean).</p>
<p>Using these two operators we can define the following terms: A <em>minimal action</em>
is an action which contains no action-or and no action-ITE.  Conversely, a
<em>compound action</em> is an action which contains at least one action-or or at
least one action-ITE.</p>
<h3><a class="header" href="#slices" id="slices">Slices</a></h3>
<p>Given a transition operator, which is most commonly a compound action, we can
decompose it into as many minimal actions as possible. We call this process
<em>slicing</em> and the resulting minimal actions <em>slices</em>.  This allows us to write
transition operators in the following equivalent way:</p>
<pre><code class="language-tla">Next == \/ Slice1
        \/ Slice2
        ...
        \/ SliceN
</code></pre>
<p>Where each <code>Slice[i]</code> is a minimal action.</p>
<p>The details of slicing are nuanced and depend on operators other than or (<code>\/</code>)
and if-then-else, but we give two examples here:</p>
<p>If a formula <code>A</code> has the shape <code>A1 \/ ... \/ An</code> (where <code>A1</code>, ... <code>An</code> are
actions), then a slice of A has the shape <code>Si</code>, where <code>Si</code> is a slice of some
<code>Ai</code>.</p>
<p>If a formula <code>A</code> has the shape <code>IF p THEN A1 ELSE A2</code> (where <code>A1</code>, <code>A2</code> are
actions), then a slice of A has the shape <code>p /\ S1</code> or <code>\neg p /\ S2</code>, where
<code>S1</code> is a slice of <code>A1</code> and <code>S2</code> is a slice of <code>S2</code>.</p>
<p>Slices allow us to formulate the final requirement: the transition operator
must be such, that we can select one assignment candidate for each variable in
each of its slices (minimal actions) as an <em>assignment</em>. The process and
conditions of selecting assignments from assignment candidates is described in
the next section.</p>
<h2><a class="header" href="#a-idasgn--assignments-and-assignment-candidates" id="a-idasgn--assignments-and-assignment-candidates"><a id='asgn' /> Assignments and Assignment Candidates</a></h2>
<p>Recall, an <em>assignment candidate</em> for <code>x</code> is a TLA+ expression that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <code>Apalache.tla</code>)</li>
</ul>
<p>While a transition operator may contain multiple assignment candidates for the
same variable, not all of them are chosen as <em>assignments</em> by Apalache. The
subsections below describe how the assignments are selected.</p>
<h3><a class="header" href="#minimality" id="minimality">Minimality</a></h3>
<p>Assignments aren't spurious; each variable must have at least one assignment
per transition operator, but no more than necessary to satisfy all of the
additional constraints below (i.e. no more than one assignment per slice).</p>
<p>If all possible slices fail to assign one or more variables, an error, like the
one below, is reported:</p>
<pre><code>Assignment error: No assignments found for: x, z
</code></pre>
<p>Such errors are usually the result of adding a <code>VARIABLE</code> without any
accompanying TLA+ code relating to it.  The case where at least one transition,
but not all of them, fails to assign a variable is shown below.</p>
<h3><a class="header" href="#syntax-order" id="syntax-order">Syntax Order</a></h3>
<p>For the purpose of evaluating assignments, Apalache considers the left-to-right
syntax order of and-operator (<code>/\</code>) arguments.  Therefore, as many assignments
as possible are selected from the first (w.r.t. syntax order) argument of and
(<code>/\</code>), then from the second, and so on.</p>
<p>Example:</p>
<pre><code class="language-tla">Next == x' = 1 /\ x' = 2
</code></pre>
<p>In the above example, <code>x' = 1</code> would be chosen as an assignment to <code>x</code>, over
<code>x' = 2</code>.</p>
<h3><a class="header" href="#assignment-before-use-convention" id="assignment-before-use-convention">Assignment-before-use Convention</a></h3>
<p>If, in the syntax order defined above, an expression containing a primed
variable <code>x'</code> syntactically precedes an assignment to <code>x</code>, the assignment
finder throws an exception of the following shape:</p>
<pre><code>Assignment error: test.tla:10:16-10:17: x' is used before it is assigned.
</code></pre>
<p>notifying the user of any variables used before assignment. In particular,
right-hand-sides of assignment candidates ( e.g. <code>x' + 2</code> in <code>y' = x' + 2</code> )are
subject to this restriction as well. Consider:</p>
<pre><code class="language-tla">A == x' &gt; 0 /\ x' = 1
B == y' = x' + 2 /\ x' = 1
</code></pre>
<p>In <code>A</code>, the expression <code>x' &gt; 0</code> precedes any assignment to <code>x</code> and in <code>B</code>,
while <code>y' = x' + 2</code> is an assignment candidate for <code>y</code>, it precedes any
assignment to <code>x</code>, so both expressions are inadmissible (and would trigger
exceptions).</p>
<p>Note that this only holds true if <code>A</code> (resp. <code>B</code>) is chosen as the transition
operator. If <code>A</code> is called inside another transition operator, for example in
<code>Next == x' = 1 /\ A</code>, no error is reported.</p>
<h3><a class="header" href="#balance" id="balance">Balance</a></h3>
<p>In cases of the or-operator (<code>\/</code>), all arguments must have assignments for the
same set of variables. In particular, if one argument contains an assignment
candidate and another does not, such as in this example:</p>
<pre><code>\/ y = 1
\/ y' = 2
</code></pre>
<p>the assignment finder will report an error, like the one below:</p>
<pre><code>Assignment error: test.tla:10:15-10:19: Missing assignments to: y
</code></pre>
<p>notifying the user of any variables for which assignments exist in some, but
not all, arguments to <code>\/</code>.  Note that if we correct and extend the above
example to</p>
<pre><code class="language-tla">/\ \/ y' = 1
   \/ y' = 2
/\ y' = 3
</code></pre>
<p>the assignments to <code>y</code> would be <code>y' = 1</code> and <code>y' = 2</code>, but not <code>y' = 3</code>;
minimality prevents us from selecting all three, the syntax order constraint
forces us to select assignments in <code>y' = 1 \/ y' = 2</code> before <code>y' = 3</code> and
balance requires that we select both <code>y' = 1</code> and <code>y' = 2</code>.  On the other hand,
if we change the example to</p>
<pre><code class="language-tla">/\ y' = 3
/\ \/ y = 1
   \/ y' = 2
</code></pre>
<p>the only assignment has to be <code>y' = 3</code>. While one of the disjuncts is an
assignment candidate and the other is not, the balance requirement is not
violated here, since neither disjunct is chosen as an assignment.</p>
<p>Similar rules apply to if-then-else: both the <code>THEN _</code> and <code>ELSE _</code> branch must
assign the same variables, however, the <code>IF _</code> condition is ignored when
determining assignments.</p>
<h3><a class="header" href="#assignment-free-expressions" id="assignment-free-expressions">Assignment-free Expressions</a></h3>
<p>Not all expressions may contain assignments.  While Apalache permits the use of
all assignment candidates, except ones defined with <code>:=</code>(details
<a href="apalache/assignments-in-depth.html#manual">here</a>), inside other expressions, some of these candidates will never
be chosen as assignments, based on the syntactic restrictions outlined below:</p>
<p>Given a transition operator <code>A</code>, based on the shape of <code>A</code>, the following holds:</p>
<ul>
<li>If <code>A</code> has the shape <code>A_1 /\ ... /\ A_n</code>, then assignments are selected from <code>A_1, ... , A_n</code> sequentially, subject to the syntax-order rule.</li>
<li>If <code>A</code> has the shape <code>A_1 \/ ... \/ A_n</code>, then assignments are selected in all <code>A_1, ... , A_n</code> independently, subject to the balance rule.</li>
<li>If <code>A</code> has the shape <code>IF p THEN A_1 ELSE A_2</code>, then:
<ul>
<li><code>p</code> may not contain assignments. Any assignment candidates in <code>p</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in both <code>A_1</code> and <code>A_n</code> independently, subject to the balance rule.</li>
</ul>
</li>
<li>If <code>A</code> has the shape <code>\E x \in S: A_1</code>, then:
<ul>
<li><code>S</code> may not contain assignments. Any assignment candidates in <code>S</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in <code>A_1</code></li>
</ul>
</li>
<li>In any other case, <code>A</code> may not contain assignments, however, any assignment candidates in <code>A</code> are subject to the assignment-before-use rule.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-tla">A == /\ x' = 2
     /\ \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Operator <code>A</code> contains assignments to both <code>x</code> and <code>y</code>; while <code>x' &gt; t</code> uses
<code>x'</code>, it does not violate the assignment-before-use rule, since the assignment
to <code>x</code> precedes the expression, w.r.t. syntax order.</p>
<pre><code class="language-tla">(* INVALID *)
B == \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>In operator <code>B</code>, the assignment to <code>x</code> is missing, therefore <code>x' &gt; t</code> produces
an error, as it violates assignment-before-use.</p>
<pre><code class="language-tla">C == /\ x' = 1
     /\ IF x' = 0 /\ 2 \in {x', x' + 2, 0}
        THEN y' = 1
        ELSE y' = 2
</code></pre>
<p>The case in <code>C</code> is similar to <code>A</code>; conditions of the if-then-else operator may
not contain assignments to <code>x</code>, so <code>x' = 0</code> can never be one, but they may use
<code>x'</code>, since a preceding expression (<code>x' = 1</code>) qualifies as an assignment.</p>
<pre><code class="language-tla">(* INVALID *)
D == IF x' = 0
     THEN y' = 1
     ELSE y' = 2
</code></pre>
<p>The operator <code>D</code> produces an error, for the same reason as <code>B</code>; even though <code>x' = 0</code> is an assignment candidate, if-conditions are assignment-free, so <code>x' = 0</code>
cannot be chosen as an assignment to <code>x</code>.</p>
<pre><code class="language-tla">(* INVALID *)
E == /\ x' = 2
     /\ \A s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Lastly, while <code>E</code> looks almost identical to <code>A</code>, the key difference is that
expressions under universal quantifiers may not contain assignments. Therefore,
<code>y' = s</code> is <em>not</em> an assignment to <code>y</code> and thus violates assignment-before-use.</p>
<a name='manual' /> 
## Manual Assignments
<p>Users may choose, but aren't required, to use manual assignments <code>x' := e</code> in
place of <code>x' = e</code>.  While the use of this operator does not change Apalache's
internal search for assignments (in particular, using manual assignment
annotations is <em>not</em> a way of circumventing the syntax order requirement), we
encourage the use of manual assignments for clarity.</p>
<p>Unlike other shapes of assignment candidates, whenever a manual assignment is
used in a position where the assignment candidate would not be chosen as an
assignment (either within assignment-free expressions or in violation of, for
example, the syntax order rule) an error, like one of the two below, is
reported:</p>
<pre><code>Assignment error: test.tla:10:12-10:18: Manual assignment is spurious, x is already assigned!
</code></pre>
<p>or</p>
<pre><code>Assignment error: test.tla:10:15-10:21: Illegal assignment inside an assignment-free expression.
</code></pre>
<p>The benefit of using manual assignments, we believe, lies in synchronizing the
user's and the tool's understanding of where assignments happen.  This helps
prevent unexpected results, where the user's expectations or intuition
regarding assignment positions are incorrect.</p>
<p>Note: To use manual assignments where the assignment candidate has the shape of
<code>x' \in S</code> use <code>\E s \in S: x' := s</code>.</p>
<h1><a class="header" href="#kera-kernel-logic-of-actions" id="kera-kernel-logic-of-actions">KerA: kernel logic of actions</a></h1>
<p>See <a href="https://dl.acm.org/citation.cfm?id=3360549">TLA+ model checking made symbolic</a>.</p>
<h1><a class="header" href="#tla-language-reference-manual-" id="tla-language-reference-manual-">TLA+ Language Reference Manual 📗</a></h1>
<p>In this manual, we summarize our knowledge about TLA+ and about its treatment
with the <a href="https://github.com/informalsystems/apalache">Apalache model checker</a>. This is not the manual on Apalache, which
can be found in <a href="lang/../.">Apalache manual</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video Course</a> by Leslie Lamport is
an excellent starting point, if you are new to TLA+. For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. There are plenty of interesting talks on TLA+ at <a href="https://www.youtube.com/channel/UCLHtwjeqBxVSEhjV0clKblA/videos">TLA
Channel</a> of Markus Kuppe. This manual completely ignores Pluscal -- a
higher-level language on top of TLA+.  If you are interested in learning
Pluscal, check <a href="https://learntla.com">LearnTla.com</a> by Hillel Wayne.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ol>
<li><a href="lang/./standard-operators.html">The standard operators of TLA+</a> 🔌</li>
<li><a href="lang/./user-operators.html">User-defined operators</a> 💡</li>
<li><a href="lang/./modules.html">Modules and instances</a>: MODULE, EXTENDS and INSTANCES ✂</li>
</ol>
<h1><a class="header" href="#the-standard-operators-of-tla" id="the-standard-operators-of-tla">The standard operators of TLA+</a></h1>
<p>In this document, we summarize the standard TLA+ operators in a form that is
similar to manuals on programming languages. The purpose of this document is to
provide you with a quick reference, whenever you are looking at the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of
TLA</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video
Course</a> by Leslie Lamport
is an excellent starting point, if you are new to TLA+.  For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. You can find handy extensions of the standard library in
<a href="https://github.com/tlaplus/CommunityModules">Community Modules</a>.</p>
<p>We explain the semantics of the operators under the lenses of the <a href="https://github.com/informalsystems/apalache">Apalache
model checker</a>.  Traditionally, the emphasis was put on the temporal operators
and action operators, as they build the foundation of TLA. We focus on the &quot;+&quot;
aspect of the language, which provides you with a language for writing a single
step by a state machine.  This part of the language is absolutely necessary for
writing and reading system specifications.  Moreover, we treat equally the
&quot;core&quot; operators of TLA+ and the &quot;library&quot; operators: This distinction is less
important to the language users than to the tool developers.</p>
<p>In this document, we present the semantics of TLA+, as if it was executed on a
computer that is equipped with an additional device that we call an <em>oracle</em>.
Most of the TLA+ operators are understood as deterministic operators, so they
can be executed on your computer. A few operators are non-deterministic, so
they require the oracle to resolve non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>. This is one of the most important features that makes TLA+
distinct from programming languages.  Wherever possible, we complement the
English semantics with code in <a href="https://www.python.org/">Python</a>. Although our
semantics are more restrictive than the denotational semantics in Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, they are very close to the treatment of TLA+ by the model
checkers: <a href="https://github.com/informalsystems/apalache">Apalache</a> and
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a>. Our relation between
TLA+ operators and Python code bears some resemblance to
<a href="https://github.com/Viasat/salt">SALT</a> and
<a href="https://github.com/tlaplus/PlusPy">PlusPy</a>.</p>
<p><em>Here, we are using the ASCII notation of TLA+, as this is what you
type. We give the nice LaTeX notation in the detailed description.  The
translation table between the LaTeX notation and ASCII can be found in <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary
of TLA</a>.</em></p>
<h2><a class="header" href="#the--operators-in-tla" id="the--operators-in-tla">The &quot;+&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#booleans-" id="booleans-">Booleans 🚥</a></h3>
<p><em>Good old Booleans</em>. <a href="lang/./booleans.html">Learn more...</a></p>
<ul>
<li>Boolean algebra:
<ul>
<li><a href="lang/./booleans.html#const"><code>FALSE</code></a> and <a href="lang/./booleans.html#const"><code>TRUE</code></a>,</li>
<li><a href="lang/./booleans.html#and"><code>A /\ B</code></a> (also <code>A \land B</code>),</li>
<li><a href="lang/./booleans.html#or"><code>A \/ B</code></a> (also <code>A \lor B</code>),</li>
<li><a href="lang/./booleans.html#not"><code>~A</code></a> (also <code>\lnot A</code> and <code>\neg A</code>),</li>
<li><a href="lang/./booleans.html#implies"><code>A =&gt; B</code></a>,</li>
<li><a href="lang/./booleans.html#equiv"><code>A &lt;=&gt; B</code></a> (also <code>A \equiv B</code>)</li>
</ul>
</li>
<li>Boolean set: <a href="lang/./booleans.html#const"><code>BOOLEAN</code></a></li>
</ul>
<h3><a class="header" href="#control-flow-and-non-determinism-" id="control-flow-and-non-determinism-">Control flow and non-determinism 🔀</a></h3>
<p><em>Hidden powers of TLA+</em>. <a href="lang/./control-and-nondeterminism.html">Learn more...</a></p>
<ul>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetOr"><code>A_1 \/ ... \/ A_n</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetExists"><code>\E x \in S: P</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetIte"><code>IF p THEN e_1 ELSE e_2</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetCase"><code>CASE</code> and <code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#deterministic-conditionals-" id="deterministic-conditionals-">Deterministic conditionals 🚕</a></h3>
<p><em>You need them less often than you think</em>. <a href="lang/./conditionals.html">Learn more...</a></p>
<ul>
<li>Deterministic <a href="lang/./conditionals.html#ite"><code>IF-THEN-ELSE</code></a></li>
<li>Deterministic <a href="lang/./conditionals.html#case"><code>CASE</code></a> and <a href="lang/./conditionals.html#caseOther"><code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#integers-" id="integers-">Integers 🔢</a></h3>
<p><em>Unbounded integers like in Python.</em> <a href="lang/./integers.html">Learn more...</a></p>
<ul>
<li>Integer algebra:
<ul>
<li><a href="lang/./integers.html#uminus"><code>-i</code></a>, <a href="lang/./integers.html#plus"><code>i + k</code></a>,
<a href="lang/./integers.html#minus"><code>i - k</code></a>,</li>
<li><a href="lang/./integers.html#mult"><code>i * k</code></a>,
<a href="lang/./integers.html#div"><code>i \div k</code></a>, <a href="lang/./integers.html#mod"><code>i % k</code></a>,
<a href="lang/./integers.html#pow"><code>i^k</code></a></li>
</ul>
</li>
<li>Integer predicates:
<ul>
<li><a href="lang/./integers.html#lt"><code>i &lt; k</code></a>, <a href="lang/./integers.html#gt"><code>i &gt; k</code></a>,</li>
<li><a href="lang/./integers.html#lte"><code>i &lt;= k</code></a> (also <code>i =&lt; k</code> and <code>i \leq k</code>),
<a href="lang/./integers.html#gte"><code>i &gt;= k</code></a> (also <code>i \geq k</code>)</li>
</ul>
</li>
<li>Integer sets: <a href="lang/./integers.html#range"><code>i..k</code></a>,
<a href="lang/./integers.html#const"><code>Int</code></a>, <a href="lang/./integers.html#const"><code>Nat</code></a></li>
</ul>
<h3><a class="header" href="#strings-" id="strings-">Strings 🔡</a></h3>
<p><em>String constants</em>. You learned it!</p>
<ul>
<li>String literals, e.g., <code>&quot;hello&quot;</code> and <code>&quot;TLA+ is awesome&quot;</code>.
<ul>
<li>In Apalache, the literals have the type <code>Str</code>.</li>
</ul>
</li>
<li>Set of all finite strings: <code>STRING</code>.
<ul>
<li>In Apalache, the set <code>STRING</code> has the type <code>Set(Str)</code>.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#sets-" id="sets-">Sets 🍣</a></h3>
<p><em>Like frozen sets in Python, but cooler</em> <a href="lang/./sets.html">Learn more...</a></p>
<ul>
<li>Set constructors:
<ul>
<li>Enumeration: <a href="lang/./sets.html#setEnum"><code>{ e_1, ..., e_n }</code></a></li>
<li>Filter: <a href="lang/./sets.html#filter"><code>{ x \in S: p }</code></a></li>
<li>Map: <a href="lang/./sets.html#map"><code>{ e: x \in S }</code></a></li>
<li>Powers: <a href="lang/./sets.html#powerset"><code>SUBSET S</code></a> and <a href="lang/./sets.html#flatten"><code>UNION S</code></a></li>
</ul>
</li>
<li>Set algebra:
<ul>
<li>Union: <a href="lang/./sets.html#union"><code>S \union T</code></a> (also <code>S \cup T</code>),</li>
<li>Intersection: <a href="lang/./sets.html#intersect"><code>S \intersect T</code></a> (also <code>S \cap T</code>),</li>
<li>Difference: <a href="lang/./sets.html#setminus"><code>S \ T</code></a></li>
</ul>
</li>
<li>Set predicates:
<ul>
<li>Membership: <a href="lang/./sets.html#in"><code>x \in S</code></a> and <a href="lang/./sets.html#notin"><code>x \notin S</code></a>,</li>
<li>Subsets: <a href="lang/./sets.html#subseteq"><code>S \subseteq T</code></a>,</li>
<li>Finiteness: <a href="lang/./sets.html#finite"><code>IsFinite</code></a></li>
</ul>
</li>
<li>Cardinality of a finite set: <a href="lang/./sets.html#card"><code>Cardinality</code></a></li>
</ul>
<h3><a class="header" href="#logic-" id="logic-">Logic 🐙</a></h3>
<p><em>How logicians write loops</em>. <a href="lang/./logic.html">Learn more...</a></p>
<ul>
<li>Equality:
<a href="lang/./logic.html#eq"><code>=</code></a> and <a href="lang/./logic.html#neq"><code>/=</code></a> (also <code>#</code>)</li>
<li>Bounded quantifiers:
<a href="lang/./logic.html#forallBounded"><code>\A x \in S: p</code></a> and <a href="lang/./logic.html#existsBounded"><code>\E x \in S: p</code></a></li>
<li>Unbounded quantifiers:
<a href="lang/./logic.html#forall"><code>\A x: p</code></a> and <a href="lang/./logic.html#exists"><code>\E x: p</code></a></li>
<li>Choice:
<a href="lang/./logic.html#chooseBounded"><code>CHOOSE x \in S: p</code></a> and <a href="lang/./logic.html#choose"><code>CHOOSE x: p</code></a></li>
</ul>
<h3><a class="header" href="#functions-" id="functions-">Functions 💹</a></h3>
<p><em>Like frozen dictionaries in Python, but cooler</em>. <a href="lang/./functions.html">Learn more...</a></p>
<ul>
<li><a href="lang/./functions.html#funCtor">Function constructor</a>: <code>[ x \in S |-&gt; e ]</code></li>
<li><a href="lang/./functions.html#funSetCtor">Set of functions</a>: <code>[S -&gt; T]</code></li>
<li><a href="lang/./functions.html#funApp">Function application</a>: <code>f[e]</code></li>
<li><a href="lang/./functions.html#except">Function replacement</a>: <code>[ f EXCEPT ![e_1] = e_2 ]</code></li>
<li><a href="lang/./functions.html#domain">Function domain</a>: <code>DOMAIN f</code></li>
</ul>
<h3><a class="header" href="#records-" id="records-">Records 📚</a></h3>
<p><em>Records like everywhere else</em>. <a href="lang/./records.html">Learn more...</a></p>
<ul>
<li><a href="lang/./records.html#recCtor">Record constructor</a>: <code>[ h_1 |-&gt; e_1, ..., h_n |-&gt; e_n ]</code></li>
<li><a href="lang/./records.html#recSetCtor">Set of records</a>: <code>[ h_1: S_1, ..., h_n: S_n ]</code></li>
<li><a href="lang/./records.html#recApp">Access by field name</a>: <code>e.h</code></li>
<li>Records are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#tuples-" id="tuples-">Tuples 📐</a></h3>
<p><em>Well, tuples</em>, indexed with 1, 2, 3... <a href="lang/./tuples.html">Learn more...</a></p>
<ul>
<li><a href="lang/./tuples.html#tuple">Tuple constructor</a>: <code>&lt;&lt; e_1, ..., e_n &gt;&gt;</code></li>
<li><a href="lang/./tuples.html#times">Cartesian product</a>: <code>S_1 \X ... \X S_n</code> (also <code>S_1 \times ... \times S_n</code>)</li>
<li>Tuples are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#sequences-" id="sequences-">Sequences 🐍</a></h3>
<p><em>Functions that pretend to be lists, indexed with 1, 2, 3,...</em></p>
<ul>
<li>Add to end: <a href="lang/./sequences.html#append"><code>Append(s, e)</code></a></li>
<li>First and rest: <a href="lang/./sequences.html#head"><code>Head(s)</code></a> and <a href="lang/./sequences.html#tail"><code>Tail(s)</code></a></li>
<li>Length: <a href="lang/./sequences.html#len"><code>Len(s)</code></a></li>
<li>Concatenation: <a href="lang/./sequences.html#concat"><code>s \o t</code></a> (also <code>s \circ t</code>)</li>
<li>Subsequence: <a href="lang/./sequences.html#subseq"><code>SubSeq(s, i, k)</code></a></li>
<li>Sequence filter: <a href="lang/./sequences.html#filter"><code>SelectSeq(s, Test)</code></a></li>
<li>Set of finite sequences over <code>S</code>: <a href="lang/./sequences.html#seq"><code>Seq(S)</code></a></li>
<li>Sequences are functions.
All operators of <a href="lang/./functions.html">functions</a> and <a href="lang/./tuples.html">tuples</a> are supported.</li>
</ul>
<h3><a class="header" href="#bags-" id="bags-">Bags 👜</a></h3>
<ul>
<li>TBD</li>
</ul>
<h3><a class="header" href="#reals-" id="reals-">Reals 🍭</a></h3>
<p><em>Like &quot;reals&quot; in your math classes, not floating point</em></p>
<ul>
<li>
<p>All operators of <code>Integers</code> but interpreted over reals</p>
</li>
<li>
<p><code>a / b</code>, <code>Real</code>, <code>Infinity</code></p>
</li>
</ul>
<h3><a class="header" href="#naturals-" id="naturals-">Naturals 🐾</a></h3>
<p><em>If you are Indiana Jones...</em></p>
<ul>
<li>All operators of <code>Integers</code> except: unary minus <code>-a</code> and <code>Int</code></li>
</ul>
<h2><a class="header" href="#the-a-operators-in-tla" id="the-a-operators-in-tla">The &quot;A&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#action-operators-" id="action-operators-">Action operators 🏃</a></h3>
<p><em>Taking a step</em></p>
<ul>
<li>Prime: <code>e'</code></li>
<li>Preservation: <code>UNCHANGED e</code></li>
<li>Stuttering: <code>[A]_e</code> and <code>&lt;A&gt;_e</code></li>
<li>Action enablement: <code>ENABLED A</code></li>
<li>Sequential composition: <code>A \cdot B</code></li>
</ul>
<h2><a class="header" href="#the-tl-operators-in-tla" id="the-tl-operators-in-tla">The &quot;TL&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#temporal-operators-" id="temporal-operators-">Temporal operators 🔜</a></h3>
<p><em>Talking about computations, finite and infinite</em></p>
<ul>
<li>Always: <code>[]F</code></li>
<li>Eventually: <code>&lt;&gt;F</code></li>
<li>Weak fairness: <code>WF_e(A)</code></li>
<li>Strong fairness: <code>SF_e(A)</code></li>
<li>Leads-to: <code>F ~&gt; G</code></li>
<li>Guarantee: <code>F -+-&gt; G</code></li>
<li>Temporal hiding: <code>\EE x: F</code></li>
<li>Temporal universal quantification: <code>\AA x: F</code></li>
</ul>
<h1><a class="header" href="#booleans" id="booleans">Booleans</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>You find these operators in every programming language and every textbook on
logic. These operators form <em>propositional logic</em>.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants" id="constants">Constants</a></h2>
<p>TLA+ contains three special constants: <code>TRUE</code>, <code>FALSE</code>, and <code>BOOLEAN</code>.
The constant <code>BOOLEAN</code> is defined as the set <code>{FALSE, TRUE}</code>.</p>
<p>In Apalache, <code>TRUE</code>, <code>FALSE</code>, and <code>BOOLEAN</code> have the types <code>Bool</code>, <code>Bool</code>,
and <code>Set(Bool)</code>, respectively.</p>
<p>A note for set-theory purists: In theory, <code>TRUE</code> and <code>FALSE</code> are also sets, but
in practice they are treated as indivisible values. For instance, Apalache and
TLC will report an error, if you try to treat <code>FALSE</code> and <code>TRUE</code> as sets.</p>
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<p><strong>Warning</strong>: Below, we discuss Boolean operators in terms of the way they are usually
defined in programming languages. However, it is important to understand that the
disjunction operator <code>F \/ G</code> induces a nondeterministic effect when <code>F</code> or <code>G</code> contain
the prime operator  (<code>'</code>), or when they are used inside the initialization predicate <code>Init</code>.
We discuss this effect <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<hr />
<p><a name="and"></a></p>
<h3><a class="header" href="#and-conjunction" id="and-conjunction">And (conjunction)</a></h3>
<p><strong>Notation:</strong> <code>F /\ G</code> or <code>F \land G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/land.png" alt="land" /></p>
<p><strong>Arguments:</strong> Two or more arbitrary expressions.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> The binary case <code>F /\ G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>FALSE</code>,
or <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 /\ ... /\ F_n</code> can be understood by evaluating
the expression <code>F_1 /\ (F_2 /\ ... /\ (F_{n-1} /\ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> Deterministic, if the arguments are deterministic.  Otherwise,
the possible effects of non-determinism of each argument are combined.  See
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if either conjunct evaluates to
a non-Boolean value (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  /\ TRUE    \* TRUE
FALSE /\ TRUE    \* FALSE
TRUE  /\ FALSE   \* FALSE
FALSE /\ FALSE   \* FALSE
FALSE /\ 1       \* FALSE in TLC, type error in Apalache
    1 /\ FALSE   \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; True  and True
True
&gt;&gt;&gt; False and True
False
&gt;&gt;&gt; True  and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; False and 1 # 1 is cast to True
False
&gt;&gt;&gt; 1 and False # 1 is cast to True
False

</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, conjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  /\ F_1
    /\ G_1
    ...
    /\ G_k
  /\ F_2
  ...
  /\ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>/\</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 /\ (G_1 /\ ... /\ G_k) /\ F_2 /\ ... /\ F_n
</code></pre>
<hr />
<p><a name="or"></a></p>
<h3><a class="header" href="#or-disjunction" id="or-disjunction">Or (disjunction)</a></h3>
<p><strong>Notation:</strong> <code>F \/ G</code> or <code>F \lor G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lor.png" alt="lor" /></p>
<p><strong>Arguments:</strong> Two or more Boolean expressions.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong></p>
<p>The binary case <code>F \/ G</code> evaluates to:</p>
<ul>
<li>
<p><code>FALSE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>TRUE</code>,
or <code>F</code> evaluates to <code>FALSE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 \/ ... \/ F_n</code> can be understood by evaluating
the expression <code>F_1 \/ (F_2 \/ ... \/ (F_{n-1} \/ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> deterministic, if the arguments may not update primed
variables.  If the arguments may update primed variables, disjunctions may
result in non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if a non-Boolean argument
is involved in the evaluation (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  \/ TRUE    \* TRUE
FALSE \/ TRUE    \* TRUE
TRUE  \/ FALSE   \* TRUE
FALSE \/ FALSE   \* FALSE
TRUE  \/ 1       \* TRUE in TLC, type error in Apalache
    1 \/ TRUE    \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; True  or True
True
&gt;&gt;&gt; False or True
True
&gt;&gt;&gt; True  or False
True
&gt;&gt;&gt; False or False
False

</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, disjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  \/ F_1
    \/ G_1
    ...
    \/ G_k
  \/ F_2
  ...
  \/ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>\/</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 \/ (G_1 \/ ... \/ G_k) \/ F_2 \/ ... \/ F_n
</code></pre>
<p>The indented form allows you to combine conjunctions and disjunctions:</p>
<pre><code class="language-tla">  \/ /\ F
     /\ G
  \/ \/ H
     \/ J
</code></pre>
<p>The above formula is equivalent to:</p>
<pre><code class="language-tla">  (F /\ G) \/ (H \/ J)
</code></pre>
<hr />
<p><a name="not"></a></p>
<h3><a class="header" href="#negation" id="negation">Negation</a></h3>
<p><strong>Notation:</strong> <code>~F</code> or <code>\neg F</code> or <code>\lnot F</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lnot.png" alt="lnot" /></p>
<p><strong>Arguments:</strong> One argument that should evaluate to a Boolean value.</p>
<p><strong>Apalache type:</strong> <code>Bool =&gt; Bool</code></p>
<p><strong>Effect:</strong></p>
<p>The value of <code>~F</code> is computed as follows:</p>
<ul>
<li>if <code>F</code> is evaluated to <code>FALSE</code>, then <code>~F</code> is evaluated to <code>TRUE</code>,</li>
<li>if <code>F</code> is evaluated to <code>TRUE</code>, then <code>~F</code> is evaluated to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if the argument evaluates to
a non-Boolean value. In this case, Apalache statically reports a type error,
whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">~TRUE    \* FALSE
~FALSE   \* TRUE
~(1)     \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True

</code></pre>
<hr />
<p><a name="implies"></a></p>
<h3><a class="header" href="#implication" id="implication">Implication</a></h3>
<p><strong>Notation:</strong> <code>F =&gt; G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/implies.png" alt="implies" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code>. Note that the <code>=&gt;</code> operator at the type level expresses the relation of inputs types to output types for operators, and as opposed to the <code>=&gt;</code> expressing the implication relation at the value level.</p>
<p><strong>Effect:</strong> <code>F =&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>FALSE</code>, or
<code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE =&gt; TRUE    \* TRUE
TRUE  =&gt; TRUE    \* TRUE
FALSE =&gt; FALSE   \* TRUE
TRUE  =&gt; FALSE   \* FALSE
FALSE =&gt; 1       \* TRUE in TLC, type error in Apalache
TRUE  =&gt; 1       \* runtime error in TLC, type error in Apalache
1     =&gt; TRUE    \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Recall that <code>A =&gt; B</code> is equivalent to <code>~A \/ B</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; (not False) or True
True
&gt;&gt;&gt; (not True)  or True
True
&gt;&gt;&gt; (not False) or False
True
&gt;&gt;&gt; (not True)  or False
False

</code></pre>
<hr />
<p><a name="equiv"></a></p>
<h3><a class="header" href="#equivalence" id="equivalence">Equivalence</a></h3>
<p><strong>Notation:</strong> <code>F &lt;=&gt; G</code> or <code>F \equiv G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/equiv.png" alt="equiv" /> or <img src="lang/./img/equiv2.png" alt="equiv2" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> <code>F &lt;=&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>,
or both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if one of the arguments evaluates to <code>TRUE</code>,
while the other argument evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>How is <code>F &lt;=&gt; G</code> different from <code>F = G</code>? Actually, <code>F &lt;=&gt; G</code> is equality
that is defined only for Boolean values. In other words, if <code>F</code> and <code>G</code> are
evaluated to Boolean values, then <code>F &lt;=&gt; G</code> and <code>F = G</code> are evaluated to the
same Boolean value. We prefer <code>F &lt;=&gt; G</code> to <code>F = G</code>, as <code>F &lt;=&gt; G</code> clearly
indicates the intended types of <code>F</code> and <code>G</code> and thus makes the logical
structure more obvious.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE &lt;=&gt; TRUE   \* FALSE
TRUE  &lt;=&gt; TRUE   \* TRUE
FALSE &lt;=&gt; FALSE  \* TRUE
TRUE  &lt;=&gt; FALSE  \* TRUE
FALSE &lt;=&gt; 1      \* runtime error in TLC, type error in Apalache
1     &lt;=&gt; TRUE   \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Assume that both expressions are Boolean. Then, in TLA+, <code>F &lt;=&gt; G</code> is
equivalent to <code>F = G</code>. In Python, we express Boolean equality using <code>==</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; False == True
False
&gt;&gt;&gt; True  == True
True
&gt;&gt;&gt; False == False
True
&gt;&gt;&gt; True  == False
False

</code></pre>
<h1><a class="header" href="#control-flow-and-non-determinism-in-tla" id="control-flow-and-non-determinism-in-tla">Control Flow and Non-determinism in TLA+</a></h1>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<p><strong>Author:</strong> Igor Konnov</p>
<p><strong>Peer review:</strong> Shon Feder, Jure Kukovec</p>
<p>Non-determinism is one of the TLA+ features that makes it different from
mainstream programming languages. However, it is very easy to overlook it: There is no
special syntax for expressing non-determinism. In pure TLA+, whether your
specification is deterministic or not depends on the evaluation of the initial
predicate and of the transition predicate. These are usually called <code>Init</code> and
<code>Next</code>, respectively. In the following, we first intuitively explain what non-determinism
means in the mathematical framework of TLA+, and then proceed with the
explanation that is friendly to computers and software engineers.</p>
<h2><a class="header" href="#explaining-non-determinism-to-humans" id="explaining-non-determinism-to-humans">Explaining non-determinism to humans</a></h2>
<p><strong>States, transitions, actions, computations.</strong> Every TLA+ specification comes
with a set of state variables. For instance, the following specification
declares two state variables <code>x</code> and <code>y</code>:</p>
<pre><code class="language-tla">-------- MODULE coord ----------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ y' = y + 1
================================
</code></pre>
<p>A <em>state</em> is a mapping from state variables to TLA+ values. We do not go into
the mathematical depths of precisely defining TLA+ values. Due to the
background theory of ZFC, this set is well-defined and is not subject to
logical paradoxes. Basically, the values are Booleans, integers, strings, sets,
functions, etc.</p>
<p>In the above example, the operator <code>Init</code> evaluates to <code>TRUE</code> on exactly one
state, which we can conveniently write using the <a href="lang/./records.html">record
constructor</a> as follows: <code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>The operator <code>Next</code> contains primes (<code>'</code>) and thus represents pairs of states,
which we call <em>transitions</em>. An operator over unprimed and primed variables
is called an <em>action</em> in TLA+. Intuitively, the operator <code>Next</code> in our example
evaluates to <code>TRUE</code> on infinitely many pairs of states. For instance, <code>Next</code>
evaluates to <code>TRUE</code> on the following pairs:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; 0, y |-&gt; 0], [x |-&gt; 1, y |-&gt; 1]&gt;&gt;
&lt;&lt;[x |-&gt; 1, y |-&gt; 1], [x |-&gt; 2, y |-&gt; 2]&gt;&gt;
&lt;&lt;[x |-&gt; 2, y |-&gt; 2], [x |-&gt; 3, y |-&gt; 3]&gt;&gt;
...
</code></pre>
<p>In our example, the second state of every transition matches the first state
of the next transition in the list. This is because the above sequence of
transitions describes the following sequence of states:</p>
<pre><code class="language-tla">[x |-&gt; 0, y |-&gt; 0]
[x |-&gt; 1, y |-&gt; 1]
[x |-&gt; 2, y |-&gt; 2]
[x |-&gt; 3, y |-&gt; 3]
...
</code></pre>
<p>Actually, we have just written a computation of our specification.
A <em>finite computation</em> is a finite sequence of states <code>s_0, s_1, ..., s_k</code>
that satisfies the following properties:</p>
<ul>
<li>The operator <code>Init</code> evaluates to <code>TRUE</code> on state <code>s_0</code>, and</li>
<li>The operator <code>Next</code> evaluates to <code>TRUE</code> on every pair of states <code>&lt;&lt;s_i, s_j&gt;&gt;</code>
for <code>0 &lt;= i &lt; k</code> and <code>j = i + 1</code>.</li>
</ul>
<p>We can also define an <em>infinite computation</em> by considering an infinite
sequence of states that are connected via <code>Init</code> and <code>Next</code> as above, but
without stopping at any index <code>k</code>.</p>
<p>Below we plot the values of <code>x</code> and <code>y</code> in the first 16 states with red dots.
Not surprisingly, we just get a line.</p>
<p><img src="lang/./img/diagonal.png" alt="diagonal" /></p>
<p><strong>Note:</strong> In the above examples, we only showed transitions that could be
produced by computations, which (by our definition) originate from the initial
states. These transitions contain <em>reachable</em> states. In principle, <code>Next</code> may
also describe transitions that contain unreachable states. For instance, the
operator <code>Next</code> from our example evaluates to <code>TRUE</code> on the following pairs as
well:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; -100, y |-&gt; -100], [x |-&gt; -99, y |-&gt; -99]&gt;&gt;
&lt;&lt;[x |-&gt; -100, y |-&gt; 100], [x |-&gt; -99, y |-&gt; 101]&gt;&gt;
&lt;&lt;[x |-&gt; 100, y |-&gt; -100], [x |-&gt; 101, y |-&gt; -99]&gt;&gt;
...
</code></pre>
<p>There is no reason to restrict transitions only to the reachable states
(and it would be hard to do, technically). This feature is often used to reason
about inductive invariants.</p>
<p><strong>Determinism and non-determinism.</strong> Our specification is quite boring: It
describes exactly one initial state, and there is no variation in computing the
next states.  We can make it a bit more interesting:</p>
<pre><code class="language-tla">------------ MODULE coord2 ---------------
VARIABLES x, y
Init == x = 0 /\ (y = 0 \/ y = 1 \/ y = 2)
Next == x' = x + 1 /\ y' = y + 1
==========================================
</code></pre>
<p>Now our plot has a bit more variation. It presents three computations
that are starting in three different initial states: <code>[x |-&gt; 0, y |-&gt; 0]</code>,
<code>[x |-&gt; 0, y |-&gt; 1]</code>, and <code>[x |-&gt; 0, y |-&gt; 2]</code>.</p>
<p><img src="lang/./img/diagonal3.png" alt="diagonal3" /></p>
<p>However, there is still not much variation in <code>Next</code>. For every state <code>s</code>,
we can precisely say which state follows <code>s</code> according to <code>Next</code>. We can
define <code>Next</code> as follows (note that <code>Init</code> is defined as in <code>coord</code>):</p>
<pre><code class="language-tla">------------ MODULE coord3 -----------------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ (y' = x \/ y' = x + 1)
============================================
</code></pre>
<p>The following plot shows the states that are visited by the computations
of the specification <code>coord3</code>:</p>
<p><img src="lang/./img/diag2.png" alt="diag2" /></p>
<p>Notice that specification <code>coord</code> describes one infinite computation (and
infinitely many finite computations that are prefixes of the infinite
computation).  Specification <code>coord2</code> describes three infinite computations.
Specification <code>coord3</code> describes infinitely many infinite computations: At
every step, <code>Next</code> may choose between <code>y' = x</code> or <code>y' = x + 1</code>.</p>
<p>Why are these specifications so different? The answer lies in non-determinism.
Specification <code>coord</code> is completely deterministic: There is just one state that
evaluates <code>Init</code> to <code>TRUE</code>, and every state is the first component of exactly
one transition, as specified by <code>Next</code>. Specification <code>coord2</code> has
non-determinism in the operator <code>Init</code>. Specification <code>coord3</code> has
non-determinism in the operator <code>Next</code>.</p>
<p><strong>Discussion.</strong>
So far we have been talking about the intuition. If you would like to know more about
the logic behind TLA+ and the semantics of TLA+, check Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and <a href="https://members.loria.fr/SMerz/papers/tla+logic2008.pdf">The Specification Language TLA+</a>.</p>
<p>When we look at the operators like <code>Init</code> and <code>Next</code> in our examples, we can
guess the states and transitions. If we could ask our logician friend to guess
the states and transitions for us every time we read a TLA+ specification, that
would be great. But this approach does not scale well.</p>
<p><strong>Can we explain non-determinism to a computer?</strong> It turns out that we can.
In fact, many model checkers support non-determinism in their input languages.
For instance, see <a href="https://github.com/boogie-org/boogie">Boogie</a> and <a href="http://spinroot.com/spin/whatispin.html">Spin</a>.
Of course, this comes with constraints on the structure of the specifications.
After all, people are much better at solving certain logical puzzles than
computers, though people get bored much faster than computers.</p>
<p>To understand how TLC enumerates states, check Chapter 14 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying
Systems</a>. In the rest of this document, we focus on treatment of
non-determinism that is close to the approach in Apalache.</p>
<h2><a class="header" href="#explaining-non-determinism-to-computers" id="explaining-non-determinism-to-computers">Explaining non-determinism to computers</a></h2>
<p>To see how a program could evaluate a TLA+ expression, we need two more
ingredients: bindings and oracles.</p>
<p><strong>Bindings.</strong> We generalize states to bindings: Given a set of names <code>N</code>, a
<em>binding</em> maps every name from <code>N</code> to a value.  When <code>N</code> is the set of all
state variables, a binding describes a state.  However, a binding does not have
to assign values to all state variables.  Moreover, a binding may assign values
to names that are not the names of state variables. In the following, we are
using bindings over subsets of names that contain: (1) names of the state
variables, and (2) names of the primed state variables.</p>
<p>To graphically distinguish bindings from states, we use parentheses and arrows
to define bindings. For instance, <code>(x -&gt; 1, x' -&gt; 3)</code> is a binding that maps
<code>x</code> to 1 and <code>x'</code> to 3. (This is our notation, not a common TLA+ notation.)</p>
<p><strong>Evaluating deterministic expressions.</strong> Consider the specification <code>coord</code>,
which was given above.  By starting with the empty binding <code>()</code>, we can see how
to automatically evaluate the body of the operator <code>Init</code>:</p>
<pre><code class="language-tla">x = 0 /\ y = 0
</code></pre>
<p>By following <a href="lang/./booleans.html">semantics of conjunction</a>, we see that <code>/\</code> is
evaluated from left-to-right. The left-hand side equality <code>x = 0</code> is treated as
an assignment to <code>x</code>, since <code>x</code> is not assigned a value in the empty binding
<code>()</code>, which it is evaluated against.  Hence, the expression <code>x = 0</code> produces
the binding <code>(x -&gt; 0)</code>. When applied to this binding, the right-hand side
equality <code>y = 0</code> is also treated as an assignment to <code>y</code>. Hence, the expression
<code>y = 0</code> results in the binding <code>(x -&gt; 0, y -&gt; 0)</code>. This binding is defined over
all state variables, so it gives us the only initial state <code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>Let's see how to evaluate the body of the operator <code>Next</code>:</p>
<pre><code class="language-tla">x' = x + 1 /\ y' = y + 1
</code></pre>
<p>As we have seen, <code>Next</code> describes pairs of states. Thus, we will produce
bindings over non-primed and primed variables, that is, over <code>x, x', y, y'</code>.
Non-primed variables represent the state before a transition fires, whereas
primed variables represent the state after the transition has been fired.</p>
<p>Consider evaluation of <code>Next</code> in the state <code>[x |-&gt; 3, y |-&gt; 3]</code>, that is, the
evaluation starts with the binding <code>(x -&gt; 3, y -&gt; 3)</code>.  Similar to the
conjunction in <code>Init</code>, the conjunction in <code>Next</code> first produces the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4)</code> and then the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4, y' -&gt; 4)</code>.  Moreover, <code>Next</code> evaluates to <code>TRUE</code> when it is evaluated against the
binding <code>(x -&gt; 3, y -&gt; 3)</code>. Hence, the state <code>[x |-&gt; 3, y |-&gt; 3]</code> has the only
successor <code>[x |-&gt; 4, y |-&gt; 4]</code>, when following the transition predicate <code>Next</code>.</p>
<p>In contrast, if we evaluate <code>Next</code> when starting with the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, the result will be <code>FALSE</code>, as the left-hand side of
the conjunction <code>x' = x + 1</code> evaluates to <code>FALSE</code>.  Indeed, <code>x'</code> has value <code>1</code>,
whereas <code>x</code> has value <code>3</code>, so <code>x' = x + 1</code> is evaluated as <code>1 = 3 + 1</code> against
the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, which gives us <code>FALSE</code>.
Hence, the pair of states <code>[x |-&gt; 3, y |-&gt; 3]</code> and <code>[x |-&gt; 1, y |-&gt; 1]</code> is not
a valid transition as represented by <code>Next</code>.</p>
<p>So far, we only considered unconditional operators. Let's have a look at the
operator <code>A</code>:</p>
<pre><code class="language-tla">A ==
  y &gt; x /\ y' = x /\ x' = x
</code></pre>
<p>Evaluation of <code>A</code> against the binding <code>(x -&gt; 3, y -&gt; 10)</code> produces the binding
<code>(x -&gt; 3, y -&gt; 10, x' -&gt; 3, y' -&gt; 3)</code> and the result <code>TRUE</code>.  However, in the
evaluation of <code>A</code> against the binding <code>(x -&gt; 10, y -&gt; 3)</code>, the leftmost
condition <code>y &gt; x</code> evaluates to <code>FALSE</code>, so <code>A</code> evaluates to <code>FALSE</code> against the
binding <code>(x -&gt; 10, y -&gt; 3)</code>. Hence, no next state can be produced from the
the state <code>[x |-&gt; 3, y |-&gt; 10]</code> by using operator <code>A</code>.</p>
<p>Until this moment, we have been considering only deterministic examples, that is,
there was no &quot;branching&quot; in our reasoning. Such examples can be easily put into
a program. What about the operators, where we can choose from multiple options
that are simultaneously enabled? We introduce an oracle to resolve this issue.</p>
<p><strong>Oracles.</strong> For multiple choices, we introduce an external device that we call
an oracle. More formally, we assume that there is a device called <code>GUESS</code> that
has the following properties:</p>
<ol>
<li>For a non-empty set <code>S</code>, a call <code>GUESS S</code> returns
some value <code>v \in S</code>.</li>
<li>A call <code>GUESS {}</code> halts the evaluation.</li>
<li>There are no assumptions about fairness of <code>GUESS</code>. It is free to return
elements in any order, produce duplicates and ignore some elements.</li>
</ol>
<p>Why do we call it a device? We cannot call it a function, as functions are
deterministic by definition. For the same reason, it is not a TLA+
operator. In logic, we would say that <code>GUESS</code> is simply a binary relation on
sets and their elements, which would be no different from the membership
relation <code>\in</code>.</p>
<p>Why do we need <code>GUESS S</code> and cannot use <code>CHOOSE x \in S: TRUE</code> instead?
Actually, <code>CHOOSE x \in S: TRUE</code> is <em>deterministic</em>. It is guaranteed to return
the same value, when it is called on two equals sets: if <code>S = T</code>, then
<code>(CHOOSE x \in S: TRUE) = (CHOOSE x \in T: TRUE)</code>. Our <code>GUESS S</code> does not have
this guarantee. It is free to return an arbitrary element of <code>S</code> each time
we call it.</p>
<p>How to implement <code>GUESS S</code>? There is no general answer to this question.
However, we know of multiple sources of non-determinism in computer science. So
we can think of <code>GUESS S</code> as being one of the following implementations:</p>
<ol>
<li>
<p><code>GUESS S</code> can be a remote procedure call in a distributed system.  Unless
we have centralized control over the distributed system, the returned value of
RPC may be non-deterministic.</p>
</li>
<li>
<p><code>GUESS S</code> can be simply the user input. In this case, the user resolves
non-determinism.</p>
</li>
<li>
<p><code>GUESS S</code> can be controlled by an adversary, who is trying to break the
system.</p>
</li>
<li>
<p><code>GUESS S</code> can pick an element by calling a pseudo-random number generator.
However, note that RNG is a very special way of resolving non-determinism: It
assumes probabilistic distribution of elements (usually, it is close to the
<a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution">uniform
distribution</a>).
Thus, the probability of producing an unfair choice of elements with RNG will
be approaching 0.</p>
</li>
</ol>
<p>As you see, there are multiple sources of non-determinism. With <code>GUESS S</code> we can
model all of them. As TLA+ does not introduce special primitives for different
kinds of non-determinism, neither do we fix any implementation of <code>GUESS S</code>.</p>
<p><strong>Halting.</strong> Note that <code>GUESS {}</code> halts the evaluation. What does it mean? The
evaluation cannot continue. It does not imply that we have found a deadlock in
our TLA+ specification. It simply means that we made wrong choices on the way.
If we would like to enumerate all possible state successors, like TLC does, we
have to backtrack (though that needs fairness of <code>GUESS</code>). In general, the
course of action depends on the program analysis that you implement. For
instance, a random simulator could simply backtrack and randomly choose another
value.</p>
<p><a name="nondetExists"></a></p>
<h3><a class="header" href="#non-determinism-in-e-x-in-s-p" id="non-determinism-in-e-x-in-s-p">Non-determinism in <code>\E x \in S: P</code></a></h3>
<p>We only have to consider the following case: <code>\E x \in S: P</code> is evaluated against
a binding <code>s</code>, and there is a primed state variable <code>y'</code> that satisfies two
conditions:</p>
<ol>
<li>The predicate <code>P</code> refers to <code>y'</code>, that is, <code>P</code> has to assign a value to <code>y'</code>.</li>
<li>The value of <code>y'</code> is not defined yet, that is, binding <code>s</code> does not have a
value for the name <code>y'</code>.</li>
</ol>
<p>If the above assumptions do not hold true, the expression <code>\E x \in S: P</code> does
not have non-determinism and it can be evaluated by following the standard
deterministic semantics of exists, see <a href="lang/./logic.html">Logic</a>.</p>
<p><strong>Note:</strong> We do not consider action operators like <code>UNCHANGED y</code>. They can be
translated into an equivalent form, e.g., <code>UNCHANGED x</code> is equivalent to <code>x' = x</code>.</p>
<p>Now it is very easy to evaluate <code>\E x \in S: P</code>. We simply evaluate the
following expression:</p>
<pre><code class="language-tla">  LET x == GUESS S IN P
</code></pre>
<p>It is the job of <code>GUESS S</code> to tell us what value of <code>x</code> should be
evaluated. There are three possible outcomes:</p>
<ol>
<li>Predicate <code>P</code> evaluates to <code>TRUE</code> when using the provided value of <code>x</code>.
In this case, <code>P</code> assigns the value of an expression <code>e</code> to <code>y'</code> as soon as
the evaluator meets the expression <code>y' = e</code>.
The evaluation may continue.</li>
<li>Predicate <code>P</code> evaluates to <code>FALSE</code> when using the provided value of <code>x</code>.
Well, that was a wrong guess. According to our semantics, the evaluation
halts. See the above discussion on &quot;halting&quot;.</li>
<li>The set <code>S</code> is empty, and <code>GUESS S</code> halts.  See the above discussion on
&quot;halting&quot;.</li>
</ol>
<p><strong>Example.</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLE x
Init == x = 0
Next ==
  \E i \in Int:
    i &gt; x /\ x' = i
</code></pre>
<p>It is easy to evaluate <code>Init</code>: It does not contain non-determinism and it
produces the binding <code>(x -&gt; 0)</code> and the state <code>[x |-&gt; 0]</code>, respectively. When
evaluating <code>Next</code> against the binding <code>(x -&gt; 0)</code>, we have plenty of choices.
Actually, we have infinitely many choices, as the set <code>Int</code> is infinite.  TLC
would immediately fail here. But there is no reason for our evaluation to fail.
Simply ask the oracle. Below we give three examples of how the evaluation
works:</p>
<pre><code>1. (GUESS Int) returns 10. (LET i == 10 IN i &gt; x /\ x' = i) is TRUE, x' is assigned 10.
2. (GUESS Int) returns 0. (LET i == 0 IN i &gt; x /\ x' = i) is FALSE. Halt.
3. (GUESS Int) returns -20. (LET i == -20 IN i &gt; x /\ x' = i) is FALSE. Halt.
</code></pre>
<p><a name="nondetOr"></a></p>
<h3><a class="header" href="#non-determinism-in-disjunctions" id="non-determinism-in-disjunctions">Non-determinism in disjunctions</a></h3>
<p>Consider a disjunction that comprises <code>n</code> clauses:</p>
<pre><code class="language-tla">  \/ P_1
  \/ P_2
  ...
  \/ P_n
</code></pre>
<p>Assume that we evaluate the disjunction against a binding <code>s</code>. Further,
let us say that <code>Unassigned(s)</code> is the set of variables that are not
defined in <code>s</code>. For every <code>P_i</code> we construct the set of state variables
<code>Use_i</code> that contains every variable <code>x'</code> that is mentioned in <code>P_i</code>.
There are three cases to consider:</p>
<ol>
<li>All sets <code>Use_i</code> agree on which variables are to be assigned.
Formally, <code>Use_i \intersect Unassigned(s) = Use_j \intersect Unassigned(s) /= {}</code>
for <code>i, j \in 1..n</code>. This is the case that we consider below.</li>
<li>Two clauses disagree on the set of variables to be assigned.
Formally, there is a pair <code>i, j \in 1..n</code> that satisfy the inequality:
<code>Use_i \intersect Unassigned(s) /= Use_j \intersect Unassigned(s)</code>.
In this case, the specification is ill-structured. TLC would
raise an error when it found a binding like this.
Apalache would detect this problem when preprocessing the specification.</li>
<li>The clauses do not assign values to the primed variables.
Formally, <code>Use_i \intersect Unassigned(s) = {}</code> for <code>i \in 1..n</code>.
This is the deterministic case. It can be evaluated by using the
deterministic semantics of <a href="lang/./booleans.html">Boolean operators</a>.</li>
</ol>
<p>We introduce a fresh variable to contain the choice of the clause.  Here we
call it <code>choice</code>. In a real implementation of an evaluator, we would have to
give it a unique name. Now we evaluate the following <em>conjunction</em>:</p>
<pre><code class="language-tla">LET choice == GUESS 1..n IN
  /\ (choice = 1) =&gt; P_1
  /\ (choice = 2) =&gt; P_2
  ...
  /\ (choice = n) =&gt; P_n
</code></pre>
<p>Importantly, at most one clause in the conjunction will be actually evaluated.
As a result, we cannot produce conflicting assignments to the primed variables.</p>
<p><strong>Example:</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLES x, y
Init == x == 0 /\ y == 0
Next ==
    \/ x &gt;= 0 /\ y' = x /\ x' = x + 1
    \/ x &lt;= 0 /\ y' = -x /\ x' = -(x + 1)
</code></pre>
<p>As you can see, the operator <code>Next</code> is non-deterministic since both clauses may
be activated when <code>x = 0</code>.</p>
<p>First, let's evaluate <code>Next</code> against the binding <code>(x -&gt; 3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE, x' is assigned 4, y' is assigned 3.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is FALSE. Halt.
</code></pre>
<p>Second, evaluate <code>Next</code> against the binding <code>(x -&gt; -3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is FALSE. Halt.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned 4, y' is assigned -3.
</code></pre>
<p>Third, evaluate <code>Next</code> against the binding <code>(x -&gt; 0, y -&gt; 0)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE. x' is assigned 1, y' is assigned 0.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned -1, y' is assigned 0.
</code></pre>
<p><em>Important note. In contrast to <a href="lang/./booleans.html">short-circuiting of
disjunction</a> in the deterministic case, we have
non-deterministic choice here. Hence, short-circuiting does not apply to
non-deterministic disjunctions.</em></p>
<p><a name="nondetIte"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-if-then-else" id="non-determinism-in-boolean-if-then-else">Non-determinism in Boolean <code>IF-THEN-ELSE</code></a></h3>
<p>For the deterministic use of <code>IF-THEN-ELSE</code>, see <a href="lang/./conditionals.html">Deterministic
conditionals</a>.</p>
<p>Consider an <code>IF-THEN-ELSE</code> expression to be evaluated in a partial state <code>s</code>:</p>
<pre><code class="language-tla">IF A THEN B ELSE C
</code></pre>
<p>In Apalache, this operator has the polymorphic type <code>(Bool, a, a) =&gt; a</code>,
where <code>a</code> can be replaced with a concrete type. Here, we consider the case
<code>(Bool, Bool, Bool) =&gt; Bool</code>.</p>
<p>Here we assume that both <code>B</code> and <code>C</code> produce Boolean results and <code>B</code> and <code>C</code>
refer to at least one primed variable <code>y'</code> that is undefined in <code>s</code>. Otherwise, the
expression can be evaluated as a <a href="lang/./conditionals.html">deterministic
conditional</a>.</p>
<p>In this case, <code>IF-THEN-ELSE</code> can be evaluated as the equivalent expression:</p>
<pre><code class="language-tla">  \/  A /\ B
  \/ ~A /\ C
</code></pre>
<p><em>We do not recommend you to use IF-THEN-ELSE with non-determinism. The structure
of the disjunction provides a clear indication that the expression may
assign to variables as a side effect. IF-THEN-ELSE has two thinking
steps: what is the expected result, and what are the possible side effects.</em></p>
<p><strong>Warning:</strong> While it is technically possible to write <code>x' = e</code> inside the
condition, the effect of <code>x' = e</code> is not obvious when <code>x'</code> is not assigned a
value.</p>
<p><a name="nondetCase"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-case" id="non-determinism-in-boolean-case">Non-determinism in Boolean <code>CASE</code></a></h3>
<p>For the deterministic use of <code>CASE</code>,
see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p><strong>CASE without OTHER.</strong>
Consider a <code>CASE</code> expression:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
</code></pre>
<p>Here, we assume that <code>e_1, ..., e_n</code> produce Boolean results.  Or, in terms of
Apalache types, this expression has the type: <code>(Bool, Bool, ..., Bool, Bool) =&gt; Bool</code>.  Otherwise, see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
</code></pre>
<p><em>Similar to IF-THEN-ELSE, we do not recommend using CASE for expressing
non-determinism. When you are using disjunction, the Boolean result and
possible side effects are expected.</em></p>
<p><strong>CASE with OTHER.</strong> The more general form of <code>CASE</code> is like follows:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
  [] OTHER -&gt; e_other
</code></pre>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
\/ ~P_1 /\ ... /\ ~P_n /\ e_other
</code></pre>
<p><em>The use of CASE with OTHER together with non-determinism is quite rare.
It is not clear why would one need a fallback option in the Boolean formula.
We recommend you to use the disjunctive form instead.</em></p>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<h1><a class="header" href="#deterministic-conditionals" id="deterministic-conditionals">Deterministic conditionals</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, we consider the instances of <code>IF-THEN-ELSE</code> and <code>CASE</code> that
may not update primed variables. For the case, when the operators inside
<code>IF-THEN-ELSE</code> or <code>CASE</code> can be used to do non-deterministic assignments, see
<a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Warning:</strong> Because frequent use of <code>IF-THEN-ELSE</code> is very common in most
programming languages, TLA+ specification authors with programming experience
often default to writing expressions such as <code>IF A THEN B ELSE C</code>.  We
encourage those authors to use this construct more sparingly.  In our
experience, the use of <code>IF-THEN-ELSE</code> is rarely required.  Many things can be
done with <a href="lang/./booleans.html">Boolean operators</a>, which provide more structure in
TLA+ code than in programming languages.  We recommend using <code>IF-THEN-ELSE</code> to
compute predicate-dependent values, not to structure code.</p>
<p><strong>Warning 2:</strong> <code>CASE</code> is considered deterministic in this
section, as it is defined with the <code>CHOOSE</code> operator in
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, Section 16.1.4.
For this reason, <code>CASE</code> should only be used when all of its guards are mutually exclusive.
Given all the intricacies of <code>CASE</code>,
we recommend using nested <code>IF-THEN-ELSE</code> instead.</p>
<hr />
<p><a name="ite"></a></p>
<h2><a class="header" href="#deterministic-if-then-else" id="deterministic-if-then-else">Deterministic IF-THEN-ELSE</a></h2>
<p><em>Use it when choosing between two values, not to structure your code.</em></p>
<p><strong>Notation:</strong> <code>IF A THEN B ELSE C</code></p>
<p><strong>LaTeX notation:</strong> the same</p>
<p><strong>Arguments:</strong> a Boolean expression <code>A</code> and two expressions <code>B</code> and <code>C</code></p>
<p><strong>Apalache type:</strong> <code>(Bool, a, a) =&gt; a</code>.  Note that <code>a</code> can be replaced with
<code>Bool</code>. If <code>a</code> is <code>Bool</code>, and only in that case, the expression <code>IF A THEN B ELSE C</code> is equivalent to <code>(A =&gt; B) /\ (~A =&gt; C)</code>.</p>
<p><strong>Effect:</strong> <code>IF A THEN B ELSE C</code> evaluates to:</p>
<ul>
<li>The value of <code>B</code>, if <code>A</code> evaluates to <code>TRUE</code>.</li>
<li>The value of <code>C</code>, if <code>A</code> evaluates to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> This is a deterministic version. For the non-deterministic
version, see <a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> If <code>A</code> evaluates to a non-Boolean value, the result is undefined.
TLC raises an error during model checking. Apalache raises a type error when
preprocessing. Additionally, if <code>B</code> and <code>C</code> may evaluate to values of different
types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> Consider the following TLA+ expression:</p>
<pre><code class="language-tla">IF x THEN 100 ELSE 0
</code></pre>
<p>As you most likely expected, this expression evaluates to <code>100</code>, when <code>x</code>
evaluates to <code>TRUE</code>; and it evaluates to <code>0</code>, when <code>x</code> evaluates to <code>FALSE</code>.</p>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">100 if x else 0
</code></pre>
<p>Note that we are using the expression syntax for <code>if-else</code> in python.
This is because we write an expression, not a series of statements that assign
values to variables!</p>
<p><a name="case"></a></p>
<h2><a class="header" href="#deterministic-case" id="deterministic-case">Deterministic CASE</a></h2>
<p><em>Read the description and never use this operator</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case.png" alt="case" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_1, ..., e_n</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool, a, Bool, a, ..., Bool, a) =&gt; a</code>, for some type <code>a</code>.
If <code>a</code> is <code>Bool</code>, then the case operator can be a part of a Boolean formula.</p>
<p><strong>Effect:</strong> Given a state <code>s</code>, define the set <code>I \subseteq 1..n</code> as follows:
The set <code>I</code> includes the index <code>j \in 1..n</code> if
and only if <code>p_j</code> evaluates to <code>TRUE</code> in the state <code>s</code>.
Then the above <code>CASE</code> expression evaluates to:</p>
<ul>
<li>the value of the expression <code>e_i</code> for some <code>i \in I</code>, if <code>I</code> is not empty; or</li>
<li>an undefined value, if the set <code>I</code> is empty.</li>
</ul>
<p>As you can see, when several predicates <code>{p_i: i \in I}</code> are evaluated
to <code>TRUE</code> in the state <code>s</code>, then the result of <code>CASE</code> is equal to one of the
elements in the set <code>{e_i: i \in I}</code>. Although the result should be stable,
the exact implementation is unknown.</p>
<p>Whenever <code>I</code> is a singleton set, the result is easy to define: Just take the
only element of <code>I</code>. <em>Hence, when <code>p_1, ..., p_n</code> are mutually exclusive,
the result is deterministic and implementation-agnostic.</em></p>
<p>Owing to the flexible semantics of simultaneously enabled predicates,
TLC interprets the above <code>CASE</code> operator as a chain of <code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE TLC!Assert(FALSE)
</code></pre>
<p><em>As TLC fixes the evaluation order, TLC may miss a bug in an arm that is never
activated in this order!</em></p>
<p>Note that the last arm of the ITE-series ends with <code>Assert(FALSE)</code>, as the
result is undefined, when no predicate evaluates to <code>TRUE</code>. As the type
of this expression cannot be precisely defined, Apalache does not support <code>CASE</code>
expressions, but only supports <code>CASE-OTHER</code> expressions (see below), which
it treats as a chain of <code>IF-THEN-ELSE</code> expressions.</p>
<p><strong>Determinism.</strong> The result of <code>CASE</code> is deterministic, if there are no primes
inside.  For the non-deterministic version, see <a href="lang/control-and-nondeterminism.html">[Control Flow and
Non-determinism]</a>.  When the predicates are
mutually exclusive, the evaluation result is clearly specified. When the predicates are
not mutually exclusive, the operator is still deterministic, but only one of
the simultaneously enabled branches is evaluated.
Which branch is evaluated depends on the <code>CHOOSE</code> operator, see <a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing. Additionally, if <code>e_1</code>, ..., <code>e_n</code>
may evaluate to values of different types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> The following expression classifies an integer variable
<code>n</code> with one of the three strings: &quot;negative&quot;, &quot;zero&quot;, or &quot;positive&quot;.</p>
<pre><code class="language-tla">  CASE n &lt; 0 -&gt; &quot;negative&quot;
    [] n = 0 -&gt; &quot;zero&quot;
    [] n &gt; 0 -&gt; &quot;positive&quot;
</code></pre>
<p>Importantly, the predicates <code>n &lt; 0</code>, <code>n = 0</code>, and <code>n &gt; 0</code> are mutually
exclusive.</p>
<p>The following expression contains non-exclusive predicates:</p>
<pre><code class="language-tla">  CASE n % 2 = 0 -&gt; &quot;even&quot;
    [] (\A k \in 2..(1 + n \div 2): n % k /= 0) -&gt; &quot;prime&quot;
    [] n % 2 = 1 -&gt; &quot;odd&quot;

</code></pre>
<p>Note that by looking at the specification, we cannot tell, whether this
expression returns &quot;odd&quot; or &quot;prime&quot;, when <code>n = 17</code>. We only know that the
case expression should consistently return the same value, whenever it is
evaluated with <code>n = 17</code>.</p>
<p><strong>Example in Python:</strong> Consider our first example in TLA+. Similar to TLC, we
give executable semantics for the fixed evaluation order of the predicates.</p>
<pre><code class="language-python">def case_example(n):
    if n &lt; 0:
        return &quot;negative&quot;
    elif n == 0:
        return &quot;zero&quot;
    elif n &gt; 0:
        return &quot;positive&quot;
</code></pre>
<p><a name="caseOther"></a></p>
<h2><a class="header" href="#deterministic-case-other" id="deterministic-case-other">Deterministic CASE-OTHER</a></h2>
<p><em>Better use IF-THEN-ELSE.</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] OTHER -&gt; e_0
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case-other.png" alt="case-other" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_0, e_1, ..., e_n</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool, a, Bool, a, ..., Bool, a, a) =&gt; a</code>, for some type <code>a</code>.
If <code>a</code> is <code>Bool</code>, then the case operator can be a part of a Boolean formula.</p>
<p><strong>Effect:</strong> This operator is equivalent to the following version of <code>CASE</code>:</p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] ~(p_1 \/ p_2 \/ ... \/ p_n) -&gt; e_0
</code></pre>
<p>Both TLC and Apalache interpret this <code>CASE</code> operator as a chain of
<code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE e_0
</code></pre>
<p>All the idiosyncrasies of <code>CASE</code> apply to <code>CASE-OTHER</code>. Hence, we recommend
using <code>IF-THEN-ELSE</code> instead of <code>CASE-OTHER</code>. Although <code>IF-THEN-ELSE</code>
is a bit more verbose, its semantics are precisely defined.</p>
<p><strong>Determinism.</strong> The result of <code>CASE-OTHER</code> is deterministic, if <code>e_0</code>, <code>e_1</code>,
..., <code>e_n</code> may not update primed variables.  For the non-deterministic version,
see <a href="lang/control-and-nondeterminism.html">[Control Flow and Non-determinism]</a>.  When
the predicates are mutually exclusive, the semantics is clearly specified. When
the predicates are not mutually exclusive, the operator is still deterministic,
but only one of the simultaneously enabled branches is evaluated. The choice of
the branch is implemented with the operator <code>CHOOSE</code>, see
<a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing.  Additionally, if <code>e_0</code>, <code>e_1</code>, ...,
<code>e_n</code> may evaluate to values of different types, Apalache raises a type error.</p>
<h1><a class="header" href="#integers" id="integers">Integers</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>The integer literals belong to the core language. They are written by
using the standard syntax: 0, 1, -1, 2, -2, 3, -3, ... Importantly, TLA+
integers are unbounded. They do not have any fixed bit width, and they cannot
overflow. In Apalache, these literals have the type <code>Int</code>.</p>
<p>The integer operators are defined in the standard module <code>Integers</code>. To use
it, write the <code>EXTENDS</code> clause in the first lines of your module. Like this:</p>
<pre><code class="language-tla">---- MODULE MyArithmetics ----
EXTENDS Integers
...
==============================
</code></pre>
<h2><a class="header" href="#integers-in-apalache-and-smt" id="integers-in-apalache-and-smt">Integers in Apalache and SMT</a></h2>
<p>Although you can write arbitrary expressions over integers in TLA+, Apalache
translates these expressions as constraints in
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>.  Some
expressions are easier to solve than the others. For instance, the expression
<code>2 * x &gt; 5</code> belongs to linear integer arithmetic, which can be solved more
efficiently than general arithmetic.  For state variables <code>x</code> and <code>y</code>, the
expression <code>x * y &gt; 5</code> belongs to non-linear integer arithmetic, which is
harder to solve than linear arithmetic.</p>
<p>When your specification is using only integer literals, e.g., <code>1</code>, <code>2</code>, <code>42</code>,
but none of the operators from the <code>Integers</code> module, the integers can
be avoided altogether.  For instance, you can replace the integer constants
with string constants, e.g., <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;42&quot;</code>. The string constants are
translated as constants in the SMT constraints. This simple trick may bring
your specification into a much simpler theory. Sometimes, this trick allows z3
to use parallel algorithms.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants-1" id="constants-1">Constants</a></h2>
<p>The module <code>Integers</code> defines two constant sets (technically, they are
operators without arguments):</p>
<ul>
<li>The set <code>Int</code> that consists of all integers. <em>This set is infinite.</em>
In Apalache, the set <code>Int</code> has the type <code>Set(Int)</code>.
A bit confusing, right? 😎</li>
<li>The set <code>Nat</code> that consists of all natural numbers, that is,
<code>Nat</code> contains every integer <code>x</code> that has the property <code>x &gt;= 0</code>.
<em>This set is infinite.</em>
In Apalache, the set <code>Nat</code> has the type... <code>Set(Int)</code>.</li>
</ul>
<hr />
<h2><a class="header" href="#operators-1" id="operators-1">Operators</a></h2>
<p><a name="range"></a></p>
<h3><a class="header" href="#integer-range" id="integer-range">Integer range</a></h3>
<p><strong>Notation:</strong> <code>a..b</code></p>
<p><strong>LaTeX notation:</strong> <code>a..b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Set(Int)</code>.</p>
<p><strong>Effect:</strong> <code>a..b</code> evaluates to the finite set <code>{i \in Int: a &lt;= i /\ i &lt;= b}</code>,
that is, the set of all integers in the range from <code>a</code> to <code>b</code>, including <code>a</code>
and <code>b</code>.  If <code>a &gt; b</code>, then <code>a..b</code> is the empty set <code>{}</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if one of the arguments
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  0..10    \* { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  -5..3    \* { -5, -4, -3, -2, -1, 0, 1, 2, 3 }
  10..0    \* { }
  &quot;a&quot;..&quot;z&quot; \* runtime error in TLC, type error in Apalache
  {1}..{3} \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> <code>a..b</code> can be written as <code>set(range(a, b + 1))</code> in
python.</p>
<pre><code class="language-python">&gt;&gt;&gt; set(range(0, 10 + 1))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
&gt;&gt;&gt; set(range(10, 2))
set()

</code></pre>
<hr />
<p><a name="uminus"></a></p>
<h3><a class="header" href="#unary-integer-negation" id="unary-integer-negation">Unary integer negation</a></h3>
<p><strong>Notation:</strong> <code>-i</code></p>
<p><strong>LaTeX notation:</strong> <code>-i</code></p>
<p><strong>Arguments:</strong> One argument. The result is only defined when the argument
evaluates to an integer.</p>
<p><strong>Apalache type:</strong> <code>Int =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>-i</code> evaluates to the negation of <code>i</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if the argument
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  -(5)    \* -5, note that '-5' is just a literal, not operator application
  -(-5)   \* 5
  -x      \* negated value of x
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; -(5)
-5
&gt;&gt;&gt; -(-5)
5

</code></pre>
<hr />
<p><a name="plus"></a></p>
<h3><a class="header" href="#integer-addition" id="integer-addition">Integer addition</a></h3>
<p><strong>Notation:</strong> <code>a + b</code></p>
<p><strong>LaTeX notation:</strong> <code>a + b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a + b</code> evaluates to the sum of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 + 3     \* 8
  (-5) + 3  \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 + 3
8
&gt;&gt;&gt; (-5) + 3
-2

</code></pre>
<hr />
<p><a name="minus"></a></p>
<h3><a class="header" href="#integer-subtraction" id="integer-subtraction">Integer subtraction</a></h3>
<p><strong>Notation:</strong> <code>a - b</code></p>
<p><strong>LaTeX notation:</strong> <code>a - b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a - b</code> evaluates to the difference of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 - 3         \* 2
  (-5) - 3      \* -8
  (-5) - (-3)   \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 - 3
2
&gt;&gt;&gt; (-5) - 3
-8
&gt;&gt;&gt; (-5) - (-3)
-2

</code></pre>
<hr />
<p><a name="mult"></a></p>
<h3><a class="header" href="#integer-multiplication" id="integer-multiplication">Integer multiplication</a></h3>
<p><strong>Notation:</strong> <code>a * b</code></p>
<p><strong>LaTeX notation:</strong> <code>a * b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a * b</code> evaluates to the product of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 * 3     \* 15
  (-5) * 3  \* -15
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 * 3
15
&gt;&gt;&gt; (-5) * 3
-15

</code></pre>
<hr />
<p><a name="div"></a></p>
<h3><a class="header" href="#integer-division" id="integer-division">Integer division</a></h3>
<p><strong>Notation:</strong> <code>a \div b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/div.png" alt="div" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a \div b</code> is defined as follows:</p>
<ol>
<li>When <code>a &gt;= 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &gt;= 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
</ol>
<p><em>When <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer division <code>a \div b</code> according to the TLA+ definition is different from the integer division <code>a / b</code> in the programming languages (C, Java, Scala, Rust).  See the
table below.</em></p>
<table><thead><tr><th>   C (clang 12)</th><th>Scala 2.13</th><th>Rust</th><th>Python 3.8.6</th><th>TLA+ (TLC)</th><th>SMT (z3 4.8.8)</th></tr></thead><tbody>
<tr><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 // 3 == 33</td><td>(100 \div 3) = 33</td><td>(assert (= 33 (div 100 3)))</td></tr>
<tr><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 // 3 == -34</td><td>((-100) \div 3) = -34</td><td>(assert (= (- 0 34) (div (- 0 100) 3)))</td></tr>
<tr><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 // (-3) == -34</td><td>(100 \div (-3)) = -34</td><td>(assert (= (- 0 33) (div 100 (- 0 3))))</td></tr>
<tr><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 // (-3) == 33</td><td>((-100) \div (-3)) = 33</td><td>(assert (= 34 (div (- 0 100) (- 0 3))))</td></tr>
</tbody></table>
<p><em>Unfortunately, <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> only gives us the definition for the case
<code>b &gt; 0</code> (that is, cases 1-2 in our description). The implementation in SMT and
TLC produce incompatible results for <code>b &lt; 0</code>. See <a href="https://github.com/informalsystems/apalache/issues/331">issue #331 in
Apalache</a>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a \div b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs
(according to TLC):</p>
<pre><code class="language-tla">    100  \div   3   \*  33
  (-100) \div   3   \* -34
    100  \div (-3)  \* -34 in TLC
  (-100) \div (-3)  \*  33 in TLC
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">&gt;&gt;&gt; 100    //   3
33
&gt;&gt;&gt; -100   //   3
-34
&gt;&gt;&gt; 100    // (-3)
-34
&gt;&gt;&gt; (-100) // (-3)
33

</code></pre>
<hr />
<p><a name="mod"></a></p>
<h3><a class="header" href="#integer-remainder" id="integer-remainder">Integer remainder</a></h3>
<p><strong>Notation:</strong> <code>a % b</code></p>
<p><strong>LaTeX notation:</strong> <code>a % b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a % b</code> is the number <code>c</code> that has the property:
<code>a = b * (a \div b) + c</code>.</p>
<p><em>Note that when <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer remainder <code>a % b</code>
according to the TLA+ definition is different from the integer remainder <code>a % b</code> in the programming languages (C, Python, Java, Scala, Rust).  See the
examples below.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a % b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs:</p>
<pre><code class="language-tla">  100  % 3      \* 1
  -100 % (-3)   \* 2
  100  % (-3)   \* 1
  -100 % 3      \* 2
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">&gt;&gt;&gt; 100 % 3
1
&gt;&gt;&gt; -100 % (-3) + 3
2
&gt;&gt;&gt; 100 % (-3) + 3
1
&gt;&gt;&gt; -100 % 3
2

</code></pre>
<hr />
<p><a name="pow"></a></p>
<h3><a class="header" href="#integer-exponentiation" id="integer-exponentiation">Integer exponentiation</a></h3>
<p><strong>Notation:</strong> <code>a^b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exp.png" alt="exp" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and these values fall into one of the several
cases:</p>
<ol>
<li><code>b &gt; 0</code>,</li>
<li><code>b = 0</code> and <code>a /= 0</code>.</li>
</ol>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a^b</code> evaluates to <code>a</code> raised to the <code>b</code>-th power:</p>
<ul>
<li>If <code>b = 1</code>, then <code>a^b</code> is defined as <code>a</code>.</li>
<li>If <code>a = 0</code> and <code>b &gt; 0</code>, then <code>a^b</code> is defined as <code>0</code>.</li>
<li>If <code>a /= 0</code> and <code>b &gt; 1</code>, then <code>a^b</code> is defined as <code>a * a^(b-1)</code>.</li>
<li>In all other cases, <code>a^b</code> is undefined.</li>
</ul>
<p>In TLA+, <code>a^b</code> extends to reals, see Chapter 18 in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.
For instance, <code>3^(-5)</code> is defined on reals. However, reals are supported
neither by TLC, nor by Apalache.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5^3       \* 125
  (-5)^3    \* -125
  0^3       \* 0
  1^5       \* 1
  (-1)^5    \* -1
  0^0       \* undefined on integers, TLC reports a runtime error
  5^(-3)    \* undefined on integers, TLC reports a runtime error
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 ** 3
125
&gt;&gt;&gt; (-5) ** 3
-125
&gt;&gt;&gt; 0 ** 3
0
&gt;&gt;&gt; 1 ** 5
1
&gt;&gt;&gt; (-1) ** 5
-1
&gt;&gt;&gt; 0 ** 0
1
&gt;&gt;&gt; 5 ** (-3)
0.008

</code></pre>
<hr />
<p><a name="lt"></a></p>
<h3><a class="header" href="#integer-less-than" id="integer-less-than">Integer less-than</a></h3>
<p><strong>Notation:</strong> <code>a &lt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &lt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &lt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is less than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt; 5     \* TRUE
  5 &lt; 5     \* FALSE
  5 &lt; 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &lt; 5
True
&gt;&gt;&gt; 5 &lt; 5
False
&gt;&gt;&gt; 5 &lt; 1
False

</code></pre>
<hr />
<p><a name="lte"></a></p>
<h3><a class="header" href="#integer-less-than-or-equal" id="integer-less-than-or-equal">Integer less-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &lt;= b</code> or <code>a =&lt; b</code> or <code>a \leq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/leq.png" alt="leq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &lt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &lt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt;= 5     \* TRUE
  5 &lt;= 5     \* TRUE
  5 &lt;= 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &lt;= 5
True
&gt;&gt;&gt; 5 &lt;= 5
True
&gt;&gt;&gt; 5 &lt;= 1
False

</code></pre>
<hr />
<p><a name="gt"></a></p>
<h3><a class="header" href="#integer-greater-than" id="integer-greater-than">Integer greater-than</a></h3>
<p><strong>Notation:</strong> <code>a &gt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &gt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &gt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is greater than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt; 5     \* FALSE
  5 &lt; 5     \* FALSE
  5 &gt; 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &gt; 5
False
&gt;&gt;&gt; 5 &gt; 5
False
&gt;&gt;&gt; 5 &gt; 1
True

</code></pre>
<hr />
<p><a name="gte"></a></p>
<h3><a class="header" href="#integer-greater-than-or-equal" id="integer-greater-than-or-equal">Integer greater-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &gt;= b</code> or <code>a \geq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/geq.png" alt="geq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &gt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &gt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt;= 5     \* FALSE
  5 &gt;= 5     \* TRUE
  5 &gt;= 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &gt;= 5
False
&gt;&gt;&gt; 5 &gt;= 5
True
&gt;&gt;&gt; 5 &gt;= 1
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality" id="equality-and-inequality">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+ and thus they are
not defined in the module <code>Integers</code>, see <a href="lang/./logic.html">Logic</a>.</p>
<h1><a class="header" href="#sets-1" id="sets-1">Sets</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Sets are the foundational data structure in TLA+. (Similar to what lists are in
Lisp and Python). The other TLA+ data structures can be all expressed with
sets: functions, records, tuples, sequences. In theory, even Booleans and
integers can be expressed with sets. In practice, TLA+ tools treat Booleans and
integers as special values that are different from sets. It is important to
understand TLA+ sets well. In contrast to programming languages, there is no
performance penalty for using sets instead of sequences: TLA+ does not have a
compiler, the efficiency is measured in the time it takes the human brain to
understand the specification.</p>
<p><strong>Immutability.</strong> In TLA+, a set is an <em>immutable</em> data structure that stores
its elements in <em>no particular order</em>. All elements of a set are unique. In
fact, those two sentences do not make a lot of sense in TLA+. We have written
them to build the bridge from a programming language to TLA+, as TLA+ does not
have a memory model. 😉</p>
<p>Sets may be constructed by enumerating values in <em>some order</em>, allowing for
duplicates:</p>
<pre><code class="language-tla">  { 1, 2, 3, 2, 4, 3 }
</code></pre>
<p>Note that the above set is equal to the sets <code>{ 1, 2, 3, 4 }</code> and <code>{ 4, 3, 2, 1 }</code>. They are actually the same set, though they are constructed by passing
various number of arguments in different orders.</p>
<p>The most basic set operation is the set membership that checks, whether a set
contains a value:</p>
<pre><code class="language-tla">  3 \in S
</code></pre>
<p>TLA+ sets are similar to
<a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset</code></a> in
Python and immutable <code>Set[Object]</code> in Java.  In contrast to programming
languages, set elements do not need hashes, as implementation efficiency is not
an issue in TLA+.</p>
<p><strong>Types.</strong> In pure TLA+, sets may contain any kinds of elements. For instance,
a set may mix integers, Booleans, and other sets:</p>
<pre><code class="language-tla">  { 2020, { &quot;is&quot; }, TRUE, &quot;fail&quot; }
</code></pre>
<p>TLC restricts set elements to comparable values. See Section 14.7.2 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. In a nutshell, if you do not mix the following five
kinds of values in a single set, TLC would not complain about your sets:</p>
<ol>
<li>Booleans,</li>
<li>integers,</li>
<li>strings,</li>
<li>sets,</li>
<li>functions, tuples, records, sequences.</li>
</ol>
<p>Apalache requires set elements to have the same type, that is, <code>Set(a)</code> for
some type <code>a</code>. This is enforced by the type checker.  (Records are an exception
to this rule, as some records can be unified to a common type.)</p>
<hr />
<h2><a class="header" href="#operators-2" id="operators-2">Operators</a></h2>
<p><a name="setEnum"></a></p>
<h3><a class="header" href="#set-constructor-by-enumeration" id="set-constructor-by-enumeration">Set constructor by enumeration</a></h3>
<p><strong>Notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>LaTeX notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>Arguments:</strong> Any number of arguments, <code>n &gt;= 0</code>.</p>
<p><strong>Apalache type:</strong> <code>(a, ..., a) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Produce the set that contains the values of the expressions <code>e_1, ..., e_n</code>, in no particular order, and only these values. If <code>n = 0</code>, the
empty set is constructed.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the set elements. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC only allows a user to construct sets out of elements that are comparable. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further and requires that all set elements have the same type.
If this is not the case, the type checker flags an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 1, 2, 3 }               \* a flat set of integers
  { { 1, 2 }, { 2, 3 } }    \* a set of sets of integers
  { FALSE, 1 }              \* a set of mixed elements.
                            \* Model checking error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; {1, 2, 3}
{1, 2, 3}
&gt;&gt;&gt; {frozenset({2, 3}), frozenset({1, 2})}
{frozenset({2, 3}), frozenset({1, 2})}
&gt;&gt;&gt; {False, 1}
{False, 1}

</code></pre>
<hr />
<p><a name="in"></a></p>
<h3><a class="header" href="#set-membership" id="set-membership">Set membership</a></h3>
<p><strong>Notation:</strong> <code>e \in S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/in-set.png" alt="in" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(a, Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>FALSE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> If you are using the special form <code>x' \in S</code>, this operator may
assign a value to <code>x'</code> as a side effect. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic, unless you are using the special form <code>x' \in S</code> to assign a value to <code>x'</code>, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \in { 1, 2, 3 }        \* TRUE
  10 \in { 1, 2, 3 }        \* FALSE
  {} \in { {1}, {2} }       \* FALSE
   1 \in { &quot;a&quot;, &quot;b&quot; }       \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>in</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1 in {1, 2, 3}
True
&gt;&gt;&gt; 10 in {1, 2, 3}
False
&gt;&gt;&gt; 1 in {&quot;a&quot;, &quot;b&quot;}
False

</code></pre>
<hr />
<p><a name="notin"></a></p>
<h3><a class="header" href="#set-non-membership" id="set-non-membership">Set non-membership</a></h3>
<p><strong>Notation:</strong> <code>e \notin S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/notin-set.png" alt="notin" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(a, Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>FALSE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>TRUE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> In contrast to <code>x' \in S</code>, the expression <code>x' \notin T</code>,
which is equivalent to <code>~(x' \in T)</code> is never
treated as an assignment in Apalache and TLC.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \notin { 1, 2, 3 }     \* FALSE
  10 \notin { 1, 2, 3 }     \* TRUE
  {} \notin { {1}, {2} }    \* TRUE
   1 \notin { &quot;a&quot;, &quot;b&quot; }    \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>not in</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1 not in {1, 2, 3}
False
&gt;&gt;&gt; 10 not in {1, 2, 3}
True
&gt;&gt;&gt; 1 not in {&quot;a&quot;, &quot;b&quot;}
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality-1" id="equality-and-inequality-1">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+,
see <a href="lang/./logic.html">Logic</a>.</p>
<hr />
<p><a name="subseteq"></a></p>
<h3><a class="header" href="#set-inclusion" id="set-inclusion">Set inclusion</a></h3>
<p><strong>Notation:</strong> <code>S \subseteq T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/subseteq.png" alt="subseteq" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> and <code>T</code> are sets, and every element of <code>S</code> is a member of <code>T</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and there is an element of <code>S</code> that
is not a member of <code>T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, if <code>S</code> and <code>T</code>
are either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2 }        \* FALSE
      { {1} } \subseteq { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                        \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&lt;=</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {1, 2} &lt;= {1, 2, 3}
True
&gt;&gt;&gt; {1, 2, 3} &lt;= {1, 2, 3}
True
&gt;&gt;&gt; {1, 2, 3} &lt;= {1, 2}
False
&gt;&gt;&gt; {frozenset({1})} &lt;= {1, 2, 3}
False

</code></pre>
<hr />
<p><a name="union"></a></p>
<h3><a class="header" href="#binary-set-union" id="binary-set-union">Binary set union</a></h3>
<p><strong>Notation:</strong> <code>S \union T</code> or <code>S \cup T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cup.png" alt="cup" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains the elements
of <code>S</code> <strong>as well</strong> as the elements of <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, if <code>S</code> and <code>T</code>
are either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \union { 1, 2, 3 } \* { 0, 1, 2, 3 }
          { } \union { 1, 2, 3 } \* { 1, 2, 3 }
  { 1, 2, 3 } \union { }         \* { 1, 2, 3 }
      { {1} } \union { 1, 2 }    \* { {1}, 1, 2 }, model checking error in TLC
                                 \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>union</code>
that can be written as <code>|</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} | {1, 2, 3}
{0, 1, 2, 3}
&gt;&gt;&gt; set() | {1, 2, 3}
{1, 2, 3}
&gt;&gt;&gt; {1, 2, 3} | set()
{1, 2, 3}
&gt;&gt;&gt; {frozenset({1})} | {1, 2}
{1, frozenset({1}), 2}

</code></pre>
<hr />
<p><a name="intersect"></a></p>
<h3><a class="header" href="#set-intersection" id="set-intersection">Set intersection</a></h3>
<p><strong>Notation:</strong> <code>S \intersect T</code> or <code>S \cap T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cap.png" alt="cap" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>also</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, if <code>S</code> and <code>T</code>
are either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \intersect { 1, 2, 3 } \* { 1, 2 }
          { } \intersect { 1, 2, 3 } \* { }
  { 1, 2, 3 } \intersect { }         \* { }
      { {1} } \intersect { 1, 2 }    \* { }, model checking error in TLC
                                     \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>intersection</code>, which
can be also written as <code>&amp;</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} &amp; {1, 2, 3}
{1, 2}
&gt;&gt;&gt; set() &amp; {1, 2, 3}
set()
&gt;&gt;&gt; {1, 2, 3} &amp; set()
set()
&gt;&gt;&gt; {frozenset({1})} &amp; {1, 2}
set()

</code></pre>
<hr />
<p><a name="setminus"></a></p>
<h3><a class="header" href="#set-difference" id="set-difference">Set difference</a></h3>
<p><strong>Notation:</strong> <code>S \ T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/setminus.png" alt="setminus" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>do not</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, if <code>S</code> and <code>T</code>
are either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \ { 1, 2, 3 }     \* { 0 }
          { } \ { 1, 2, 3 }     \* { }
  { 1, 2, 3 } \ { }             \* { 1, 2, 3 }
      { {1} } \ { 1, 2 }        \* { {1} }, model checking error in TLC
                                \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>difference</code>, which
can be also written as <code>-</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} - {1, 2, 3}
{0}
&gt;&gt;&gt; set() - {1, 2, 3}
set()
&gt;&gt;&gt; {1, 2, 3} - set()
{1, 2, 3}
&gt;&gt;&gt; {frozenset({1})} - {1, 2}
{frozenset({1})}

</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#set-filter" id="set-filter">Set filter</a></h3>
<p><strong>Notation:</strong> <code>{ x \in S: P }</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/filter.png" alt="filter" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name (or a tuple of names, see
<strong>Advanced syntax</strong>), a set, and an expression.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>{ x \in S: P }</code> has the type <code>Set(a)</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator constructs a new set <code>F</code> as follows.  For every
element <code>e</code> of <code>S</code>, do the following (we give a sequence of steps to ease
the understanding):</p>
<ol>
<li>Bind the element <code>e</code> to variable <code>x</code>,</li>
<li>Evaluate the predicate <code>P</code>,</li>
<li>If <code>P</code> evaluates to <code>TRUE</code> under the binding <code>[x |-&gt; e]</code>,
then insert the element of <code>e</code> into set <code>F</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use a tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ &lt;&lt;x, y&gt;&gt; \in S: P }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The filter expression constructs the set of elements (tuples) that make
<code>P</code> evaluate to <code>TRUE</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { x \in {1, 2, 3, 4}: x &gt; 2 }             \* { 3, 4 }
  { x \in {1, 2, 3, 4}: x &gt; 10 }            \* { }
  \* check the section on tuples to understand the following syntax
  { &lt;&lt;x, y&gt;&gt; \in (1..4) \X (1..4): y = 3 }  \* {&lt;&lt;1, 3&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;, &lt;&lt;4, 3&gt;&gt;}
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; { x for x in S if x &gt; 2 }
{3, 4}
&gt;&gt;&gt; { x for x in S if x &gt; 10 }
set()
&gt;&gt;&gt; S2 = {(x, y) for x in S for y in S}
&gt;&gt;&gt; {(x, y) for (x, y) in S2 if y == 3}
{(2, 3), (3, 3), (1, 3), (4, 3)}

</code></pre>
<hr />
<p><a name="map"></a></p>
<h3><a class="header" href="#set-map" id="set-map">Set map</a></h3>
<p><strong>Notation:</strong> <code>{ e: x \in S }</code> or <code>{ e: x \in S, y \in T }</code>, or more arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/map.png" alt="map" /></p>
<p><strong>Arguments:</strong> At least three arguments: a mapping expression,
a variable name (or a tuple of names, see <strong>Advanced syntax</strong>),
a set. Additional arguments are variables names and sets, interleaved.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description for the one-argument case:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>e</code> has the type <code>b</code>, for some type <code>b</code>,</li>
<li>the expression <code>{ e: x \in S }</code> has the type <code>Set(b)</code>.</li>
</ul>
<p><strong>Effect:</strong> We give the semantics for two arguments.
We write it as a sequence of steps to ease understanding.
This operator constructs a new set <code>M</code> as follows.
For every element <code>e_1</code> of <code>S</code> and every element <code>e_2</code> of <code>T</code>:</p>
<ol>
<li>Bind the element <code>e_1</code> to variable <code>x</code>,</li>
<li>Bind the element <code>e_2</code> to variable <code>y</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; e_1, y |-&gt; e_2]</code>,</li>
<li>Insert the value <code>e</code> into the set <code>M</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>e</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ x + y: &lt;&lt;x, y&gt;&gt; \in S }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The map expression constructs the set of expressions that are computed
under this binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 2 * x: x \in { 1, 2, 3, 4 } }          \* { 2, 4, 6, 8 }
  { x + y: x \in 1..2, y \in 1..2 }        \* { 2, 3, 4 }
  \* check the section on tuples to understand the following syntax
  { x + y: &lt;&lt;x, y&gt;&gt; \in (1..2) \X (1..2) } \* { 2, 3, 4 }
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = frozenset({1, 2, 3, 4})
&gt;&gt;&gt; {2 * x for x in S}
{8, 2, 4, 6}
&gt;&gt;&gt; T = {1, 2}
&gt;&gt;&gt; {x + y for x in T for y in T}
{2, 3, 4}
&gt;&gt;&gt; T2 = {(x, y) for x in T for y in T}
&gt;&gt;&gt; T2
{(1, 1), (1, 2), (2, 1), (2, 2)}
&gt;&gt;&gt; {x + y for (x, y) in T2}
{2, 3, 4}

</code></pre>
<hr />
<p><a name="powerset"></a></p>
<h3><a class="header" href="#powerset" id="powerset">Powerset</a></h3>
<p><strong>Notation:</strong> <code>SUBSET S</code></p>
<p><strong>LaTeX notation:</strong> <code>SUBSET S</code></p>
<p><strong>Arguments:</strong> One argument. If it is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Set(Set(a))</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator computes the set of all subsets of <code>S</code>.
That is, the set <code>T</code> the has the following properties:</p>
<ul>
<li>If <code>X \in T</code>, then <code>X \subseteq S</code>.</li>
<li>If <code>X \subseteq S</code>, then <code>X \in T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set.  Apalache
produces a static type error, if the type of <code>S</code> is not a set type.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SUBSET { 0, 1, 2 }
  \* { {}, {0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}, {0, 1, 2} }
</code></pre>
<p><strong>Example in Python:</strong> An implementation of <code>SUBSET S</code> in Python is not trivial.
To appreciate the power of TLA+, see <a href="lang/./examples/subset.py">subset.py</a>.</p>
<hr />
<p><a name="flatten"></a></p>
<h3><a class="header" href="#set-flattening" id="set-flattening">Set flattening</a></h3>
<p><strong>Notation:</strong> <code>UNION S</code></p>
<p><strong>LaTeX notation:</strong> <code>UNION S</code></p>
<p><strong>Warning:</strong> Do not confuse <code>UNION S</code> with <code>S \union T</code>. These are two
different operators, which unfortunately have similar-looking names.</p>
<p><strong>Arguments:</strong> One argument. If it is not a set of sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Given that <code>S</code> is a set of sets, this operator computes the set
<code>T</code> that contains all elements of elements of <code>S</code>:</p>
<ul>
<li>If <code>X \in S</code>, then <code>X \subseteq T</code>.</li>
<li>If <code>y \in T</code>, then there is a set <code>Y \in S</code> that contains <code>y</code>,
that is, <code>y \in Y</code>.</li>
</ul>
<p>In particular, <code>UNION</code> flattens the powerset that is produced by <code>SUBSET</code>. That
is, <code>(UNION (SUBSET S)) = S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set of sets.
Apalache produces a static type error, if the type of <code>S</code> is different from a
set of sets.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  UNION { {0, 1}, {1, 2}, {3} }
  \* { 0, 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong> In contrast to <code>SUBSET S</code>, an implementation of <code>UNION S</code>
in Python is quite simple:</p>
<pre><code class="language-python">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; s = { frozenset({0, 1}), frozenset({1, 2}), frozenset({3}) }
&gt;&gt;&gt; reduce((lambda x, y: x | y), s, set())
{0, 1, 2, 3}

</code></pre>
<hr />
<p><a name="card"></a></p>
<h3><a class="header" href="#set-cardinality" id="set-cardinality">Set cardinality</a></h3>
<p><strong>Notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>Warning:</strong> <code>Cardinality(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, or <code>S</code> is an infinite set,
the result is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Int</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> <code>Cardinality(S)</code> evaluates to the number of (unique) elements in
<code>S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set, or when it is an
infinite set.  Apalache produces a static type error, if the type of <code>S</code> is
different from a finite set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  Cardinality({ 1, 2, 3 })
  \* 3
</code></pre>
<p><strong>Example in Python:</strong> In Python, we just use the set size:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = { 1, 2, 3 }
&gt;&gt;&gt; len(S)
3

</code></pre>
<hr />
<p><a name="finite"></a></p>
<h3><a class="header" href="#set-finiteness" id="set-finiteness">Set finiteness</a></h3>
<p><strong>Notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>Warning:</strong> <code>IsFinite(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, the result is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> <code>IsFinite(S)</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, when <code>S</code> is a finite set,</li>
<li><code>FALSE</code>, when <code>S</code> is an infinite set.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set. Apalache
produces a static type error, if the type of <code>S</code> is different from a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  IsFiniteSet({ 1, 2, 3 })      \* TRUE
  IsFiniteSet(BOOLEAN)          \* TRUE
  IsFiniteSet(Nat)              \* FALSE
  IsFiniteSet(Int)              \* FALSE
  IsFiniteSet(STRING)           \* FALSE
</code></pre>
<p><strong>Example in Python:</strong> We can construct only finite sets in Python.</p>
<h1><a class="header" href="#logic-1" id="logic-1">Logic</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, you find the operators that – together with <a href="lang/./sets.html">Sets</a>
– form the foundation of TLA+. It is a bit strange that we call this section
&quot;Logic&quot;, as the whole language of TLA+ is a logic. However, the operators of
this section are often seen in first-order logic, as opposed to propositional
logic (see <a href="lang/./booleans.html">Booleans</a>).</p>
<p>Note that the special form <code>\E y \in S: x' = y</code> is often used to express
non-determinism in TLA+. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>. In this
section, we only consider the deterministic use of the existential quantifier.</p>
<hr />
<p><a name="forallBounded"></a></p>
<h3><a class="header" href="#bounded-universal-quantifier" id="bounded-universal-quantifier">Bounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall-bounded.png" alt="forall-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined. You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>\A x \in S: P</code> has the type <code>Bool</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\A x \in S: P</code> evaluates to <code>TRUE</code>, if for every element <code>e</code> of <code>S</code>, the
expression <code>P</code> evaluates to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\A x \in S: P</code> evaluates to <code>FALSE</code>, if there exists an element
<code>e</code> of <code>S</code> that makes the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\A x \in S: P</code> evaluates to
<code>TRUE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\A x \in S: P</code> evaluates to <code>TRUE</code>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type
of <code>x</code> that is expected in the predicate <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\A &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\A x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\A x \in S: \A y \in T: P</code>. Similarly, <code>\A x, y \in S: P</code> is syntax sugar for
<code>\A x \in S: \A y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \A x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \A x \in {1, 2, 3, 4}:
    x &gt; 2
  \* FALSE
  \* check the section on tuples to understand the following syntax
  \A &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; all(x &gt; 0 for x in S)
True
&gt;&gt;&gt; all(x &gt; 2 for x in S)
False
&gt;&gt;&gt; T2 = {(x, y) for x in [1, 2] for y in [3, 4]}
&gt;&gt;&gt; all(x &lt; y for (x, y) in T2)
True

</code></pre>
<hr />
<p><a name="existsBounded"></a></p>
<h3><a class="header" href="#bounded-existential-quantifier" id="bounded-existential-quantifier">Bounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists-bounded.png" alt="exists-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined.You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>\E x \in S: P</code> has the type <code>Bool</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\E x \in S: P</code> evaluates to <code>TRUE</code>, if there is an element <code>e</code> of <code>S</code>
that makes the expression <code>P</code> evaluate to <code>TRUE</code> against the binding
<code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\E x \in S: P</code> evaluates to <code>FALSE</code>, if for all elements
<code>e</code> of <code>S</code>, the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to
<code>FALSE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to <code>FALSE</code>.</em></p>
<p>As you probably have noticed, <code>\E x \in S: P</code> is equivalent to <code>~(\A x \in S: ~P)</code>, and <code>\A x \in S: P</code> is equivalent to <code>~(\E x \in S: ~P)</code>. This is called
<em>duality</em> in logic. But take care!  If <code>\E x \in S: P</code> may act as a
non-deterministic assignment, duality does not work anymore!  See <a href="lang/./control-and-nondeterminism.html">Control
Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic when <code>P</code> contains no action operators (including
the prime operator <code>'</code>).  For the non-deterministic case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>P</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\E &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\E x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\E x \in S: \E y \in T: P</code>. Similarly, <code>\E x, y \in S: P</code> is syntax sugar for <code>\E x \in S: \E y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \E x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \E x \in {1, 2, 3, 4}:
    x &gt; 2
  \* TRUE
  \* check the section on tuples to understand the following syntax
  \E &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; any(x &gt; 0 for x in S)
True
&gt;&gt;&gt; any(x &gt; 2 for x in S)
True
&gt;&gt;&gt; T2 = {(x, y) for x in [1, 2] for y in [3, 4]}
&gt;&gt;&gt; any(x &lt; y for (x, y) in T2)
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality" id="equality">Equality</a></h3>
<p><em>A foundational operator in TLA+</em></p>
<p><strong>Notation:</strong> <code>e_1 = e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/eq.png" alt="eq" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Apalache type:</strong> <code>(a, a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It tests the values
of <code>e_1</code> and <code>e_2</code> for structural equality. The exact effect depends on the
values of <code>e_1</code> and <code>e_2</code>. Let <code>e_1</code> and <code>e_2</code> evaluate to the values
<code>v_1</code> and <code>v_2</code>. Then <code>e_1 = e_2</code> evaluates to:</p>
<ul>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are Booleans, then <code>e_1 = e_2</code> evaluates to <code>v_1 &lt;=&gt; v_2</code>.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are integers, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same integers.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are strings, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same strings.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are sets, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">v_1 \subseteq v_2 /\ v_2 \subseteq v_1
</code></pre>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are functions, tuples, records, or sequences,
then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">  DOMAIN v_1 = DOMAIN v_2 /\ \A x \in DOMAIN v_1: v_1[x] = v_2[x]
</code></pre>
</li>
<li>
<p>In other cases, <code>e_1 = e_2</code> evaluates to <code>FALSE</code> if the values have comparable types.</p>
</li>
<li>
<p>TLC and Apalache report an error, if the values have incomparable types.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic, unless <code>e_1</code> has the form <code>x'</code>, which can be
interpreted as an assignment to the variable <code>x'</code>.  For the non-deterministic
case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments. TLC flags a
model checking error, if <code>e_1</code> and <code>e_2</code> evaluate to incomparable values.
Apalache produces a static type error, if the types of <code>e_1</code> and <code>e_2</code> do not
match.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  FALSE = FALSE         \* TRUE
  FALSE = TRUE          \* FALSE
  10 = 20               \* FALSE
  15 = 15               \* TRUE
  &quot;Hello&quot; = &quot;world&quot;     \* FALSE
  &quot;Hello&quot; = &quot;hello&quot;     \* FALSE
  &quot;Bob&quot; = &quot;Bob&quot;         \* TRUE
  { 1, 2 } = { 2, 3}    \* FALSE
  { 1, 2 } = { 2, 1}    \* TRUE
  { 1 } \ { 1 } = { &quot;a&quot; } \ { &quot;a&quot; } \* TRUE in pure TLA+ and TLC,
                                    \* type error in Apalache
  { { 1, 2 } } = { { 1, 2, 2, 2 } } \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;a&quot;&gt;&gt;           \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;b&quot;&gt;&gt;           \* FALSE
  &lt;&lt;1, FALSE&gt;&gt; = &lt;&lt;2&gt;&gt;              \* FALSE in pure TLA+ and TLC,
                                    \* type error in Apalache
  &lt;&lt;1, 2&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;            \* FALSE in pure TLA+ and TLC,
                                    \* FALSE in Apalache, when both values
                                    \* are treated as sequences
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1, b |-&gt; 3 ]           \* TRUE
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1 ]                    \* FALSE
  [ x \in 2..2 |-&gt; x + x ] = [ x \in {2} |-&gt; 2 * x ]    \* TRUE
  [ x \in 2..3 |-&gt; x + x ] = [ x \in {2, 3} |-&gt; 2 * x ] \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> The standard data structures also implement
structural equality in Python, though we have to be careful to
use <code>==</code> instead of <code>=</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; False == False
True
&gt;&gt;&gt; False == True
False
&gt;&gt;&gt; 10 == 20
False
&gt;&gt;&gt; 15 == 15
True
&gt;&gt;&gt; &quot;Hello&quot; == &quot;world&quot;
False
&gt;&gt;&gt; &quot;Hello&quot; == &quot;hello&quot;
False
&gt;&gt;&gt; &quot;Bob&quot; == &quot;Bob&quot;
True
&gt;&gt;&gt; { 1, 2 } == { 2, 3 }
False
&gt;&gt;&gt; { 1, 2 } == { 2, 1 }
True
&gt;&gt;&gt; { 1 } - { 1 } == { &quot;a&quot; } - { &quot;a&quot; }
True
&gt;&gt;&gt; { frozenset({ 1, 2 }) } == { frozenset({ 1, 2, 2, 2 }) }
True
&gt;&gt;&gt; (1, &quot;a&quot;) == (1, &quot;a&quot;)
True
&gt;&gt;&gt; (1, &quot;a&quot;) == (1, &quot;b&quot;)
False
&gt;&gt;&gt; (1, False) == (2, )
False
&gt;&gt;&gt; (1, 2) == (1, 2, 3)
False
&gt;&gt;&gt; { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1, &quot;b&quot;: 3 }
True
&gt;&gt;&gt; { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1 }
False
&gt;&gt;&gt; { x: (x + x) for x in { 2 } } == { x: (x * x) for x in { 2 } }
True
&gt;&gt;&gt; { x: (x + x) for x in { 2, 3 } } == { x: 2 * x for x in { 2, 3 } }
True

</code></pre>
<hr />
<p><a name="neq"></a></p>
<h3><a class="header" href="#inequality" id="inequality">Inequality</a></h3>
<p><strong>Notation:</strong> <code>e_1 /= e_2</code> or <code>e_1 # e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/ne.png" alt="ne" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Apalache type:</strong> <code>(a, a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator is syntax sugar for <code>~(e_1 = e_2)</code>. Full stop.</p>
<hr />
<p><a name="chooseBounded"></a></p>
<h3><a class="header" href="#bounded-choice" id="bounded-choice">Bounded Choice</a></h3>
<p><em>This operator causes a lot of confusion. Read carefully!</em></p>
<p><strong>Notation:</strong> <code>CHOOSE x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/choose-bounded.png" alt="choose-bounded" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name, a set, and an
expression.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>CHOOSE x \in S: P</code> has the type <code>a</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator implements a black-box algorithm that <em>somehow</em> picks
one element from the set <code>{x \in S: P}</code>.  Is it an algorithm? Yes! <code>CHOOSE x \in S: P</code> is deterministic.  When you give it two equal sets and two equivalent
predicates, <code>CHOOSE</code> produces the same value. Formally, the only known property
of <code>CHOOSE</code> is as follows (which is slightly more general than what we wrote
above):</p>
<pre><code class="language-tla">  {x \in S: P} = {y \in T: Q} =&gt;
      (CHOOSE x \in S: P) = (CHOOSE y \in T: Q)
</code></pre>
<p>Importantly, when <code>{x \in S: P} = {}</code>, the expression <code>CHOOSE x \ in S: P</code>
evaluates to an undefined value.</p>
<p>How does <code>CHOOSE</code> actually work? TLA+ does not fix an algorithm for <code>CHOOSE</code> by
design. Maybe it returns the first element of the set? Sets are not ordered, so
there is no first element.</p>
<p>Why should you use <code>CHOOSE</code>? Actually, you should not. Unless you have no other
choice 🎀</p>
<p>There are two common use cases, where the use of <code>CHOOSE</code> is well justified:</p>
<ul>
<li>
<p><em>Use case 1:</em> Retrieving the only element of a singleton set. If you know
that <code>Cardinality({x \in S: P}) = 1</code>, then <code>CHOOSE x \in S: P</code> returns
the only element of <code>{x \in S: P}</code>. No magic.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L63-L64">Min and Max in FiniteSetsExt</a>.</p>
</li>
<li>
<p><em>Use case 2:</em> Enumerating set elements in a fixed but unknown order.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L5-L17">ReduceSet in FiniteSetsExt</a>.</p>
</li>
</ul>
<p>In other cases, we believe that <code>CHOOSE</code> is bound to do <a href="https://en.wikipedia.org/wiki/Program_synthesis">Program synthesis</a>.
So TLC does some form of synthesis by brute force when it has to evaluate
<code>CHOOSE</code>.</p>
<p><strong>Determinism:</strong> Deterministic. Very much deterministic. Don't try to model
non-determinism with <code>CHOOSE</code>. For non-determinism, see:
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p>Apalache picks a set element that satisfies the predicate <code>P</code>, but it does not
guarantee the repeatability property of <code>CHOOSE</code>. It does not guarantee
non-determinism either. Interestingly, this behavior does not really make a
difference for the use cases 1 and 2. If you believe that this causes a problem
in your specification, <a href="https://github.com/informalsystems/apalache/issues/new/choose">open an issue...</a></p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  CHOOSE x \in 1..3: x &gt;= 3
  \* 3
  CHOOSE x \in 1..3:
    \A y \in 1..3: y &gt;= x
  \* 1, the minimum
  CHOOSE f \in [ 1..10 -&gt; BOOLEAN ]:
    \E x, y \in DOMAIN f:
      f[x] /\ ~f[y]
  \* some Boolean function from 1..10 that covers FALSE and TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python does not have anything similar to <code>CHOOSE</code>.
The closest possible solution is to sort the filtered set by the string values
and pick the first one (or the last one). So we have introduced a particular
way of implementing CHOOSE, see <a href="lang/./examples/choose.py">choose.py</a>:</p>
<pre><code class="language-python"># A fixed implementation of CHOOSE x \in S: TRUE
# that sorts the set by the string representation and picks the head
def choose(s):
    lst = sorted([(str(e), e) for e in s], key=(lambda pair: pair[0]))
    (_, e) = lst[0]
    return e


if __name__ == &quot;__main__&quot;:
    s = { 1, 2, 3}
    print(&quot;CHOOSE {} = {}&quot;.format(s, choose(s)))
    s2 = { frozenset({1}), frozenset({2}), frozenset({3})}
    print(&quot;CHOOSE {} = {}&quot;.format(s2, choose(s2)))
</code></pre>
<hr />
<p><a name="forall"></a></p>
<h3><a class="header" href="#unbounded-universal-quantifier" id="unbounded-universal-quantifier">Unbounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall.png" alt="forall" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when every element in the logical universe makes the expression <code>P</code> evaluate to
<code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to consider
only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="exists"></a></p>
<h3><a class="header" href="#unbounded-existential-quantifier" id="unbounded-existential-quantifier">Unbounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists.png" alt="exists" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when at least one element in the logical universe makes the expression <code>P</code>
evaluate to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to
consider only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="choose"></a></p>
<h3><a class="header" href="#unbounded-choose" id="unbounded-choose">Unbounded CHOOSE</a></h3>
<p><strong>Notation:</strong> <code>CHOOSE x: P</code></p>
<p><strong>LaTeX notation:</strong> CHOOSE x: P</p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to some value <code>v</code> in the logical universe
that evaluates <code>P</code> to <code>TRUE</code> against the binding <code>[x |-&gt; v]</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe and introduce a fixed rule for enumerating its elements.</p>
<p>Congratulations! You have reached the bottom of this page. If you want to learn
more about unbounded <code>CHOOSE</code>, read Section 16.1.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<h1><a class="header" href="#functions-1" id="functions-1">Functions</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p><strong>Contributors:</strong> @konnov, @shonfeder, @Kukovec, @Alexander-N</p>
<p>Functions are probably the second most used TLA+ data structure after sets. TLA+
functions are not like functions in programming languages. In programming
languages, functions contain code that calls other functions. Although it is
technically possible to use functions when constructing a function in TLA+,
functions are more often used like tables or dictionaries: they are simple maps from a set of inputs to a set of outputs. For instance, in
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">Two-phase commit</a>, the function <code>rmState</code> stores the transaction state for
each process:</p>
<table><thead><tr><th>argument</th><th>rmState[argument]</th></tr></thead><tbody>
<tr><td>&quot;process1&quot;</td><td>&quot;working&quot;</td></tr>
<tr><td>&quot;process2&quot;</td><td>&quot;aborted&quot;</td></tr>
<tr><td>&quot;process3&quot;</td><td>&quot;prepared&quot;</td></tr>
</tbody></table>
<p>In the above table, the first column is the value of the function argument,
while the second column is the function result. An important property of this
table is that no value appears in the first column more than once, so
<em>every argument value is assigned at most one result value</em>.</p>
<p>Importantly, every function is defined in terms of the set of arguments over which it is
defined. This set is called the function's <em>domain</em>.  There is even a special
operator <code>DOMAIN f</code>, which returns the domain of a function <code>f</code>.</p>
<p>In contrast to TLA+ operators, <em>TLA+ functions are proper values</em>, so they can be
used as values in more complex data structures.</p>
<p><strong>Construction.</strong> Typically, the predicate <code>Init</code> constructs a function that
maps all elements of its domain to a default value.
In the example below we map the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code>
to the value &quot;working&quot;:</p>
<pre><code class="language-tla">Init ==
  rmState = [ p \in { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } |-&gt; &quot;working&quot; ]
</code></pre>
<p>In general, we can construct a function by giving an expression that shows us
how to map every argument to the result:</p>
<pre><code class="language-tla">  [ fahrenheit \in Int |-&gt; (fahrenheit - 32) * 5 \div 9 ]
</code></pre>
<p>Note that this function effectively defines an infinite table, as the set <code>Int</code>
is infinite. Both TLC and Apalache would give up on a function with an infinite
domain. (Though in the above example, it is obvious that we could treat the
function symbolically, without enumerating all of its elements.)</p>
<p>Another way to construct a function is to <em>non-deterministically</em> pick one
from a set of functions by using the <a href="lang/functions.html#funSetCtor">function set constructor</a>, <code>-&gt;</code>. E.g.:</p>
<pre><code class="language-tla">Init ==
    \E f \in [ { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } -&gt;
                    { &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; } ]:
        rmState = f
</code></pre>
<p>In the above example we are not talking about one function that is somehow
initialized &quot;by default&quot;. Rather, we say that <code>rmState</code> can be set to an
arbitrary function that receives arguments from the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code> and returns values that belong to the set <code>{ &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; }</code>. As a result, TLC has to
enumerate all possible functions that match this constraint. On the contrary,
Apalache introduces one instance of a function and restricts it with the
symbolic constraints. So it efficiently considers all possible functions
without enumerating them. However, this trick only works with existential
quantifiers. If you use a universal quantifier over a set of functions,
both TLC and Apalache unfold this set.</p>
<p><strong>Immutability</strong>. As you can see, TLA+ functions are similar to <a href="https://docs.python.org/3/library/stdtypes.html#dict">dictionaries
in Python</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">maps in
Java</a> rather than
to normal functions in programming languages. However, <em>TLA+ functions are
immutable</em>. Hence, they are even closer to immutable maps in Scala.  As in the
case of sets, you do not need to define hash or equality, in order to use
functions.</p>
<p>If you want to update a function, you have to produce another function and
describe how it is different from the original function. Luckily, TLA+ provides
you with operators for describing these updates in a compact way: By using the
function constructor (above) along with <code>EXCEPT</code>. For instance, to produce a
new function from <code>rmState</code>, we write the following:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process3&quot;] = &quot;committed&quot; ]
</code></pre>
<p>This new function is like <code>rmState</code>, except that it returns <code>&quot;committed&quot;</code>
on the argument <code>&quot;process3&quot;</code>:</p>
<pre><code class="language-tla">&quot;process1&quot;,  &quot;working&quot;
&quot;process2&quot;,  &quot;aborted&quot;
&quot;process3&quot;,  &quot;committed&quot;
</code></pre>
<p><em>Importantly, you cannot extend the function domain by using <code>EXCEPT</code>.</em>
For instance, the following expression produces the function that is
equivalent to <code>rmState</code>:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process10&quot;] = &quot;working&quot; ]
</code></pre>
<p><strong>Types.</strong> In pure TLA+, functions are free to mix values of different types in their domains.
See the example below:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
        IF x \in { 1, &quot;TRUE&quot;, TRUE}
        THEN TRUE
        ELSE FALSE
  ]
</code></pre>
<p>TLA+ functions are also free to return any kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
    CASE x = 0 -&gt; 1
      [] x = 1 -&gt; 0
      [] x = &quot;FALSE&quot; -&gt; &quot;TRUE&quot;
      [] x = &quot;TRUE&quot; -&gt; &quot;FALSE&quot;
      [] x = FALSE -&gt; TRUE
      OTHER -&gt; FALSE
  ]
</code></pre>
<p>As in the case of <a href="lang/./sets.html">sets</a>, TLC restricts function domains to comparable
values. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. So, TLC rejects the two
examples that are given above.</p>
<p>However, functions in TLC are free to return different kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 1, 2 } |-&gt;
                        IF x = 1 THEN FALSE ELSE 3 ]
</code></pre>
<p>This is why, in pure TLA+ and TLC, records, tuples, and sequences are just
functions over particular domains (finite sets of strings and finite sets
of integers).</p>
<p>Apalache enforces stricter types. It has designated types for all four
data structures: general functions, records, tuples, and sequences.
Moreover, all elements of the function domain must have the same type.
The same is true for the codomain. That is, general functions have the
type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>. This is enforced
by the type checker.</p>
<p>In this sense, the type restrictions of Apalache are similar to those for the
generic collections of Java and Scala.  As a result, the type checker in
Apalache rejects the three above examples.</p>
<p><strong>TLA+ functions and Python dictionaries</strong>. As we mentioned before, TLA+
functions are similar to maps and dictionaries in programming languages. To
demonstrate this similarity, let us compare TLA+ functions with <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">Python
dictionaries</a>.  Consider a TLA+ function <code>price</code> that is defined as follows:</p>
<pre><code class="language-tla">  [ meal \in { &quot;Schnitzel&quot;, &quot;Gulash&quot;, &quot;Cordon bleu&quot; } |-&gt;
                CASE meal = &quot;Schnitzel&quot;     -&gt; 18
                  [] meal = &quot;Gulash&quot;        -&gt; 11
                  [] meal = &quot;Cordon bleu&quot;   -&gt; 12
  ]
</code></pre>
<p>If we had to define a similar dictionary in Python, we would normally introduce
a Python dictionary like follows:</p>
<pre><code class="language-python">py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
</code></pre>
<p>As long as we are using the variable <code>py_price</code> to access the dictionary, our
approach works. For instance, we can type the following in the python shell:</p>
<pre><code class="language-python"># similar to DOMAIN price in TLA+
py_price.keys()
</code></pre>
<p>In the above example, we used <code>py_price.keys()</code>, which produces a view of the
mutable dictionary's keys. In TLA+, <code>DOMAIN</code> returns a set. If we want to
faithfully model the effect of <code>DOMAIN</code>, then we have to produce an immutable
set. We use
<a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset</code></a>,
which is a less famous cousin of the python <code>set</code>. A frozen set can be
inserted into another set, in contrast to the standard (mutable) set.</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; frozenset(py_price.keys()) == frozenset({'Schnitzel', 'Gulash', 'Cordon bleu'})
True

</code></pre>
<p>We can also apply our python dictionary similar to the TLA+ function <code>price</code>:</p>
<pre><code class="language-tla">&gt;&gt;&gt; # similar to price[&quot;Schnitzel&quot;] in TLA+
&gt;&gt;&gt; py_price[&quot;Schnitzel&quot;]
18

</code></pre>
<p>However, there is a catch! What if you like to put the function <code>price</code> in a
set? In TLA+, this is easy: Simply construct the singleton set that contains
the function <code>price</code>.</p>
<pre><code class="language-tla"># TLA+: wrapping a function with a set
{ price }
</code></pre>
<p>Unfortunately, this does not work as easy in Python:</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; # python expects hashable and immutable data structures inside sets
&gt;&gt;&gt; frozenset({py_price})
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'

</code></pre>
<p>Of course, this is an implementation detail of Python and it has nothing to do
with TLA+. This example probably demonstrates that the built-in primitives of
TLA+ are more powerful than the standard primitives of many programming
languages (see <a href="https://github.com/informalsystems/apalache/discussions/551">this
discussion</a>).</p>
<p>Alternatively, we could represent a TLA+ function in Python as a set
of pairs <code>(key, value)</code> and implement TLA+ function operators over such a
set. Surely, this implementation would be inefficient, but this is not
an issue for a <em>specification language</em> such as TLA+. For instance:</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; { tuple(py_price.items()) }
{(('Schnitzel', 18), ('Gulash', 11), ('Cordon bleu', 12))}

</code></pre>
<p>If we try to implement TLA+-like operators over this data structure, things
will get complicated very quickly. For this reason, we are just using
mutable dictionaries in the Python examples in the rest of this text.</p>
<hr />
<h2><a class="header" href="#operators-3" id="operators-3">Operators</a></h2>
<hr />
<p><a name="funCtor"></a></p>
<h3><a class="header" href="#function-constructor" id="function-constructor">Function constructor</a></h3>
<p><strong>Notation:</strong> <code>[ x \in S |-&gt; e ]</code> or <code>[ x \in S, y \in T |-&gt; e ]</code>, or more
arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/fun-ctor.png" alt="fun-ctor" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name (or a tuple of names,
see <strong>Advanced syntax</strong>), a set, and a mapping expression. Instead of one
variable and one set, you can use multiple variables and multiple sets.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>e</code> has the type <code>b</code>, for some type <code>b</code>,</li>
<li>the expression <code>[ x \in S |-&gt; e ]</code> has the type <code>a -&gt; b</code>.</li>
</ul>
<p><strong>Effect:</strong> We give the semantics for one argument.  We write a sequence of
steps to ease the understanding.  This operator constructs a function <code>f</code> over
the domain <code>S</code> as follows.  For every element <code>elem</code> of <code>S</code>, do the following:</p>
<ol>
<li>Bind the element <code>elem</code> to variable <code>x</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; elem]</code> and store it
in a temporary variable called <code>result</code>.</li>
<li>Set <code>f[elem]</code> to <code>result</code>.</li>
</ol>
<p>Of course, the semantics of the function constructor in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>
does not require us to compute the function at all. We believe that
our description helps you to see that there is a way to compute this data
structure, though in a very straightforward and inefficient way.</p>
<p>If the function constructor introduces multiple variables, then the constructed
function maps a tuple to a value. See <strong>Example</strong>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the function domain and the mapping
expression. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC accepts function domains of comparable values. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further: It requires the function domain to be well-typed (as a
set), and it requires the mapping expression <code>e</code> to be well-typed. If this
is not the case, the type checker flags an error.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>[ &lt;&lt;x, y&gt;&gt; \in S |-&gt; x + y ]</code>. In this case, for
every element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound
to <code>e[2]</code>. The function constructor maps the tuples from <code>S</code> to the values
that are computed under such a binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ x \in 1..3 |-&gt; 2 * x ]  \* a function that maps 1, 2, 3 to 2, 4, 6
  [ x, y \in 1..3 |-&gt; x * y ]
    \* a function that maps &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;, ..., &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
    \* to 1, 2, 3, ..., 6, 9
  [ &lt;&lt;x, y&gt;&gt; \in (1..3) \X (4..6) |-&gt; x + y ]
    \* a function that maps &lt;&lt;1, 4&gt;&gt;, &lt;&lt;1, 5&gt;&gt;, &lt;&lt;1, 6&gt;&gt;, ..., &lt;&lt;2, 6&gt;&gt;, &lt;&lt;3, 6&gt;&gt;
    \* to 5, 6, 7, ..., 8, 9
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]]
    \* a function that maps a number n from 1 to 3
    \* to a function from 1..n to n + i. Like an array of arrays.
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: [ x \in 1..3 |-&gt; 2 * x ]
&gt;&gt;&gt; {x: 2 * x for x in range(1, 4)}
{1: 2, 2: 4, 3: 6}
&gt;&gt;&gt; # TLA: [ x, y \in 1..3 |-&gt; x * y ]
&gt;&gt;&gt; {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}
{(1, 1): 1, (1, 2): 2, (1, 3): 3, (2, 1): 2, (2, 2): 4, (2, 3): 6, (3, 1): 3, (3, 2): 6, (3, 3): 9}
&gt;&gt;&gt; # TLA: [ &lt;&lt;x, y&gt;&gt; \in (1..3) \X (4..6) |-&gt; x + y ]
&gt;&gt;&gt; xy = {(x, y) for x in range(1, 4) for y in range(4, 7)}
&gt;&gt;&gt; {(x, y): x + y for (x, y) in xy}
{(2, 4): 6, (3, 4): 7, (1, 5): 6, (1, 4): 5, (2, 6): 8, (3, 6): 9, (1, 6): 7, (2, 5): 7, (3, 5): 8}
&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt;
&gt;&gt;&gt; #        [ i \in 1..n |-&gt; n + i ]]
&gt;&gt;&gt; {
...     n: {i: n + i for i in range(1, n + 1)}
...     for n in range(1, 4)
... }
{1: {1: 2}, 2: {1: 3, 2: 4}, 3: {1: 4, 2: 5, 3: 6}}

</code></pre>
<hr />
<p><a name="funSetCtor"></a></p>
<h3><a class="header" href="#function-set-constructor" id="function-set-constructor">Function set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ S -&gt; T ]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/funset.png" alt="funset" /></p>
<p><strong>Arguments:</strong> Two arguments. Both have to be sets. Otherwise, the result is
undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(b)) =&gt; Set(a -&gt; b)</code>, for some types <code>a</code> and <code>b</code>.</p>
<p><strong>Effect:</strong> This operator constructs the set of all possible functions that
have <code>S</code> as their domain, and for each argument <code>x \in S</code> return a value <code>y \in T</code>.</p>
<p>Note that if one of the sets is infinite, then the set <code>[S -&gt; T]</code> is infinite
too. TLC flags an error, if <code>S</code> or <code>T</code> are infinite. Apalache flags an error,
if <code>S</code> is infinite, but when it does not have to explicitly construct <code>[S -&gt; T]</code>, it may accept infinite <code>T</code>. For instance:</p>
<pre><code class="language-tla">  \E f \in [ 1..3 -&gt; 4..6]:
    ...
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, if <code>S</code> and <code>T</code> are not sets, then <code>[S -&gt; T]</code>
is undefined. If either <code>S</code> or <code>T</code> is not a set, TLC flags a model checking error.
Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ 1..3 -&gt; 1..100 ]
    \* the set of functions that map 1, 2, 3 to values from 1 to 100
  [ Int -&gt; BOOLEAN ]
    \* The infinite set of functions that map every integer to a Boolean.
    \* Error in TLC.
</code></pre>
<p><strong>Example in Python:</strong> We do not give here the code that enumerates all
functions. It should be similar in spirit to <a href="lang/./examples/subset.py">subset.py</a>,
but it should enumerate strings over the alphabet of <code>0..(Cardinality(T) - 1)</code>
values, rather than over the alphabet of 2 values.</p>
<p><a name="funApp"></a></p>
<h3><a class="header" href="#function-application" id="function-application">Function application</a></h3>
<p><strong>Notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>Arguments:</strong> At least two arguments. The first one should be a function,
the other arguments are the arguments to the function. Several arguments
are treated as a tuple. For instance, <code>f[e_1, ..., e_n]</code> is shorthand for
<code>f[&lt;&lt;e_1, ..., e_n&gt;&gt;]</code>.</p>
<p><strong>Apalache type:</strong> In the single-index case, the type is
<code>((a -&gt; b), a) =&gt; b</code>, for some types <code>a</code> and <code>b</code>. In the multi-index case,
the type is <code>((&lt;&lt;a_1, ..., a_n&gt;&gt; -&gt; b), a_1, ..., a_n) =&gt; b</code>.</p>
<p><strong>Effect:</strong> This operator is evaluated as follows:</p>
<ul>
<li>If <code>e \in DOMAIN f</code>, then <code>f[e]</code> evaluates to the value that function
<code>f</code> associates with the value of <code>e</code>.</li>
<li>If <code>e \notin DOMAIN f</code>, then the value is undefined.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>e \notin DOMAIN f</code>, TLC flags a model checking error.</p>
<p>When <code>e</code> has a type incompatible with the type of <code>DOMAIN f</code>, Apalache flags
a type error. When <code>e \notin DOMAIN f</code>, Apalache assigns some type-compatible
value to <code>f[e]</code>, but does not report any error. This is not a bug in Apalache,
but a feature of the SMT encoding. Usually, an illegal access surfaces
somewhere, when checking a specification.  If you want to detect an access
outside of the function domain, instrument your code with an additional state
variable.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [x \in 1..10 |-&gt; x * x][5]                \* 25
  [x \in 1..3, y \in 1..3 |-&gt; x * y][2, 2]
    \* Result = 4. Accessing a two-dimensional matrix by a pair
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]][3][2]
    \* The first access returns a function, the second access returns 5.
  [x \in 1..10 |-&gt; x * x][100]              \* model checking error in TLC,
                                            \* Apalache produces some value
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: [x \in 1..10 |-&gt; x * x][5]
&gt;&gt;&gt; {x: x * x for x in range(1, 11)}[5]
25
&gt;&gt;&gt; # TLA: [x, y \in 1..3 |-&gt; x * y][2, 2]
&gt;&gt;&gt; {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}[(2, 2)]
4
&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]][3][2]
&gt;&gt;&gt; {n: {i: n + i for i in range(1, n + 1)} for n in range(1, 4)}[3][2]
5

</code></pre>
<hr />
<p><a name="except"></a></p>
<h3><a class="header" href="#function-replacement" id="function-replacement">Function replacement</a></h3>
<p><strong>Notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>Arguments:</strong> At least three arguments. The first one should be a function,
the other arguments are interleaved pairs of argument expressions and value
expressions.</p>
<p><strong>Apalache type:</strong> In the case of a single-point update, the type is simple:
<code>(a -&gt; b, a, b) =&gt; (a -&gt; b)</code>, for some types <code>a</code> and <code>b</code>. In the general case,
the type is: <code>(a -&gt; b, a, b, ..., a, b) =&gt; (a -&gt; b)</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to a new function <code>g</code> that is constructed
as follows:</p>
<ul>
<li>Set the domain of <code>g</code> to <code>DOMAIN f</code>.</li>
<li>For every element <code>b \in DOMAIN f</code>, do:
<ul>
<li>If <code>b = a_i</code> for some <code>i \in 1..n</code>, then set <code>g[b]</code> to <code>e_i</code>.</li>
<li>If <code>b \notin { a_1, ..., a_n }</code>, then set <code>g[b]</code> to <code>f[b]</code>.</li>
</ul>
</li>
</ul>
<p><em>Importantly, <code>g</code> is a new function: the function <code>f</code> is not modified!</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>a_i \notin DOMAIN f</code> for some <code>i \in 1..n</code>,
TLC flags a model checking error.</p>
<p>When <code>a_1, ..., a_n</code> are not type-compatible with the type of <code>DOMAIN f</code>,
Apalache flags a type error. When <code>a_i \notin DOMAIN f</code>, Apalache ignores this
argument. This is consistent with the semantics of TLA+ in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p><strong>Advanced syntax:</strong> There are three extensions to the basic syntax.</p>
<p><em>Extension 1</em>. If the domain elements of a function <code>f</code> are tuples, then, similar to
function application, the expressions <code>a_1, ..., a_n</code> can be written without
the tuple braces <code>&lt;&lt;...&gt;&gt;</code>. For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1, 2] = e ]
</code></pre>
<p>In the above example, the element <code>f[&lt;&lt;1, 2&gt;&gt;]</code> is replaced with <code>e</code>.
As you can see, this is just syntax sugar.</p>
<p><em>Extension 2</em>. The operator <code>EXCEPT</code> introduces an implicit alias <code>@</code>
that refers to the element <code>f[a_i]</code> that is going to be replaced:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1] = @ + 1, ![2] = @ + 3 ]
</code></pre>
<p>In the above example, the element <code>f[1]</code> is replaced with <code>f[1] + 1</code>, whereas
the element <code>f[2]</code> is replaced with <code>f[2] + 3</code>.
This is also syntax sugar.</p>
<p><em>Extension 3</em>. The advanced syntax of <code>EXCEPT</code> allows for chained replacements.
For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1][a_2]...[a_n] = e ]
</code></pre>
<p>This is syntax sugar for:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1] =
    [ @ EXCEPT ![a_2] =
        ...
            [ @ EXCEPT ![a_n] = e ]]]
</code></pre>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET f1 == [ p \in 1..3 |-&gt; &quot;working&quot; ] IN
  [ f1 EXCEPT ![2] = &quot;aborted&quot; ]
    \* a new function that maps: 1 to &quot;working&quot;, 2 to &quot;aborted&quot;, 3 to &quot;working&quot;

  LET f2 == [x \in 1..3, y \in 1..3 |-&gt; x * y] IN
  [ f2 EXCEPT ![1, 1] = 0 ]
    \* a new function that maps:
    \*   &lt;&lt;1, 1&gt;&gt; to 0, and &lt;&lt;x, y&gt;&gt; to x * y when `x /= 0` or `y /= 0`
  LET f3 ==  [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]] IN
  [ f3 EXCEPT ![2][2] = 100 ]
    \* a new function that maps:
    \*   1 to the function that maps: 1 to 2
    \*   2 to the function that maps: 1 to 3, 2 to 100
    \*   3 to the function that maps: 1 to 4, 2 to 5, 3 to 6
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance. Additionally, given a Python
dictionary <code>f</code>, we write <code>f.items()</code> to quickly iterate over the pairs of keys
and values. Had we wanted to follow the TLA+ semantics more precisely, we would
have to enumerate over the keys in the function domain and apply the function to
each key, in order to obtain the value that is associated with the key.  This
code would be less efficient than the idiomatic Python code.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: LET f1 == [ p \in 1..3 |-&gt; &quot;working&quot; ] IN
&gt;&gt;&gt; f1 = {i: &quot;working&quot; for i in range(1, 4)}
&gt;&gt;&gt; f1
{1: 'working', 2: 'working', 3: 'working'}
&gt;&gt;&gt; # TLA: [ f1 EXCEPT ![2] = &quot;aborted&quot; ]
&gt;&gt;&gt; g1 = {i: status if i != 2 else &quot;aborted&quot; for i, status in f1.items()}
&gt;&gt;&gt; g1
{1: 'working', 2: 'aborted', 3: 'working'}

&gt;&gt;&gt; # TLA: LET f2 == [x, y \in 1..3 |-&gt; x * y] IN
&gt;&gt;&gt; f2 = {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}
&gt;&gt;&gt; # TLA: [ f2 EXCEPT ![1, 1] = 0
&gt;&gt;&gt; g2 = {k: v if k != (1, 1) else 0 for k, v in f2.items()}
&gt;&gt;&gt; g2
{(1, 1): 0, (1, 2): 2, (1, 3): 3, (2, 1): 2, (2, 2): 4, (2, 3): 6, (3, 1): 3, (3, 2): 6, (3, 3): 9}

&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]]
&gt;&gt;&gt; f3 = {n: {i: n + i for i in range(1, n + 1)} for n in range(4)}
&gt;&gt;&gt; # TLA: [ f3 EXCEPT ![2][2] = 100 ]
&gt;&gt;&gt; g3 = f3.copy()
&gt;&gt;&gt; g3[2][2] = 100
&gt;&gt;&gt; g3
{0: {}, 1: {1: 2}, 2: {1: 3, 2: 100}, 3: {1: 4, 2: 5, 3: 6}}

</code></pre>
<hr />
<p><a name="domain"></a></p>
<h3><a class="header" href="#function-domain" id="function-domain">Function domain</a></h3>
<p><strong>Notation:</strong> <code>DOMAIN f</code></p>
<p><strong>LaTeX notation:</strong> <code>DOMAIN f</code></p>
<p><strong>Arguments:</strong> One argument, which should be a function
(respectively, a record, tuple, sequence).</p>
<p><strong>Apalache type:</strong> <code>(a -&gt; b) =&gt; Set(a)</code>.</p>
<p><strong>Effect:</strong> <code>DOMAIN f</code> returns the set of values, on which the function
has been defined, see: Function constructor and Function set constructor.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if <code>f</code> is not a function
(respectively, a record, tuple, or sequence). TLC flags a model checking error
if <code>f</code> is a value that does not have a domain. Apalache flags a type checking
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET f == [ x \in 1..3 |-&gt; 2 * x ] IN
  DOMAIN f \* { 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; f = {x: 2 * x for x in range(1, 4)}
&gt;&gt;&gt; f.keys()
dict_keys([1, 2, 3])

</code></pre>
<p>In the above code, we write <code>f.keys()</code> to obtain an iterable over the
dictionary keys, which can be used in a further python code. In a more
principled approach that follows the semantics of TLA+, we would have to
produce a set, that is to write:</p>
<pre><code class="language-python">frozenset(f.keys())
</code></pre>
<h1><a class="header" href="#records-1" id="records-1">Records</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Records in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that have the
following properties:</p>
<ul>
<li>The domain of a record contains only strings.</li>
<li>The domain of a record is finite.</li>
</ul>
<p>That is it in pure TLA+. Essentially, TLA+ is following the duck-typing principle for
records: Any function over strings can be also treated as a record, and vice
versa, a record is also a function. So you can use all function operators on
records too.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
records.  For instance, the following example shows how to construct a record
that has two fields: Field <code>&quot;a&quot;</code> is assigned value <code>2</code>, and field <code>&quot;b&quot;</code> is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  [ a |-&gt; 2, b |-&gt; TRUE ]
</code></pre>
<p>Similar to the function set <code>[S -&gt; T]</code>, there is a record set constructor:</p>
<pre><code class="language-tla">  [ name: { &quot;Alice&quot;, &quot;Bob&quot; }, year_of_birth: 1900..2000 ]
</code></pre>
<p>The expression in the above example constructs a set of records that have: the
<code>name</code> field set to either &quot;Alice&quot; or &quot;Bob&quot;, and the <code>year_of_birth</code> field set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> TLA+ provides you with a shorthand operator for accessing
a record field by following C-style struct-member notation. For example:</p>
<pre><code class="language-tla">  r.myField
</code></pre>
<p>This is essentially syntax sugar for <code>r[&quot;myField&quot;]</code>.</p>
<p><strong>Immutability</strong>. As records are special kinds of <a href="lang/./functions.html">functions</a>,
records are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions and records. When Apalache processes a
record constructor, it assigns the record type to the result. This record type
carries the information about the names of the record fields and their types.
Similarly, Apalache assigns the type of a set of records, when it processes a
record set constructor.  See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types.</p>
<p><em>Owing to the type information, records are translated into SMT more efficiently
by Apalache than the general functions.</em></p>
<p>Every record is assigned a type in Apalache. For instance, the record
<code>[name |-&gt; &quot;A&quot;, a |-&gt; 3]</code> has the type <code>{ name: Str, a: Int }</code>. In contrast to
TLC, the type checker statically flags an error, if a spec is trying to access
a non-existent field. Consider the following example:</p>
<pre><code class="language-tla">--------------------------- MODULE TestUnsafeRecord ---------------------------
\* the record in R has the type { name: Str, a: Int}
R == [name |-&gt; &quot;A&quot;, a |-&gt; 3]

\* the type checker will report a type error in UnsafeAccess
UnsafeAccess == R.b
===============================================================================
</code></pre>
<p>If we run the type checker, it will immediately find unsafe record access:</p>
<pre><code class="language-sh">$ apalache-mc typecheck TestUnsafeRecord.tla
...
[TestUnsafeRecord.tla:6:17-6:19]: Cannot apply R() to the argument &quot;b&quot; in R()[&quot;b&quot;]
</code></pre>
<p>Sometimes, record types can get tricky, when operators in a spec only have
partial type information. For example, consider operator <code>GetX</code>:</p>
<pre><code class="language-tla">----------------------------- MODULE TestGetX ---------------------------------
GetX(r) == r.x
===============================================================================
</code></pre>
<p>If we run the type checker, it will complain about not being able to infer
the type of <code>r</code>:</p>
<pre><code class="language-sh">$ apalache-mc typecheck TestGetX.tla
...
[TestGetX.tla:2:12-2:14]: Cannot apply r to the argument &quot;x&quot; in r[&quot;x&quot;].
</code></pre>
<p>The reason is simple: The type checker could not decide, whether <code>r</code> was a
record or a function. Even if we knew that <code>r</code> was a record, what type should
it have? Luckily, the Apalache type checker supports <a href="https://en.wikipedia.org/wiki/Row_polymorphism">Row polymorphism</a>.
Hence, we can specify the type of <code>r</code> as follows:</p>
<pre><code class="language-tla">--------------------- MODULE TestGetXWithRows ---------------------------------
\* @type: { x: a, b } =&gt; a;
GetX(r) == r.x
===============================================================================
</code></pre>
<p>In the type annotation, we are saying that <code>r</code> is a record that has the field
<code>x</code> of some type <code>a</code> (which we don't know), and the rest of the record does not
matter. This matches our intuition about the behavior of <code>GetX</code>. This time the
type checker does not complain:</p>
<pre><code class="language-sh">$ apalache-mc typecheck TestGetXWithRows.tla
...
Type checker [OK]
</code></pre>
<p>In untyped TLA+, it is common to mix records of different shapes into sets. For
instance, see how the variable <code>msgs</code> is updated in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>. It is not
possible to do so with records in Apalache. To address this pattern, Apalache
supports <a href="lang/./variants.html">Variants</a>.</p>
<hr />
<h2><a class="header" href="#operators-4" id="operators-4">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="recCtor"></a></p>
<h3><a class="header" href="#record-constructor" id="record-constructor">Record constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/rec-ctor.png" alt="rec-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Apalache type:</strong> <code>(a_1, ..., a_n) =&gt; { field_1: a_1, ..., field_n: a_n }</code>, for
some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The record constructor returns a function <code>r</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN r</code> to <code>{ field_1, ..., field_n }</code>,</li>
<li>set <code>r[field_i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ]
    \* A record that has two fields:
    \* field &quot;name&quot; that is equal to &quot;Printer&quot;, and field &quot;port&quot; that is equal to 631.
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; { &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 }
{'name': 'Printer', 'port': 631}

</code></pre>
<hr />
<p><a name="recSetCtor"></a></p>
<h3><a class="header" href="#record-set-constructor" id="record-set-constructor">Record set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1: S_1, ..., field_n: S_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/recset-ctor.png" alt="recset-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Apalache type:</strong> <code>(Set(a_1), ..., Set(a_n)) =&gt; Set({ field_1: a_1, ..., field_n: a_n })</code>, for some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The record set constructor <code>[ field_1: S_1, ..., field_n: S_n]</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ [ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]: e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite records sets in some cases, when one record
is picked with <code>\E r \in [ field_1: S_1, ..., field_n: S_n]</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name: { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, port: 1..65535 ]
    \* A set of records. Each has two fields:
    \* field &quot;name&quot; that has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \* field &quot;port&quot; that has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  frozenset({ frozendict({ &quot;name&quot;: n, &quot;port&quot;: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="recApp"></a></p>
<h3><a class="header" href="#access-by-field-name" id="access-by-field-name">Access by field name</a></h3>
<p><strong>Notation:</strong> <code>r.field_i</code></p>
<p><strong>LaTeX notation:</strong> <code>r.field_i</code></p>
<p><strong>Arguments:</strong> Two arguments: a record and a field name (as an identifier).</p>
<p><strong>Apalache type:</strong> <code>{ field_i: a, b } =&gt; b</code>, for some types <code>a</code> and <code>b</code>
(technically, <code>b</code> is a row that captures the other fields).</p>
<p>Note that <code>r.field_i</code> is just a syntax sugar for <code>r[&quot;field_i&quot;]</code> in TLA+.
Hence, if the Apalache type checker cannot choose between <code>r</code> being a record or
a function, the type checker fails with a type error. In this case, you have to
type-annotate the definition that contains <code>r</code>.</p>
<p><strong>Effect:</strong> As records are also functions, this operator works as <code>r[&quot;field_i&quot;]</code>.</p>
<p>Apalache treats records as values of a record type. In comparison to the
general function application <code>r[&quot;field&quot;]</code>, the operator <code>r.field</code> is handled
much more efficiently in Apalache. Due to the use of types, Apalache can
extract the respective field when translating the access expression into SMT.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET r == [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ] IN
  r.name    \* &quot;Printer&quot;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; r = { &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 }
&gt;&gt;&gt; r[&quot;name&quot;]
'Printer'

</code></pre>
<hr />
<h1><a class="header" href="#tuples-1" id="tuples-1">Tuples</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Tuples in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that satisfy one
of the following properties:</p>
<ul>
<li>The domain is either empty, that is, <code>{}</code>, or</li>
<li>The domain is <code>1..n</code> for some <code>n &gt; 0</code>.</li>
</ul>
<p>That is right. You can construct the empty tuple <code>&lt;&lt;&gt;&gt;</code> in TLA+ as well as a
single-element tuple, e.g., <code>&lt;&lt;1&gt;&gt;</code>. You can also construct pairs, triples, an
so on, e.g., <code>&lt;&lt;1, TRUE&gt;&gt;</code>, <code>&lt;&lt;&quot;Hello&quot;, &quot;world&quot;, 2020&gt;&gt;</code>. If you think that
empty tuples do not make sense: In TLA+, there is no difference between tuples
and <a href="lang/./sequences.html">sequences</a>.  Again, it is duck typing: Any function with
the domain <code>1..n</code> can be also treated as a tuple (or a sequence!), and vice
versa, tuples and sequences are also functions. So you can use all function
operators on tuples.</p>
<p>Importantly, the domain of a nonempty tuple is <code>1..n</code> for some <code>n &gt; 0</code>. So tuples never
have a 0th element. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us 1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
tuples. For instance, the following example shows how to construct a tuple
that has two fields: Field 1 is assigned value <code>2</code>, and field 2 is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  &lt;&lt;2, TRUE&gt;&gt;
</code></pre>
<p>There is a tuple set constructor, which is well-known as <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>:</p>
<pre><code class="language-tla">  { &quot;Alice&quot;, &quot;Bob&quot; } \X (1900..2000)
</code></pre>
<p>The expression in the above example constructs a set of tuples <code>&lt;&lt;n, y&gt;&gt;</code>: the
first field <code>n</code> is set to either &quot;Alice&quot; or &quot;Bob&quot;, and the second field <code>y</code> is set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>t[2]</code>.</p>
<p><strong>Immutability</strong>. As tuples are special kinds of <a href="lang/./functions.html">functions</a>,
tuples are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>A -&gt; B</code> that
restricts the arguments and results as follows: the arguments have the type
<code>A</code> and the results have the type <code>B</code>. A sequence has the type
<code>Seq(C)</code>, which restricts the sequence elements to have the same type <code>C</code>. In
contrast, tuples have more fine-grained types in Apalache: <code>&lt;&lt;T_1&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2, T_3&gt;&gt;</code> and so on. As a result, different tuple fields are
allowed to carry elements of different types, whereas functions and sequences
are not allowed to do that. See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types for details.</p>
<p>As tuples are also sequences in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence. Usually, this problem is resolved by annotating the
type of a variable or the type of a user operator. See <a href="lang/../../HOWTOs/howto-write-type-annotations.html">HOWTO write type
annotations</a>.</p>
<p><em>Owing to the type information, tuples are translated into SMT much more efficiently
by Apalache than the general functions and sequences!</em></p>
<hr />
<h2><a class="header" href="#operators-5" id="operators-5">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="tuple"></a></p>
<h3><a class="header" href="#tuplesequence-constructor" id="tuplesequence-constructor">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Apalache type:</strong> This operator is overloaded. There are two potential types:</p>
<ol>
<li>A tuple constructor: <code>(a_1, ..., a_n) =&gt; &lt;&lt;a_1, ..., a_n&gt;&gt;</code>,
for some types <code>a_1, ..., a_n</code>.</li>
<li>A sequence constructor: <code>(a, ..., a) =&gt; Seq(a)</code>, for some type <code>a</code>.</li>
</ol>
<p>That is why the Apalache type checker is sometimes asking you to add annotations,
in order to resolve this ambiguity.</p>
<p><strong>Effect:</strong> The tuple constructor returns a function <code>t</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a [type
annotation].</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
tuples, which are indexed with 0!. If we want to stick to the
principle &quot;tuples are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">&gt;&gt;&gt; (&quot;Printer&quot;, 631)          # the pythonic way, introducing fields 0 and 1
('Printer', 631)
&gt;&gt;&gt; { 1: &quot;Printer&quot;, 2: 631 }  # the &quot;tuples-are-functions&quot; way
{1: 'Printer', 2: 631}

</code></pre>
<hr />
<p><a name="times"></a></p>
<h3><a class="header" href="#cartesian-product" id="cartesian-product">Cartesian product</a></h3>
<p><strong>Notation:</strong> <code>S_1 \X ... \X S_n</code> (or <code>S_1 \times ... \times S_n</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/set-prod.png" alt="set-prod" /></p>
<p><strong>Arguments:</strong> At least two arguments. All of them should be sets.</p>
<p><strong>Apalache type:</strong> <code>(Set(a_1), ..., Set(a_n)) =&gt; Set(&lt;&lt;a_1, ..., a_n&gt;&gt;)</code>,
for some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The Cartesian product <code>S_1 \X ... \X S_n</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ &lt;&lt; e_1, ..., e_n &gt;&gt; : e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite sets in some cases, e.g., when one tuple
is picked with <code>\E t \in S_1 \X S_2</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } \X (1..65535)
    \* A set of tuples. Each tuple has two fields:
    \*   - field 1 has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \*   - field 2 has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a set of python tuples (indexed with 0, 1, ...)
  frozenset({ (n, p)
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
  # the TLA+ way
  frozenset({ frozendict({ 1: n, 2: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-1" id="function-application-1">Function application</a></h3>
<p>As tuples are functions, you can access tuple elements by <a href="lang/./functions.html#funApp">function
application</a>, e.g., <code>tup[2]</code>. However, in the case of a
tuple, the type of the function application will be: <code>(&lt;&lt;a_1, ..., a_i, ..., a_n&gt;&gt;, Int) =&gt; a_i</code>, for some types <code>a_1, ..., a_n</code>.</p>
<h1><a class="header" href="#sequences-1" id="sequences-1">Sequences</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>On the surface, TLA+ sequences are very much like lists in your programming
language of choice.  If you are writing code in Java, Python, Lisp, C++, Scala,
you will be tempted to use sequences in TLA+ too. This is simply due to the
fact that arrays, vectors, and lists are the most efficient collections in
programming languages (for many tasks, but not all of them). But TLA+ is not
about efficient compilation of your data structures!  Many algorithms can be
expressed in a much nicer way with <a href="lang/./sets.html">sets</a> and
<a href="lang/./functions.html">functions</a>. In general, use sequences when you really need
them.</p>
<p>In pure TLA+, sequences are just <a href="lang/./tuples">tuples</a>. As a tuple, a sequence is
a function of the domain <code>1..n</code> for some <code>n &gt;= 0</code> (the domain may be empty).
The duck-typing principle applies to sequences too: Any function with the domain <code>1..n</code> can also be
treated as a sequence (or a tuple), and vice versa, tuples and sequences are
also functions. So you can use all function and tuple operators on sequences.</p>
<p>Importantly, the domain of a sequence is <code>1..n</code> for some <code>n &gt;= 0</code>. So the
indices in a sequence start with 1, not 0. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us
1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p>The operators on sequences are defined in the standard module <code>Sequences</code>. To
use it, write the <code>EXTENDS</code> clause in the first lines of your module. Like
this:</p>
<pre><code class="language-tla">------ MODULE MyLists ----====
EXTENDS Sequences
...
==============================
</code></pre>
<p><strong>Construction.</strong> Sequences are constructed exactly as tuples in TLA+:</p>
<pre><code class="language-tla">  &lt;&lt;2, 4, 8&gt;&gt;
</code></pre>
<p>Sometimes, you have to talk about all possible sequences. The operator
<code>Seq(S)</code> constructs the set of all (finite) sequences that draw elements
from the set <code>S</code>. For instance, <code>&lt;&lt;1, 2, 2, 1&gt;&gt; \in Seq({1, 2, 3})</code>.
Note that <code>Seq(S)</code> is an infinite set. To use it with TLC, you often have
to override this operator, see <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, page 237.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>s[2]</code>.</p>
<p><strong>Immutability.</strong> As sequences are special kinds of
<a href="lang/./functions.html">functions</a>, sequences are immutable.</p>
<p><strong>Sequence operators.</strong> The module <code>Sequences</code> provides you with convenient
operators on sequences:</p>
<ul>
<li>Add to end: <code>Append(s, e)</code></li>
<li>First and rest: <code>Head(s)</code> and <code>Tail(s)</code></li>
<li>Length: <code>Len(s)</code></li>
<li>Concatenation: <code>s \o t</code></li>
<li>Subsequence: <code>SubSeq(s, i, k)</code></li>
<li>Sequence filter: <code>SelectSeq(s, Test)</code></li>
</ul>
<p>See the detailed description in <strong>Operators</strong>.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>T_1 -&gt; T_2</code> that
restricts the arguments and results as follows: the arguments have the type
<code>T_1</code> and the results have the type <code>T_2</code>. A sequence has the type <code>Seq(T_3)</code>,
which restricts the sequence elements to have the same type <code>T_3</code>.</p>
<p>As sequences are also tuples in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence.  Usually, this problem is resolved by annotating the
type of a variable or the type of a user operator. See <a href="lang/../../HOWTOs/howto-write-type-annotations.html">HOWTO write type
annotations</a>.</p>
<p><em>The current SMT encoding of sequences in Apalache is not optimized,
so operations on sequences are often significantly slower than operations
on sets.</em></p>
<hr />
<h2><a class="header" href="#operators-6" id="operators-6">Operators</a></h2>
<p><a name="seqCtor"></a></p>
<h3><a class="header" href="#tuplesequence-constructor-1" id="tuplesequence-constructor-1">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Apalache type:</strong> This operator is overloaded. There are two potential types:</p>
<ol>
<li>A tuple constructor: <code>(a_1, ..., a_n) =&gt; &lt;&lt;a_1, ..., a_n&gt;&gt;</code>,
for some types <code>a_1, ..., a_n</code>.</li>
<li>A sequence constructor: <code>(a, ..., a) =&gt; Seq(a)</code>, for some type <code>a</code>.</li>
</ol>
<p>That is why the Apalache type checker is sometimes asking you to add annotations,
in order to resolve this ambiguity.</p>
<p><strong>Effect:</strong> The tuple/sequence constructor returns a function <code>t</code> that is
constructed as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a [type
annotation].</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
lists, which are indexed with 0!. If we want to stick to the
principle &quot;sequences are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">&gt;&gt;&gt; [&quot;Printer&quot;, 631]          # the pythonic way, a two-element list
['Printer', 631]
&gt;&gt;&gt; { 1: &quot;Printer&quot;, 2: 631 }  # the &quot;sequences-are-functions&quot; way
{1: 'Printer', 2: 631}

</code></pre>
<hr />
<p><a name="append"></a></p>
<h3><a class="header" href="#sequence-append" id="sequence-append">Sequence append</a></h3>
<p><strong>Notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>LaTeX notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>Arguments:</strong> Two arguments. The first argument should be a sequence, the
second one is an arbitrary expression.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), a) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Append(seq, e)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \union { Len(seq) + 1 }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i]</code> for <code>i \in 1..Len(seq)</code>.</li>
<li>set <code>newSeq[Len(seq) + 1]</code> to <code>e</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined in pure TLA+.
TLC raises a model checking error. Apalache flags a static type error.</p>
<p>Apalache flags a static type error, when the type of <code>e</code> is not compatible with
the type of the sequence elements.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Append(&lt;&lt;1, 2&gt;&gt;, 5)
    \* The sequence &lt;&lt;1, 2, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l = [ 1, 2 ]
&gt;&gt;&gt; l.append(5)
&gt;&gt;&gt; l
[1, 2, 5]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 1, 2: 2 }
&gt;&gt;&gt; { i: l[i] if i &lt;= len(l) else 5
...   for i in range(1, len(l) + 2) }
{1: 1, 2: 2, 3: 5}

</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-2" id="function-application-2">Function application</a></h3>
<p>As sequences are functions, you can access sequence elements with <a href="lang/./functions.html#funApp">function
application</a>, e.g., <code>seq[2]</code>.  However, in the case of a
sequence, the type of the function application is: <code>(Seq(a), Int) =&gt; a</code>, for
some type <code>a</code>.</p>
<hr />
<p><a name="head"></a></p>
<h3><a class="header" href="#sequence-head" id="sequence-head">Sequence head</a></h3>
<p><strong>Notation:</strong> <code>Head(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Head(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; a</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Head(seq)</code> evaluates to <code>seq[1]</code>.
If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Head(&lt;&lt;3, 4&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4 ]
&gt;&gt;&gt; l[0]
3
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4 }
&gt;&gt;&gt; l[1]
3

</code></pre>
<hr />
<p><a name="tail"></a></p>
<h3><a class="header" href="#sequence-tail" id="sequence-tail">Sequence tail</a></h3>
<p><strong>Notation:</strong> <code>Tail(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Tail(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Tail(seq)</code> constructs a new sequence <code>newSeq</code> as
follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \ { Len(seq) }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i + 1]</code> for <code>i \in 1..(Len(seq) - 1)</code>.</li>
</ul>
<p>If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Tail</code> is a very simple operation that just increments <code>start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Tail(&lt;&lt;3, 4, 5&gt;&gt;)
    \* &lt;&lt;4, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4, 5 ]
&gt;&gt;&gt; l[1:]
[4, 5]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 5 }
&gt;&gt;&gt; { i: l[i + 1] for i in range(1, len(l)) }
{1: 4, 2: 5}

</code></pre>
<hr />
<p><a name="len"></a></p>
<h3><a class="header" href="#sequence-length" id="sequence-length">Sequence length</a></h3>
<p><strong>Notation:</strong> <code>Len(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Len(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; Int</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Len(seq)</code> is semantically equivalent to
<code>Cardinality(DOMAIN seq)</code>.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Len</code> is simply computed as <code>end - start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Len(&lt;&lt;3, 4, 5&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4, 5 ]
&gt;&gt;&gt; len(l)
3
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 5 }
&gt;&gt;&gt; len(l.keys())
3

</code></pre>
<hr />
<p><a name="concat"></a></p>
<h3><a class="header" href="#sequence-concatenation" id="sequence-concatenation">Sequence concatenation</a></h3>
<p><strong>Notation:</strong> <code>s \o t</code> (or <code>s \circ t</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/seq-concat.png" alt="seq-concat" /></p>
<p><strong>Arguments:</strong> Two arguments: both should be sequences (or tuples).</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), Seq(a)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>s \o t</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(Len(s) + Len(t))</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[i]</code> for <code>i \in 1..Len(s)</code>.</li>
<li>set <code>newSeq[Len(s) + i]</code> to <code>t[i]</code> for <code>i \in 1..Len(t)</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>s</code> and <code>t</code> must be sequences, that is, functions
over integers <code>1..n</code> and <code>1..k</code> for some <code>n</code> and <code>k</code>. Otherwise, the result is
undefined in pure TLA+. TLC raises a model checking error. Apalache flags a
static type error.</p>
<p>Apalache flags a static type error, when the types of <code>s</code> and <code>t</code> are
incompatible.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;3, 5&gt;&gt; \o &lt;&lt;7, 9&gt;&gt;
    \* The sequence &lt;&lt;3, 5, 7, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l1 = [ 3, 5 ]
&gt;&gt;&gt; l2 = [ 7, 9 ]
&gt;&gt;&gt; l1 + l2
[3, 5, 7, 9]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l1 = { 1: 3, 2: 5 }
&gt;&gt;&gt; l2 = { 1: 7, 2: 9 }
&gt;&gt;&gt; { i: l1[i] if i &lt;= len(l1) else l2[i - len(l1)]
...    for i in range(1, len(l1) + len(l2) + 1) }
{1: 3, 2: 5, 3: 7, 4: 9}

</code></pre>
<hr />
<p><a name="subseq"></a></p>
<h3><a class="header" href="#subsequence" id="subsequence">Subsequence</a></h3>
<p><strong>Notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>LaTeX notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>Arguments:</strong> Three arguments: a sequence (tuple), and two integers.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), Int, Int) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>SubSeq(seq, m, n)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(n - m)</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[m + i - 1]</code> for <code>i \in 1..(n - m + 1)</code>.</li>
</ul>
<p>If <code>m &gt; n</code>, then <code>newSeq</code> is equal to the empty sequence <code>&lt;&lt; &gt;&gt;</code>.
If <code>m &lt; 1</code> or <code>n &gt; Len(seq)</code>, then the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..k</code> for some <code>k</code>. The arguments <code>m</code> and <code>n</code> must be integers.
Otherwise, the result is undefined in pure TLA+. TLC raises a model checking
error. Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SubSeq(&lt;&lt;3, 5, 9, 10&gt;&gt;, 2, 3)
    \* The sequence &lt;&lt;5, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l = [ 3, 5, 9, 10 ]
&gt;&gt;&gt; l[1:3]
[5, 9]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 5, 3: 9, 4: 10 }
&gt;&gt;&gt; m = 2
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; { i: l[i + m - 1]
...   for i in range(1, n - m + 2) }
{1: 5, 2: 9}

</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#sequence-filter" id="sequence-filter">Sequence filter</a></h3>
<p><strong>Notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>LaTeX notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>Arguments:</strong> Two arguments: a sequence (a tuple) and a one-argument
operator that evaluates to <code>TRUE</code> or <code>FALSE</code> when called with
an element of <code>seq</code> as its argument.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), (a =&gt; Bool)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>SelectSeq(seq, Test)</code> constructs a new sequence
<code>newSeq</code> that contains every element <code>e</code> of <code>seq</code> on which <code>Test(e)</code> evaluates
to <code>TRUE</code>.</p>
<p>It is much easier to describe the effect of <code>SelectSeq</code> in words than to
give a precise sequence of steps. See <strong>Examples</strong>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> If the arguments are not as described in <strong>Arguments</strong>, then the
result is undefined in pure TLA+. TLC raises a model checking error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET Test(x) ==
    x % 2 = 0
  IN
  SelectSeq(&lt;&lt;3, 4, 9, 10, 11&gt;&gt;, Test)
    \* The sequence &lt;&lt;4, 10&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; def test(x):
...   return x % 2 == 0
&gt;&gt;&gt;
&gt;&gt;&gt; l = [ 3, 4, 9, 10, 11 ]
&gt;&gt;&gt; [ x for x in l if test(x) ]
[4, 10]

&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 9, 4: 10, 5: 11 }
&gt;&gt;&gt; as_list = sorted(list(l.items()))
&gt;&gt;&gt; filtered = [ x for (_, x) in as_list if test(x) ]
&gt;&gt;&gt; { i: x
...   for (i, x) in zip(range(1, len(filtered) + 1), filtered)
... }
{1: 4, 2: 10}

</code></pre>
<hr />
<p><a name="seq"></a></p>
<h3><a class="header" href="#all-sequences" id="all-sequences">All sequences</a></h3>
<p><strong>Notation:</strong> <code>Seq(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Seq(S)</code></p>
<p><strong>Arguments:</strong> One argument that should be a set.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Set(Seq(a))</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Seq(S)</code> constructs the set of all (finite) sequences
that contain elements from <code>S</code>. This set is infinite.</p>
<p>It is easy to give a recursive definition of all sequences whose length
is bounded by some <code>n &gt;= 0</code>:</p>
<pre><code class="language-tla">RECURSIVE BSeq(_, _)
BSeq(S, n) ==
  IF n = 0
  THEN {&lt;&lt; &gt;&gt;}  \* the set that contains the empty sequence
  ELSE LET Shorter == BSeq(S, n - 1) IN
        Shorter \union { Append(seq, x): seq \in Shorter, x \in S }
</code></pre>
<p>Then we can define <code>Seq(S)</code> to be <code>UNION { BSeq(S, n): n \in Nat }</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>S</code> must be a set.
Apalache flags a static type error, if <code>S</code> is not a set.</p>
<p>TLC raises a model checking error, when it meets <code>Seq(S)</code>, as <code>Seq(S)</code> is
infinite. You can override <code>Seq(S)</code> with its bounded version <code>BSeq(S, n)</code>
for some <code>n</code>. See: <a href="https://groups.google.com/g/tlaplus/c/sYx_6e3YyWk/m/4CnwPqIVAgAJ">Overriding Seq in TLC</a>.</p>
<p>Apalache does not support <code>Seq(S)</code> yet. As a workaround, you can manually
replace <code>Seq(S)</code> with <code>BSeq(S, n)</code> for some constant <code>n</code>.  See the progress in
<a href="https://github.com/informalsystems/apalache/issues/314">Issue 314</a>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Seq({1, 2, 3})
    \* The infinite set
      { &lt;&lt;&gt;&gt;,
        &lt;&lt;1&gt;&gt;, &lt;&lt;2&gt;&gt;, &lt;&lt;3&gt;&gt;,
        &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;,
            &lt;&lt;2, 1&gt;&gt;, &lt;&lt;2, 2&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 1&gt;&gt;, &lt;&lt;3, 2&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
        ...
      }
</code></pre>
<p><strong>Example in Python:</strong> We cannot construct an infinite set in Python. However,
we could write an iterator that enumerates the sequences in <code>Seq(S)</code>
till the end of the universe.</p>
<h1><a class="header" href="#apalache-extensions" id="apalache-extensions">Apalache extensions</a></h1>
<p>Apalache provides the user with several TLA+ modules. These modules introduce
TLA+ operators to allow for more efficient model checking with Apalache. Since
our users may run Apalache and TLC interchangeably, the modules contain
default definitions in TLA+ that are compatible with TLC. Apalache overrides
these definitions internally for more efficient treatment compared to the default TLA+
definitions.</p>
<p>Currently supported modules:</p>
<ul>
<li><a href="lang/./apalache-operators.html">Apalache module</a></li>
<li><a href="lang/./variants.html">Variants</a></li>
<li><a href="lang/./option-types.html">Option Types</a></li>
</ul>
<h1><a class="header" href="#apalache-operators" id="apalache-operators">Apalache operators</a></h1>
<p>In addition to the standard TLA+ operators described in the previous section, Apalache defines a number of operators, which do not belong to the core language of TLA+, but which Apalache uses to provide clarity, efficiency, or special functionality. These operators belong to the module <code>Apalache</code>, and can be used in any specification by declaring <code>EXTENDS Apalache</code>.</p>
<p><a name="Assignment"></a></p>
<h2><a class="header" href="#assignment" id="assignment">Assignment</a></h2>
<p><strong>Notation:</strong> <code>v' := e</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/coloneq.png" alt="coloneq" /></p>
<p><strong>Arguments:</strong> Two arguments. The first is a primed variable name, the second is arbitrary.</p>
<p><strong>Apalache type:</strong> <code>(a, a) =&gt; Bool</code>, for some type <code>a</code></p>
<p><strong>Effect:</strong> The expression <code>v' := e</code> evaluates to <code>v' = e</code>. At the level of Apalache static analysis, such expressions indicate parts of an action, where the value of a state-variable in a successor state is determined. See <a href="lang/../idiomatic/001assignments.html">here</a> for more details about assignments in Apalache.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> 
If the first argument is not a primed variable name, or if the assignment operator is used where assignments are prohibited, Apalache statically reports an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">x' := 1                   \* x' = 1 
x' := (y = z)             \* x' = (y = z) 
x' := (y' := z)           \* x' = (y' = z) in TLC, assignment error in Apalache 
x' := 1 \/ x' := 2        \* x' = 1 \/ x' = 2 
x' := 1 /\ x' := 2        \* FALSE in TLC, assignment error in Apalache
x' := 1 \/ x' := &quot;a&quot;      \* Type error in Apalache 
(x' + 1) := 1             \* (x' + 1) = 1 in TLC, assignment error in Apalache 
IF x' := 1 THEN 1 ELSE 0  \* Assignment error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt; a = 1          # a' := 1
&gt;&gt; a == 1         # a' = 1
True
&gt;&gt; a = b = &quot;c&quot;    # b' := &quot;c&quot; /\ a' := b'
&gt;&gt; a = (b == &quot;c&quot;) # a' := (b = &quot;c&quot;)
</code></pre>
<hr />
<p><a name="Guess"></a></p>
<h2><a class="header" href="#non-deterministically-guess-a-value" id="non-deterministically-guess-a-value">Non-deterministically guess a value</a></h2>
<p><strong>Notation:</strong> <code>Guess(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Guess(S)</code></p>
<p><strong>Arguments:</strong> One argument: a finite set <code>S</code>, possibly empty.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; a</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Non-deterministically pick a value out of the set <code>S</code>, if <code>S</code> is
non-empty. If <code>S</code> is empty, return some value of the proper type.</p>
<p><strong>Determinism:</strong> Non-deterministic if <code>S</code> is non-empty, that is, two subsequent
calls to <code>Guess(S)</code> may return <code>x, y \in S</code> that can differ (<code>x /= y</code>) or may
be equal (<code>x = y</code>). Moreover, Apalache considers all possible combinations of
elements of <code>S</code> in the model checking mode. If <code>S</code> is empty, <code>Guess(S)</code>
produces the same value of proper type.</p>
<p><strong>Errors:</strong>
If <code>S</code> is not a set, Apalache reports an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">/\ 1 = Guess({ 1, 2, 3 })         \* TRUE or FALSE
/\ 2 = Guess({ 1, 2, 3 })         \* TRUE or FALSE
/\ 3 = Guess({ 1, 2, 3 })         \* TRUE or FALSE
/\ 4 /= Guess({ 1, 2, 3 })        \* TRUE
/\ Guess({ 1, 2, 3 }) \in Int     \* TRUE
</code></pre>
<hr />
<p><a name="Gen"></a></p>
<h2><a class="header" href="#value-generators" id="value-generators">Value generators</a></h2>
<p><strong>Notation:</strong> <code>Gen(bound)</code></p>
<p><strong>LaTeX notation:</strong> <code>Gen(bound)</code></p>
<p><strong>Arguments:</strong> One argument: an integer literal or a constant expression (of
the integer type).</p>
<p><strong>Apalache type:</strong> <code>Int =&gt; a</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> A generator of a data structure. Given a positive integer <code>bound</code>,
and assuming that the type of the operator application is known, we recursively
generate a TLA+ data structure as a tree, whose width is bound by the number
<code>bound</code>.</p>
<p><strong>Determinism:</strong> The generated data structure is unrestricted.  It is
effectively implementing data non-determinism.</p>
<p><strong>Errors:</strong>
If the type of <code>Gen</code> cannot be inferred from its application context,
or if <code>bound</code> is not an integer, Apalache reports an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* produce an unrestricted integer
LET \* @type: Int;
    oneInt == Gen(1)
IN
\* produce a set of integers up to 10 elements
LET \* @type: Set(Int);
    setOfInts == Gen(10)
IN
\* produce a sequence of up to 10 elements
\* that are integers up to 10 elements each
LET \* @type: Seq(Set(Int));
    sequenceOfInts == Gen(10)
IN
...
</code></pre>
<hr />
<h2><a class="header" href="#folding" id="folding">Folding</a></h2>
<p>The operators <code>ApaFoldSet</code> and <code>ApaFoldSeqLeft</code> are explained in more detail in a dedicated section <a href="lang/../apalache/principles/folds.html">here</a>.</p>
<hr />
<p><a name="SetAsFun"></a></p>
<h2><a class="header" href="#convert-a-set-of-pairs-to-a-function" id="convert-a-set-of-pairs-to-a-function">Convert a set of pairs to a function</a></h2>
<p><strong>Notation:</strong> <code>SetAsFun(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>SetAsFun(S)</code></p>
<p><strong>Arguments:</strong> One argument: A set of pairs <code>S</code>, which may be empty.</p>
<p><strong>Apalache type:</strong> <code>Set(&lt;&lt;a, b&gt;&gt;) =&gt; (a -&gt; b)</code>, for some types <code>a</code> and <code>b</code>.</p>
<p><strong>Effect:</strong> Convert a set of pairs <code>S</code> to a function <code>F</code>, with the property that <code>F(x) = y =&gt; &lt;&lt;x,y&gt;&gt; \in S</code>. Note that if <code>S</code>
contains at least two pairs <code>&lt;&lt;x, y&gt;&gt;</code> and <code>&lt;&lt;x, z&gt;&gt;</code>, such that <code>y /= z</code>, then <code>F</code> is not uniquely defined.
We use <code>CHOOSE</code> to resolve this ambiguity. The operator <code>SetAsFun</code> can be defined as follows:</p>
<pre><code class="language-tla">SetAsFun(S) ==
    LET Dom == { x: &lt;&lt;x, y&gt;&gt; \in S }
        Rng == { y: &lt;&lt;x, y&gt;&gt; \in S }
    IN
    [ x \in Dom |-&gt; CHOOSE y \in Rng: &lt;&lt;x, y&gt;&gt; \in S ]
</code></pre>
<p>Apalache implements a more efficient encoding of this operator than the default one.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong>
If <code>S</code> is ill-typed, Apalache reports an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">SetAsFun({ &lt;&lt;1, 2&gt;&gt;, &lt;&lt;3, 4&gt;&gt; }) = [x \in { 1, 3 } |-&gt; x + 1]   \* TRUE
SetAsFun({}) = [x \in {} |-&gt; x]                                 \* TRUE
LET F == SetAsFun({ &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;, &lt;&lt;1, 4&gt;&gt; }) IN
  \* this is all we can guarantee, when the relation is non-deterministic
  \/ F = [x \in { 1 } |-&gt; 2]
  \/ F = [x \in { 1 } |-&gt; 3]
  \/ F = [x \in { 1 } |-&gt; 4]
</code></pre>
<hr />
<p><a name="MkSeq"></a></p>
<h2><a class="header" href="#construct-a-sequence" id="construct-a-sequence">Construct a sequence</a></h2>
<p><strong>Notation:</strong> <code>MkSeq(n, F)</code></p>
<p><strong>LaTeX notation:</strong> <code>MkSeq(n, F)</code></p>
<p><strong>Arguments:</strong> Two arguments: sequence length <code>n</code> (a constant integer
expression), and element constructor <code>F(i)</code>.</p>
<p><strong>Apalache type:</strong> <code>(Int, (Int =&gt; a)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Produce the sequence of <code>n</code> elements <code>&lt;&lt;F(1), .., F(n)&gt;&gt;</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong>
If <code>n</code> is not a constant, or is negative, Apalache reports an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET Double(i) == 2 * i IN
MkSeq(3, Double) = &lt;&lt;2, 4, 6&gt;&gt;   \* TRUE
</code></pre>
<hr />
<p><a name="Cast"></a></p>
<h2><a class="header" href="#interpret-a-function-as-a-sequence" id="interpret-a-function-as-a-sequence">Interpret a function as a sequence</a></h2>
<p><strong>Notation:</strong> <code>FunAsSeq(fn, len, maxLen)</code></p>
<p><strong>LaTeX notation:</strong> <code>FunAsSeq(fn, len, maxLen)</code></p>
<p><strong>Arguments:</strong> Three arguments:</p>
<ul>
<li>A function <code>fn</code> that should be interpreted as a sequence.</li>
<li>An integer <code>len</code>, denoting the length of the sequence, with the property
<code>1..len \subseteq DOMAIN fn</code>. Apalache does not check this requirement. It is up to the user to ensure that it holds. This expression is not necessarily constant.</li>
<li>An integer constant <code>maxLen</code>, which is an upper bound on <code>len</code>, that is, <code>len &lt;= maxLen</code>.</li>
</ul>
<p><strong>Apalache type:</strong> <code>(Int -&gt; a, Int, Int) =&gt; Seq(a)</code>, for some type <code>a</code></p>
<p><strong>Effect:</strong> The expression <code>FunAsSeq(fn, len, maxLen)</code> evaluates to the
sequence <code>&lt;&lt; fn[1], ..., fn[Min(len, maxLen)] &gt;&gt;</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> If the types of <code>fn</code>, <code>len</code> or <code>maxLen</code> do not match the expected types, Apalache statically reports a
type error. Additionally, if it is not the case that <code>1..len \subseteq DOMAIN fn</code>, the result is undefined.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">Head([ x \in 1..5 |-&gt; x * x ])                \* 1 in TLC, type error in Apalache
FunAsSeq([ x \in 1..5 |-&gt; x * x ], 3, 3)      \* &lt;&lt;1,4,9&gt;&gt;
Head(FunAsSeq([ x \in 1..5 |-&gt; x * x ], 3, 3)) \* 1
FunAsSeq(&lt;&lt;1,2,3&gt;&gt;, 3, 3)                     \* &lt;&lt;1,2,3&gt;&gt; in TLC, type error in Apalache
FunAsSeq([ x \in {0,42} |-&gt; x * x ], 3, 3)    \* UNDEFINED
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python"># define a TLA+-like dictionary via a python function
def boundedFn(f, dom):
  return { x: f(x) for x in dom }

# this is how we could define funAsSeq in python
def funAsSeq(f, length, maxLen):
  return [ f.get(i) for i in range(1, min(length, maxLen) + 1) ]

# TLA+: [ x \in 1..5 |-&gt; x * x ]
f = boundedFn(lambda x: x * x, range(1,6))
# TLA+: [ x \in {0, 42} |-&gt; x * x ]
g = boundedFn(lambda x: x * x, {0, 42})
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; funAsSeq(f, 3, 3)
[1, 4, 9]
&gt;&gt;&gt; funAsSeq(f, 3, 3)[1]
1
&gt;&gt;&gt; funAsSeq(g, 3, 3)
[None, None, None]
</code></pre>
<p><a name="Skolem"></a></p>
<h2><a class="header" href="#skolemization-hint" id="skolemization-hint">Skolemization Hint</a></h2>
<p><strong>Notation:</strong> <code>Skolem(e)</code></p>
<p><strong>LaTeX notation:</strong> <code>Skolem(e)</code></p>
<p><strong>Arguments:</strong> One argument. Must be an expression of the form <code>\E x \in S: P</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> The expression <code>Skolem(\E x \in S: P)</code> provides a hint to Apalache, that the existential quantification may be skolemized. It evaluates to the same value as <code>\E x \in S: P</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> 
If <code>e</code> is not a Boolean expression, throws a type error. If it is Boolean, but not an existentially quantified expression, throws a <code>StaticAnalysisException</code>.</p>
<p><strong>Note:</strong>
This is an operator produced internally by Apalache. You may see instances of this operator, when reading the <code>.tla</code> side-outputs of various passes. Manual use of this operator is discouraged and, in many cases, not supported.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">Skolem( \E x \in {1,2}: x = 1 ) \* TRUE
Skolem( 1 )                     \* 1 in TLC, type error in Apalache
Skolem( TRUE )                  \* TRUE in TLC, error in Apalache
</code></pre>
<p><a name="Expand"></a></p>
<h2><a class="header" href="#set-expansion" id="set-expansion">Set expansion</a></h2>
<p><strong>Notation:</strong> <code>Expand(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Expand(S)</code></p>
<p><strong>Arguments:</strong> One argument. Must be either <code>SUBSET SS</code> or <code>[T1 -&gt; T2]</code>.</p>
<p><strong>Apalache type:</strong> <code>(Set(a)) =&gt; Set(a)</code>, for some <code>a</code>.</p>
<p><strong>Effect:</strong> The expression <code>Expand(S)</code> provides instructions to Apalache, that the large set <code>S</code> (powerset or set of functions) should be explicitly constructed as a finite set, overriding Apalache's optimizations for dealing with such collections. It evaluates to the same value as <code>S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> 
If <code>e</code> is not a set, throws a type error. If the expression is a set, but is not of the form <code>SUBSET SS</code> or <code>[T1 -&gt; T2]</code>, throws a <code>StaticAnalysisException</code>.</p>
<p><strong>Note:</strong>
This is an operator produced internally by Apalache. You may see instances of this operator, when reading the <code>.tla</code> side-outputs of various passes. Manual use of this operator is discouraged and, in many cases, not supported.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">Expand( SUBSET {1,2} ) \* {{},{1},{2},{1,2}}
Expand( {1,2} )        \* {1,2} in TLC, error in Apalache
Expand( 1 )            \* 1 in TLC, type error in Apalache
</code></pre>
<p><a name="ConstCard"></a></p>
<h2><a class="header" href="#cardinality-hint" id="cardinality-hint">Cardinality Hint</a></h2>
<p><strong>Notation:</strong> <code>ConstCardinality(e)</code></p>
<p><strong>LaTeX notation:</strong> <code>ConstCardinality(e)</code></p>
<p><strong>Arguments:</strong> One argument. Must be an expression of the form <code>Cardinality(S) &gt;= k</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> The expression <code>ConstCardinality(Cardinality(S) &gt;= k)</code> provides a hint to Apalache, that <code>Cardinality(S)</code> is a constant, allowing Apalache to encode the constraint <code>e</code> without attempting to dynamically encode <code>Cardinality(S). It evaluates to the same value as </code>e`.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> 
If <code>S</code> is not a Boolean expression, throws a type error. If it is Boolean, but not an existentially quantified expression, throws a <code>StaticAnalysisException</code>.</p>
<p><strong>Note:</strong>
This is an operator produced internally by Apalache. You may see instances of this operator, when reading the <code>.tla</code> side-outputs of various passes. Manual use of this operator is discouraged and, in many cases, not supported.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">Skolem( \E x \in {1,2}: x = 1 ) \* TRUE
Skolem( 1 )                     \* 1 in TLC, type error in Apalache
Skolem( TRUE )                  \* TRUE in TLC, error in Apalache
</code></pre>
<h1><a class="header" href="#variants" id="variants">Variants</a></h1>
<p><a href="lang/./apalache-extensions.html">[Back to Apalache extensions]</a></p>
<p><a href="https://en.wikipedia.org/wiki/Tagged_union">Variants</a> (also called <em>tagged unions</em> or <em>sum types</em>) are useful, when you want to combine
values of different shapes in a single set or a sequence.</p>
<p><strong>Idiomatic tagged unions in untyped TLA+.</strong> In untyped TLA+, one can construct sets, which contain records with different fields, where one filed is typically used as a disambiguation tag. 
For instance, we could create a set that contains two records of different shapes:</p>
<pre><code class="language-tla">ApplesAndOranges == {
    [ tag |-&gt; &quot;Apple&quot;, color |-&gt; &quot;red&quot; ],
    [ tag |-&gt; &quot;Orange&quot;, seedless |-&gt; TRUE ]
  }
</code></pre>
<p>We can dynamically reason about the elements of <code>ApplesAndOranges</code> based on their tag:</p>
<pre><code class="language-tla">  \E e \in ApplesAndOranges:
    /\ e.tag = &quot;Apple&quot;
    /\ e.color /= &quot;green&quot;
</code></pre>
<p>This idiom is quite common in untyped TLA+. <a href="https://github.com/tlaplus/Examples/blob/779852ba9951621f062fc4074b8e81fd12db21dc/specifications/Paxos/Paxos.tla#L85-L106">Tagged unions in Paxos</a> is
probably the most illuminating example of this idiom. Unfortunately, it is way
too easy to make a typo in the tag name, since it is a string, or simply access
a field, which records marked with the given tag do not have. For example:</p>
<pre><code class="language-tla">  \E e \in ApplesAndOranges:
    /\ e.tag = &quot;Apple&quot;
    /\ e.seedless
</code></pre>
<p><strong>Variants module.</strong> Apalache formalizes the above idiom in the module
<a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Variants.tla">Variants.tla</a>. Apalache's type checker alerts users with a type error when
they access a wrong value. Additionally, the default implementation raises an
error in TLC when a variant is used incorrectly.</p>
<p><strong>Immutability</strong>. All variants are immutable.</p>
<p><strong>Construction.</strong> An instance of a variant can be constructed via the operator
<code>Variant</code>:</p>
<pre><code class="language-tla">Variant(&quot;Apple&quot;, &quot;red&quot;)
</code></pre>
<p>If we just construct a variant like in the example above, it will be assigned
a parametric variant type:</p>
<pre><code>Apple(Str) | a
</code></pre>
<p>In this type, we know that whenever a value is tagged with &quot;Apple&quot; it should be
of the string type. However, we know nothing about other options. Most of the
time, we want to define variants that are sealed, that is, we know all
available options. Suppose we wanted to reason about different kinds of fruit, 
but wanted to limit our model to only comparing apples and oranges.
In Apalache, the type for a value that could be either an apple or an orange, but nothing else, 
would be as follows:</p>
<pre><code>Apple(Str) | Orange(Bool)
</code></pre>
<p>To make it easier to represent the fruits, we can introduce variants together with 
user-defined constructors for each option::</p>
<pre><code class="language-tla">\* @typeAlias: FRUIT = Apple(Str) | Orange(Bool);

\* @type: Str =&gt; FRUIT;
Apple(color) == Variant(&quot;Apple&quot;, color)

\* @type: Bool =&gt; FRUIT;
Orange(seedless) == Variant(&quot;Orange&quot;, seedless)
</code></pre>
<p>Now we can naturally construct apples and orange as follows:</p>
<pre><code class="language-tla">Apple(&quot;red&quot;)
Orange(TRUE)
</code></pre>
<p>Variants can wrap records, for when we want to represent compound data with named fields:</p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])
</code></pre>
<p>Once a variant is constructed, it becomes opaque to the type checker, that is,
the type checker only knows that <code>Water(TRUE)</code> and <code>Beer(&quot;Dark&quot;, 5)</code> are both
of type <code>DRINK</code>. This is exactly what we want, in order to combine these values
in a single set. However, we have lost the ability to access the fields of
these values. To deconstruct values of a variant type, we have to use other
operators, presented below.</p>
<p><strong>Filtering by tag name.</strong> Following the idiomatic use of tagged unions in
untyped TLA+, we can filter a set of variants:</p>
<pre><code class="language-tla">LET Drinks == { Water(TRUE), Water(FALSE), Beer(&quot;Radler&quot;, 2) } IN
\E d \in VariantFilter(&quot;Beer&quot;, Drink):
    d.strength &lt; 3
</code></pre>
<p>We believe that <code>VariantFilter</code> is the most commonly used way to partition a
set of variants. Note that <code>VariantFilter</code> transforms a set of variants into a
set of values (that correspond to the associated tag name).</p>
<p><strong>Type-safe get.</strong> Sometimes, we do have just a value that does not belong to a
set, so we cannot use <code>VariantFilter</code> directly. In this case, we can use
<code>VariantGetOrElse</code>:</p>
<pre><code class="language-tla">LET water == Water(TRUE) IN
VariantGetOrElse(&quot;Beer&quot;, water,
                 [ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0])).strength
</code></pre>
<p>In the above example, we unpack <code>water</code> by using the tag name <code>&quot;Beer&quot;</code>.  Since
<code>water</code> is actually tagged with <code>&quot;Water&quot;</code>, the operator falls back to the
default case and returns the record <code>[ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0]</code>.</p>
<p><strong>Type-unsafe get.</strong> Sometimes, using <code>VariantFilter</code> and <code>VariantGetOrElse</code>
is a nuisance, when we know the exact value type. In this case, we can bypass
the type checker and get the value notwithstanding the tag:</p>
<pre><code class="language-tla">LET drink == ... IN
LET nonFree ==
    IF VariantTag(drink) = &quot;Water&quot;
    THEN VariantGetUnsafe(&quot;Water&quot;, drink).sparkling
    ELSE VariantGetUnsafe(&quot;Beer&quot;, drink).strength &gt; 0
IN
...
</code></pre>
<p>In general, you should avoid using <code>VariantGetUnsafe</code>, as it is type unsafe.
Consider the following example:</p>
<pre><code class="language-tla">  VariantGetUnsafe(&quot;Beer&quot;, Water(TRUE)).strength
</code></pre>
<p>In the above example, we treat water as beer. If you try this example with TLC,
it would complain about the missing field <code>strength</code>, as it computes some form
of types dynamically. If you try this example with Apalache, it would compute
types statically and in the case of <code>VariantGetUnsafe</code> it would simply produce
an arbitrary integer. Most likely, this arbitrary integer would propagate into
an invariant violation and will lead to a spurious counterexample.</p>
<hr />
<h2><a class="header" href="#operators-7" id="operators-7">Operators</a></h2>
<hr />
<p><a name="variantCtor"></a></p>
<h3><a class="header" href="#variant-constructor" id="variant-constructor">Variant constructor</a></h3>
<p><strong>Notation:</strong> <code>Variant(tagName, associatedValue)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a value
(a TLA+ expression).</p>
<p><strong>Apalache type:</strong> <code>(Str, a) =&gt; tagName(a) | b </code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The variant constructor returns a new value of the variant type.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])
</code></pre>
<hr />
<p><a name="variantTag"></a></p>
<h3><a class="header" href="#variant-tag" id="variant-tag">Variant tag</a></h3>
<p><strong>Notation:</strong> <code>VariantTag(variant)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> One argument: a variant constructed via <code>Variant</code>.</p>
<p><strong>Apalache type:</strong> <code>(tagName(a) | b) =&gt; Str</code>, for some types <code>a</code> and <code>b</code>. Note
that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a type
variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> This operator simply returns the tag attached to the variant.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">VariantTag(Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])) = &quot;Water&quot;
</code></pre>
<hr />
<p><a name="variantFilter"></a></p>
<h3><a class="header" href="#variant-filter" id="variant-filter">Variant filter</a></h3>
<p><strong>Notation:</strong> <code>VariantFilter(tagName, set)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a set of
variants (a TLA+ expression).</p>
<p><strong>Apalache type:</strong> <code>(Str, Set(tagName(a) | b)) =&gt; Set(a)</code>, for some types <code>a</code>
and <code>b</code>. Note that <code>tagName</code> is an identifier in this notation. In this type,
<code>b</code> is a type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The variant filter keeps the set elements that are tagged with
<code>tagName</code>. It removes the tags from these elements and produces the set of
values that were packed with <code>Variant</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET Drinks == { Water(TRUE), Water(FALSE), Beer(&quot;Radler&quot;, 2) } IN
\E d \in VariantFilter(&quot;Beer&quot;, Drinks):
    d.strength &lt; 3
</code></pre>
<hr />
<p><a name="variantGetOrElse"></a></p>
<h3><a class="header" href="#unpacking-a-variant-safely" id="unpacking-a-variant-safely">Unpacking a variant safely</a></h3>
<p><strong>Notation:</strong> <code>VariantGetOrElse(tagName, variant, defaultValue)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Three arguments: the tag name (a string literal), a variant
constructed via <code>Variant</code>, a default value compatible with the value carried by
the variant.</p>
<p><strong>Apalache type:</strong> <code>(Str, tagName(a) | b, a) =&gt; a</code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The operator <code>VariantGetOrElse</code> returns the value that was wrapped
via the <code>Variant</code> constructor, if the variant is tagged with <code>tagName</code>.
Otherwise, the operator returns <code>defaultValue</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET water == Water(TRUE) IN
VariantGetOrElse(&quot;Beer&quot;, water,
                 [ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0])).strength
</code></pre>
<hr />
<p><a name="variantGetUnsafe"></a></p>
<h3><a class="header" href="#unpacking-a-variant-unsafely" id="unpacking-a-variant-unsafely">Unpacking a variant unsafely</a></h3>
<p><strong>Notation:</strong> <code>VariantGetUnsafe(tagName, variant)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a variant
constructed via <code>Variant</code>.</p>
<p><strong>Apalache type:</strong> <code>(Str, tagName(a) | b) =&gt; a</code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The operator <code>VariantGetUnsafe</code> unconditionally returns some value
that is compatible with the type of values tagged with <code>tagName</code>. If <code>variant</code>
is tagged with <code>tagName</code>, the returned value is the value that was wrapped via
the <code>Variant</code> constructor. Otherwise, it is some arbitrary value of proper type. As such,
this operator does not guarantee that the retrieved value is always constructed
via <code>Variant</code>, unless the operator is used with the right tag.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET drink == Beer(&quot;Dunkles&quot;, 4) IN
LET nonFree ==
    IF VariantTag(drink) = &quot;Water&quot;
    THEN VariantGetUnsafe(&quot;Water&quot;, drink).sparkling
    ELSE VariantGetUnsafe(&quot;Beer&quot;, drink).strength &gt; 0
IN
...
</code></pre>
<h1><a class="header" href="#option-types" id="option-types">Option Types</a></h1>
<p><a href="lang/./apalache-extensions.html">[Back to Apalache extensions]</a></p>
<p><a href="https://en.wikipedia.org/wiki/Option_type">Option types</a> are useful when you
want to internalize reasoning about partial functions. A simple motivating
example is division over integers, for which <code>n/0</code> is undefined.</p>
<p>The basic idea is as follows: given a partial function <code>f : A -&gt; B</code>, we form the
type <code>Option(B)</code> by extending <code>B</code> with an element representing a missing value,
<code>None</code>, and lift each value <code>b</code> in <code>B</code> to <code>Some(b)</code>, allowing us to represent
the partial function <code>pf : A -&gt; Option(B)</code>, such that, for each <code>a</code> in <code>A</code>,
<code>pf(a) = Some(f(a))</code> iff <code>f(a)</code> is defined, and <code>None</code> otherwise.</p>
<p>Apalache leverages its support for <a href="lang/./variants.html">variants</a> to define a
polymorphic option type along with some common utility functions in the module
<a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Option.tla">Option.tla</a>. </p>
<p>The module defines a type alias <code>$option</code> as</p>
<pre><code class="language-tla">\* @typeAlias: option = Some(a) | None(UNIT);
</code></pre>
<p>However, due to the current lack of support for polymorphic aliases, this alias
has limited utility, and parametric option types can only be properly expressed
by writing out the full variant type <code>Some(a) | None(UNIT)</code>. Nonetheless, in this manual
page, we will sometimes write <code>$option(a)</code> as a shorthand for the type <code>Some(a) | None(UNIT)</code>.</p>
<p>In the context of TLA+, our encoding of option types is generalized over
&quot;partial operators&quot;, meaning operators which return a value of type
<code>$option(a)</code>. Support for partial functions is supplied by two operators,
<a href="lang/option-types.html#OptionPartialFun">OptionPartialFun</a> and <a href="lang/option-types.html#OptionFunApp">OptionFunApp</a>.</p>
<h2><a class="header" href="#operators-8" id="operators-8">Operators</a></h2>
<h3><a class="header" href="#constructing-present-optional-values" id="constructing-present-optional-values">Constructing present optional values</a></h3>
<p><strong>Notation:</strong> <code>Some(v)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(a) =&gt; Some(a) | None(UNIT)</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong> The value <code>v</code> of type <code>a</code> to be lifted into the
option.</p>
<p><strong>Effect:</strong> Produces a new value of the optional type.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @type: Some(Int) | None(UNIT);
SomeInt == Some(42)
</code></pre>
<h3><a class="header" href="#constructing-absent-optional-values" id="constructing-absent-optional-values">Constructing absent optional values</a></h3>
<p><strong>Notation:</strong> <code>None</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>Some(a) | None(UNIT)</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong> None</p>
<p><strong>Effect:</strong> Produces a representation of an absent value.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @type: Some(Int) | None(UNIT);
NoInt == None
</code></pre>
<hr />
<h3><a class="header" href="#checking-for-presence-or-absence-of-a-value" id="checking-for-presence-or-absence-of-a-value">Checking for presence or absence of a value</a></h3>
<p><strong>Notation:</strong> <code>IsSome(o)</code> or <code>IsNone(o)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(Some(a) | None(UNIT)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong> One argument: a value of type <code>$option(a)</code> for some type <code>a</code>.</p>
<p><strong>Effect:</strong> These operators are <code>TRUE</code> or <code>FALSE</code> depending on whether the
optional value is present or absent, in the expected way.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE = IsSome(Some(5)) /\ IsNone(None)
</code></pre>
<hr />
<h3><a class="header" href="#case-analysis-and-elimination-of-optional-values" id="case-analysis-and-elimination-of-optional-values">Case analysis and elimination of optional values</a></h3>
<p><strong>Notation:</strong> <code>OptionCase(o, caseSome, caseNone)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(Some(a) | None(UNIT), a =&gt; b, UNIT =&gt; b) =&gt; b</code>, for some types <code>a</code>
and <code>b</code>. </p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>o</code> an optional value</li>
<li><code>caseSome</code> is an operator to be applied to a present value</li>
<li><code>caseNone</code> is an operator to be applied to the <code>UNIT</code> if the value is absent</li>
</ul>
<p><strong>Effect:</strong> <code>OptionCase(o, caseSome, caseNone)</code> is <code>caseSome(v)</code> if <code>o = Some(v)</code>, or else <code>caseNone(UNIT)</code>. This is a way of eliminating a value of type
<code>Option(a)</code> to produce a value of type <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">/\ LET
    \* @type: Int =&gt; Int;
    caseSome(x) == x + 1
    IN LET
    \* @type: UNIT =&gt; Int;
    caseNone(u) == 0
    IN
    OptionCase(Some(3), caseSome, caseNone) = 4
/\ LET
    \* @type: Int =&gt; Str;
    caseSome(x) == &quot;Some Number&quot;
    IN LET
    \* @type: UNIT =&gt; Str;
    caseNone(u) == &quot;None&quot;
    IN
    OptionCase(None, caseSome, caseNone) = &quot;None&quot;
</code></pre>
<hr />
<h3><a class="header" href="#sequencing-application-of-partial-operators" id="sequencing-application-of-partial-operators">Sequencing application of partial operators</a></h3>
<p><strong>Notation:</strong> <code>OptionFlatMap(f, o)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(a =&gt; Some(b) | None(UNIT), Some(a) | None(UNIT)) =&gt; Some(b) | None(UNIT)</code>, for some types <code>a</code>
and <code>b</code>. </p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>f</code> is a partial operator</li>
<li><code>o</code> an optional value</li>
</ul>
<p><strong>Effect:</strong> <code>OptionFlatMap(f, o)</code> is <code>f(v)</code> if <code>o = Some(v)</code>, or else <code>None</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET incr(n) == Some(n + 1) IN
LET fail(n) == None IN
LET q == OptionFlatMap(incr, Some(1)) IN
LET r == OptionFlatMap(incr, q) IN
LET s == OptionFlatMap(fail, r) IN
/\ r = Some(3)
/\ s = None
</code></pre>
<hr />
<h3><a class="header" href="#unwrapping-optional-values" id="unwrapping-optional-values">Unwrapping optional values</a></h3>
<p><strong>Notation:</strong> <code>OptionGetOrElse(o, default)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(Some(a) | None(UNIT), a) =&gt; a</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>o</code> an optional value</li>
<li><code>default</code> is a default value to return</li>
</ul>
<p><strong>Effect:</strong> <code>OptionGetOrElse(o, default)</code> is <code>v</code> iff <code>o = Some(v)</code>, or else <code>default</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @type: Set(Int) =&gt; Some(Int) | None(UNIT);
MaxSet(s) ==
  LET max(oa, b) ==
    IF OptionGetOrElse(oa, b) &gt; b
    THEN oa
    ELSE Some(b)
  IN
  ApaFoldSet(max, None, s)
</code></pre>
<hr />
<h3><a class="header" href="#converting-optional-values" id="converting-optional-values">Converting optional values</a></h3>
<h4><a class="header" href="#converting-to-sequences" id="converting-to-sequences">Converting to sequences</a></h4>
<p><strong>Notation:</strong> <code>OptionToSeq(o)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(Some(a) | None(UNIT)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>o</code> an optional value</li>
</ul>
<p><strong>Effect:</strong> <code>OptionToSeq(o)</code> is <code>&lt;&lt;v&gt;&gt;</code> iff <code>o = Some(v)</code>, or else <code>&lt;&lt;&gt;&gt;</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET \* @type: Seq(Int);
    empty == &lt;&lt;&gt;&gt;
IN
/\ OptionToSeq(None) = empty
/\ OptionToSeq(Some(1)) = &lt;&lt;1&gt;&gt;
</code></pre>
<h4><a class="header" href="#converting-to-sets" id="converting-to-sets">Converting to sets</a></h4>
<p><strong>Notation:</strong> <code>OptionToSet(o)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(Some(a) | None(UNIT)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>o</code> an optional value</li>
</ul>
<p><strong>Effect:</strong> <code>OptionToSet(o)</code> is like <code>OptionToSeq</code>, but producing a set.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET \* @type: Set(Int);
    empty == {}
IN
/\ OptionToSet(None) = empty
/\ OptionToSet(Some(1)) = {1}
</code></pre>
<hr />
<h3><a class="header" href="#obtaining-an-optional-value-from-a-set" id="obtaining-an-optional-value-from-a-set">Obtaining an optional value from a set</a></h3>
<p><strong>Notation:</strong> <code>OptionGuess(s)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Some(a) | None(UNIT)</code>, for some type <code>a</code>.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>s</code> is a set</li>
</ul>
<p><strong>Effect:</strong> <code>OptionGuess(s)</code> is <code>None</code> if <code>s = {}</code>, otherwise it is <code>Some(x)</code>,
where <code>x \in s</code>. <code>x</code> is selected from <code>s</code> nondeterministically.</p>
<p><strong>Determinism:</strong> Nondeterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET
    \* @type: Set(Int);
    empty == {}
IN
/\ OptionGuess(empty) = None
/\ LET choices == {1,2,3,4} IN
    LET choice == OptionGuess(choices) IN
    VariantGetUnsafe(&quot;Some&quot;, choice) \in choices
</code></pre>
<hr />
<p><a name="OptionFunApp"></a></p>
<h3><a class="header" href="#apply-a-function-to-a-partial-value" id="apply-a-function-to-a-partial-value">Apply a function to a partial value</a></h3>
<p><strong>Notation:</strong> <code>OptionFunApp(f, o)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(a -&gt; b, Some(a) | None(UNIT)) =&gt; Some(b) | None(UNIT)</code></p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>f</code> is a function</li>
<li><code>o</code> is an optional value</li>
</ul>
<p><strong>Effect:</strong> <code>OptionFunApp(f, o)</code> is <code>Some(f[v])</code> if <code>o = Some(v)</code> or else <code>None</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET f == [x \in 1..3 |-&gt; x + 1] IN
/\ OptionFunApp(f, Some(1)) = Some(2)
/\ OptionFunApp(f, None) = None
</code></pre>
<hr />
<p><a name="OptionPartialFun"></a></p>
<h3><a class="header" href="#extend-a-total-function-into-a-partial-function" id="extend-a-total-function-into-a-partial-function">Extend a total function into a partial function</a></h3>
<p><strong>Notation:</strong> <code>OptionPartialFun(f, undef)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Apalache type:</strong> <code>(a -&gt; b, Set(a)) =&gt; (a -&gt; Some(b) | None(UNIT))</code></p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>f</code> is a total function</li>
<li><code>undef</code> is a set of values for which the new function is to be &quot;undefined&quot;</li>
</ul>
<p><strong>Effect:</strong> <code>OptionPartialFun(f, undef)</code> is a function mapping each value in
<code>undef</code> to <code>None</code>, and each value <code>x \in (DOMAIN f \ undef)</code> to <code>Some(f[x])</code>.
This can be used to extend a total function into a &quot;partial function&quot; whose domain is
extended to include the values in 'undef'.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">LET def == 1..3 IN
LET undef == 4..10 IN
LET f == [x \in def |-&gt; x + 1] IN
LET pf == OptionPartialFun(f, undef) IN
/\ \A n \in def: pf[n] = Some(n + 1)
/\ \A n \in undef: pf[n] = None
</code></pre>
<h1><a class="header" href="#user-defined-operators" id="user-defined-operators">User-defined operators</a></h1>
<p><em>Like macros, to do a lot of things in one system step...</em></p>
<p>User-defined operators in TLA+ may be confusing. At first, they look like
functions in programming languages. (Recall that <a href="lang/./functions.html">TLA+
functions</a> are more like dictionaries or hash maps, not
functions in PL.) Then you realize that operators such as <code>Init</code> and <code>Next</code> are
used as logic predicates. However, large specifications often contain operators
that are not predicates, but in fact are similar to pure functions in
programming languages: They are computing values over the system state but pose
no constraints over the system states. </p>
<p>Recently, Leslie Lamport has extended the syntax of TLA+ operators in <a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf">TLA+
version 2</a>, which supports recursive operators and lambda operators. We explain why Apalache does not support those in <a href="lang/./principles/recursive.html">Recursive operators and functions</a>. </p>
<p>The operator syntax that is described in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying Systems</a> describes TLA+
version 1. This page summarizes the syntax of user-defined operators in
versions 1 and 2.</p>
<p><strong>Short digression</strong>. The most important thing to understand about user-defined
operators is that they are normally used inside <code>Init</code> and <code>Next</code>. While the
operator <code>Init</code> describes the initial states, the operator <code>Next</code> describes a
single step of the system.  That is, these two operators are describing the
initial states and the possible transitions of the system, respectively. They
do not describe the whole system computation.  Most of the time, we are writing
<em>canonical specifications</em>, which are written in temporal logic as <code>Init /\ [][Next]_vars</code>. Actually, you do not have to understand temporal logic, in
order to write canonical specifications. A canonical specification is saying:
(1) Initialize the system as <code>Init</code> prescribes, and (2) compute system
transitions as <code>Next</code> prescribes. It also allows for stuttering, but this
belongs to <a href="http://lamport.azurewebsites.net/tla/advanced.html?back-link=user-operators.html">Advanced topics</a>.</p>
<p>After the digression, you should now see that user-defined operators in TLA+
are (normally) describing a single step of the system. Hence, they should be
terminating. That is why user operators are often understood as macros.  The
same applies to [Recursive operator definitions]. They have to
terminate within a single system step.</p>
<p><strong>Quirks of TLA+ operators.</strong> Below we summarize features of
user-defined operators that you would probably find unexpected:</p>
<ol>
<li>
<p>Some operators are used as predicates and some are used to compute
values (<em>à la pure</em>).</p>
</li>
<li>
<p>Operators may accept other operators as parameters. Such operators are
called <a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a>.</p>
</li>
<li>
<p>Although operators may be passed as parameters, they are not first-class
citizens in TLA+. For instance, an operator cannot be returned as a result of
another operator. Nor can an operator be assigned to a variable (only the result
of its application may be assigned to a variable).</p>
</li>
<li>
<p>Operators do not support <a href="https://en.wikipedia.org/wiki/Currying">Currying</a>. That is, you can only apply an operator
by providing values for all of its expected arguments.</p>
</li>
<li>
<p>Operators can be nested. However, nested operators require a slightly
different syntax. They are defined with LET-IN definitions.</p>
</li>
</ol>
<p><strong>Details about operators.</strong> We go in detail about different kinds of operators
and recursive functions below:</p>
<ul>
<li>
<p><a href="lang/./user/top-level-operators.html">Top-level operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/let-in.html">LET-IN definitions</a></p>
</li>
<li>
<p><a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/lambdas.html">Anonymous operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/local-operators.html">Local operator definitions</a></p>
</li>
</ul>
<h1><a class="header" href="#top-level-operator-definitions" id="top-level-operator-definitions">Top-level operator definitions</a></h1>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h2><a class="header" href="#quick-example" id="quick-example">Quick example</a></h2>
<p>Here is a quick example of a top-level user operator (which has to be defined
in a module) and of its application:</p>
<pre><code class="language-tla">----------------------- MODULE QuickTopOperator -------------------------------
...
Abs(i) == IF i &gt;= 0 THEN i ELSE -i
...
B(k) == Abs(k)
===============================================================================
</code></pre>
<p>As you most probably guessed, the operator <code>Abs</code> expects one argument <code>i</code>.
Given an integer <code>j</code>, then the result of computing <code>Abs(j)</code> is the absolute
value of <code>j</code>. The same applies, when <code>j</code> is a natural number or a real number.</p>
<h2><a class="header" href="#syntax-of-operator-definitions" id="syntax-of-operator-definitions">Syntax of operator definitions</a></h2>
<p>In general, operators of <code>n</code> arguments are
defined as follows:</p>
<pre><code class="language-tla">\* an operator without arguments (nullary)
Opa0 == body_0

\* an operator of one argument (unary)
Opa1(param1) == body_1

\* an operator of two arguments (binary)
Opa2(param1, param2) == body_2
...
</code></pre>
<p>In this form, the operator arguments are not allowed to be operators. If you want
to receive an operator as an argument, see the syntax of <a href="lang/user/./higher-order-operators.html">Higher-order operators</a>.</p>
<p>Here are concrete examples of operator definitions:</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
...

ABSOLUTE_ZERO_IN_CELCIUS ==
    -273

Fahrenheit2Celcius(t) ==
    (t - 32) * 10 / 18

Max(s, t) ==
    IF s &gt;= t THEN s ELSE t
...
===============================================================================
</code></pre>
<p><em>What is their arity (number of arguments)?</em></p>
<p>If you are used to imperative languages such as Python or Java, then you are
probably surprised that operator definitions do not have any <code>return</code>
statement. The reason for that is simple: TLA+ is not executed on any hardware.
To understand how operators are evaluated, see the semantics below.</p>
<h2><a class="header" href="#syntax-of-operator-applications" id="syntax-of-operator-applications">Syntax of operator applications</a></h2>
<p>Having defined an operator, you can apply it inside another operator as follows
(in a module):</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
VARIABLE fahrenheit, celcius
\* skipping the definitions of
\* ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius, and Max
...

UpdateCelcius(t) ==
    celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(t))

Next ==
    /\ fahrenheit' \in -1000..1000
    /\ UpdateCelcius(fahrenheit')
...
===============================================================================
</code></pre>
<p>In the above example, you see examples of four operator applications:</p>
<ol>
<li>
<p>The nullary operator <code>ABSOLUTE_ZERO_IN_CELCIUS</code> is applied without any
arguments, just by its name. Note how a nullary operator does not require
parentheses <code>()</code>. Yet another quirk of TLA+.</p>
</li>
<li>
<p>The one-argument operator Fahrenheit2Celcius is applied to <code>t</code>,
which is a parameter of the operator <code>UpdateCelcius</code>.</p>
</li>
<li>
<p>The two-argument operator <code>Max</code> is applied to <code>ABSOLUTE_ZERO_IN_CELCIUS</code>
and <code>Fahrenheit2Celcius(t)</code>.</p>
</li>
<li>
<p>The one-argument operator <code>UpdateCelcius</code> is applied to <code>fahrenheit'</code>,
which is the value of state variable <code>fahrenheit</code> in the next state of the
state machine. TLA+ has no problem applying the operator to <code>fahrenheit'</code> or
to <code>fahrenheit</code>.</p>
</li>
</ol>
<p>Technically, there are more than four operator applications in our example.
However, all other operators are the <a href="lang/user/./standard-operators.html">standard
operators</a>. We do not focus on them here.</p>
<p><strong>Note on the operator order.</strong> As you can see, we are applying operators after
they have been defined in a module. This is a general rule in TLA+: A name can
be only referred to, if it has been defined in the code before. TLA+ is not
the first language to impose that rule. For instance, <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal</a> had it too.</p>
<p><strong>Note on shadowing.</strong> TLA+ does not allow you to use the same name as an
operator parameter, if it has been defined in the context of the operator
definition. For instance, the following is not allowed:</p>
<pre><code class="language-tla">-------------------------- MODULE NoShadowing ---------------------------------
VARIABLE x

\* the following operator definition produces a semantic error:
\* the parameter x is shadowing the state variable x
IsZero(x) == x = 0
===============================================================================
</code></pre>
<p>There are a few tricky cases, where shadowing can actually happen, e.g., see
the operator <code>dir</code> in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SlidingPuzzles/SlidingPuzzles.tla">SlidingPuzzles</a>. However, we recommend to keep things
simple and avoid shadowing at all.</p>
<h2><a class="header" href="#semantics-of-operator-application" id="semantics-of-operator-application">Semantics of operator application</a></h2>
<p>Precise treatment of operator application is given on page 320 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying
Systems</a>. In a nutshell, operator application in TLA+ is a <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_macro_expansion">Call by macro
expansion</a>, though it is a bit smarter: It does not blindly mix names from the
operator's body and its application context. For example, the following
semantics by substitution is implemented in the <a href="https://apalache.informal.systems">Apalache</a> model checker.</p>
<p>Here we give a simple explanation for non-recursive operators. Consider the
definition of an <code>n</code>-ary operator <code>A</code> and its application in the definition
of another operator <code>B</code>:</p>
<pre><code class="language-tla">A(p_1, ..., p_n) == body_of_A
...
B(p_1, ..., p_k) ==
    ...
    A(e_1, ..., e_n)
    ...
</code></pre>
<p>The following three steps allow us to replace application of the operator <code>A</code>
in <code>B</code>:</p>
<ol>
<li>Change the names in the definition of <code>A</code> in such a way such they do not
clash with the names in <code>B</code> (as well as with other names that may be used in
<code>B</code>). This is the well-known technique of <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> in programming
languages. This may also require renaming of the parameters <code>p_1, ..., p_n</code>.
Let the result of alpha conversion be the following operator:</li>
</ol>
<pre><code class="language-tla">uniq_A(uniq_p_1, ..., uniq_p_n) == body_of_uniq_A
</code></pre>
<ol>
<li>
<p>Substitute the expression <code>A(e_1, ..., e_n)</code> in the definition of <code>B</code> with
<code>body_of_uniq_A</code>.</p>
</li>
<li>
<p>Substitute the names <code>uniq_p_1, ..., uniq_p_n</code> with the expressions <code>e_1, ..., e_n</code>, respectively.</p>
</li>
</ol>
<p>The above transformation is usually called <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a>.</p>
<p><strong>Example.</strong> Let's go back to the module <code>FandC</code>, which we considered above. By
applying the substitution approach several times, we transform <code>Next</code> in
several steps as follows:</p>
<p>First, by substituting the body of <code>UpdateCelsius</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(fahrenheit'))
</code></pre>
<p>Second, by substituting the body of <code>Max</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= Fahrenheit2Celcius(fahrenheit')
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE Fahrenheit2Celcius(fahrenheit')
</code></pre>
<p>Third, by substituting the body of <code>Fahrenheit2Celcius</code> (twice):</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= (fahrenheit' - 32) * 10 / 18
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE (fahrenheit' - 32) * 10 / 18
</code></pre>
<p>You could notice that we applied beta reduction syntactically from top to
bottom, like peeling an onion. We could do it in another direction: First
starting with the application of <code>Fahrenheit2Celcius</code>. This actually does not
matter, as long as our goal is to produce a TLA+ expression that is free of
user-defined operators. For instance, <a href="https://apalache.informal.systems">Apalache</a> applies <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> and
<a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a> to remove user-defined operator and then translates the TLA+
expression to SMT.</p>
<h1><a class="header" href="#let-in-operator-definitions" id="let-in-operator-definitions">LET-IN operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#higher-order-operator-definitions" id="higher-order-operator-definitions">Higher-order operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#anonymous-operator-definitions" id="anonymous-operator-definitions">Anonymous operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#local-operator-definitions" id="local-operator-definitions">Local operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#idiomatic-tla" id="idiomatic-tla">Idiomatic TLA+</a></h1>
<p><strong>Authors:</strong> Shon Feder, Igor Konnov, Gabriela Moreira + (who likes to contribute?)</p>
<p><em>This document is under construction.
If you like to contribute, open a pull request.</em></p>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>In this document, we collect specification idioms that aid us in writing TLA+
specifications that are:</p>
<ol>
<li>understood by distributed system engineers,</li>
<li>understood by verification engineers, and</li>
<li>understood by automatic analysis tools such as the Apalache model checker.</li>
</ol>
<p>If you believe, that the above points are contradictory when put together, it is
to some extent true. TLA+ is an extremely general specification language. As a
result, it is easy to write a short specification that leaves a human reader
puzzled . It is even easier to write a (syntactically correct) specification that
turns any program trying to reason about TLA+ to dust.</p>
<p>Nevertheless, we find TLA+ quite useful when writing concise specifications of
distributed protocols at <a href="https://informal.systems">Informal Systems</a>. Other specification languages --
especially, those designed for software verification -- would require us to
introduce unnecessary book-keeping details that would both obfuscate the
protocols and make their verification harder. However, we do not always need
<em>&quot;all the power of mathematics&quot;</em>, so we find it useful to introduce additional
structure in TLA+ specifications.</p>
<p>Below, we summarize the idioms that help us in maintaining that structure.  As
a bonus, these idioms usually aid the Apalache model checker in analyzing the
specifications. Our idioms are quite likely different from the original ideas
of <a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (the author of TLA+).
So it is useful to read Lamport's <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>. Importantly, these are
<em>idioms</em>, not rules set in stone. If you believe that one of those idioms
does not work for you in your specific setting, don't follow it.</p>
<p>If this is the first page where you encounter the word &quot;TLA+&quot;, we do not
recommend that you continue to read the material. It is better to start with <a href="http://lamport.azurewebsites.net/video/videos.html">The TLA+
Video Course</a> by Leslie
Lamport.  Once you have understood the basics and tried the language, it makes
sense to ask the question: &quot;How do I write a specification that other people
understand?&quot;.  We believe that many TLA+ users reinvent rules that are
similar to our idioms.  By providing you with a bit of guidance, we hope to
reduce your discomfort when learning more advanced TLA+.</p>
<h2><a class="header" href="#the-idioms" id="the-idioms">The idioms</a></h2>
<p><strong>Idiom 0:</strong>
<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the minimum</a> 🔋</p>
<p><strong>Idiom 1:</strong> <a href="idiomatic/001assignments.html">Update state variables with assignments</a> 📅</p>
<p><strong>Idiom 2:</strong> <a href="idiomatic/002primes.html">Apply primes only to state variables</a> 📌</p>
<p><strong>Idiom 3:</strong> Isolate updates to VARIABLES 👻</p>
<p><strong>Idiom 4:</strong> Isolate non-determinism in actions 🔮</p>
<p><strong>Idiom 5:</strong> Introduce pure operators 🙈</p>
<p><strong>Idiom 6:</strong> Introduce a naming convention for operator parameters 🛂</p>
<p><strong>Idiom 7:</strong> <a href="idiomatic/007if-then-else.html">Use Boolean operators in actions, not <code>IF-THEN-ELSE</code></a> 🙅</p>
<p><strong>Idiom 8:</strong> <code>CHOOSE</code> smart, prefer <code>\E</code> 💂‍♂</p>
<p><strong>Idiom 9:</strong> Do not over-structure 🔬</p>
<p><strong>Idiom 10:</strong> Do not over-modularize 🦆</p>
<p><strong>Idiom 11:</strong> Separate normal paths from error paths. ⚡</p>
<p><strong>Idiom 12:</strong> Do you really need those nice recursive operators? 🌀</p>
<p><strong>Idiom 13:</strong> Do you really need set cardinalities? 🍕</p>
<p><strong>Idiom 14:</strong> Do you really need integers? 🔢</p>
<p><strong>Idiom 15:</strong> <a href="idiomatic/003record-sets.html">Replace sets of mixed records with disjoint unions</a> 🛄</p>
<h1><a class="header" href="#idiom-0-keep-state-variables-to-the-minimum" id="idiom-0-keep-state-variables-to-the-minimum">Idiom 0: Keep state variables to the minimum</a></h1>
<p>In imperative programming, it is common to use mutable variable assignments liberally, but to exercise caution whenever mutable variables have a global scope. In TLA+, mutable variables are always global, so it is important to use them carefully and in a way that accurately reflects the global state of the system you are specifying.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p><em>A good TLA+ specification minimizes the computation state and makes it visible</em>.</p>
<p>TLA+ does not have special syntax for variable assignment.  For a good
reason. The power of TLA+ is in writing constraints on variables rather than in
writing detailed commands. If you have been writing in languages such as C, C++,
Java, Python, your first reflex would be to define a variable to store the
intermediate result of a complex computation.</p>
<p>In programming languages, we introduce temporary variables for several reasons:</p>
<ol>
<li>To avoid repetitive computations of the same expression,</li>
<li>To break down a large expression into a series of smaller expressions,</li>
<li>To make the code concise.</li>
</ol>
<p>Point 1 is a non-issue in TLA+, as it is mostly executed in the reader's brain,
and people are probably less efficient in caching expressions than computers.
Points 2 and 3 can be nicely addressed with LET-definitions in TLA+. Hence,
there is no need for auxiliary variables.</p>
<p>Usually, we should minimize the specification state, that is, the scope of the data
structures that are declared with <code>VARIABLES</code>. It does not mean that one variable
is always better than two. It means that what is stored in <code>VARIABLES</code> should be
absolutely necessary to describe the computations or the observed properties.</p>
<h2><a class="header" href="#advantages" id="advantages">Advantages</a></h2>
<p>By avoiding auxiliary state variables, we localize the updates to the state.
This improves specification readability. It also helps the tools, as large parts
of the specification become deterministic.</p>
<h2><a class="header" href="#disadvantages" id="disadvantages">Disadvantages</a></h2>
<p>Sometimes, we have to expose the internals of the computation. For instance,
if we want to closely monitor the values of the computed expressions, when using
the specification for model-based testing.</p>
<p>Sometimes, we have to break this idiom to make the specification more readable. Here is an example by Markus Kuppe. The specification of <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueueSplit.tla#L16-L51">BlockingQueue</a> that has one more variable is easier to read than <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueue.tla">the original specification</a> with a minimal number of variables.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Consider the following implementation of <a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble sort</a> in Python:</p>
<pre><code class="language-python">    my_list = [5, 4, 3, 8, 1]
    finished = False
    my_list_len = len(my_list)  # cache the length
    while not finished:
        finished = True
        if my_list_len &gt; 0:
            prev = my_list[0]       # save the first element to use in the loop
        for i in range(1, my_list_len):
            current = my_list[i]
            if prev &lt;= current:
                # save current for the next iteration
                prev = current
            else:
                # swap the elements
                my_list[i - 1] = current
                my_list[i] = prev
                finished = False
</code></pre>
<p>Notice that we have introduced three local variables to optimize the code:</p>
<ul>
<li><code>my_list_len</code> to cache the length of the list,</li>
<li><code>prev</code> to cache the previously accessed element of the list,
in order to minimize the number of list accesses,</li>
<li><code>current</code> to cache the iterated element of the list.</li>
</ul>
<p>In TLA+, one usually does not introduce local variables for the intermediate
results of the computation, but rather introduces variables to represent the
essential part of the algorithm state. (While we have spent some time on code
optimization, we might have missed the fact that our sorting algorithm is not
as good as <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a>.) In the above example, the essential variables are
<code>finished</code> and <code>my_list</code>.</p>
<p>Compare the above code to (a slightly more abstract) <a href="idiomatic/./example/bubble.tla">bubble sort in
TLA+</a>:</p>
<pre><code class="language-tla">EXTENDS Integers, Sequences

in_list == &lt;&lt;5, 4, 3, 8, 1&gt;&gt;
VARIABLES my_list, finished

Init ==
    /\ my_list = in_list
    /\ finished = FALSE

IsSorted(lst) ==
    \A i \in DOMAIN lst \ {1}:
        lst[i - 1] &lt;= lst[i]

WhenSorted ==
    /\ IsSorted(my_list)
    /\ finished' = TRUE
    /\ UNCHANGED my_list

WhenUnsorted ==
    /\ \E i \in DOMAIN my_list \ {1}:
        /\ my_list[i - 1] &gt; my_list[i]
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
    /\ finished' = FALSE

Next ==
    IF finished
    THEN UNCHANGED &lt;&lt;my_list, finished&gt;&gt;
    ELSE WhenSorted \/ WhenUnsorted

</code></pre>
<p>Our TLA+ code contains only two state variables: <code>my_list</code> and <code>finished</code>.
Other variables are introduced by quantifiers (e.g., <code>\E i \in ...</code>).
The state variables are not updated in the sense of programming languages.
Rather, one writes constraints over unprimed and primed versions, e.g.:</p>
<pre><code class="language-tla">        ...
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
</code></pre>
<p>Of course, one can introduce aliases for intermediate expressions, for instance,
by using let-definitions:</p>
<pre><code class="language-tla">        ...
        LET prev == my_list[i - 1]
            current == my_list[i]
        IN
        /\ prev &gt; current
        /\ my_list' = [my_list EXCEPT ![i - 1] = current, ![i] = prev]
</code></pre>
<p>However, the let-definitions are not variables, they are just aliases for more
complex expressions. Importantly, one cannot update the value of an expression
that is defined with a let-definition. In this sense, TLA+ is similar to
functional languages, where side effects are carefully avoided and minimized.</p>
<p>In contrast to functional languages, the value of TLA+ is not in computing
the result of a function application, but in producing sequences of states
(called behaviors). Hence, some parts of a useful TLA+ specification should have side effects to record the states.</p>
<h1><a class="header" href="#idiom-1-update-state-variables-with-assignments" id="idiom-1-update-state-variables-with-assignments">Idiom 1: Update state variables with assignments</a></h1>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The idiom &quot;<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the
minimum</a>&quot; tells us to store the minimum
necessary state variables. By following this idiom, we develop
the specification by writing constraints over the primed variables.</p>
<p>TLA+ comes with a great freedom of expressing constraints over variables.
While we love TLA+ for that freedom, we believe that constraints over primed
variables are sometimes confusing.
TLA+ uses the same glyph, <code>=</code> for three separate purposes: assignment, asserting equality, and binding variables. But these are very different operations and have different semantics.</p>
<h3><a class="header" href="#issue-1" id="issue-1">Issue 1</a></h3>
<p><strong>tl;dr:</strong> Use <code>:=</code> (supplied by the <code>Apalache.tla</code> module) instead of <code>=</code> for assignment.</p>
<p>Consider the expression:</p>
<pre><code class="language-tla">  x' = x + 1
</code></pre>
<p>It is all clear here. The value of <code>x</code> in the next states (there may be many)
is equal to <code>val(x)+1</code>, where <code>val(x)</code> is the value of <code>x</code> in the current
state.</p>
<p>Wait. Is it clear? What if that expression was just the first line of the following
expression:</p>
<pre><code class="language-tla">  x' = x + 1
    =&gt; x' = 3
</code></pre>
<p>This says, &quot;if <code>x'</code> is equal to <code>x + 1</code>, then assign the value of <code>3</code> to <code>x'</code> in the next state&quot;, which
implies that <code>x'</code> may receive a value from the set:</p>
<pre><code class="language-tla">  { 3 } \union { y \in Int: y /= val(x) + 1 }
</code></pre>
<p>But maybe the author of that specification just made a typo and never
meant to put the implication <code>=&gt;</code> in the first place. Actually, the intended
specification looks like follows:</p>
<pre><code class="language-tla">  x' = x + 1
    \/ x' = 3
</code></pre>
<p>We believe that it is helpful to label the expressions that intend to denote the
values of the state variables in the next state. Apalache introduces the infix
operator <code>:=</code> in the module <code>Apalache.tla</code> for that purpose:</p>
<pre><code class="language-tla">  x' := x + 1
    \/ x' := 3
</code></pre>
<p>Hence, it would be obvious in our motivating example that the author made a typo:</p>
<pre><code class="language-tla">  x' := x + 1
    =&gt; x' := 3
</code></pre>
<p>because the assignment <code>x' := x + 1</code> does not express a boolean value
and so cannot be the antecedent of the conditional.</p>
<h3><a class="header" href="#issue-2" id="issue-2">Issue 2</a></h3>
<p><strong>tl;dr:</strong> Use existential variables with the <code>:=</code> operator for non-deterministic assignment.</p>
<p>Another common use of primed variables is to select the next value of a variable
from a set:</p>
<pre><code class="language-tla">  x' \in { 1, 2, 3 }
</code></pre>
<p>This expression can be rewritten as an equivalent one:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' = y
</code></pre>
<p>Which one to choose? The first one is more concise. The second one highlights
the important effect, namely, non-deterministic choice of the next value of <code>x</code>.
When combined with the operator <code>:=</code>, the effect of non-deterministic choice is
clearly visible:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' := y
</code></pre>
<p>In fact, every constraint over primes can be translated into the existential form.
For instance, consider the expression:</p>
<pre><code class="language-tla">  x' * x' = 4
</code></pre>
<p>It can be written as:</p>
<pre><code class="language-tla">  \E y \in Int:
    /\ y * y = 4
    /\ x' := y
</code></pre>
<h2><a class="header" href="#advantages-1" id="advantages-1">Advantages</a></h2>
<ul>
<li>
<p>The reader clearly sees the writer's intention about the updates
to the primed variables.</p>
</li>
<li>
<p>Non-determinism is clearly isolated in existential choice: <code>\E y \in S: x' := y</code>.
If there is no existential choice, the assignment is deterministic.</p>
</li>
<li>
<p>When the existential form is used, the range of the values is clearly indicated.
This is in contrast to the negated form such as: <code>~(x' = 10)</code>.</p>
</li>
<li>
<p>TLC treats the expressions of the form <code>x' = e</code> and <code>x' \in S</code> as assignments,
as long as <code>x'</code> is not bound to a value.</p>
</li>
<li>
<p>Apalache uses assignments to decompose the specification into smaller pieces.
Although Apalache tries to find assignments automatically, it often has to choose
from several expressions, some of them may be more complex than the others. By using
the <code>:=</code> operator, Apalache gets unambiguous instructions about when assignment is taking
place</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-1" id="disadvantages-1">Disadvantages</a></h2>
<ul>
<li>Replacing <code>x' \in S</code> with <code>\E y \in S: x' := y</code> makes the specification a bit larger.</li>
</ul>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>The following example <a href="idiomatic/./example/deliver.tla">deliver.tla</a> demonstrates how
one can clearly mark assignments using the <code>:=</code> operator.</p>
<pre><code class="language-tla">------------------------------ MODULE deliver ----------------------------------
(*
 * A simple specification of two processes in the network: sender and receiver.
 * The sender sends messages in sequence. The receiver may receive the sent
 * messages out of order, but delivers them to the client in order.
 *
 * Igor Konnov, 2020
 *)
EXTENDS Integers, Apalache

VARIABLES
    sentSeqNo,      \* the sequence number of the next message to be sent
    sent,           \* the messages that are sent by the sender
    received,       \* the messages that are received by the receiver
    deliveredSeqNo  \* the sequence number of the last delivered message
(* We assign to the unprimed state variables to set their initial values. *)
Init ==
    /\ sentSeqNo := 0
    /\ sent := {}
    /\ received := {}
    /\ deliveredSeqNo := -1

(* Subsequent assignments are all to primed variables, designating changed values
   after state transition. *)
Send ==
    /\ sent' := sent \union {sentSeqNo}
    /\ sentSeqNo' := sentSeqNo + 1
    /\ UNCHANGED &lt;&lt;received, deliveredSeqNo&gt;&gt;

Receive ==
    (* We make the nonderministic assignment explicit, by use of existential quantification *)
    /\ \E msgs \in SUBSET (sent \ received):
        received' := received \union msgs
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, deliveredSeqNo&gt;&gt;

Deliver ==
    /\ (deliveredSeqNo + 1) \in received
    /\ deliveredSeqNo' := deliveredSeqNo + 1
        \* deliver the message with the sequence number deliveredSeqNo'
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, received&gt;&gt;

Next ==
    \/ Send
    \/ Receive
    \/ Deliver

Inv ==
    (deliveredSeqNo &gt;= 0) =&gt; deliveredSeqNo \in sent
================================================================================
</code></pre>
<h1><a class="header" href="#idiom-2-apply-primes-only-to-state-variables" id="idiom-2-apply-primes-only-to-state-variables">Idiom 2: Apply primes only to state variables</a></h1>
<p>(<em>Until you learn how prime actually works!</em>)</p>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>In many formal languages, the notation <code>x'</code> denotes the value that a variable
<code>x</code> has after the system has fired a transition. The reason for having both <code>x</code>
and <code>x'</code> is that the transitions are often described as relations over unprimed
and primed variables, e.g., <code>x' = x+1</code>. It is easy to extend this idea to
vectors of variables, but for simplicity we will use only one variable.</p>
<p>TLA+ goes further and declares prime (<code>'</code>) as an operator! This operator distributes over
any state variables in the scope of its application. For example, assume that we
evaluate a TLA+ expression <code>A</code> over <code>x</code> and <code>x'</code>, and <code>v[i]</code> and <code>v[i+1]</code> are
meant to be the values of <code>x</code> in the ith state and i+1-th state, respectively.
Then <code>x</code> is evaluated to <code>v[i]</code> and <code>x'</code> is evaluated to <code>v[i+1]</code>.  Naturally,
<code>x + 3</code> is evaluated to <code>v[i] + 3</code>, whereas <code>x' + 4</code> is evaluated to <code>v[i+1] + 4</code>. We can go further and evaluate <code>(x + 4)'</code>, which can be rewritten as <code>x' + 4</code>.</p>
<p>Intuitively, there is nothing wrong with the operator &quot;prime&quot;. However, you
have to understand this operator well, in order to use it right. For starters, check
the warning by Leslie Lamport in <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a> on page 82. The following
example illustrates the warning:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3 ------------------------------------
(* Model a system of three processes, each one equipped with a logical clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

\* a shortcut to refer to the clock of the process that is taking the step
MyClock == clocks[turn]
\* a shortcut to refer to the processes that are not taking the step
Others == DOMAIN clocks \ {turn}

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes (the section Example shows a better way)
    /\ \E f \in [1..3 -&gt; Int]:
        clocks' := f
    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<p>Did you spot a problem in the above example? If not, check these lines again:</p>
<pre><code class="language-tla">    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
</code></pre>
<p>The code does not match the comment. By writing <code>MyClock'</code>, we get
<code>(clocks[turn])'</code> that is equivalent to <code>clocks'[turn']</code>. So our constraint
says: Increment the clock of the process that is taking the next step.  By
looking at the next constraint, we can see that <code>Next</code> can never be evaluated
to true (a logician would say that <code>Next</code> is &quot;unsatisfiable&quot;):</p>
<pre><code class="language-tla">    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
</code></pre>
<p>Our intention was to make the specification easier to read, but instead we have
introduced a deadlock in the system. In a larger specification, this bug would be
much harder to find.</p>
<p>We recommend to follow this simple rule: <em>Apply primes only to state variables</em></p>
<p>Can we remove the &quot;prime&quot; operator altogether and agree to use <code>x</code> and <code>x'</code> as
names of the variables? Not really. More advanced features of TLA+ require this
operator.  In a nutshell, TLA+ is built around the idea of refinement, that is,
replacing an abstract specification with a more detailed one. Concretely, this
idea is implemented by module instances in TLA+. It often happens that
refinement requires us to replace a state variable of the abstract
specification with an operator of the detailed specification.  Voilà. You have
to apply prime to an expression. For the details,
see Chapter 5 and pages 312-313 of <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>.</p>
<h2><a class="header" href="#advantages-2" id="advantages-2">Advantages</a></h2>
<ul>
<li>
<p>It is easy to see, whether the specification author intended to talk about
the variables in the next state or about the variable in the current state.</p>
</li>
<li>
<p>It is harder to make an unexpected substitution mistake, as in the above
example.</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-2" id="disadvantages-2">Disadvantages</a></h2>
<ul>
<li>Sometimes, the operator &quot;prime&quot; helps us in avoiding code duplication.
For instance, you can write a state invariant <code>Inv</code> and later evaluate it
against a next state by simply writing <code>Inv'</code>. However, you have to be
careful about propagation of primes in <code>Inv</code>.</li>
</ul>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<p>A better version of the <code>clocks</code> example applies prime only to state variables.
By doing so, we notice that the specification can be further simplified:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3_2 ----------------------------------
(* Model a system of three processes, each one equipped with a digital clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes
    /\ clocks' :=
        [p \in 1..3 |-&gt;
            IF p = turn THEN clocks[turn] + 1 ELSE clocks[p]]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<h1><a class="header" href="#idiom-7-use-boolean-operators-in-actions-not-if-then-else" id="idiom-7-use-boolean-operators-in-actions-not-if-then-else">Idiom 7: Use Boolean operators in actions, not <code>IF-THEN-ELSE</code></a></h1>
<p><strong>author:</strong> Gabriela Moreira</p>
<h2><a class="header" href="#description-3" id="description-3">Description</a></h2>
<p>TLA+ provides an <code>IF-THEN-ELSE</code> operator, and it can be pretty tempting to use it for flow control, as it's done in procedural programming. However, TLA+ is about transitions over a state machine, and a transition-defining action declared with <code>IF-THEN-ELSE</code> can be more complex than 2 actions declared without it. Considering that any expression of the form <code>IF b THEN x ELSE y</code>, where <code>x</code> and <code>y</code> are Booleans, can be rewritten as <code>(b /\ x) \/ (~b /\ y)</code>, there's a pattern we can apply to get rid of some potentially troublesome <code>IF-THEN-ELSE</code> definitions.</p>
<p>The <code>IF-THEN-ELSE</code> operator can be used either to define a value, or to branch some action as a sort of flow control. Defining values with <code>IF-THEN-ELSE</code> is common practice and is similar to the use of <code>IF</code> expressions in declarative programming languages. However, flow control in TLA+ can be done naturally by behavior definition through actions, making the use of <code>IF-THEN-ELSE</code> for flow control unnecessary. This idiom aims to clarify different usages of <code>IF-THEN-ELSE</code> expressions, keeping in mind the TLA+ essence of declaring actions to define transitions. </p>
<h2><a class="header" href="#when-to-use-if-then-else" id="when-to-use-if-then-else">When to use <code>IF-THEN-ELSE</code></a></h2>
<h3><a class="header" href="#when-the-result-is-not-boolean" id="when-the-result-is-not-boolean">When the result is not Boolean</a></h3>
<p>When the <code>IF-THEN-ELSE</code> expression doesn't evaluate to a Boolean value, it cannot be rewritten using Boolean operators, so this idiom doesn't apply. For example:</p>
<pre><code class="language-tla">SafeDiv(x, y) == IF y /= 0 THEN x/y ELSE 0
</code></pre>
<h3><a class="header" href="#when-the-result-is-a-state-formula" id="when-the-result-is-a-state-formula">When the result is a state formula</a></h3>
<p>State formulas are formulas that don't contain any action operator (e.g. primed variables, <code>UNCHANGED</code>). Using <code>IF-THEN-ELSE</code> on this type of formula can make it easier to read in some situations, and don't come with any disadvantage. This example state formula uses <code>IF-THEN-ELSE</code> to return a Boolean value: </p>
<pre><code class="language-tla">ValidIdentity(person) == IF Nationalized(person) THEN ValidId(person) ELSE ValidPassport(person)
</code></pre>
<p>Although it could be rewritten with Boolean operators, it doesn't read as nicely:</p>
<pre><code class="language-tla">ValidIdentity(person) == \/ /\ Nationalized(person)
                            /\ ValidId(person)
                         \/ /\ ~Nationalized(person)
                            /\ ValidPassport(person)
</code></pre>
<h2><a class="header" href="#when-there-are-dependent-conditions" id="when-there-are-dependent-conditions">When there are dependent conditions</a></h2>
<p>Nesting <code>IF-THEN-ELSE</code> expressions can be useful when there is a dependency between the conditions where some conditions are only relevant if other conditions are met. This is an example where using an <code>IF-THEN-ELSE</code> expressions is clearer than the Boolean operator form. Consider the following:</p>
<pre><code class="language-tla">IF c1
THEN a1
ELSE IF c2
THEN a2
ELSE IF
...
ELSE IF cn
THEN an
ELSE a 
</code></pre>
<p>The Boolean operator version is quite verbose:</p>
<pre><code class="language-tla">\/ c1 /\ a1
\/ ~c1 /\ c2 /\ a2
\/ ...
\/ ~c1 /\ ... /\ ~c_{n-1} /\ cn /\ an
\/ ~c1 /\ ... /\ ~c_{n-1} /\ ~cn /\ a
</code></pre>
<h2><a class="header" href="#when-and-how-not-to-use-if-then-else" id="when-and-how-not-to-use-if-then-else">When (and how) <em>not</em> to use <code>IF-THEN-ELSE</code></a></h2>
<p>Mixing <code>IF-THEN-ELSE</code> expressions with action operators introduces unnecessary branching to definitions that could be self-contained and look more like a transition definition. </p>
<pre><code class="language-tla">Withdraw(amount) == IF balance &gt;= amount 
                     THEN /\ balance' = balance - amount
                          /\ response' = &quot;SUCCESS&quot;
                     ELSE /\ UNCHANGED balance
                          /\ response' = &quot;FAILURE&quot;
</code></pre>
<p>We could separate the two branches into their own actions with clarifying names and explicit conditions, and use a disjunction between the two actions instead of the <code>IF-THEN-ELSE</code> block:</p>
<pre><code class="language-tla">WithdrawSuccess(amount) == /\ balance &gt;= amount 
                           /\ balance' = balance - amount
                           /\ response' = &quot;SUCCESS&quot;
                            
WithdrawFailure(amount) == /\ balance &lt; amount 
                           /\ response' = &quot;FAILURE&quot;
                           /\ UNCHANGED balance 
                            
Withdraw(amount) == WithdrawSuccess(amount) \/ WithdrawFailure(amount)
</code></pre>
<h2><a class="header" href="#advantages-3" id="advantages-3">Advantages</a></h2>
<ul>
<li>Each action declares fewer transitions, so it's easier to reason about it</li>
<li>A disjunction of actions is closer to a union of transition relations than an <code>IF-THEN-ELSE</code> expression is</li>
<li>Nested <code>IF-THEN-ELSE</code> expressions are an extrapolation of these problems and can over-constrain some branches if not done carefully. Using different actions defining its conditions explicitly leaves less room for implicit wrong constraints that an <code>ELSE</code> branch allows. See the example below.</li>
</ul>
<p>Assuming <code>C1()</code> is a condition for <code>A1()</code> and <code>C2()</code> is a condition for <code>A2()</code>:</p>
<pre><code class="language-tla">Next == IF C1() 
          THEN A1()
          ELSE 
            IF C2() 
              THEN A2()
              ELSE A3()
</code></pre>
<p>What if <code>C1() /\ C2()</code> is true? In this case, only <code>A1()</code> would be enabled, which is incorrect. </p>
<pre><code class="language-tla">Next == \/ /\ C1()
           /\ A1()
        \/ /\ C2()
           /\ A2()
        \/ A3()
           
</code></pre>
<p>This second definition can allow more behaviors than the first one (depending on whether <code>C1()</code> and <code>C2()</code> overlap), and these additional behaviors can be unintentionally left out when <code>IF-THEN-ELSE</code> is used without attention.</p>
<h2><a class="header" href="#disadvantages-3" id="disadvantages-3">Disadvantages</a></h2>
<p>A disjunction in TLA+ may or may not represent non-determinism, while an <code>IF-THEN-ELSE</code> is incapable of introducing non-determinism. If it's important that readers can easily differentiate deterministic and non-deterministic definitions, using <code>IF-THEN-ELSE</code> expressions can help to make determinism explicit.</p>
<h1><a class="header" href="#idiom-15-replace-sets-of-mixed-records-with-disjoint-unions" id="idiom-15-replace-sets-of-mixed-records-with-disjoint-unions">Idiom 15: Replace sets of mixed records with disjoint unions</a></h1>
<p>Message sets are canonically modeled as sets of records with mixed types. While the current type system supports this, in the future, Apalache is likely going to change support for these kinds of sets and implement stricter type-checking. See <a href="https://github.com/informalsystems/apalache/issues/401">this</a> issue for a discussion.
This document aims to provide instructions for users to migrate their specs to maintain type compatibility in the future (and improve the performance and robustness of current specs in the present).</p>
<h2><a class="header" href="#the-common-approach" id="the-common-approach">The common approach</a></h2>
<p>Apalache allows mixed sets of records, by defining the type of the set to be <code>Set(r)</code>, where <code>r</code> is the record type which contains all of the fields, which are held by at least one set member. For example:</p>
<pre><code class="language-tla">{ [x: Int], [y: Str] }
</code></pre>
<p>would have the type <code>Set([x:Int,y:Str])</code>. The only constraints Apalache imposes are that, if two set elements declared the same field name, the types of the fields have to match. Consequently, given</p>
<pre><code class="language-tla">A == { [x: Int, z: Bool], [y: Str, z: Bool] }
B == { [x: Int, z: Bool], [y: Str, z: Int] }
</code></pre>
<p><code>A</code> is considered well typed, and is assigned the type <code>Set([x:Int, y:Str, z:Bool])</code>, whereas <code>B</code> is rejected by the type checker.</p>
<p>The treatment of record types was implemented in this fashion, to maintain backward-compatibility with specifications of message-based algorithms, which typically encoded different message types as records of the shape <code>[ type: Str, ... ]</code>, where all messages shared a disambiguation filed (commonly named <code>type</code>), the value of which described the category of the message. Additional fields depended on the value of <code>type</code>.
The bellow snippet from <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos.tla</a> demonstrates this convention:</p>
<pre><code class="language-tla">\* The set of all possible messages 
Message ==      [type : {&quot;1a&quot;}, bal : Ballot]
           \union [type : {&quot;1b&quot;}, acc : Acceptor, bal : Ballot, 
                 mbal : Ballot \union {-1}, mval : Value \union {None}]
           \union [type : {&quot;2a&quot;}, bal : Ballot, val : Value]
           \union [type : {&quot;2b&quot;}, acc : Acceptor, bal : Ballot, val : Value]
</code></pre>
<p>Ultimately, this approach both disagrees with our interpretation of the purpose of a type-system for TLA+, as well as introduces unsoundness, in the sense that it makes it impossible, at the type-checking level, to detect record-field access violations.
Consider the following:</p>
<pre><code>\E m \in Message: m.type = &quot;1a&quot; /\ m.mbal = -1
</code></pre>
<p>As defined above, messages for which <code>m.type = &quot;1a&quot;</code> do not define a field named <code>mbal</code>, however, the type of <code>Message</code> is <code>Set([type: Str, ..., mbal: Int, ...])</code>, which means, that <code>m</code> is assumed to have an <code>mbal</code> field, typed <code>Int</code>. Thus, this access error can only be caught much later in the model-checking process, instead of at the level of static analysis provided by the type-checker. </p>
<h2><a class="header" href="#the-proposed-changes" id="the-proposed-changes">The proposed changes</a></h2>
<p>This section outlines a proposed migration strategy, to replace such sets in older specifications. The convention presented in this section works with both the current version of Apalache, as well as the next iteration of the type-checker, currently in development.</p>
<p>Suppose we use messages with types <code>t1,...,tn</code> in the specification and a message set variable <code>msgs</code>, like in the snippet below:</p>
<pre><code class="language-tla">
VARIABLE 
  \* @type: Set( [ type: Str, x1: a1, ..., xn: an, ... ] );
  msgs

...

\* Assuming S1: Set(a1), ..., Sn: Set(an) 
\* @type: Set( [ type: Str, x1: a1, ..., xn: an, ... ] );
Message ==      [type : {&quot;t1&quot;}, x1: S1, ...]
           \union  ...
           \union [type : {&quot;tn&quot;}, xn: Sn, ...]
...

TypeOk: msgs \subseteq Message
</code></pre>
<p>We propose the following substitution: Instead of modeling the union of all messages as a single set, we model their disjoint union explicitly, with a record, in the following way:</p>
<pre><code class="language-tla">\* @type: [ int: Set([x: Int]), str: Set([y: Str]) ];
Messages == [ 
              t1: [x1: S1, ...],
              ...,
              tn: [xn: Sn, ...] 
            ]
</code></pre>
<p>This way, <code>Messages.t1</code> represents the set of all messages <code>m</code>, for which <code>m.type</code> would have been equal to &quot;t1&quot; in the original implementation, that is, <code>[type: {&quot;t1&quot;}, x1: S1, ...]</code>.
For example, assume the original specification included</p>
<pre><code class="language-tla">Messages == [type: {&quot;t1&quot;}, x: {1,2,3}] \union [type: {&quot;t2&quot;}, y:{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}]
</code></pre>
<p>that is, defined two types of messages: &quot;t1&quot;, with an integer-valued field &quot;x&quot; and &quot;t2&quot; with a string-valued field &quot;y&quot;. The type of any <code>m \in Messages</code> would have been <code>[type: Str, x: Int, y: Str]</code> in the old approach.
The rewritten version would be:</p>
<pre><code class="language-tla">Messages == [ t1: [x:{1,2,3}], t2: [y:{&quot;a&quot;,&quot;b&quot;, &quot;c&quot;}] ]
</code></pre>
<p>If we took <code>m: [ t1: Set([x: Int]), t2: Set([y: Str]) ]</code>, <code>m</code> would be a record pointing to two disjoint sets of messages (of categories &quot;t1&quot; and &quot;t2&quot; respectively). Values in <code>m.t1</code> would be records with the type <code>[x: Int]</code> and values in <code>m.t2</code> would be records with the type <code>[y: Str]</code>. </p>
<p>Note, however, that this approach also requires a change in the way messages are added to, or read from, the &quot;set&quot; of all messages (<code>m</code> is a record representing a set, but not a set itself, in the new approach).
Previously, a message <code>m</code> would be added by writing:</p>
<pre><code>msgs' = msgs \union {m}
</code></pre>
<p>regardless of whether <code>m.type = &quot;t1&quot;</code> or <code>m.type = &quot;t2&quot;</code>. In the new approach, one must always specify which type of message is being added. However, the type no longer needs to be a property of the message itself, i.e. the <code>type</code> field is made redundant.</p>
<p>To add a message <code>m</code> of the category <code>ti</code> one should write</p>
<pre><code>msgs' = [ msgs EXCEPT !.ti = msgs.ti \union {m} ]
</code></pre>
<p>Similarly, reading/processing a message, which used to be done in the following way:</p>
<pre><code class="language-tla">\E m \in msgs:
  /\ m.type = &quot;ti&quot;
  /\ A(m)
</code></pre>
<p>is replaced by</p>
<pre><code>\E m \in msgs.ti: A(m)
</code></pre>
<h2><a class="header" href="#example-3" id="example-3">Example</a></h2>
<p>Below, we demonstrate this process on a concrete specification:
The old approach:</p>
<pre><code class="language-tla">------------------------------- MODULE MsgSetOld ------------------------------

VARIABLE 
    \* @type: Set( [ type: Str, x: Int, y: Str ] );
    msgs, 
    \* @type: Bool;
    found3,
    \* @type: Bool;
    foundC


Ints == {1,2,3}
Strs == {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}

\* @type: () =&gt; Set([ type: Str, x: Int, y: Str ] );
Messages == [ type: {&quot;int&quot;}, x: Ints ] \union [ type: {&quot;str&quot;}, y: Strs ]

Init == 
    /\ msgs = {}
    /\ found3 = FALSE
    /\ foundC = FALSE

Send(m) == msgs' = msgs \union {m}
Rm(m) == msgs' = msgs \ {m}

AddIntMsg == 
    /\ \E v \in Ints: 
        /\ Send( [type |-&gt; &quot;int&quot;, x |-&gt; v] )
    /\ UNCHANGED &lt;&lt;found3, foundC&gt;&gt;

CheckIntMsg == 
    /\ \E m \in msgs:
        /\ m.type = &quot;int&quot;
        /\ found3' = ( m.x = 3 )
        /\ Rm(m)
    /\ UNCHANGED foundC

AddStrMsg == 
    /\ \E v \in Strs: 
        /\ Send( [type |-&gt; &quot;str&quot;, y |-&gt; v] )
    /\ UNCHANGED &lt;&lt;found3, foundC&gt;&gt;

CheckStrMsg == 
    /\ \E m \in msgs:
        /\ m.type = &quot;str&quot;
        /\ foundC' = ( m.y = &quot;c&quot; )
        /\ Rm(m)
    /\ UNCHANGED found3

Next ==
    \/ AddIntMsg
    \/ CheckIntMsg
    \/ AddStrMsg
    \/ CheckStrMsg

TypeOk == msgs \subseteq Messages

===============================================================================
</code></pre>
<p>The new approach:</p>
<pre><code class="language-tla">------------------------------- MODULE MsgSetNew ------------------------------

VARIABLE 
    \* @type: [ int: Set([x: Int]), str: Set([y: Str]) ];
    msgs, 
    \* @type: Bool;
    found3,
    \* @type: Bool;
    foundC


Ints == {1,2,3}
Strs == {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}

\* no annotation required
Messages == [ 
              int |-&gt; [x: Ints],
              str |-&gt; [y: Strs]
            ]

Init == 
    /\ msgs = [ int |-&gt; {}, str |-&gt; {} ]
    /\ found3 = FALSE
    /\ foundC = FALSE

\* @type: ([x: Int]) =&gt; Bool; 
SendInt(m) == 
    msgs' = [msgs EXCEPT !.int = msgs.int \union {m}]

\* @type: ([x: Int]) =&gt; Bool; 
RmInt(m) == 
    msgs' = [msgs EXCEPT !.int = msgs.int \ {m}]

\* @type: ([y: Str]) =&gt; Bool;
SendStr(m) == 
    msgs' = [msgs EXCEPT !.str = msgs.str \union {m}]

\* @type: ([x: Int]) =&gt; Bool; 
RmStr(m) == 
    msgs' = [msgs EXCEPT !.str = msgs.str \ {m}]


AddIntMsg == 
    /\ \E v \in Ints: 
        /\ SendInt( [x |-&gt; v] )
    /\ UNCHANGED &lt;&lt;found3, foundC&gt;&gt;

CheckIntMsg == 
    /\ \E m \in msgs.int:
        /\ found3' = ( m.x = 3 )
        /\ RmInt(m)
    /\ UNCHANGED foundC

AddStrMsg == 
    /\ \E v \in Strs: 
        /\ SendStr( [y |-&gt; v] )
    /\ UNCHANGED &lt;&lt;found3, foundC&gt;&gt;

CheckStrMsg == 
    /\ \E m \in msgs.str:
        /\ foundC' = ( m.y = &quot;c&quot; )
        /\ RmStr(m)
    /\ UNCHANGED found3

Next ==
    \/ AddIntMsg
    \/ CheckIntMsg
    \/ AddStrMsg
    \/ CheckStrMsg

TypeOk == 
    /\ msgs.int \subseteq Messages.int
    /\ msgs.str \subseteq Messages.str

===============================================================================
</code></pre>
<p>Note that the new approach, in addition to being sound w.r.t. record types, also typically results in a performance improvement, since type-unification for record sets is generally expensive for the solver.</p>
<h1><a class="header" href="#rfc-001-types-and-type-annotations" id="rfc-001-types-and-type-annotations">RFC 001: types and type annotations</a></h1>
<p>Contributors (in alphabetical order): Shon Feder @shonfeder,
Igor Konnov @konnov, Jure Kukovec @Kukovec,
Markus Kuppe @lemmy, Andrey Kupriyanov @andrey-kuprianov, Leslie Lamport</p>
<p>This is an RFC that reviews a number of possibilities.
A concrete proposal can be found in <a href="adr/../../src/adr/002adr-types.html">ADR-002</a>.</p>
<p>It is good to have a number of different opinions here. We have three
questions:</p>
<ol>
<li>How to write types in TLA+.</li>
<li>How to write type annotations (as a user).</li>
<li>How to display and use inferred types.</li>
</ol>
<h2><a class="header" href="#1-how-to-write-types-in-tla" id="1-how-to-write-types-in-tla">1. How to write types in TLA+</a></h2>
<p>Everybody has a different opinion here. It would be great to use
the native TLA+ constructs to express types.</p>
<p><a name="typesAsTypeOk"></a></p>
<h3><a class="header" href="#11-typeok-syntax" id="11-typeok-syntax">1.1. TypeOK syntax</a></h3>
<p>The only way to write types in the <code>TypeOK</code> style is by set membership.
For instance:</p>
<ul>
<li><code>x</code> is an integer: <code>x \in Int</code></li>
<li><code>f</code> is a function from an integer to an integer: <code>f \in [Int -&gt; Int]</code></li>
<li><code>f</code> is a function from a set of integers to a set of integers:
<code>f \in [SUBSET Int -&gt; SUBSET Int]</code></li>
<li><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string: <code>r \in [a: Int, b: STRING]</code></li>
<li><code>f</code> is a set of functions from a tuple of integers to an integer:
<code>f \in SUBSET [Int \X Int -&gt; Int]</code></li>
<li><code>Foo</code> is an operator of an <code>Int</code> and <code>STRING</code> that returns an <code>Int</code>:
<code>\A a \in Int: \A b \in STRING: Foo(a, b) \in Int</code></li>
<li><code>Bar</code> is a higher-order operator that takes an operator that takes
an <code>Int</code> and <code>STRING</code> and returns an <code>Int</code>, and returns a <code>BOOLEAN</code>.</li>
</ul>
<p>Here is an approach to higher-order operators suggested by Leslie Lamport,
where he uses a theorem:</p>
<pre><code class="language-tla">THEOREM BarType ==
  ASSUME NEW G(_,_),
         \A x \in Int, y \in STRING : G(x,y) \in Int
         PROVE  Bar(G) \in BOOLEAN
</code></pre>
<p>Similar to that, we can write a theorem about the type of <code>Foo</code>:</p>
<pre><code class="language-tla">THEOREM FooType ==
  \A a \in Int: \A b \in STRING: Foo(a, b) \in Int
</code></pre>
<p><a name="typesAsTerms"></a></p>
<h3><a class="header" href="#12-types-as-terms" id="12-types-as-terms">1.2. Types as terms</a></h3>
<p>A classical way of writing types is by using logical terms (or algebraic datatypes).
To this end, we can define a special module <code>Types.tla</code>:</p>
<pre><code class="language-tla">---- MODULE Types ----
\* Types as terms. The right-hand side of an operator does not play a role,
\* but we define it as the corresponding set of values.
\* Alternatively, we could just define tuples of strings in rhs.

\* a type annotation operator that erases the type
value &lt;: type == value

\* the integer type
IntT == Int
\* the Boolean type
BoolT == BOOLEAN
\* the string type
StrT == STRING

\* a set type
SetT(elemT) == SUBSET elemT
\* a function type
FunT(fromT, toT) == [fromT -&gt; toT]
\* a sequence type
SeqT(elemT) == Seq(elemT)

\* tuple types
Tup0T == {}
Tup1T(t1) == t1
Tup2T(t1, t2) == t1 \X t2
Tup3T(t1, t2, t3) == t1 \X t2 \X t3
\* and so on, e.g., Scala has 26 tuples. how many do we like to have?

\* Record types. We assume that field names are alphabetically ordered.
\* We cannot use record-set notation here,
\* as the field names are parameters. So I gave up here on giving corresponding sets.
Rec1T(f1, t1) == &lt;&lt;&quot;Rec1&quot;, f1, t1&gt;&gt;
Rec2T(f1, t1, f2, t2) == &lt;&lt;&quot;Rec2&quot;, f1, t1, f2, t2&gt;&gt;
Rec3T(f1, t1, f2, t2, f3, t3) == &lt;&lt;&quot;Rec3&quot;, f1, t1, f2, t2, f3, t3&gt;&gt;
\* and so on

\* Operator types. No clear set semantics.
\* Note that the arguments can be operators as well!
\* So this approach gives us higher-order operators for free.
Oper0T(resT) == &lt;&lt;&quot;Oper0&quot;, resT&gt;&gt;
Oper1T(arg1T, resT) == &lt;&lt;&quot;Oper1&quot;, arg1T, res1T&gt;&gt;
Oper2T(arg1T, arg2T, resT) == &lt;&lt;&quot;Oper2&quot;, arg1T, arg2T, res1T&gt;&gt;
\* and so on
======================
</code></pre>
<p>Assuming that we have some syntax for writing down that <code>x</code> has type <code>T</code>,
e.g., by writing <code>x &lt;: T</code>, we can write the above examples as follows:</p>
<ul>
<li>
<p><code>x</code> is an integer: <code>x &lt;: IntT</code></p>
</li>
<li>
<p><code>f</code> is a function from an integer to an integer: <code>f &lt;: FunT(IntT, IntT)</code></p>
</li>
<li>
<p><code>f</code> is a function from a set of integers to a set of integers:
<code>f &lt;: FunT(SetT(IntT), SetT(IntT))</code></p>
</li>
<li>
<p><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string: <code>r &lt;: Rec2T(&quot;a&quot;, IntT, &quot;b&quot;, StrT)</code></p>
</li>
<li>
<p><code>f</code> is a set of functions from a tuple of integers to an integer:
<code>f &lt;: SetT(FunT(Tup2T(IntT, IntT), IntT))</code></p>
</li>
<li>
<p><code>Foo</code> is an operator of an <code>Int</code> and <code>STRING</code> that returns an <code>Int</code>:
<code>\A a: \A b: Foo(a, b) &lt;: Oper2(IntT, StrT, IntT)</code>.</p>
<ul>
<li><strong>Here it gets tricky, as the TLA+ syntax does not allow us to
mention an operator by name without applying it.</strong></li>
</ul>
</li>
<li>
<p><code>Bar</code> is a higher-order operator that takes an operator that takes
an <code>Int</code> and <code>STRING</code> and returns an <code>Int</code>, and returns a <code>BOOLEAN</code>.
<code>\A a, b, c: Bar(LAMBDA a, b: c) &lt;: Oper1(Oper2(IntT, StrT, IntT), BoolT)</code>.</p>
<ul>
<li><strong>Here we have to pull lambda operators, but at least it is possible to write
down a type annotation.</strong></li>
</ul>
</li>
</ul>
<p><a name="typesAsStrings"></a></p>
<h3><a class="header" href="#13-types-as-strings" id="13-types-as-strings">1.3. Types as strings</a></h3>
<p>Let us introduce the following grammar for types:</p>
<pre><code>T ::= var | Bool | Int | Str | T -&gt; T | Set(T) | Seq(T) |
      &lt;&lt;T, ..., T&gt;&gt; | [h_1 |-&gt; T, ..., h_k |-&gt; T] | (T, ..., T) =&gt; T
</code></pre>
<p>In this grammar, <code>var</code> stands for a type variable, which can be instantiated with
concrete variable names such as <code>a</code>, <code>b</code>, <code>c</code>, etc., whereas <code>h_1</code>,...,<code>h_k</code> are
field names. The rule <code>T -&gt; T</code> defines a function, while the rule
<code>(T, ..., T) =&gt; T</code> defines an operator.</p>
<p>Assuming that we have some syntax for writing down that <code>x</code> has type <code>T</code>,
e.g., by writing <code>isType(&quot;x&quot;, &quot;T&quot;)</code>, we can write the above examples as follows:</p>
<ul>
<li>
<p><code>x</code> is an integer: <code>isType(&quot;x&quot;, &quot;Int&quot;)</code>.</p>
</li>
<li>
<p><code>f</code> is a function from an integer to an integer: <code>isType(&quot;f&quot;, &quot;Int -&gt; Int&quot;)</code>.</p>
</li>
<li>
<p><code>f</code> is a function from a set of integers to a set of integers:
<code>isType(&quot;f&quot;, &quot;Set(Int) -&gt; Set(Int))&quot;</code>.</p>
</li>
<li>
<p><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string: <code>isType(&quot;r&quot;, &quot;[a |-&gt; Int, b |-&gt; Str])&quot;</code>.</p>
</li>
<li>
<p><code>f</code> is a set of functions from a tuple of integers to an integer:
<code>isType(&quot;f&quot;, &quot;Set(&lt;&lt;Int, Int&gt;&gt; -&gt; Int))&quot;</code>.</p>
</li>
<li>
<p><code>Foo</code> is an operator of an <code>Int</code> and <code>STRING</code> that returns an <code>Int</code>:
<code>isType(&quot;Foo&quot;, &quot;(Int, Str) =&gt; Int&quot;)</code>.</p>
</li>
<li>
<p><code>Bar</code> is a higher-order operator that takes an operator that takes
an <code>Int</code> and <code>STRING</code> and returns an <code>Int</code>, and returns a <code>BOOLEAN</code>:
<code>isType(&quot;Bar&quot;, &quot;((Int, Str) =&gt; Int) =&gt; Bool&quot;)</code>.</p>
</li>
</ul>
<p><strong>Note:</strong> We have to pass names as strings, as it is impossible to pass operator
names, e.g., <code>Foo</code> and <code>Bar</code> in other operators, unless <code>Foo</code> and <code>Bar</code>
are nullary operators and <code>isType</code> is a higher-order operator.</p>
<h2><a class="header" href="#2-how-to-write-type-annotations-as-a-user" id="2-how-to-write-type-annotations-as-a-user">2. How to write type annotations (as a user)</a></h2>
<p><strong>Note</strong>: This question is not a priority, as we do not expect the user to
write type annotations. However, it would be good to have a solution, as sometimes
users want to write types.</p>
<p>Again, we have plenty of options and opinions here:</p>
<ol>
<li>Write type annotations by calling a special operator like <code>&lt;:</code> or <code>|=</code>.</li>
<li>Write type annotations as assumptions.</li>
<li>Write type annotations in comments.</li>
<li>Write type annotations as operator definitions.</li>
</ol>
<h3><a class="header" href="#21-type-annotations-with-a-special-operator" id="21-type-annotations-with-a-special-operator">2.1. Type annotations with a special operator</a></h3>
<p>This is the current approach in Apalache. One has to define an operator, e.g., <code>&lt;:</code>:</p>
<pre><code class="language-tla">value &lt;: type == value
</code></pre>
<p>Then an expression may be annotated with a type as follows:</p>
<pre><code class="language-tla">VARIABLE S
Init ==
  S = {} &lt;: {Int}
</code></pre>
<p><strong>Pros</strong>:</p>
<ul>
<li>Intutive notation, similar to programming languages.</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>This approach works well for expressions. However, it is not clear how to extend
it to operators.</li>
<li>This notation is more like type clarification, rather than a type annotation.
Normally types are specified for names, that is, constants, variables, functions,
operators, etc.</li>
<li>Same expression may be annotated in a Boolean formula. What shall we do, if the
user writes: <code>x &lt;: BOOLEAN \/ x &lt;: Int</code>?</li>
</ul>
<p><strong>Note:</strong> The current approach has an issue. If one declares the operator <code>&lt;:</code> in
a module <code>M</code> and then uses an unnamed instance <code>INSTANCE M</code> in a module <code>M2</code>,
then <code>M</code> and <code>M2</code> will clash on the operator <code>&lt;:</code>. We should define the operator
once in a special module <code>Types</code> or <code>Apalache</code>.</p>
<p><a name="annotationsAsAssumptions"></a></p>
<h3><a class="header" href="#22-type-annotations-as-assumptions" id="22-type-annotations-as-assumptions">2.2. Type annotations as assumptions</a></h3>
<p>One can use TLA+ syntax to write assumptions and assertions about the types.
We are talking only about type assumptions here.
The similar approach can be used to write theorems about types.
Consider the following specification:</p>
<pre><code class="language-tla">EXTENDS Sequences
CONSTANTS Range
VARIABLES list

Mem(e, es) ==
  \E i \in DOMAIN es:
    e = es[i]
</code></pre>
<p>In this example, the operator <code>Mem</code> is polymorphic, whereas the types of <code>Range</code>
and <code>list</code> are parameterized.  If the user wants to
restrict the types of constants, variables, and operators, they could write (using the
<a href="adr/001rfc-types.html#typesAsTypeOk">TypeOK syntax</a>):</p>
<pre><code class="language-tla">ASSUME(Range \in SUBSET Int)
ASSUME(list \in Seq(Int))
ASSUME(\A e \in Int, \A es \in Seq(Int): Mem(e, es) \in BOOLEAN)
</code></pre>
<p>SANY parser only accepts the first assumption in the above
example. <strong>The two other assumptions are rejected by the parser, as they
refer to non-constant values.</strong></p>
<p>Moreover, using the proof syntax of
<a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf">TLA+ Version 2</a>,
we can annotate the
types of variables introduced inside the operators.  For instance, we could
label the name <code>i</code> as follows:</p>
<pre><code class="language-tla">Mem(e, es) ==
  \E i \in DOMAIN es:
    e = es[i_use :: i]
</code></pre>
<p>And then write:</p>
<pre><code class="language-tla">ASSUME(\A e, es, i: Mem(e, es)!i_use(i) \in Int)
</code></pre>
<p><strong>Pros</strong>:</p>
<ul>
<li>The assumptions syntax is quite appealing, when writing types of
CONSTANTS, VARIABLES, and top-level operators.</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>The syntax gets verbose and hard to write, when writing types of
LET-IN operators and bound variables.</li>
<li>It is not clear how to extend this syntax to higher-order operators.</li>
<li><strong>One cannot write assumptions about state variables.</strong></li>
</ul>
<h3><a class="header" href="#23-type-annotations-in-comments" id="23-type-annotations-in-comments">2.3. Type annotations in comments</a></h3>
<p>This solution basically gives up on TLA+ syntax and introduces a special
syntax à la javadoc for type annotations:</p>
<pre><code class="language-tla">EXTENDS Sequences
CONSTANTS Range \*@ Range: Set(Int)
VARIABLES list  \*@ list: Seq(Int)

Mem(e, es) ==
\*@ Mem: (Int, Seq(Int)) =&gt; Bool
  \E i \in DOMAIN es:
    \*@ i: Int
    e = es[i]
</code></pre>
<p>We have not come up with a good syntax for these annotaions. The above
example demonstrates one possible approach.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Non-verbose, simple syntax</li>
<li>Type annotations do not stand in the way of the specification author</li>
<li>Type annotations may be collapsed, removed, etc.</li>
<li>If we have an annotation preprocessor, we can use it for other
kinds of annotations</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>As we give up on the TLA+ syntax, TLA+ Toolbox will not help us
(though it is not uncommon for IDEs to parse javadoc annotations,
so there is some hope)</li>
<li>The users have to learn new syntax for writing type annotations and types</li>
<li>We have to write an annotation preprocessor</li>
</ul>
<h3><a class="header" href="#24-type-annotations-as-operator-definitions" id="24-type-annotations-as-operator-definitions">2.4. Type annotations as operator definitions</a></h3>
<p>Operators definitions and LET-IN definitions can be written almost anywhere in
TLA+. Instead of writing in-comment annotations, we can write annotations
with operator definitions (assuming <a href="adr/001rfc-types.html#typesAsStrings">types as strings</a>,
but this is not necessary):</p>
<pre><code class="language-tla">EXTENDS Sequences
CONSTANTS Range
Range_type == &quot;set(z)&quot;

VARIABLES list
list_type == &quot;seq(z)&quot;

Mem(e, es) ==
  LET Mem_type == &quot;&lt;a, seq(a)&gt; =&gt; Bool&quot; IN
  \E i \in DOMAIN es:
    LET i_type == &quot;Int&quot; IN
    e = es[i]

Init ==
  LET Init_type == &quot;&lt;&gt; =&gt; Bool&quot; IN
  list = &lt;&lt;&gt;&gt;

Next ==
  LET Next_type == &quot;&lt;&gt; =&gt; Bool&quot; IN
  \E e \in Range:
    LET e_type == &quot;set(z)&quot; IN
    list' = Append(list, e)
</code></pre>
<p><strong>Pros:</strong></p>
<ul>
<li>No need for a comment preprocessor,
easy to extract annotations from the operator definitions</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Fruitless operator definitions</li>
<li>Looks like a hack</li>
</ul>
<h2><a class="header" href="#3-how-to-display-and-use-inferred-types" id="3-how-to-display-and-use-inferred-types">3. How to display and use inferred types</a></h2>
<p><strong>TBD</strong></p>
<p>Basically, use <a href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a> and introduce
THEOREMs in the spirit of <a href="adr/001rfc-types.html#typesAsTypeOk">types as TypeOK</a>.</p>
<h1><a class="header" href="#adr-002-types-and-type-annotations" id="adr-002-types-and-type-annotations">ADR-002: types and type annotations</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th><th align="right">revision date</th></tr></thead><tbody>
<tr><td>Shon Feder, Igor Konnov, Jure Kukovec</td><td align="right">8</td><td align="right">July 22, 2022</td></tr>
</tbody></table>
<p><em>This is an architectural decision record. For user documentation, check the
<a href="https://apalache.informal.systems/docs/tutorials/snowcat-tutorial.html">Snowcat tutorial</a> and <a href="https://apalache.informal.systems/docs/HOWTOs/howto-write-type-annotations.html">Snowcat HOWTO</a>.</em></p>
<p>This is a follow up of <a href="adr/./001rfc-types.html">RFC-001</a>, which discusses plenty of
alternative solutions. In this <strong>ADR-002</strong>, we fix one solution that seems to be
most suitable. The interchange format for the type inference tools will be
discussed in a separate ADR.</p>
<ol>
<li>How to write types in TLA+ (Type Systems 1 and 1.2).</li>
<li>How to write type annotations (as a user).</li>
</ol>
<p>This document assumes that one can write a simple type checker that computes
the types of all expressions based on the annotations provided by the user.
Such an implementation is provided by the type checker Snowcat.
See the <a href="adr/../apalache/typechecker-snowcat.html">manual chapter</a> on Snowcat.</p>
<p>System engineers often want to write type annotations and quickly check types
when writing TLA+ specifications. This document is filling this gap.</p>
<h2><a class="header" href="#1-how-to-write-types-in-tla-1" id="1-how-to-write-types-in-tla-1">1. How to write types in TLA+</a></h2>
<p><a id="ts1"></a></p>
<h3><a class="header" href="#11-type-grammar-type-system-1-or-ts1" id="11-type-grammar-type-system-1-or-ts1">1.1. Type grammar (Type System 1, or TS1)</a></h3>
<p><strong>Upgrade warning.</strong> This system is replaced with <a href="adr/002adr-types.html#ts12">Type System 1.2</a>.
In October of 2022, we will stop supporting Type System 1. For the transition
period, pass <code>--features=no-rows</code> to Apalache, to enable Type System 1.</p>
<p>We write types as strings that follow the type grammar:</p>
<pre><code>T ::=   // Booleans
      | 'Bool'
        // integers
      | 'Int'
        // immutable constant strings
      | 'Str'
        // functions
      | T '-&gt;' T
        // sets
      | 'Set' '(' T ')'
        // sequences
      | 'Seq' '(' T ')'
        // tuples
      | '&lt;&lt;' T ',' ...',' T '&gt;&gt;'
        // operators
      | '(' T ',' ...',' T ')' '=&gt;' T
        // constant types (uninterpreted types)
      | typeConst
        // type variables
      | typeVar
        // parentheses, e.g., to change associativity of functions
      | '(' T ')'
        // imprecise records of Type System 1, removed in Type System 1.2
      | '[' field ':' T ',' ...',' field ':' T ']'

field     ::= &lt;an identifier that matches [a-zA-Z_][a-zA-Z0-9_]*&gt;

typeConst ::= &lt;an identifier that matches [A-Z_][A-Z0-9_]*&gt;

typeVar   ::= &lt;a single letter from [a-z]&gt;
</code></pre>
<p>The type rules have the following meaning:</p>
<ul>
<li>The rules <code>Bool</code>, <code>Int</code>, <code>Str</code> produce primitive types:
the Boolean type, the integer type, and the string type, respectively.</li>
<li>The rule <code>T -&gt; T</code> produces a function.</li>
<li>The rule <code>Set(T)</code> produces a set type over elements of type <code>T</code>.</li>
<li>The rule <code>Seq(T)</code> produces a sequence type over elements of type <code>T</code>.</li>
<li>The rule <code>&lt;&lt;T, ..., T&gt;&gt;</code> produces a tuple type over types that
are produced by <code>T</code>. <em>Types at different positions may differ</em>.</li>
<li>The rule <code>[field: T, ..., field: T]</code> produces a record type over types that
are produced by <code>T</code>. <em>Types at different positions may differ.</em>
<em>This syntax will change in <a href="adr/002adr-types.html#ts12">Type System 1.2</a>.</em></li>
<li>The rule <code>(T, ..., T) =&gt; T</code> defines an operator whose result type and parameter types are produced by <code>T</code>.</li>
<li>The rule <code>typeConst</code> defines an uninterpreted type (or a reference to a type alias), look for an explanation below.</li>
<li>The rule <code>typeVar</code> defines a type variable, look for an explanation below.</li>
</ul>
<p>Importantly, a multi-argument function always receives a tuple, e.g., <code>&lt;&lt;Int, Bool&gt;&gt; -&gt; Int</code>, whereas a single-argument function receives the type of its
argument, e.g., <code>Int -&gt; Int</code>.  The arrow <code>-&gt;</code> is right-associative, e.g., <code>A -&gt; B -&gt; C</code> is understood as <code>A -&gt; (B -&gt; C)</code>, which is consistent with programming
languages. If you like to change the priority of <code>-&gt;</code>, use parentheses, as
usual.  For example, you may write <code>(A -&gt; B) -&gt; C</code>.</p>
<p>An operator always has the types of its arguments inside <code>(...)</code>, e.g., <code>(Int, Bool) =&gt; Int</code> and <code>() =&gt; Bool</code>. If a
type <code>T</code> contains a type variable, e.g.,
<code>a</code>, then <code>T</code> is a polymorphic type, in which <code>a</code> can be instantiated with a monotype (a variable-free term). Type
variables are useful for describing the types of polymorphic operators. Although the grammar accepts an operator type
that returns an operator, e.g., <code>Int =&gt; (Int =&gt; Int)</code>, such a type does not have a meaningful interpretation in TLA+.
Indeed, TLA+ does not allow operators to return other operators.</p>
<p>A type constant should be understood as a type we don't know and we don't want to know, that is, an uninterpreted type.
Type constants are useful for fixing the types of CONSTANTS and using them later in a specification. Two different type
constants correspond to two different -- yet uninterpreted -- types. If you
know <a href="https://github.com/Z3Prover/z3">Microsoft Z3</a>, a type constant can be understood as an uninterpreted sort in SMT.
Essentially, values of an uninterpreted type can be only checked for equality.</p>
<p>Another use for a type constant is referring to a type alias, see <a href="adr/002adr-types.html#defTypeAlias">Section 1.2</a>. This is purely a
convenience feature to make type annotations more concise and easier to maintain. We expect that only users will write
type aliases: tools should always exchange data with types in the alias-free form.</p>
<p><strong>Examples.</strong></p>
<ul>
<li><code>x</code> is an integer. Its type is <code>Int</code>.</li>
<li><code>f</code> is a function from an integer to an integer. Its type is <code>Int -&gt; Int</code>.</li>
<li><code>f</code> is a function from a set of integers to a set of integers.
Its type is <code>Set(Int) -&gt; Set(Int)</code>.</li>
<li><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string. Its type is <code>[a: Int, b: Str]</code>.
This is the old syntax for record types, see <a href="adr/002adr-types.html#ts12">Type System 1.2</a>.</li>
<li><code>F</code> is a set of functions from a pair of integers to an integer.
Its type is <code>Set(&lt;&lt;Int, Int&gt;&gt; -&gt; Int)</code>.</li>
<li><code>Foo</code> is an operator of an integer and of a string that returns an integer.
Its type is  <code>(Int, Str) =&gt; Int</code>.</li>
<li><code>Bar</code> is a higher-order operator that takes an operator that takes
an integer and a string and returns an integer, and returns a Boolean.
Its type is  <code>((Int, Str) =&gt; Int) =&gt; Bool</code>.</li>
<li><code>Baz</code> is a polymorphic operator that takes two arguments of the same type
and returns a value of the type equal to the types of its arguments.
Its type is <code>(a, a) =&gt; a</code>.</li>
<li><code>Proc</code> and <code>Faulty</code> are sets of the same type.
Their type is <code>Set(PID)</code>.</li>
</ul>
<p><a id="defTypeAlias"></a></p>
<h3><a class="header" href="#12-type-aliases" id="12-type-aliases">1.2. Type aliases</a></h3>
<h4><a class="header" href="#new-syntax-for-type-aliases" id="new-syntax-for-type-aliases">New syntax for type aliases</a></h4>
<p>We introduce a special syntax for introducing type alises, which is
defined by the following single-rule grammar:</p>
<pre><code>A ::= aliasName &quot;=&quot; T
// an identifer in camel case, starting with a lower-case letter
aliasName ::= [a-z]+(?:[A-Z][a-z]*)*
</code></pre>
<p>Typically, a type alias is defined via an annotation such as:</p>
<pre><code class="language-tla">\* @typeAlias: setOfIntegers = Set(Int);
module_typedefs == TRUE
</code></pre>
<p>To refer to a type alias, we extend the grammar <code>T</code> with one more option:</p>
<pre><code>T ::= // all rules as above
     | '$' aliasName
</code></pre>
<p>Whenever the type checker meets a reference like <code>$aliasName</code>, it tries to
substitute <code>$aliasName</code> with the type that was earlier defined with the type
alias. If no such alias is found, the type checker emits a type error.</p>
<h4><a class="header" href="#old-syntax-for-type-aliases" id="old-syntax-for-type-aliases">Old syntax for type aliases</a></h4>
<p><em>This is the old syntax. We will drop its support in September, 2022.</em></p>
<p>Similar to the old syntax, type aliases are defined via a one-grammar rule:</p>
<pre><code>A_old ::= typeConst &quot;=&quot; T
</code></pre>
<p>In contrast to the new syntax, the rule <code>A_old</code> uses the same syntax for
aliases as for type constants.  This rule binds a type (produced by <code>T</code>) to a
name (produced by <code>typeConst</code>). As you can see from the definition of
<code>typeConst</code>, the name should be an identifier in the upper case. The type
checker should use the bound type instead of the constant type.</p>
<p>In retrospect, this syntax confused the users and introduced usability issues.
For instance, when the users forgot to include a type alias, the type alias was
interpreted as a type constant, and the type checker showed incomprehensible
error messages.</p>
<p><a id="rows"></a>
<a id="ts12"></a></p>
<h3><a class="header" href="#13-type-system-12-including-precise-records-variants-and-rows" id="13-type-system-12-including-precise-records-variants-and-rows">1.3. Type System 1.2, including precise records, variants, and rows</a></h3>
<p>As discussed in <a href="https://github.com/informalsystems/apalache/blob/main/docs/src/adr/014adr-precise-records.md">ADR014</a>, many users expressed the need for precise type
checking for records in Snowcat. Records in untyped TLA+ are used in two
capacities: as plain records and as variants. While the technical proposal is
given in <a href="https://github.com/informalsystems/apalache/blob/main/docs/src/adr/014adr-precise-records.md">ADR014</a>, we discuss the extension of the type grammar in this
ADR-002. If you do not know about row typing, it may be useful to check the
Wikipedia page on  <a href="https://en.wikipedia.org/wiki/Row_polymorphism">Row polymorphism</a>. We extend the grammar with new
records, variants, and rows as follows:</p>
<pre><code>// Type System 1.2
T12 ::=
    // all types of Type System 1 except records
    T
    // A new record type with a fully defined structure.
    // The set of fields may be empty. If typeVar is present,
    // the record type is parameterized (typeVar must be of the 'row' kind).
    | '{' field ':' T12 ',' ...',' field ':' T12 [',' typeVar] '}'
    // A variant that contains several options,
    // optionally parameterized (typeVar must be of the 'row' kind).
    | variantOption '|' ... '|' variantOption '|' [typeVar]
    // A purely parameterized variant (typeVar must be of the 'row' kind).
    | 'Variant' '(' typeVar ')'

variantOption ::=
    // A variant option with a fully defined structure,
    // tagged with a name that is defined with 'identifier'
    identifier '(' T12 ')'

// Special syntax for the rows, which is internal to the type checker.
row ::=
    // A row with a fully defined structure
    //   (having at least one field).
    | '(|' field ':' T12 '|' ...'|' field ':' T12 '|)'
    // A row with a partially defined structure
    //   (having at least one field and ending with a variable of the 'row' kind).
    | '(|' field ':' T12 '|' ...'|' field ':' T12 '|' typeVar '|)'
</code></pre>
<p><strong>Examples.</strong></p>
<ul>
<li>
<p><code>r1</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer and
<code>b</code> is a string. Its type is <code>{ a: Int, b: Str }</code>.</p>
</li>
<li>
<p><code>r2</code> is a record that has the fields <code>a</code> of type <code>Int</code> and <code>b</code> of type <code>Str</code>
and other fields, whose precise structure is captured with a type variable
<code>c</code>. The type of <code>r2</code> is <code>{ a: Int, b: Str, c }</code>.  More precisely, the
variable <code>c</code> must be a row. For instance, <code>c</code> can be equal to the row <code>(| f: Bool | g: Set(Int) |)</code>; in this case, <code>r2</code> would be a record of type <code>{ a: Int, b: Str, f: Bool, g: Set(Int) }</code>.</p>
</li>
<li>
<p><code>v1</code> is a variant that has one of the two possible shapes:</p>
<ul>
<li>Either it carries the tag <code>A</code> and an associated value of type <code>Int</code>, or</li>
<li>It carries the tag <code>B</code> and an associated value of type <code>Bool</code>.</li>
<li>The type of <code>v1</code> is <code>A(Int) | B(Bool)</code>.</li>
</ul>
</li>
<li>
<p><code>v2</code> is a variant whose structure is entirely defined by the type variable
<code>b</code>. The type of <code>v2</code> is <code>Variant(b)</code>. Note that <code>b</code> must be a
row. For instance, it could be equal to <code>(| A: Int | B: Str |)</code>.</p>
</li>
</ul>
<p>Note that this syntax encapsulates rows in records and variants. We introduce
the syntax for row types for completeness. Most likely, the users will never
see messages that mention rows explicitly, without referring to records or
variants. </p>
<p><a id="comments"></a></p>
<h3><a class="header" href="#14-comments-inside-types" id="14-comments-inside-types">1.4. Comments inside types</a></h3>
<p>When you introduce records that have dozens of fields, it is useful to explain
those fields right in the type annotations. For that reason, the type lexer
supports one-line comments right in the type definitions. The following
text presents a type definition that contains comments:</p>
<pre><code>// packets are stored in a set
Set({
  // unique sequence number
  seqno: Int,
  // payload hash
  payloadHash: Str
})
</code></pre>
<p>The parser only supports one-line comments that starts with <code>//</code>. Since type
annotations are currently written inside TLA+ comments, we feel that more
complex comments would complicate the matters.</p>
<h3><a class="header" href="#15-discussion" id="15-discussion">1.5. Discussion</a></h3>
<p>Our type grammar presents a minimal type system that, in our understanding,
captures all interesting cases that occur in practice. Obviously, this type
system considers ill-typed some perfectly legal TLA+ values. For instance, we
cannot assign a reasonable type to <code>{1, TRUE}</code>.</p>
<p><strong>Legacy: Sets of tagged records in Type System 1.</strong> We can assign a reasonable
type to the set:</p>
<pre><code class="language-tla">{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1], [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}
</code></pre>
<p>This pattern often occurs in practice, e.g., see <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>.  The type of that
set will be <code>Set([type: Str, bal: Int, val: Int])</code>, which is probably not what
you expected, but it is the best type we can actually compute without having
algebraic datatypes in TLA+. It also reminds the user that one must test the
field <code>type</code> carefully.</p>
<p>In retrospect, we have found that almost every user of Apalache made typos in
their record types (including the Apalache developers!). Hence, we are
migrating to Type System 1.2.</p>
<p><strong>Default: Sets of tagged records (variants) in Type System 1.2.</strong> Apalache
provides the user with the module <a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Variants.tla">Variants.tla</a> that implements operators
over <a href="https://en.wikipedia.org/wiki/Tagged_union">variant types</a>.</p>
<p>Using variants, we can write the above set of messages as follows:</p>
<pre><code class="language-tla">{
  Variant(&quot;M1a&quot;, [bal |-&gt; 1]),
  Variant(&quot;M2a&quot;, [bal |-&gt; 2, val |-&gt; 3])
}
</code></pre>
<p>In Type System 1.2 (<a href="adr/002adr-types.html#ts12">Section 1.3</a>), this set has the type of a set over a variant
type:</p>
<pre><code class="language-tla">  Set(
      M1a({ bal: Int })
    | M2a({ bal: Int, val: Int })
    | a
  )
</code></pre>
<p>Note that the variant type is open-ended (parameterized with <code>a</code>) in the above
example, as we have not restricted its type. If we want to restrict the type to
exactly two options, we have to do that explicitly:</p>
<pre><code class="language-tla">  \* @typeAlias: MESSAGE = M1a({ bal: Int }) | M2a({ bal: Int, val: Int });
  LET \* @type: Int =&gt; MESSAGE;
    M1a(bal) == Variant(&quot;M1a&quot;, [bal |-&gt; bal])
  IN
  LET \* @type: (Int, Int) =&gt; MESSAGE;
    M2a(bal, val) == Variant(&quot;M2a&quot;, [bal |-&gt; bal, val |-&gt; val])
  IN
  { M1a(1), M2a(2, 3) }
</code></pre>
<p>Many programming languages would automatically declare constructors such as
<code>M2a</code> and <code>M1a</code> from the type declaration. Since we are extending TLA+ with
types, we have to introduce some idiomatic boilerplate code. This could be
handled better in a surface syntax that is designed with types in mind.</p>
<p><strong>Other type systems.</strong>
Type System 1 is also very much in line with the <a href="https://dblp.org/search?q=Automatic+Verification+of+%7BTLA%7D+%2B+Proof+Obligations+with+%7BSMT%7D+Solvers">type system by Stephan Merz and Hernan Vanzetto</a>,
which is used internally by
<a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a> when translating proof obligations in SMT. We introduce
types for user-defined operators, on top of their types for TLA+ expressions that do not contain user-defined operators.</p>
<p>We expect that this type system will evolve in the future. That is why we call
it <strong>Type System 1</strong>. <a href="adr/002adr-types.html#ts12">Section 1.3</a> presents its extension to <strong>Type System
1.2</strong>. Feel free to suggest <strong>Type System 2.0</strong> :-)</p>
<h2><a class="header" href="#2-how-to-write-type-annotations-as-a-user-1" id="2-how-to-write-type-annotations-as-a-user-1">2. How to write type annotations (as a user)</a></h2>
<p>In the following, we discuss how to annotate different TLA+ declarations.</p>
<p><em>In the previous version of this document, we defined two operators:
<code>AssumeType(_, _)</code> and <code>_ ## _</code>. They are no longer needed as we have introduced <a href="adr/./004adr-annotations.html">Code annotations</a>.</em></p>
<h3><a class="header" href="#21-annotating-constants-and-variables" id="21-annotating-constants-and-variables">2.1. Annotating CONSTANTS and VARIABLES</a></h3>
<p>Simply write an annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the declaration of a constant declaration or
a variable. See the following example:</p>
<pre><code class="language-tla">CONSTANT
  \* @type: Int;
  N,
  \* @type: Set(ID);
  Base

VARIABLE
  \* @type: ID;
  x,
  \* @type: Set(ID);
  S
</code></pre>
<p><strong>Why don't we use THEOREMs?</strong> It is tempting to declare the types of variables
as theorems. For example:</p>
<pre><code class="language-tla">THEOREM N &lt;: &quot;Int&quot;
</code></pre>
<p>However, this theorem must be proven. A <em>type inference engine</em> would be able
to infer the type of <code>N</code> and thus state such a theorem. However, with type
assumptions, the user merely states the variable types and the <em>type checker</em>
has a simple job of checking type consistency and finding the types of the
expressions.</p>
<h2><a class="header" href="#22-annotating-operators" id="22-annotating-operators">2.2. Annotating operators</a></h2>
<p>Again, write a type annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the operator declaration. For example:</p>
<pre><code class="language-tla">\* @type: (a, Seq(a)) =&gt; Bool;
Mem(e, es) ==
    (e \in {es[i]: i \in DOMAIN es})
</code></pre>
<p>Higher-order operators are also easy to annotate:</p>
<pre><code class="language-tla">\* @type: ((a) =&gt; Bool, Seq(a)) =&gt; Int;
Find(Pred(_), es) ==
    IF \E i \in DOMAIN es: Pred(es[i])
    THEN CHOOSE i \in DOMAIN es: Pred(es[i])
    ELSE -1
</code></pre>
<p>The following definition declares a (global) function, not an
operator. However, the annotation syntax is quite similar to that of the
operators (note though that we are using <code>-&gt;</code> instead of <code>=&gt;</code>):</p>
<pre><code class="language-tla">\* @type: (a -&gt; b) -&gt; Int;
CardDomain[f \in T] ==
    LET \* @type: Set(a);
        \* we could also write: &quot;() =&gt; Set(a)&quot; instead of just &quot;Set(a)&quot;
        D == DOMAIN f
    IN LET \* @type: (Int, Int) =&gt; Int;
           PlusOne(p,q) == p + 1
    IN FoldSet(PlusOne, 0, D)
</code></pre>
<p>In the definition of <code>CardDomain</code>, we annotated the let-definition <code>D</code> with its type, though any type checker should be
able to compute the type of
<code>D</code> from its context. So the type of <code>D</code> is there for clarification. According to our type grammar, the type of <code>D</code> should be <code>() =&gt; Set(a)</code>, as <code>D</code> is an operator. It is not obvious from the syntax: TLA+ blends in nullary operators with other names. We have found that LET-definitions without arguments are so common, so it is more convenient to write the shorter type annotation, that is, just <code>Set(a)</code>.</p>
<h3><a class="header" href="#23-dealing-with-bound-variables" id="23-dealing-with-bound-variables">2.3. Dealing with bound variables</a></h3>
<p>A number of TLA+ operators are defining bound variables. Following <a href="https://lamport.azurewebsites.net/tla/summary.pdf">TLA+
Summary</a>, we list these
operators here (we omit the unbounded quantifiers and temporal quantifiers):</p>
<ul>
<li><code>\A x \in S: P</code></li>
<li><code>\E x \in S: P</code></li>
<li><code>CHOOSE x: P</code></li>
<li><code>{x \in S: P}</code></li>
<li><code>{e: x \in S}</code></li>
<li><code>[x \in S |-&gt; e}</code></li>
</ul>
<p>We do not introduce any special annotation to support these operators. Indeed, they are all introducing bound variables
that range over sets. In most cases, the type checker should be able to extract the element type from a set expression.</p>
<p>However, there are a few pathological cases arising from empty collections. For example:</p>
<pre><code class="language-tla">/\ \E x \in {}: x &gt; 1
/\ f = [x \in {} |-&gt; 2]
/\ z \in DOMAIN &lt;&lt; &gt;&gt;
</code></pre>
<p>Similar typing issues occur in programming languages, e.g., Scala and Java. In these rare cases, you can write an
auxiliary LET-definition to specify the type of the empty collection:</p>
<pre><code class="language-tla">/\ LET \* @type: Set(Int);
       EmptyInts == {}
   IN
   \E x \in EmptyInts: x &gt; 1
/\ LET \* @type: Set(Str);
       EmptyStrings == {}
   IN
   f = [x \in EmptyStrings |-&gt; 2]
/\ LET \* @type: Seq(Int);
       EmptyIntSeq == {}
   IN
   z \in DOMAIN EmptyIntSeq
</code></pre>
<p>The type checker uses the type annotation to refine the type of an empty set
(or, of an empty sequence).</p>
<p><a id="useTypeAlias"></a></p>
<h3><a class="header" href="#24-introducing-and-using-type-aliases" id="24-introducing-and-using-type-aliases">2.4. Introducing and using type aliases</a></h3>
<p>A type alias is introduced with the annotation <code>@typeAlias: &lt;ALIAS&gt; = &lt;Type&gt;;</code>.
Since it is convenient to group type aliases of a module <code>MyModule</code>
in one place, we usually use the following idiom:</p>
<pre><code class="language-tla">\* @typeAlias: id = Int;
\* @typeAlias: entry = { a: $id, b: Bool };
MyModule_typedefs == TRUE

VARIABLE
    \* @type: Set($entry);
    msgs

\* @type: (Set($entry), $entry) =&gt; $entry;
Foo(ms, m) ==
    msgs' = ms \union {m}
</code></pre>
<p>The use of the dummy operator is a convention followed to simplify reasoning
about where type aliases belong, and to ensure all aliases are located in one
place. The prefix such as the module name protects against name clashes when
the module is extended or instantiated.</p>
<p>The actual rules around the placement of the <code>@typeAlias</code> annotation allows more
flexibility:</p>
<ol>
<li>
<p>You can define a type alias with <code>@typeAlias</code> anywhere you can define a <code>@type</code>.</p>
</li>
<li>
<p>The names of type aliases must be unique in a module.</p>
</li>
<li>
<p>There is no scoping for aliases within a module. Even if an alias is defined
deep in a tree of LET-IN definitions, it can be referenced at any level in
the module.</p>
</li>
</ol>
<h2><a class="header" href="#3-example" id="3-example">3. Example</a></h2>
<p>As an example that contains non-trivial type information, we chose the specification
of <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">Cigarette Smokers</a>
by @mryndzionek from <a href="https://github.com/tlaplus/Examples/tree/master/specifications">TLA+ Examples</a>. In this document,
we focus on the type information and give a shorter version of the specification. For detailed comments,
check <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">the original
specification</a>.</p>
<pre><code class="language-tla">---------------------- MODULE CigaretteSmokersTyped --------------------------
(***************************************************************************)
(* A specification of the cigarette smokers problem, originally            *)
(* described in 1971 by Suhas Patil.                                       *)
(* https://en.wikipedia.org/wiki/Cigarette_smokers_problem                 *)
(*                                                                         *)
(* This specification has been extended with type annotations for the      *)
(* demonstration purposes. Some parts of the original specification are    *)
(* omitted for brevity.                                                    *)
(*                                                                         *)
(* The original specification by @mryndzionek can be found here:           *)
(* https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla *)
(***************************************************************************)

EXTENDS Integers, FiniteSets

CONSTANT
  \* @type: Set(INGREDIENT);
  Ingredients,
  \* @type: Set(Set(INGREDIENT));
  Offers

VARIABLE
  \* @type: INGREDIENT -&gt; { smoking: Bool };
  smokers,
  \* @type: Set(INGREDIENT);
  dealer

(* try to guess the types in the code below *)
ASSUME /\ Offers \subseteq (SUBSET Ingredients)
       /\ \A n \in Offers : Cardinality(n) = Cardinality(Ingredients) - 1

vars == &lt;&lt;smokers, dealer&gt;&gt;

(***************************************************************************)
(* 'smokers' is a function from the ingredient the smoker has              *)
(* infinite supply of, to a BOOLEAN flag signifying smoker's state         *)
(* (smoking/not smoking)                                                   *)
(* 'dealer' is an element of 'Offers', or an empty set                     *)
(***************************************************************************)
TypeOK == /\ smokers \in [Ingredients -&gt; [smoking: BOOLEAN]]
          /\ dealer  \in Offers \/ dealer = {}

\* @type: (Set(INGREDIENT), (INGREDIENT) =&gt; Bool) =&gt; INGREDIENT;
ChooseOne(S, P(_)) ==
    (CHOOSE x \in S : P(x) /\ \A y \in S : P(y) =&gt; y = x)

Init ==
    /\ smokers = [r \in Ingredients |-&gt; [smoking |-&gt; FALSE]]
    /\ dealer \in Offers

startSmoking ==
    /\ dealer /= {}
    /\ smokers' = [r \in Ingredients |-&gt;
                    [smoking |-&gt; {r} \union dealer = Ingredients]]
    /\ dealer' = {}

stopSmoking ==
    /\ dealer = {}
        (* the type of LAMBDA should be inferred from the types
           of ChooseOne and Ingredients *)
    /\ LET r == ChooseOne(Ingredients, LAMBDA x : smokers[x].smoking)
       IN smokers' = [smokers EXCEPT ![r].smoking = FALSE]
    /\ dealer' \in Offers

Next ==
    startSmoking \/ stopSmoking

Spec ==
    Init /\ [][Next]_vars

FairSpec ==
    Spec /\ WF_vars(Next)

AtMostOne ==
    Cardinality({r \in Ingredients : smokers[r].smoking}) &lt;= 1
=============================================================================
</code></pre>
<h1><a class="header" href="#adr-003-transition-executor-trex" id="adr-003-transition-executor-trex">ADR-003: transition executor (TRex)</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">1</td></tr>
</tbody></table>
<p>Transition executor is a new abstraction layer between the model checker and
the translator of TLA+ expressions to SMT. The goal of this layer is to do the
following:</p>
<ul>
<li>encapsulate the interaction with:
<ul>
<li>the translator to SMT (called <code>SymbStateRewriter</code>)</li>
<li>the SMT solver (accessed via <code>Z3SolverContext</code>)</li>
<li>the type checker (accessed via <code>TypeFinder</code>)</li>
</ul>
</li>
<li>provide the model checker with an API for symbolic execution:
<ul>
<li>independent of the assumptions about how satisfiability of TLA+
formulas is checked</li>
<li>constraints can be added and removed incrementally,
even if the background SMT solver is non-incremental
(this is important as some constraints are better solved by incremental
solvers and some constraints are better solved by offline solvers)</li>
<li>the state of the symbolic execution (context) can be saved
and restored on another machine (essential for a multicore or distributed
model checker)</li>
</ul>
</li>
</ul>
<p>TRex can be thought of as an API for a satisfiability solver on top of TLA+ (in
the fragment of <a href="https://apalache.informal.systems/docs/apalache/kera.html">KerA+</a>). We can even say that TRex is a solver for TLA+, in
contrast to an SMT solver, which is a solver for theories in first-order logic.
As TLA+ is built around the concepts of a state and a transition, the TRex API
abstracts symbolic execution in terms of symbolic states and symbolic
transitions.</p>
<h2><a class="header" href="#classes" id="classes">Classes</a></h2>
<p>The figure below shows the class diagram of the essential classes
in TRex.  <code>TransitionExecutor</code> provides the higher level (a model checker) with
an API for symbolic execution. <code>TransitionExecutorImpl</code> is the implementation
of <code>TransitionExecutor</code>. It maintains <code>ExecutionContext</code> that interacts with
the lower layer: the translator to SMT, the SMT solver, and the type checker.</p>
<p>Importantly, there are two implementations of <code>ExecutionContext</code>: an
incremental one (<code>IncrementalExecutionContext</code>) and an offline one
(<code>OfflineExecutionContext</code>). In contrast to the standard stack API of SMT
solvers (push/pop), <code>ExecutionContext</code> operates in terms of differential
snapshots. The implementation decides on how to translate differential
snapshots into interactions with the SMT solver.</p>
<p><code>IncrementalExecutionContext</code> simply maintains the SMT context stack by calling
<code>push</code> and <code>pop</code>. When a snapshot must be taken, it simply returns the depth of
the context stack.  Recovery from a snapshot is done by a sequence of calls to
pop. (<code>IncrementalExecutionContext</code> is not able to recover to an arbitrary
snapshot that is not subsumed by its current stack.) Thus,
<code>IncrementalExecutionContext</code> can be used for efficient interaction with an
incremental SMT solver on a single machine (even in a single thread, as Z3
contexts are not multithreaded).</p>
<p><code>OfflineExecutionContext</code> records calls to SMT with the wrapper
<code>RecordingZ3SolverContext</code>. A snapshot produces an hierarchical log of calls to
SMT that can be replayed in another <code>OfflineExecutionContext</code>, even on another
machine.</p>
<p><img src="adr/./trex-arch.png" alt="TRex architecture" /></p>
<h2><a class="header" href="#interaction-with-transitionexecutor" id="interaction-with-transitionexecutor">Interaction with TransitionExecutor</a></h2>
<p>We demonstrate a typical interaction with <code>TransitionExecutor</code> for the
following TLA+ specification, which has been preprocessed by the passes
preceding the model checker pass:</p>
<pre><code class="language-tla">------------- MODULE Test -------------
EXTENDS Integers
CONSTANT N
VARIABLES x

ConstInit ==
  N &gt; 0

Init$0 ==
  x = 10

Next$0 ==
  x &lt; 0 /\ x' = x + N

Next$1 ==
  x &gt;= 0 /\ x' = x - N

Inv ==
  x &gt;= 0

=======================================
</code></pre>
<p>The sequence diagram below shows how the sequential model checker translates
<code>ConstInit</code> to SMT and then translates <code>Init$0</code>.</p>
<p><img src="adr/./trex-initialization.png" alt="Initialization" /></p>
<p>The sequence diagram below shows how the sequential model checker translates
<code>Next$0</code> and <code>Next$1</code> to SMT. It first finds that <code>Next$0</code> is disabled and
then it finds that <code>Next$1</code> is enabled. The enabled transition is picked.</p>
<p><img src="adr/./trex-step.png" alt="Step" /></p>
<p>The sequence diagram below shows how the sequential model checker translates
<code>~Inv</code> to SMT and checks, whether there is a concrete state that witnesses
the negation of the invariant.</p>
<p><img src="adr/./trex-inv.png" alt="Invariant" /></p>
<p>As you can see, <code>TransitionExecutor</code> is still offering a lot flexibility to the
model checker layer, while it is completely hiding the lower layer.  We do not
explain how the parallel checker is working. This is a subject to another ADR.</p>
<p>To sum up, this layer is offering you a nice abstraction to write different
model checking strategies.</p>
<h1><a class="header" href="#adr-004-syntax-for-java-like-annotations-in-tla-comments" id="adr-004-syntax-for-java-like-annotations-in-tla-comments">ADR-004: Syntax for Java-like annotations in TLA+ comments</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">2</td></tr>
</tbody></table>
<p>This ADR documents our decision on using Java-like annotations in comments.
Our main motivation to have annotations is to simplify type annotations, as
presented in <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR-002</a>. Hence, in the following text, we are using
examples for type annotations. However, the annotations framework is not
restricted to types. Similar to Java and Scala, we can use annotations
to decorate operators with hints, which may aid the model checker.</p>
<h2><a class="header" href="#1-what-can-be-annotated" id="1-what-can-be-annotated">1. What can be annotated</a></h2>
<p>Annotations should be written in comments that are written in front of a
declaration. The following declarations are supported:</p>
<ol>
<li>Constant declarations, e.g., <code>CONSTANT N</code>.</li>
<li>Variable declarations, e.g., <code>VARIABLE x</code>.</li>
<li>Operator declarations, including:</li>
<li>Top-level operator declarations, e.g., <code>Foo(x) == e</code>.</li>
<li>Operators defined via LET-IN, e.g., <code>Foo(x) == LET Inner(y) == e IN f</code>.</li>
<li>Recursive operators, e.g., <code>RECURSIVE Fact(_) Fact(n) == ...</code></li>
<li>Recursive and non-recursive functions including:</li>
<li>Top-level functions, e.g., <code>foo[i \in Int] == e</code>.</li>
<li>Functions defined via LET-IN, e.g.,<code>Foo == LET foo[i \in Int] == e IN f</code></li>
</ol>
<p>For an example, see Section 3.</p>
<h2><a class="header" href="#2-annotations-syntax" id="2-annotations-syntax">2. Annotations syntax</a></h2>
<p>An annotation is a string that follows the grammar (question mark denotes
optional rules):</p>
<pre><code>Annotation  ::= '@' tlaIdentifier ( '(' ArgList? ')' | ':' inlineArg ';' )?
ArgList     ::= (Arg) ( ',' Arg )*
Arg         ::= (string | integer | boolean | tlaIdentifier)
string      ::= '&quot;' &lt;char sequence&gt; '&quot;'
integer     ::= '-'? [0-9]+
boolean     ::= ('false' | 'true')
inlineArg   ::= &lt;char sequence excluding ';' and '@'&gt;
</code></pre>
<p>The sequence <code>&lt;char sequence&gt;</code> is a sequence of characters admitted by the TLA+ parser:</p>
<ul>
<li>Any ASCII character except double quotes, control characters or backslash <code>\</code></li>
<li>A backslash followed by another backslash, a single or double quote,
or one of the letters <code>f</code>, <code>n</code>, <code>r</code> or <code>t</code>.</li>
</ul>
<p><strong>Examples.</strong> The following strings are examples of syntactically correct
annotations:</p>
<ol>
<li><code>@tailrec</code></li>
<li><code>@type(&quot;(Int, Int) =&gt; Int&quot;)</code></li>
<li><code>@require(Init)</code></li>
<li><code>@type: (Int, Int) =&gt; Int ;</code></li>
<li><code>@random(true)</code></li>
<li><code>@deprecated(&quot;Use operator Foo instead&quot;)</code></li>
<li><code>@range(0, 100)</code></li>
</ol>
<p>The above examples are just syntactically correct. Their meaning, if there is
any, is defined by the tool that is reading these annotations. Note that the
example 3 is not following the syntax of Java annotations. We have introduced
this format for one-argument annotations, especially, for type annotations.
Its purpose is to reduce the visual clutter in annotations that accept a string
as their only argument.</p>
<p>Currently, annotations are written in comments that precede a definition (see
the explanation below). String arguments can span over multiple lines. For instance,
the following examples demonstrate valid annotations inside TLA+ comments:</p>
<pre><code class="language-tla">(*
  @type: Int
            =&gt; Int
  ;
 *)

\* @type: Int
\*           =&gt; Int
\* ;

\* @hal_msg(&quot;Sorry,
\*           I
\*           CAN
\*           do that,
\*           Dave&quot;)
</code></pre>
<h2><a class="header" href="#3-an-annotated-specification" id="3-an-annotated-specification">3. An annotated specification</a></h2>
<p>The following specification shows how to write annotations, so they can be
correctly parsed by the SANY parser and Apalache. Note the location of comments
in front of: local operators, LET-definitions, and recursive operators.
Although these locations may seem to be suboptimal, this is how the SANY
parser locates comments that precede declarations.</p>
<pre><code class="language-tla">-------------------------- MODULE Annotations ---------------------------------
EXTENDS Integers

CONSTANT
  \* @type: Int;
  N

VARIABLE
  \* the single-argument annotation
  \* @type: Set(Int);
  set

\* @pure
\* using the Java annotations, a bit verbose:
\* @type(&quot; Int =&gt; Int &quot;)
Inc(n) == n + 1

\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1

A(n) ==
  LET \* @pure
      \* @type: Int =&gt; Int;
      Dec(x) == x + 1
  IN
  Dec(n)

RECURSIVE Fact(_)
\* @tailrec
\* @type: Int =&gt; Int;
Fact(n) ==
  IF n &lt;= 1 THEN 1 ELSE n * Fact(n - 1)

\* @tailrec
\* @type: Int -&gt; Int;
FactFun[n \in Int] ==
  IF n &lt;= 1 THEN 1 ELSE n * FactFun[n - 1]

===============================================================================
</code></pre>
<h2><a class="header" href="#4-implementation" id="4-implementation">4. Implementation</a></h2>
<p>The implementation of the annotation parser can be found in the class
<code>at.forsyte.apalache.io.annotations.AnnotationParser</code> of the module
<code>tla-io</code>, see <a href="https://github.com/informalsystems/apalache/blob/main/tla-io/src/main/scala/at/forsyte/apalache/io/annotations/AnnotationParser.scala">AnnotationParser</a>.</p>
<h2><a class="header" href="#5-discussion" id="5-discussion">5. Discussion</a></h2>
<p>Most likely, this topic does not deserve much discussion, as we are using
the pretty standard syntax of Java annotations. So we are following the
principle of the least surprise.</p>
<p>We also support the concise syntax for the annotations that accept a string as
a simple argument. For these annotations, we had to add the end marker ';'.
This is done because the SANY parser is pruning the linefeed character <code>\n</code>,
so it would be otherwise impossible to find the end of an annotation.</p>
<h1><a class="header" href="#adr-005-json-serialization-format" id="adr-005-json-serialization-format">ADR-005: JSON Serialization Format</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1.1</td></tr>
</tbody></table>
<p>This ADR documents our decision on serializing the Apalache internal representation (IR) as JSON.
The purpose of introducing such a serialization is to expose the internal representation in a standardized format, which can be used for persistent storage, or for analysis by third-party tools in the future.</p>
<h2><a class="header" href="#1-serializable-classes" id="1-serializable-classes">1. Serializable classes</a></h2>
<p>The following classes are serializable:</p>
<ol>
<li>
<p>TLA+ expressions (see <a href="https://github.com/informalsystems/apalache/blob/main/tlair/src/main/scala/at/forsyte/apalache/tla/lir/TlaEx.scala#L10">TlaEx</a>) and subclasses thereof:</p>
<ul>
<li>Named expressions <code>NameEx</code></li>
<li>Literal values <code>ValEx</code> for the following literals:
<ul>
<li>Integers <code>TlaInt</code></li>
<li>Strings <code>TlaStr</code></li>
<li>Booleans <code>TlaBool</code></li>
<li>Decimals <code>TlaDecimal</code></li>
</ul>
</li>
<li>Operator expressions <code>OperEx</code></li>
<li>LET-IN expressions <code>LetInEx</code></li>
</ul>
</li>
<li>
<p>TLA+ declarations (see <a href="https://github.com/informalsystems/apalache/blob/main/tlair/src/main/scala/at/forsyte/apalache/tla/lir/TlaDecl.scala#L9">TlaDecl</a>) and subclasses thereof:</p>
<ul>
<li>Variable declarations <code>TlaVarDecl</code></li>
<li>Constant declarations <code>TlaConstDecl</code></li>
<li>Operator declarations <code>TlaOperDecl</code></li>
<li>Assumption declarations <code>TlaAssumeDecl</code></li>
<li>Theorem declarations <code>TlaTheoremDecl</code></li>
</ul>
</li>
<li>
<p>TLA+ modules, see <a href="https://github.com/informalsystems/apalache/blob/main/tlair/src/main/scala/at/forsyte/apalache/tla/lir/TlaDecl.scala#L19">TlaModule</a></p>
</li>
</ol>
<h2><a class="header" href="#2-disambiguation-field" id="2-disambiguation-field">2. Disambiguation field</a></h2>
<p>Every serialization will contain a disambiguation field, named <code>kind</code>. This field holds the name of the class being serialized. For example, the serialization of a <code>NameEx</code> will have the shape</p>
<pre><code>{
  &quot;kind&quot;: &quot;NameEx&quot;
  ...
}
</code></pre>
<h2><a class="header" href="#3-serializing-tagged-entities" id="3-serializing-tagged-entities">3. Serializing tagged entities</a></h2>
<p>Serializations of entities annotated with a <code>TypeTag</code> will have an additional field named <code>type</code>, containing the type of the expression (see <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR-002</a>, <a href="https://apalache.informal.systems/docs/adr/004adr-annotations.html">ADR-004</a> for a description of our type system and the syntax for types-as-string-annotations respectively), if the tag is <code>Typed</code>, or <code>Untyped</code> otherwise. For example, the integer literal <code>1</code> is represented by a <code>ValEx</code>, which has type <code>Int</code> and is serialized as follows:</p>
<pre><code>{
  &quot;kind&quot;: &quot;ValEx&quot;,
  &quot;type&quot;: &quot;Int&quot;
  ...
}
</code></pre>
<p>in the typed encoding, or </p>
<pre><code>{
  &quot;kind&quot;: &quot;ValEx&quot;,
  &quot;type&quot;: &quot;Untyped&quot;
  ...
}
</code></pre>
<p>in the untyped encoding.</p>
<h2><a class="header" href="#4-source-information" id="4-source-information">4. Source information</a></h2>
<p>Entities in the internal representation are usually annotated with source information, of the form <code>{filename}:{startLine}:{startColumn}-{endLine}:{endColumn}</code>, relating them to a file range in the provided specification (from which they may have been transformed as part of preprocessing).
JSON encodings may, but are not required to, contain a <code>source</code> providing this information, of the following shape:</p>
<pre><code>{
  &quot;source&quot;: {
    &quot;filename&quot; : &lt;FILENAME&gt;,
    &quot;from&quot; : {
      &quot;line&quot; : &lt;STARTLINE&gt;,
      &quot;column&quot; : &lt;STARTCOLUMN&gt;
    },
    &quot;to&quot; : {
      &quot;line&quot; : &lt;ENDLINE&gt;,
      &quot;column&quot; : &lt;ENDCOLUMN&gt;
    }
  }
}
</code></pre>
<p>or</p>
<pre><code>{
  &quot;source&quot;: &quot;UNKNOWN&quot;
}
</code></pre>
<p>if no source information is available (e.g. for expressions generated purely by Apalache).
Serializations generated by Apalache are always guaranteed to contain a <code>source</code> field entry.</p>
<p>Example:</p>
<pre><code>{
  &quot;kind&quot; : &quot;NameEx&quot;,
  &quot;type&quot; : &quot;Int&quot;,
  &quot;name&quot; : &quot;myName&quot;,
  &quot;source&quot;: {
    &quot;filename&quot; : &quot;MyModule.tla&quot;,
    &quot;from&quot; : {
      &quot;line&quot; : 3,
      &quot;column&quot; : 5
    },
    &quot;to&quot; : {
      &quot;line&quot; : 3,
      &quot;column&quot; : 10
    }
  }
}
</code></pre>
<h2><a class="header" href="#5-root-wrapper" id="5-root-wrapper">5. Root wrapper</a></h2>
<p>JSON serializations of one or more <code>TlaModule</code> objects are wrapped in a root object with two required fields:</p>
<ul>
<li><code>version</code>, the value of which is a string representation of the current JSON encoding version, shaped <code>{major}.{minor}</code>, and</li>
<li><code>modules</code>, the value of which is an array containing the JSON encodings of zero or more <code>TlaModule</code> objects</li>
</ul>
<p>It may optionally contain a field <code>&quot;name&quot; : &quot;ApalacheIR&quot;</code>.
This document defines JSON Version 1.0. If and when a different JSON version is defined, this document will be updated accordingly.
Apalache may refuse to import, or trigger warnings for, JSON objects with obsolete versions of the encoding in the future.
Example:</p>
<pre><code>{
  &quot;name&quot;: &quot;ApalacheIR&quot;,
  &quot;version&quot;: &quot;1.0&quot;,
  &quot;modules&quot; = [
    {
      &quot;kind&quot;: &quot;TlaModule&quot;,
      &quot;name&quot;: &quot;MyModule&quot;
      ...
    },
    ...]
}
</code></pre>
<h2><a class="header" href="#6-general-serialization-rules" id="6-general-serialization-rules">6. General serialization rules</a></h2>
<p>The goal of the serialization is for the JSON structure to mimic the internal representation as closely as possible, for ease of deserialization. 
Concretely, whenever a class declares a field <code>fld: T</code>, its serialization also contains a field named <code>fld</code>, containing the serialization of the field value.
For example, if <code>TlaConstDecl</code> declares a <code>name: String</code> field, its JSON serialization will have a <code>name</code> field as well, containing the name string.</p>
<p>If a class field has the type <code>Traversable[T]</code>, for some <code>T</code>, the corresponding JSON entry is a list containing serializations of the individual arguments. For example, <code>OperEx</code> is variadic and declares <code>args: TlaEx*</code>, so its serialization has an <code>args</code> field containing a (possibly empty) list.</p>
<p>As a running example, take the expression <code>1 + 1</code>, represented with the correct type annotations as </p>
<pre><code>OperEx( 
  oper = TlaArithOper.plus, 
  args = Seq( 
    ValEx( TlaInt( 1 ) )( typeTag = Typed( IntT1() ) ), 
    ValEx( TlaInt( 1 ) )( typeTag = Typed( IntT1() ) )
    ) 
  )( typeTag = Typed( IntT1() ) )
</code></pre>
<p>Since both sub-expressions, the literals <code>1</code>, are identical, their serializations are equal as well:</p>
<pre><code>{
  &quot;kind&quot;: &quot;ValEx&quot;,
  &quot;type&quot;: &quot;Int&quot;,
  &quot;value&quot;: {
    &quot;kind&quot;: &quot;TlaInt&quot;,
    &quot;value&quot;: 1
  }
}
</code></pre>
<p>Observe that we choose to serialize <code>TlaValue</code> as a JSON object, which is more verbose, but trivial to deserialize. It has the following shape</p>
<pre><code>{
  &quot;kind&quot;: &lt;KIND&gt; ,
  &quot;value&quot;: &lt;VALUE&gt;
}
</code></pre>
<p>The <code>value</code> field depends on the kind of <code>TlaValue</code>:</p>
<ol>
<li>For <code>TlaStr</code>: a JSON string</li>
<li>For <code>TlaBool</code>: a JSON Boolean</li>
<li>For <code>TlaInt(bigIntValue)</code>: 
<ol>
<li>If <code>bigIntValue.isValidInt</code>: a JSON number</li>
<li>Otherwise: <code>{ &quot;bigInt&quot;: bigIntValue.toString() }</code></li>
</ol>
</li>
<li>For <code>TlaDecimal(decValue)</code>: a JSON string <code>decValue.toString</code></li>
</ol>
<p>The reason for the non-uniform treatment of integers is that Apalache encodes its TLA+ integers as <code>BigInt</code>, which means that it permits values for which <code>.isValidInt</code> does not hold. </p>
<p>While it might seem more natural to encode the entire <code>TlaValue</code> as a JSON primitive, without the added object layer we would have a much tougher time deserializing.
We would need a) a sensible encoding of <code>BigInt</code> values, which are not valid integers, and b) a way to distinguish both variants of <code>BigInt</code>, as well as decimals, when deserializing (since JSON is not typed).
We could encode all values as strings, but they would be similarly indistinguishable when deserializing. Importantly, the <code>type</code> field of the <code>ValEx</code> expression is not guaranteed to contain a hint, as it could be <code>Untyped</code></p>
<p>Take <code>jsonOf1</code> to be the serialization of <code>ValEx( TlaInt( 1 ) )( typeTag = Typed( IntT1() ) )</code> shown above. The serialization of <code>1 + 1</code> is then equal to</p>
<pre><code>{
  &quot;kind&quot;: &quot;OperEx&quot;,
  &quot;type&quot;: &quot;Int&quot;,
  &quot;oper&quot;: &quot;PLUS&quot;,
  &quot;args&quot;: [jsonOf1, jsonOf1]
}
</code></pre>
<p>In general, for any given <code>oper: TlaOper</code> of <code>OperEx</code>, the value of the <code>oper</code> field in the serialization equals <code>oper.name</code>.</p>
<h2><a class="header" href="#7-implementation" id="7-implementation">7. Implementation</a></h2>
<p>The implementation of the serialization can be found in the class
<code>at.forsyte.apalache.io.json.TlaToJson</code> of the module <code>tla-import</code>, see <a href="https://github.com/informalsystems/apalache/blob/main/tla-io/src/main/scala/at/forsyte/apalache/io/json/TlaToJson.scala#L54">TlaToJson</a>.</p>
<h1><a class="header" href="#rfc-006-unit-testing-and-property-based-testing-of-tla-specifications" id="rfc-006-unit-testing-and-property-based-testing-of-tla-specifications">RFC-006: Unit testing and property-based testing of TLA+ specifications</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov, Vitor Enes, Shon Feder, Andrey Kuprianov, ...</td><td align="right">2</td></tr>
</tbody></table>
<!-- toc -->
<p><strong>Abstract.</strong> This document discusses a framework for testing TLA+
specifications. Our first goal is to give the writers of TLA+ specifications an
interactive approach to quickly test their specifications in the design
phase, similar to unit-testing in programming languages. Our second goal is to
give the readers of TLA+ specifications a clear framework for dissecting TLA+
specifications, in order to understand them in smaller pieces. These ideas
have not been implemented yet. We believe that the testing framework will
enable the users of Apalache and TLC to write and read TLA+ specifications in a
much more efficient manner than they do it today.</p>
<h2><a class="header" href="#1-long-rationale" id="1-long-rationale">1. Long rationale</a></h2>
<p>TLA+ is a specification language that was designed to be executable inside a
human brain. Moreover, it was intended to run in the brains that underwent a
specific software upgrade, called mathematical training. Many years have passed
since then. We now have automatic tools that can run TLA+ in a computer (to
some extent). Even more, these tools can prove or disprove certain properties
of TLA+ specs.</p>
<p>Nowadays, we have two tools that aid us in writing a TLA+ spec: our brain and a
model checker. Both these tools have the same problem. They are slow. Software
engineers are facing a similar problem when they are trying to test their
system against different inputs. Interestingly, software engineers have found a
way around this problem. They first test the individual parts of the system and
then they test the system as a whole. The former is done with unit tests,
whereas the latter is done with integration tests. (Software engineers probably
borrowed this approach from industrial engineers.) Unit tests are used almost
interactively, to debug a small part of the system, while integration tests are
run in a continuous integration environment, which is not interactive at all.</p>
<p>Actually, our brains also have a built-in ability of abstracting away from one
part of a problem while thinking about the other part. That is why some of us
can still win against automatic tools. Model checkers do not have this built-in
ability. So it looks like when we are using TLC or Apalache, we are doing
integration testing all the time. Unfortunately, when we are checking a
specification as a whole, we rarely get a quick response, except for very small
specs. This is hardly surprising, as we are interested in specifying complex
systems, not the trivial ones.</p>
<p>Surprisingly, when we are writing large TLA+ specs, our interaction with the
model checker looks more like an interaction with a <a href="https://en.wikipedia.org/wiki/Mainframe_computer">Mainframe computer</a> from
the early days of computing than a modern interactive development cycle. We
feed the model checker our specification and wait for hours in the hope that it
gives us a useful response. If it does not, we have to make the specification
parameters small enough for the model checker to do anything useful. If our
parameters are already ridiculously small, we have to throw more computing
power at the problem and wait for days. In contrast, verification tools for
programs are meant to be much more interactive, e.g., see <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a> and
<a href="https://github.com/kenmcmil/ivy">Ivy</a>.</p>
<p>Why cannot we do something like <a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> in Apalache? We believe that
we actually can do that. We can probably do it even better by implementing
<a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, that is, test parts of our specifications against a
large set of inputs instead of testing it against a few carefully crafted
inputs.</p>
<h2><a class="header" href="#2-a-motivating-example" id="2-a-motivating-example">2. A motivating example</a></h2>
<p>Let's consider a relatively simple distributed algorithm as an example.  The
repository of <a href="https://github.com/tlaplus/Examples/">TLA+ examples</a> contains the well-known leader election
algorithm called <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> (specified in TLA+ by Stephan Merz). The algorithm is
over 40 years old, but it is tricky enough to be still interesting. To
understand the algorithm, check <a href="https://dl.acm.org/doi/book/10.5555/2821576">Distributed Algorithms</a> by Nancy Lynch.</p>
<p>As the description suggests, when we fix <code>N</code> to <code>6</code> and <code>Id</code> to
<code>&lt;&lt;27, 4, 42, 15, 63, 9&gt;&gt;</code>, TLC checks that the spec satisfies the invariant
<code>Correctness</code> in just 11 seconds, after having explored 40K states.
Of course, had we wanted to check the property for all possible combinations
of six unique identifiers in the range of <code>1..6</code>, we would had to run TLC
<code>6! = 720</code> times, which would take over 2 hours.</p>
<p>In Apalache, we can setup a TLA+ module instance, to check all instances of
the algorithm that have from 2 to 6 processes:</p>
<pre><code class="language-tla">--------------------- MODULE ChangRobertsTyped_Test -------------------------
(*
 * A test setup for ChangRobertsTyped.
 *)
EXTENDS Integers, Apalache

\* a copy of constants from ChangRobertsTyped
CONSTANTS
    \* @type: Int;
    N,
    \* @type: Int -&gt; Int;
    Id

\* a copy of state variables from ChangRobertsTyped
VARIABLES
    \* @type: Int -&gt; Set(Int);
    msgs,
    \* @type: Int -&gt; Str;
    pc,
    \* @type: Int -&gt; Bool;
    initiator,
    \* @type: Int -&gt; Str;
    state

INSTANCE ChangRobertsTyped

\* We bound N in the test
MAX_N == 6

\* we override Node, as N is not known in advance
OVERRIDE_Node == { i \in 1..MAX_N: i &lt;= N }

\* initialize constants
ConstInit ==
    /\ N \in 2..MAX_N
    /\ Id \in [ 1..MAX_N -&gt; Int ]

\* The below constraints are copied from ASSUME.
\* They are not enforced automatically, see issue #69.
Assumptions ==    
    /\ Node = DOMAIN Id
    /\ \A n \in Node: Id[n] &gt;= 0
    /\ \A m,n \in Node : m # n =&gt; Id[m] # Id[n]  \* IDs are unique

InitAndAssumptions ==
    Init /\ Assumptions

</code></pre>
<p>By running Apalache as follows, we can check <code>Correctness</code> for all
configurations of 2 to 6 processes and all combinations of <code>Id</code>:</p>
<pre><code class="language-sh">apalache check --cinit=ConstInit \
  --init=InitAndAssumptions --inv=Correctness ChangRobertsTyped_Test.tla
</code></pre>
<p>Actually, we do not restrict <code>Id</code> to be a function from <code>1..N</code> to <code>1..N</code>, but
rather allow <code>Id</code> to be a function from <code>1..N</code> to <code>Int</code>. So Apalache should
be able to check an infinite number of configurations!</p>
<p>Unfortunately, Apalache starts to dramatically slow down after having explored
6 steps of the algorithm. Indeed, it does symbolic execution for a
non-deterministic algorithm and infinitely many inputs. We could try to improve
the SMT encoding, but that would only win us several steps more. A more
realistic approach would be to find an inductive invariant and let Apalache
check it.</p>
<p>It looks like we are trapped: Either we have to invest some time in
verification, or we can check the algorithm for a few data points. In case
of LCR, the choice of process identifiers is important, so it is not clear at
all, whether a few data points are giving us a good confidence.</p>
<p>This situation can be frustrating, especially when you are designing a large
protocol. For instance, both Apalache and TLC can run for hours on <a href="https://github.com/tlaplus/Examples/tree/master/specifications/raft">Raft</a>
without finishing. We should be able to quickly debug our specs like software
engineers do!</p>
<h2><a class="header" href="#3-an-approach-to-writing-tests" id="3-an-approach-to-writing-tests">3. An approach to writing tests</a></h2>
<p><em>What we describe below has not been implemented yet. Apalache has all the
necessary ingredients for implementing this approach. We are asking for your
input to find an ergonomic approach to testing TLA+ specifications.  Many of
the following ideas apply to TLC as well. We are gradually introducing
Apalache-specific features.</em></p>
<p>A complete specification can be found in <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/ChangRobertsTyped_Test.tla">ChangRobertsTyped_Test.tla</a>.</p>
<p>Our idea is to quickly check operators in isolation, without analyzing the
whole specification and without analyzing temporal behavior of the
specification. There are three principally different kinds of operators in TLA+:</p>
<ul>
<li>
<p>Stateless operators that take input parameters and return the result.
These operators are similar to functions in functional languages.</p>
</li>
<li>
<p>Action operators that act on a specification state.
These operators are similar to procedures in imperative languages.</p>
</li>
<li>
<p>Temporal operators that act on executions, which are called behaviors
in TLA+. These operators are somewhat similar to regular expressions,
but they are more powerful, as they reason about infinite executions.</p>
</li>
</ul>
<h3><a class="header" href="#31-testing-stateless-operators" id="31-testing-stateless-operators">3.1. Testing stateless operators</a></h3>
<p>Consider the following auxiliary operator in the specification:</p>
<pre><code class="language-tla">succ(n) == IF n=N THEN 1 ELSE n+1  \* successor along the ring
</code></pre>
<p>While this operator is defined in the specification, it is clear that it is
well isolated from the rest of the specification: We only have to know the
value of the constant <code>N</code> and the value of the operator parameter <code>n</code>.</p>
<pre><code class="language-tla">\* Note that succ(n) is not referring to state variables,
\* so we can test it in isolation.
\*
\* @require(ConstInit)
\* @testStateless
Test_succ ==
    \* This is like a property-based test.
    \* Note that it is exhaustive (for the range of N).
    \A n \in Node:
        succ(n) \in Node
</code></pre>
<p>This test is very simple. It requires <code>succ(n)</code> to be in the set <code>Node</code>, for
all values <code>n \in Node</code>. The body of the operator <code>Test_succ</code> is pure TLA+.
We annotate the operator with <code>@testStateless</code>, to indicate that it should
be checked in a stateless context.</p>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla Test_succ
</code></pre>
<p>We pass the test name <code>Test_succ</code>, as we expect the <code>test</code> command to run all
tests by default, if no test name is specified. Also, we have to initialize the
constants with <code>ConstInit</code>, which we specify with the annotation
<code>@require(ConstInit)</code>.</p>
<p><a id="testAction"></a></p>
<h3><a class="header" href="#32-testing-actions" id="32-testing-actions">3.2. Testing actions</a></h3>
<p>Testing stateless operators is nice. However, TLA+ is built around the concept
of a state machine. Hence, we believe that most of the testing activity will be
centered around TLA+ actions. For instance, the <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> specification has two
actions: <code>n0</code> and <code>n1</code>. Let's have a look at <code>n0</code>:</p>
<pre><code class="language-tla">n0(self) == /\ pc[self] = &quot;n0&quot;
            /\ IF initiator[self]
                  THEN /\ msgs' = [msgs EXCEPT ![succ(self)] = @ \union {Id[self]}]
                  ELSE /\ TRUE
                       /\ msgs' = msgs
            /\ pc' = [pc EXCEPT ![self] = &quot;n1&quot;]
            /\ UNCHANGED &lt;&lt; initiator, state &gt;&gt;
</code></pre>
<p>Assume we like to test it without looking at the rest of the system, namely,
the predicates <code>Init</code> and <code>n1</code>. First of all, we have to describe the states
that could be passed to the action <code>n0</code>. In this section, we will just use
TypeOK (see <a href="adr/006rfc-unit-testing.html#generators">Section 5</a> for a more fine-grained control over the
inputs):</p>
<pre><code class="language-tla">TypeOK ==
  /\ pc \in [Node -&gt; {&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;Done&quot;}]
  /\ msgs \in [Node -&gt; SUBSET {Id[n] : n \in Node}]
  /\ initiator \in [Node -&gt; BOOLEAN]
  /\ state \in [Node -&gt; {&quot;cand&quot;, &quot;lost&quot;, &quot;won&quot;}]

</code></pre>
<p>Further, we specify what kind of outcome we expect:</p>
<pre><code class="language-tla">\* Assertion that we expect to hold true after firing Action_n0.
Assert_n0 ==
    \E n, m \in Node:
        msgs'[n] = msgs[n] \union {m}
</code></pre>
<p>(Do you think this condition actually holds true after firing <code>n0</code>?)</p>
<p>Finally, we have to specify, how to run the action <code>n0</code>. In fact, if you look
at <code>Next</code>, this requires us to write a bit of code, instead of just calling
<code>n0</code>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>The operator <code>TestAction_n0</code> carries several annotations:</p>
<ul>
<li>The annotation <code>@require(TypeOK)</code> tells the framework that
<code>TypeOK</code> should act as an initialization predicate for testing
<code>TestAction_n0</code>.</li>
<li>The annotation <code>@testAction</code> indicates that <code>TestAction_n0</code> should be tested
as an action that is an operator over unprimed and primed variable.</li>
<li>The annotation <code>@ensure(Assert_n0)</code> tells the framework that
<code>Assert_n0</code> should hold after <code>TestAction_n0</code> has been fired.</li>
</ul>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>Importantly, we decompose the test in three parts:</p>
<ul>
<li>preparing the states by evaluating predicates <code>ConstInit</code> and <code>TypeOK</code>
(similar to <code>Init</code>),</li>
<li>executing the action by evaluating the action predicate <code>TestAction_n0</code>
(like a single instance of <code>Next</code>),</li>
<li>testing the next states against the previous states by evaluating
the predicate <code>Assert_n0</code>
(like an action invariant).</li>
</ul>
<h3><a class="header" href="#33-testing-executions" id="33-testing-executions">3.3. Testing executions</a></h3>
<p>Engineers often like to test a particular set of executions to support their
intuition, or to communicate an example to their peers. Sometimes, it is useful
to isolate a set of executions to make continuous integration break, until the
protocol is fixed. Needless to say, TLA+ tools have no support for this
standard technique, though they have all capabilities to produce such tests.</p>
<p>Similar to testing an action in isolation, we propose an interface for testing
a restricted set of executions as follows:</p>
<pre><code class="language-tla">\* Execute a sequence of 5 actions, similar to TestAction_n0.
\* We test a final state with Assert_n0.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
TestExec_n0_n1 ==
    \* in this test, we only execute actions by processes 1 and 2
    \E self \in { 1, 2 }:
        n0(self) \/ n1(self)

</code></pre>
<p>In this case, we are using a different assertion in the <code>@ensure</code> annotation:</p>
<pre><code class="language-tla">\* We expect no winner in the final state.
\* Note that Assert_noWinner is a predicate over a trace of states.
\*
\* @typeAlias: state = { msgs: Int -&gt; Set(Int), pc: Int -&gt; Str,
\*                       initiator: Int -&gt; Bool, state: Int -&gt; Str };
\* @type: Seq($state) =&gt; Bool;
Assert_noWinner(trace) ==
    LET last == trace[Len(trace)] IN
        \A n \in Node:
            last.state[n] /= &quot;won&quot;
</code></pre>
<p>Similar to <code>TestAction_n0</code>, the test <code>TestExec_n0_n1</code> initialized the state
with the predicate <code>Prepare_n0</code>. In contrast to <code>TestAction_n0</code>, the 
test <code>TestExec_n0_n1</code> does two other steps differently:</p>
<ol>
<li>
<p>Instead of firing just one action, it fires up to 5 actions in a sequence
(the order and action are chosen non-deterministically).</p>
</li>
<li>
<p>Instead of testing a pair of states, the predicate <code>Assert_noWinner</code> tests
the whole trace. In our example, we check the final state of the trace. In
general, we could test every single state of the trace.</p>
</li>
</ol>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<p>If the test is violated, a counterexample should be produced in the file
<code>counterexample_TestExec_n0_n1.tla</code>.</p>
<h3><a class="header" href="#34-test-executions-with-temporal-properties" id="34-test-executions-with-temporal-properties">3.4. Test executions with temporal properties</a></h3>
<p><em>We see this feature to have the least priority, as you can do a lot by
writing trace invariants. Actually, you can check bounded lassos as trace
invariants. So for bounded model checking, you can always write a trace
invariant instead of a temporal formula.</em></p>
<p>When we wrote the test <code>TestExec_n0_n1</code>, we did not think about the
intermediate states of an execution. This test was a functional test: It is
matching the output against the input. When reasoning about state machines,
we often like to restrict the executions and check the properties of those
executions.</p>
<p>Fortunately, we have all necessary ingredients in TLA+ to do
exactly this. Test <code>TestExec_correctness_under_liveness</code>.</p>
<pre><code class="language-tla">\* @type: Seq($state) =&gt; Bool;
Assert_noWinner(trace) ==
    LET last == trace[Len(trace)] IN
        \A n \in Node:
            last.state[n] /= &quot;won&quot;

\* Execute a sequence of 5 actions, while using temporal properties.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @require(Liveness)
</code></pre>
<p>Predicates <code>Correctness</code> and <code>Liveness</code> are defined in the spec as follows:</p>
<pre><code class="language-tla">(***************************************************************************)
(* Safety property: when node n wins the election, it is the initiator     *)
(* with the smallest ID, and all other nodes know that they lost.          *)
(***************************************************************************)
Correctness ==
  \A n \in Node : state[n] = &quot;won&quot; =&gt;
     /\ initiator[n]
     /\ \A m \in Node \ {n} : 
           /\ state[m] = &quot;lost&quot;
           /\ initiator[m] =&gt; Id[m] &gt; Id[n]

Liveness == (\E n \in Node : state[n] = &quot;cand&quot;) =&gt; &lt;&gt;(\E n \in Node : state[n] = &quot;won&quot;)
</code></pre>
<p>Since <code>Correctness</code> is a state predicate, we wrap it with a temporal operator
to check it against all states of an execution:</p>
<pre><code class="language-tla">\* @ensure(GlobalCorrectness)
\* @testExecution(5)
</code></pre>
<h3><a class="header" href="#35-discussion" id="35-discussion">3.5. Discussion</a></h3>
<p>As you can see, we clearly decompose a test in three parts:</p>
<ul>
<li>Preparing the states (like a small version of <code>Init</code>),</li>
<li>Executing the action (like a small version of <code>Next</code>),</li>
<li>Testing the next states against the previous states (like an action invariant).
Alternatively, you can write an assertion over a trace. </li>
</ul>
<p>In the rest of this section, we comment on the alternative approaches.</p>
<h4><a class="header" href="#351-but-i-can-do-all-of-that-in-tla" id="351-but-i-can-do-all-of-that-in-tla">3.5.1. But I can do all of that in TLA+</a></h4>
<p>True. TLA+ is an extremely expressive language.</p>
<p>Let's go back to the test <code>TestAction_n0</code> that was explained in <a href="adr/006rfc-unit-testing.html#testAction">Section
3.2</a>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Can we rewrite this test in pure TLA+? Yes, but it is an error-prone approach.
Let's do it step-by-step.</p>
<p>First of all, there is no simple way to initialize constants in TLA+, as we did
with <code>ConstInit</code> (this is an Apalache-specific feature). Of course, one can
restrict constants with <code>ASSUME(...)</code>.  However, assumptions about constants
are global, so we cannot easily isolate constant initialization in one test.
The canonical way of initializing constants is to define them in a TLC
configuration file. If we forget about all these idiosyncrasies of TLC, we
could just use implication (<code>=&gt;</code>), as we normally do in logic. So our test
<code>TestAction_n0_TLA</code> in pure TLA+ would look like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt; (* ... *)
</code></pre>
<p>Second, we want to restrict the states with <code>TypeOK</code>. That should be easy:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK (* ... *)
</code></pre>
<p>Third, we want to execute the action <code>n0</code>, as we did in <code>TestAction_n0</code>.
The intuitive way is to write it like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    /\ TypeOK
    /\ \E self \in Node:
         n0(self)
    (* ... *)     
</code></pre>
<p>Although the above code looks reasonable, we cheated. It combines two steps in
one: It initializes states with <code>TypeOK</code> and it simultaneously executes the
action <code>n0</code>. If we tried that in TLC (forgetting about <code>ConstInit</code>), that would
not work. Though there is nothing wrong about this constraint from the
perspective of logic, it just restricts the unprimed variables and primed
variables.  There is probably a way to split this code in two steps by applying
the operator <code>\cdot</code>, which is implemented neither in TLC, nor in Apalache:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      \E self \in Node:
         n0(self)
      (* ... *)
    )
</code></pre>
<p>In these circumstances, a more reasonable way would be to introduce a new file
like <code>MCTestAction_n0.tla</code> and clearly specify <code>TypeOK</code> as the initial
predicate and the action as the next predicate. But we do not want
state-of-the-art dictate us our behavior.</p>
<p>Finally, we have to place the assertion <code>Assert_n0</code>. Let's try it this way:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert_n0
    )
</code></pre>
<p>Unfortunately, this is not the right solution. Instead of executing <code>n0</code>
and checking that the result satisfies <code>Assert_n0</code>, we have restricted
the next states to always satisfy <code>Assert_n0</code>!</p>
<p>Again, we would like to write something like the implication <code>Action =&gt; Assertion</code>, but we are not allowed do that with the model checkers for TLA+.
We can use the operator <code>Assert</code> that is supported by TLC:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert(Assert_n0, &quot;assertion violation&quot;)
    )
</code></pre>
<p>This time it should conceptually work. Once <code>n0</code> has been executed, TLC could
start evaluating <code>Assert(...)</code> and find a violation of <code>Assert_n0</code>.  There is
another problem. The operator <code>Assert</code> is a purely imperative operator, which
relies on the order in which the formula is evaluated. Hence, Apalache does not
support this operator and, most likely, it never will. The imperative semantics
of the operator <code>Assert</code> is simply incompatible with logical constraints.
Period.</p>
<p>Phew. It was not easy to write <code>TestAction_n0_TLA</code>. In principle, we could
fix this pattern and extract the test in a dedicated file <code>MC.tla</code> to run
it with TLC or Apalache.</p>
<p>Let's compare it with <code>TestAction_n0</code>. Which one would you choose?</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Another problem of <code>TestAction_n0_TLA</code> is that it has a very brittle structure.
What happens if one writes <code>~ConstInit \/ TypeOK ...</code> instead of <code>ConstInit =&gt; TypeOK ...</code>? In our experience, when one sees a logical formula, they expect
that an equivalent logical formula should be also allowed.</p>
<p><em>In the defense of TLA+, the issues that we have seen above are not the issues
of TLA+ as a language, but these are the problems of the TLA+ tooling. There
is a very simple and aesthetically pleasing way of writing <code>TestAction_n0</code> in
the logic of TLA+:</em></p>
<pre><code class="language-tla">TestAction_n0_pure_TLA ==
  (ConstInit /\ TypeOK) =&gt;
    (\E self \in Node: n0(self)) =&gt; Assert_n0
</code></pre>
<p>The operator <code>TestAction_n0_pure_TLA</code> could be probably reasoned about in <a href="adr/">TLA+
Proof System</a>.  From the automation perspective, it would require a
completely automatic constraint-based solver for TLA+, which we do not have.
In practice, this would mean either rewriting TLC and Apalache from scratch, or
hacking them to enforce the right semantics of the above formula.</p>
<h4><a class="header" href="#352-why-annotations-instead-of-special-operators" id="352-why-annotations-instead-of-special-operators">3.5.2. Why annotations instead of special operators</a></h4>
<p>The annotations <code>@require</code> and <code>@ensure</code> are not our invention. You can find
them in <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design-by-contract</a> languages. In particular, they are used as pre-
and post-conditions in code verification tools, e.g., <a href="https://www.thestrangeloop.com/2018/contracts-for-getting-more-programs-less-wrong.html">JML</a>, <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a>, <a href="http://mcmil.net/pubs/SIGCOMM19.pdf">QUIC
testing</a> with <a href="https://github.com/kenmcmil/ivy">Ivy</a>. </p>
<p>You could ask a reasonable question: Why cannot we introduce operators such
as <code>Require</code> and <code>Ensure</code> instead of writing annotations? For instance,
we could rewrite <code>TestAction_n0</code> as follows:</p>
<pre><code class="language-tla">TestAction_n0_no_annotations ==
  /\ Require(ConstInit)
  /\ Require(TypeOK)
  /\ \E self \in Node:
        n0(self)
  /\ Ensure(Assert_n0)
</code></pre>
<p>The above test looks self-contained, no annotations. Moreover, we have probably
given more power to the users: They could pass expressions to <code>Require</code> and
<code>Ensure</code>, or they could combine <code>Require</code> and <code>Ensure</code> in other ways and do
something great... Well, we have actually introduced more problems to the users
than solutions. Since logical formulas can be composed in a lot of ways, we
could start writing interesting things:</p>
<pre><code class="language-tla">Can_I_do_that ==
  /\ ~Require(ConstInit)
  /\ Require(TypeOK) =&gt; Ensure(ConstInit)
  /\ \E self \in Node:
        n0(self) /\ Require(self \in { 1, 2 })
  /\ Ensure(Assert_n0) \/ Ensure(Assert_noWinner)
</code></pre>
<p>It is not clear to us how the test <code>Can_I_do_that</code> should be understood.
But what is written is kind of legal, so it should work, right?</p>
<p><em>The annotations gives us a clear structure instead of obfuscating the
requirements in logical formulas.</em></p>
<p>For the moment, we are using Apalache annotations in code comments.  However,
TLA+ could be extended with ensure/require one day, if they prove to be useful.</p>
<h2><a class="header" href="#4-using-tests-for-producing-quick-examples" id="4-using-tests-for-producing-quick-examples">4. Using tests for producing quick examples</a></h2>
<p>It is often nice to see examples of test inputs that pass the
test. Apalache has all the ingredients to do that that. We should be able
to run a command like that:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>The above call would produce <code>example_TestAction_n0.tla</code>, a TLA+ description of
two states that satisfy the test. This is similar to <code>counterexample.tla</code>,
which is produced when an error is found.</p>
<p>In a similar way we should be able to produce an example of an execution:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<h2><a class="header" href="#5-bounding-the-inputs" id="5-bounding-the-inputs">5. Bounding the inputs</a></h2>
<p>The following ideas clearly stem from <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, e.g., we use
generators similar to <a href="https://www.scalacheck.org/">Scalacheck</a>. In contrast to property-based testing, we
want to run the test not only on some random inputs, but to run it exhaustively
on all inputs within a predefined bounded scope.</p>
<p><a id="generators"></a></p>
<h3><a class="header" href="#51-using-apalache-generators" id="51-using-apalache-generators">5.1. Using Apalache generators</a></h3>
<p>Let's go back to the example in <a href="adr/006rfc-unit-testing.html#testAction">Section 3.2</a>.</p>
<p>In <code>TestAction_n0</code> we used <code>TypeOK</code> to describe the states that can be used as
the input to the test. While this conceptually works, it often happens that
<code>TypeOK</code> describes a large set of states. Sometimes, this set is even infinite,
e.g., when <code>TypeOK</code> refers to the infinite set of sequences <code>Seq(S)</code>.
In Apalache, we can use the operator <code>Gen</code> that produces bounded data structures,
similar to <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. Here is how we could describe the set
of input states, by bounding the size of the data structures:</p>
<pre><code class="language-tla">\* Preparing the inputs for the second test. Note that this is a step of its own.
\* This is similar to an initialization predicate.
Prepare_n0 ==
    \* the following constraint should be added automatically in the future
    /\ Assumptions
    \* let the solver pick some data structures within the bounds
    \* up to 15 messages
    /\ msgs = Gen(3 * MAX_N)
    /\ pc = Gen(MAX_N)
    /\ initiator = Gen(MAX_N)
    /\ state = Gen(MAX_N)
    \* restrict the contents with TypeOK,
    \* so we don't generate useless data structures
    /\ TypeOK
</code></pre>
<p>In <code>Prepare_n0</code>, we let the solver to produce bounded data structures with
<code>Gen</code>, by providing bounds on the size of every set, function, sequence, etc.
Since we don't want to have completely arbitrary values for the data
structures, we further restrict them with <code>TypeOK</code>, which we conveniently have
in the specification.</p>
<p>The more scoped version of <code>TestAction_n0</code> looks like following:</p>
<pre><code class="language-tla">\* Another version of the test where we further restrict the inputs.
\* 
\* @require(ConstInit)
\* @require(Prepare_n0)
\* @ensure(Assert_n0)
\* @testAction
TestAction2_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<h3><a class="header" href="#52-using-tlc-random" id="52-using-tlc-random">5.2. Using TLC Random</a></h3>
<p>Leslie Lamport has recently introduced a solution that allows one to run TLC
in the spirit of <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. This is done by initializing
states with the operators that are defined in the module <code>Randomization</code>. For
details, see Leslie's paper on <a href="http://lamport.azurewebsites.net/tla/inductive-invariant.pdf">Inductive invariants with TLC</a>.</p>
<h2><a class="header" href="#6-test-options" id="6-test-options">6. Test options</a></h2>
<p>To integrate unit tests in the standard TLA+ development cycle, the tools
should remember how every individual test was run. To avoid additional
scripting on top of the command-line interface, we can simply pass the tool
options with the annotation <code>@testOption</code>. The following example demonstrates
how it could be done:</p>
<pre><code class="language-tla">TestExec_correctness_under_liveness ==
    \E self \in Node:
        n0(self) \/ n1(self)

GlobalCorrectness == []Correctness

\* A copy of TestExec_n0_n1 that passes additional flags to the model checker.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
\* @testOption(&quot;tool&quot;, &quot;apalache&quot;)
</code></pre>
<p>The test options in the above example have the following meaning:</p>
<ul>
<li>
<p>The annotation <code>testOption(&quot;tool&quot;, &quot;apalache&quot;)</code> runs the test only if it is
executed in Apalache. For example, if we run this test in TLC, it should be
ignored.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;search.smt.timeout&quot;, 10)</code> sets the tool-specific
option <code>search.smt.timeout</code> to 10, meaning that the SMT solver should time
out if it cannot solve a problem in 10 seconds.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.algo&quot;, &quot;offline&quot;)</code> sets the tool-specific
option <code>checker.algo</code> to <code>offline</code>, meaning that the model checker should
use the offline solver instead of the incremental one.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.nworkers&quot;, 2)</code> sets the tool-specific
option <code>checker.nworkers</code> to <code>2</code>, meaning that the model checker should
use two cores.</p>
</li>
</ul>
<p>By having all test options specified directly in tests, we reach two goals:</p>
<ul>
<li>We let the users to save their experimental setup, to enable reproducibility
of the experiments and later re-design of specifications.</li>
<li>We let the engineers integrate TLA+ tests in continuous integration, to
make sure that updates in a specification do not break the tests.
This would allow us to integrate TLA+ model checkers in a CI/CD loop,
e.g., at GitHub.</li>
</ul>
<h2><a class="header" href="#7-what-do-you-think" id="7-what-do-you-think">7. What do you think?</a></h2>
<p>Let us know:</p>
<ul>
<li>
<p>At <a href="https://informal-systems.zulipchat.com/#narrow/stream/265309-apalache">Apalache Zulip stream</a>,</p>
</li>
<li>
<p>On <a href="https://twitter.com/ApalacheTLA">ApalacheTLA Twitter</a>,</p>
</li>
<li>
<p>email: igor at informal.systems.</p>
</li>
</ul>
<h1><a class="header" href="#adr-007-apalache-package-structure-guidelines" id="adr-007-apalache-package-structure-guidelines">ADR-007: Apalache Package Structure Guidelines</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1</td></tr>
</tbody></table>
<p>This ADR documents the design policies guiding the package and dependency structure of Apalache.
When introducing new classes, use the guidelines defined below to determine which package to place them in.</p>
<h2><a class="header" href="#1-level-structure" id="1-level-structure">1. Level Structure</a></h2>
<p>We define Apalache architecture in terms of enumerated levels (L0, L1, L2, etc.). Each level may only hold dependencies belonging to a lower level.</p>
<p>Levels are split into two strata:</p>
<ol>
<li>Interface core: Classes within the interface core relate to general TLA+ concepts, and are intended to be usable by 3rd party developers.</li>
<li>Apalalache core: Classes in the Apalache core relate to specific Apalache- or model-checking- functionality</li>
</ol>
<p>Staking the &quot;core&quot; strata together gives us the complete stack implementing Apalache. </p>
<h2><a class="header" href="#2-interface-core" id="2-interface-core">2. Interface core</a></h2>
<p>Together, L0-L6 make up the interface core. Notably, these levels are Apalache-agnostic. The concepts of these levels are packaged as follows:</p>
<ol>
<li><code>tla-ir</code>    : L0-L3</li>
<li><code>tla-types</code> : L4</li>
<li><code>tla-aux</code>   : L5-L6</li>
</ol>
<h1><a class="header" href="#l0-tla-ir" id="l0-tla-ir">L0: TLA+ IR</a></h1>
<p>In L0, we have implementations of the following concepts:</p>
<ul>
<li>The internal representation of TLA+, with the exception of:
<ul>
<li>Apalache-specific operators (<code>ApalacheOper</code>)</li>
</ul>
</li>
<li>Any utility required to define the IR, such as:
<ul>
<li><code>UID</code>s</li>
<li><code>TypeTag</code>s &amp; TT1</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#l1-auxiliary-structures" id="l1-auxiliary-structures">L1: Auxiliary structures</a></h1>
<p>In L1, we have implementations of the following concepts:</p>
<ul>
<li>Meta-information about the IR, such as:
<ul>
<li>Annotations</li>
<li>Source information</li>
</ul>
</li>
<li>Generic utilities, such as:
<ul>
<li>Unique name generators</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#l2-ir-io" id="l2-ir-io">L2: IR IO</a></h1>
<p>In L2, we have implementations of the following concepts:</p>
<ul>
<li>String printers for TLA-IR</li>
<li>Reading from or writing to files (<code>.tla</code>, <code>.json</code>, TLC-formats) </li>
</ul>
<h1><a class="header" href="#l3-basic-ir-manipulation" id="l3-basic-ir-manipulation">L3: Basic IR manipulation</a></h1>
<p>In L3, we have implementations of the following concepts:</p>
<ul>
<li>TLA+ transformations that:
<ul>
<li>do not introduce operators excluded from L0</li>
<li>have type-correctness asserted by manual inspection</li>
</ul>
</li>
</ul>
<p>Any implementation of a L3 transformation must be explicitly annotated and 
special care should be made during PR review to ascertain type-correctness. Whenever possible, unit tests should test for type correctness.</p>
<h1><a class="header" href="#l4-type-analysis" id="l4-type-analysis">L4: Type analysis</a></h1>
<p>In L4, we have implementations of the following concepts:</p>
<ul>
<li>Any calculus in a TLA+ type system, including:
<ul>
<li>Unification</li>
<li>Sub/supertype relations </li>
</ul>
</li>
<li>Any type-related static analysis, such as:
<ul>
<li>Type checking</li>
<li>Type inference</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#l5-self-typing-builder" id="l5-self-typing-builder">L5: Self-typing Builder:</a></h1>
<p>In L5, we have implementations of the following concepts:</p>
<ul>
<li>The TLA-IR builder</li>
</ul>
<h1><a class="header" href="#l6-type-guaranteed-ir-manipulation" id="l6-type-guaranteed-ir-manipulation">L6: Type-guaranteed IR manipulation</a></h1>
<p>In L6, we have implementations of the following concepts:</p>
<ul>
<li>TLA+ transformations that:
<ul>
<li>do not introduce operators excluded from L0</li>
<li>do not manually introduce IR constructors and type-tags, but use the self-typing builder instead</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#3-apalache-core" id="3-apalache-core">3. Apalache core</a></h2>
<p>L7+ make up the Apalache core. The concepts of these levels are packaged as follows:</p>
<ol>
<li><code>apa-base</code> : L7-L9</li>
<li><code>apa-pass</code> : L10</li>
<li><code>apa-tool</code> : L11+</li>
</ol>
<p>If individual passes in L10 are deemed complex enough, they may be placed in their own package (e.g. <code>apa-bmc</code>)</p>
<h1><a class="header" href="#l7-extensions-of-tla" id="l7-extensions-of-tla">L7: Extensions of TLA+</a></h1>
<p>In L7, we have implementations of the following concepts:</p>
<ul>
<li>Any Apalache-specific operators, introduced into the IR (e.g. <code>ApalacheOper</code>)</li>
<li>Extensions of any printer/reader/writer classes with support for the above specific operators</li>
</ul>
<h1><a class="header" href="#l8-apalache-specific-transformations" id="l8-apalache-specific-transformations">L8: Apalache-specific transformations</a></h1>
<p>In L8, we have implementations of the following concepts:</p>
<ul>
<li>TLA+ transformations that introduce operators from L7</li>
</ul>
<p>Like L3 transformations, if the builder is not used, the transformation should be explicitly marked and inspected for type-correctness.</p>
<h1><a class="header" href="#l9-glue" id="l9-glue">L9: Glue</a></h1>
<p>In L9, we have implementations of the following concepts:</p>
<ul>
<li>Classes and traits used to define Apalache workflow or auxiliary functions, but not core functionality, such as:
<ul>
<li>Exception handling</li>
<li>Logging</li>
</ul>
</li>
<li>Classes and traits related to 3rd party technologies, such as:
<ul>
<li>SMT</li>
<li>TLC config</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#l10-pass-implementations" id="l10-pass-implementations">L10: Pass implementations</a></h1>
<p>In L10, we have implementations of the following concepts:</p>
<ul>
<li>Apalache passes and related infrastructure</li>
</ul>
<h1><a class="header" href="#l11-module-implementations" id="l11-module-implementations">L11: Module implementations</a></h1>
<p>In L11, we have implementations of the following concepts:</p>
<ul>
<li>Apalache modules</li>
</ul>
<h1><a class="header" href="#l12-tool-wrapper" id="l12-tool-wrapper">L12: Tool wrapper:</a></h1>
<p>In L12, we have implementations of the following concepts:</p>
<ul>
<li>Apalache CMD interface</li>
</ul>
<h1><a class="header" href="#l13-gui" id="l13-gui">L13: GUI</a></h1>
<p>In L13, we have implementations of the following concepts:</p>
<ul>
<li>Graphical interface, if/when one exists</li>
</ul>
<h2><a class="header" href="#4-aliases-factories-and-exceptions" id="4-aliases-factories-and-exceptions">4. Aliases, factories and exceptions</a></h2>
<p>Any global alias (e.g <code>type TlaExTransformation = TlaEx =&gt; TlaEx</code>) or factory belongs to the lowest possible level required to define it. For example, <code>type uidToExMap = Map[UID, TlaEx]</code> belongs to L0, since <code>UID</code> and <code>TlaEx</code> are both L0 concepts, so it should be defined in an L0 alias package, even if it is only being used in a package of a higher level. Local aliases may be used wherever convenient.</p>
<p>Any exception belongs to the lowest possible level, at which it can be thrown. For example, <code>AssignmentException</code> belongs to L10, as it is thrown in the <code>TransitionPass</code>.</p>
<h2><a class="header" href="#5-visualization" id="5-visualization">5. Visualization</a></h2>
<p>A visualization of the architecture and the dependencies can be found below. Black arrows denote dependencies between components within a package, while red arrows denote dependencies on packages. Dotted arrows denote conditional dependencies, subject to the concrete implementation of components that have not yet been implemented (marked TBD).
Classes within the level boxes are examples, but are not exhaustive.</p>
<p><img src="adr/./ApaPkg.png" alt="Architecture" /></p>
<h1><a class="header" href="#adr-008-apalache-exceptions" id="adr-008-apalache-exceptions">ADR-008: Apalache Exceptions</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1</td></tr>
</tbody></table>
<p>This ADR documents the various exception thrown in Apalache, and the circumstances that trigger them.</p>
<h2><a class="header" href="#1-user-input-exceptions" id="1-user-input-exceptions">1. User input exceptions</a></h2>
<p>Exceptions in this family are caused by incorrect input from the user. All of these exceptions should exit cleanly and should NOT report a stack trace. We should be able to statically enforce that none of these exceptions can be left unhandled.</p>
<h3><a class="header" href="#11-parser-level" id="11-parser-level">1.1. Parser-level</a></h3>
<p>Since we depend on Sany for parsing, Apalache rejects any syntax which Sany cannot parse.
If Sany produces an exception Apalache catches it and re-throws a class extending</p>
<pre><code>ParserException
</code></pre>
<p>The exception should report the following details:</p>
<ul>
<li>Location of at least one parser issue</li>
</ul>
<h3><a class="header" href="#12-apalache-specific-input-exceptions" id="12-apalache-specific-input-exceptions">1.2. Apalache-specific input exceptions</a></h3>
<p>This category of exceptions deals with problems triggered by incorrect or incomplete information regarding Apalache inputs. Examples include:</p>
<ul>
<li>Malformed config files</li>
<li>Incorrect or missing <code>OVERRIDE_</code></li>
<li>Incorrect or missing <code>UNROLL_</code></li>
<li>Problems with <code>--init/next/cinit/...</code></li>
</ul>
<p>Exceptions thrown in response to these issues should extend </p>
<pre><code>ApalacheInputException
</code></pre>
<p>The exceptions should report the following details:</p>
<ul>
<li>If an input is missing: the name of the expected input </li>
<li>If an input is incorrect: the way in which it is incorrect</li>
</ul>
<h3><a class="header" href="#13-type-related-exceptions" id="13-type-related-exceptions">1.3. Type-related exceptions</a></h3>
<p>This category of exceptions deals with problems arising from the type-system used by Apalache. Examples include:</p>
<ul>
<li>Missing or incorrect type annotations</li>
<li>Incompatibility of argument types and operator types</li>
</ul>
<p>Exceptions thrown in response to these issues should extend </p>
<pre><code>TypeingException
</code></pre>
<p>The exceptions should report the following details:</p>
<ul>
<li>If an annotation is missing: the declaration with the missing annotation and its location</li>
<li>If the types of the arguments at a built-in operator application site are incompatible with the operator type: Both the computed and expected types, and the location of the application site </li>
<li>If the types of the arguments at a user-defined operator application site are incompatible with the operator annotation: Both the computed and expected types, the operator declaration, and the location of the application site</li>
</ul>
<h3><a class="header" href="#14-static-analysis-exceptions" id="14-static-analysis-exceptions">1.4. Static-analysis exceptions</a></h3>
<p>This category of exceptions deals with problems arising from the various static analysis passes performed by Apalache. Examples include:</p>
<ul>
<li>Missing or incorrect variable assignments</li>
<li>Other analyses we might run in the future</li>
</ul>
<p>Exceptions thrown in response to these issues should extend </p>
<pre><code>StaticAnalysisException
</code></pre>
<p>The exceptions should report the following details:</p>
<ul>
<li>The location in the specification where the analysis failed and the expected result</li>
</ul>
<h3><a class="header" href="#15-unsupported-language-exceptions" id="15-unsupported-language-exceptions">1.5. Unsupported language exceptions</a></h3>
<p>This category of exceptions deals with user input, which falls outside of the TLA+ fragment supported by Apalache. Examples include:</p>
<ul>
<li>Unbounded quantification</li>
<li>(Unbounded) <code>CHOOSE</code></li>
<li><code>SelectSeq</code></li>
<li>Fragments of community modules</li>
</ul>
<p>Exceptions thrown in response to these issues should extend </p>
<pre><code>UnsupportedFeatureException
</code></pre>
<p>The exceptions should report the following details:</p>
<ul>
<li>The location of the unsupported expression(s)</li>
</ul>
<h2><a class="header" href="#2-tool-failures" id="2-tool-failures">2. Tool failures</a></h2>
<p>These exceptions are caused by bugs in Apalache. They are fatal and should throw with a stack trace.</p>
<h3><a class="header" href="#21-assumption-violations" id="21-assumption-violations">2.1. Assumption violations</a></h3>
<p>Whenever possible, it's recommended to test against the assumptions of a given pass/transformation. If the assumptions are violated, an</p>
<pre><code>AssumptionViolationException
</code></pre>
<p>should be thrown. It should report the following details:</p>
<ul>
<li>The assumption being violated</li>
<li>The pass/class/method in which the assumption is made</li>
</ul>
<h3><a class="header" href="#22-passtransformation-specific-exceptions" id="22-passtransformation-specific-exceptions">2.2. Pass/Transformation-specific exceptions</a></h3>
<p>Depending on the pass/transformation, specialized exceptions may be thrown, to indicate some problem in either the pipeline, malformed input, missing or incomplete metadata or any other issue that cannot be circumvented. The exceptions should include a reasonable (concise) explanation and, whenever possible, source information for relevant expressions. </p>
<h2><a class="header" href="#3-exception-explanations" id="3-exception-explanations">3. Exception explanations</a></h2>
<p>On their own, exceptions should include concise messages with all the relevant information components, outlined above. In addition to that, we should implement an advanced variant of <code>ExceptionAdapter</code>, called <code>ExceptionExplainer</code>, that is enabled by default, but can be quieted if Apalache is invoked with the flag <code>--quiet-exceptions</code> . </p>
<p>The purpose of this class is to offer users a comprehensive explanation of the exceptions defined in Section 1. Whenever an exception is thrown, <code>ExceptionExplainer</code> should offer:</p>
<ul>
<li>Inlined TLA+ code, in place of source location references</li>
<li>Examples of similar malformed inputs, if relevant</li>
<li>Suggestions on how to fix the exception</li>
<li>A link to the manual, explaining the cause of the exception</li>
</ul>
<h1><a class="header" href="#adr-009-apalache-outputs" id="adr-009-apalache-outputs">ADR-009: Apalache Outputs</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Jure Kukovec, Shon Feder</td><td align="right">2021-12-14</td></tr>
</tbody></table>
<p>This ADR documents the various files produced by Apalache, and where they get written to.</p>
<h2><a class="header" href="#1-categories-of-outputs" id="1-categories-of-outputs">1. Categories of outputs</a></h2>
<p>Files produced by Apalache belong to one of the following categories:</p>
<ol>
<li>Counterexamples </li>
<li>Log files</li>
<li>Intermediate state outputs</li>
<li>Run analysis files</li>
</ol>
<p>Counterexamples (if there are any) and basic logs should always be produced, but the remaining outputs are considered optional. 
Each optional category is associated with a flag: <code>--write-intermediate</code> for intermediate state outputs and an individual flag for each kind of analysis. At the time of writing, the only analysis is governed by <code>--profiling</code>, for profiling results. 
All such optional flags should default to <code>false</code>.</p>
<h2><a class="header" href="#2-output-directory-and-run-directories" id="2-output-directory-and-run-directories">2. Output directory and run directories</a></h2>
<p>Apalache should define an <code>out-dir</code> parameter, which defines the location of all outputs produced by Apalache. If unspecified, this value should default to the working directory, during each run, but it should be possible to designate a fixed location, e.g. <code>&lt;HOME&gt;/apalache-out/</code>.</p>
<p>Each run looks for a subdirectory inside of the <code>out-dir</code> with the same name as
the principle file provided as input (or, for commands that do not read input
from a file, named after the executed subcommand). This subdirectory is called
the specification's (resp. command's) <em>namespace</em> within the <code>out-dir</code>.  All
outputs originating from that input file (resp. command) will be written to this
namespace.</p>
<p>Each run produces a subdirectory in its namespace, with the following name:</p>
<pre><code>&lt;DATE&gt;T&lt;TIME&gt;_&lt;UNIQUEID&gt;
</code></pre>
<p>based on the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> standard.
Here, <code>&lt;DATE&gt;</code> is the date in <code>YYYY-MM-DD</code> format, <code>&lt;TIME&gt;</code> is the local time in <code>HH-MM-SS</code> format.</p>
<p>Example file structure for a run executed on a file <code>test.tla</code>:</p>
<pre><code>_apalache-out/
└── test.tla
    ├── 2021-11-05T22-54-55_810261790529975561
</code></pre>
<h3><a class="header" href="#custom-run-directories" id="custom-run-directories">Custom run directories</a></h3>
<p>The <code>--run-dir</code> flag can be used to specify an output directory into which
outputs are written directly. When the <code>--run-dir</code> flag is specified, all
content included in the run directory specified above will <em>also</em> be written
into the directories specified by this argument.</p>
<h2><a class="header" href="#3-structure-of-a-run-directory" id="3-structure-of-a-run-directory">3. Structure of a run directory</a></h2>
<p>Each run directory outlined in the previous section, should contain the
following:</p>
<ul>
<li>A file <code>run.txt</code>, containing the command issued for this run, with all implicit parameters filled in, so it can be replicated exactly</li>
<li>0 or more counterexample files</li>
<li>a pre-filled bug report file <code>BugReport.md</code>, if the tool exited with a <code>FailureMessage</code></li>
<li>if <code>--write-intermediate</code> is set, a subdirectory <code>intermediate</code>, containing outputs associated with each of the passes in Apalache</li>
<li>an Apalache log file <code>detailed.log</code>.</li>
<li>an SMT log file <code>log0.smt</code></li>
<li>Files associated with enabled analyses, e.g. <code>profile-rules.txt</code></li>
</ul>
<h2><a class="header" href="#4-global-configuration-file" id="4-global-configuration-file">4. Global Configuration File</a></h2>
<p>Apalache should define a global configuration file <code>apalache.cfg</code>, e.g. in the <code>&lt;HOME&gt;/.tlaplus</code> directory, in which users can define the default values of all parameters, including all flags listed in section 1, as well as <code>out-dir</code>. The format of the configuration file is an implementation detail and will not be specified here.</p>
<p>Apalache should also look for a local configuration file <code>.apalache.cfg</code>, within
current working directory or its parents. If it finds such file, any configured
parameters therein will override the parameters from the global config file.</p>
<p>If a parameter is specified in the configuration file, it replaces the default value, but specifying a parameter manually always overrides config defaults.
In other words, parameter values are determined in the following way, by order of priority:</p>
<ol>
<li>If <code>--&lt;flag&gt;=&lt;value&gt;</code> is given, use <code>&lt;value&gt;</code>, otherwise</li>
<li>if a local <code>.apalache.cfg</code> file is found (or is specified with the <code>--config-file</code> argument) containing <code>&lt;flag&gt;: &lt;value&gt;</code>, then
use <code>&lt;value&gt;</code>, otherwise</li>
<li>if the global <code>apalache.cfg</code> specifies <code>&lt;flag&gt;: &lt;value&gt;</code> use <code>&lt;value&gt;</code>,
otherwise</li>
<li>Use the defaults specified in the <code>ApalacheConfig</code> class.</li>
</ol>
<h1><a class="header" href="#rfc-010-implementation-of-transition-exploration-server" id="rfc-010-implementation-of-transition-exploration-server">RFC-010: Implementation of Transition Exploration Server</a></h1>
<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/010rfc-transition-explorer.html#rfc-010-implementation-of-transition-exploration-server">RFC-010: Implementation of Transition Exploration Server</a></li>
<li><a href="adr/010rfc-transition-explorer.html#problem">Problem</a></li>
<li><a href="adr/010rfc-transition-explorer.html#proposal">Proposal</a>
<ul>
<li><a href="adr/010rfc-transition-explorer.html#overview">Overview</a></li>
<li><a href="adr/010rfc-transition-explorer.html#requirements">Requirements</a></li>
<li><a href="adr/010rfc-transition-explorer.html#architecture">Architecture</a></li>
<li><a href="adr/010rfc-transition-explorer.html#api">API</a></li>
<li><a href="adr/010rfc-transition-explorer.html#constructing-the-ir">Constructing the IR</a></li>
<li><a href="adr/010rfc-transition-explorer.html#protocol">Protocol</a>
<ul>
<li><a href="adr/010rfc-transition-explorer.html#grpc-example">gRPC Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- markdown-toc end -->
<h2><a class="header" href="#problem" id="problem">Problem</a></h2>
<p>Users of Apalache have voiced a need for the following kinds of behavior:</p>
<ul>
<li>incremental results (that can be iterated through to exhaustively enumerate all counterexamples)</li>
<li>interactive selection of checking strategies</li>
<li>interactive selection of parameter values</li>
</ul>
<p>The discussion around these needs is summarized and linked in
<a href="https://github.com/informalsystems/apalache/issues/79">#79</a> .</p>
<p>The proximal use cases motivating this feature are discovered in the needs of or
collaborators working on implementing model based testing (MBT) via the
<a href="https://github.com/informalsystems/modelator">Modelator</a> project.
<a href="https://github.com/konnov">@konnov</a> has given the following articulation of the
general concern:</p>
<blockquote>
<p>For MBT we need some way to exhaustively enumerate all counterexamples
according to some strategy. There could be different strategies that vary in
terms of implementation complexity or the number of produced counterexamples</p>
</blockquote>
<p>The upshot: we can provide value by adding a utility that will allow users to
interactively and incrementally explore the transition systems defined by a
given TLA+ spec.</p>
<h2><a class="header" href="#proposal" id="proposal">Proposal</a></h2>
<h3><a class="header" href="#overview-3" id="overview-3">Overview</a></h3>
<p>In the current architecture, there is a single mode of operation in which</p>
<ul>
<li>the user invokes Apalache with an initial configuration, including an input
specification,</li>
<li>the specification and configurations are parsed and pre-processed,</li>
<li>and then the model checker proper drives the
<a href="adr/./003adr-trex.html">TransitionExecutor</a> to effect symbolic
executions verifying the specified properties for the specified model.</li>
</ul>
<p>This RFC proposes the addition of a <em>symbolic transition exploration server</em>.
The server will allow a client to interact with the various steps of the
verification process. The client is thus empowered  to call upon the parser and
preprocessors at will, and to drive the <code>TransitionExecutor</code> interactively, via
a simplified API.</p>
<p>The specific functionality that should be available for interaction is
enumerated in the <a href="adr/010rfc-transition-explorer.html#requirements">Requirements</a>.</p>
<p>As per <a href="https://github.com/informalsystems/apalache/issues/730#issue-855835332">previous
discussions</a>,
interactivity will be supported by running a daemon (or &quot;service&quot;) that serves
incoming requests. Clients will interact via a simple, well supported protocol,
that provides an online RPC interface.</p>
<p>As a followup, we can create our own front-end clients to interact with this
server. In the near term, we envision a CLI, a web front-end, and editor
integrations. Many aspects of such clients should be trivial, once we can use
the client code generated by the gRPC library . See the <a href="adr/010rfc-transition-explorer.html#grpc-example">gRPC
Example</a> for details.</p>
<h3><a class="header" href="#requirements" id="requirements">Requirements</a></h3>
<p>The following requirements have been gathered through conversation and discussion
on our GitHub issues:</p>
<p>| TRANS-EX.1::QCHECK.1 |
: enable checking specs without repeated JVM startup costs
<a href="https://github.com/informalsystems/apalache/issues/730#issue-855835332">730#issue-855835332</a></p>
<p>| TRANS-EX.1::EXPLORE.1 |
: enable exploring model checking results for a spec without repeated
preprocessing costs
<a href="https://github.com/informalsystems/apalache/issues/730#issue-855835332">730#issue-855835332</a></p>
<p>| TRANS-EX.1::LOAD.1 |
: enable loading and unloading specs
<a href="https://github.com/informalsystems/apalache/issues/730#issue-855835332">730#issuecomment-818201654</a></p>
<p>| TRANS-EX.1::EXTENSIBLE.1 |
: The transition explorer should be extensible in the following ways:</p>
<p>| TRANS-EX.1::EXTENSIBLE.1::CLOUD.1 |
: extensible for cloud-based usage</p>
<p>| TRANS-EX.1::EXTENSIBLE.1::CLI.1 |
: extensible for interactive terminal usage |</p>
<p>| TRANS-EX.1::SBMC.1 |
: expose symbolic model checking
<a href="https://github.com/informalsystems/apalache/issues/730#issue-855835332">730#issue-855835332</a></p>
<p>| TRANS-EX.1::SBMC.1::ADVANCE.1 |
: can incrementally advance symbolic states</p>
<p>| TRANS-EX.1::SBMC.1::ROLLBACK.1 |
: can incrementally rollback symbolic states</p>
<p>| TRANS-EX.1::SBMC.1::TRANSITIONS.1 |
: can send data on available transitions</p>
<p>| TRANS-EX.1::SBMC.1::SELECT.1 |
: can execute a specific transition given a selected action</p>
<p>| TRANS-EX.1::SBMC.1::COUNTER.1 |
: supports enumerating counterexamples
<a href="https://github.com/informalsystems/apalache/issues/79#issue-534407916">79#issue-534407916</a></p>
<p>| TRANS-EX.1::SBMC.1::PARAMS.1 |
: supports enumerating parameter values (<code>CONSTANTS</code>) that lead to a
counterexample
<a href="https://github.com/informalsystems/apalache/issues/79#issuecomment-576449107">79#issuecomment-576449107</a></p>
<h3><a class="header" href="#architecture" id="architecture">Architecture</a></h3>
<p>The interactive mode will take advantage of the <code>TransitionExecutor</code>'s
abstraction for writing different model checking strategies, to give the user an
abstracted, interactive interface for dynamically specifying checking
strategies.</p>
<p>I propose the following high-level architecture:</p>
<ul>
<li>Use an RPC protocol to allow the client and server mutually transparent
interaction. (This allows us to abstract away the communication protocol and
only consider the functional API in what follows.)</li>
<li>Introduce a new module, <code>ServerModule</code>, into the <code>apa-tool</code> package. This
module will abstract over the relevant BMC passes which lead up to, and
provide input for, the <code>TransitionExplorer</code>, described below.</li>
<li>Introduce a new module, <code>TransitionExplorer</code> that enables the interactive
exploration of the transition system.</li>
<li>Internally, the <code>TransitionExplorer</code> will make use of the <code>TransitionExecutor</code>
and relevant aspects of the <code>SeqModelChecker</code> (or slightly altered versions of
its methods).</li>
</ul>
<p><em>NOTE</em>: The high-level sketch above assumes the new code organization proposed
in <a href="https://github.com/informalsystems/apalache/tree/main/docs/src/adr/007adr-restructuring.md">ADR 7</a>.</p>
<h4><a class="header" href="#api" id="api">API</a></h4>
<p>The following is a rough sketch of the proposed API for the transition explorer.
It aims to present a highly abstracted interface, but in terms of existing data
structures. Naturally, refinements and alterations are to be expected during
implementation.</p>
<p>We refer to symbolic states as <code>Frames</code>, which are understood as a set of
constraints, and we put this terminology in the API in order to help users
understand when they should be thinking in terms of constraint sets as opposed
to concrete states. Concrete states can be obtained by the functions suffixed
with <code>Example</code>.</p>
<p>In essence, this proposed API is only a thin wrapper around the
<a href="https://github.com/informalsystems/apalache/tree/main/tla-bmcmt/src/main/scala/at/forsyte/apalache/tla/bmcmt/trex/TransitionExecutor.scala">TransitionExecutor
class</a>.
During previous iterations of the proposed API we discussed exposing a
higher-level API, targeted at meeting the requirements more directly.  However,
discussion revealed that the expensive computational costs of SAT solving in
most cases made it infeasible to meet the requirements in this way.  Instead, we
must expose most of the underlying logic of the <code>TransitionExecutor</code>, and task
the users with building their own exploration strategies with these primitives.</p>
<p>It is likely that we will be able to provide some higher-level functionality to users
by way of wrapper libraries we implement on top of the proposed API, but that
work should be left to a subsequent iteration.</p>
<p><strong>NOTE:</strong> This interface is intended as an abstract API, to communicate the
mappings from request to reply. See the <a href="adr/010rfc-transition-explorer.html#grpc-example">gRPC Example</a> for a
sketch of what the actual implementation may look like.</p>
<pre><code class="language-scala">/** A State is a map from variable names to values, and represents a concrete state.  */
type State = Map[String, TlaEx]

/** An abstract representation of a transition.
 *
 * These correspond to the numbered transitions that the `TransitionExectur` uses
 * to advance frames. But we likely want to present some more illuminating metadata
 * associated with the transitions to the users. E.g., ability to view a
 * representation as a `TlaEx` or see an associated operator name (if any)?  */
type Transition

/** An execution is an alternating sequence of states and transitions,
 *  terminating in a state with no transition.
 *
 * It is a high-level representation of the `EncodedExecution` maintained by the
 * transition executor).
 *
 * E.g., an execution from `s1` to `sn` with transitions `ti` for each `i` in `1..n-1`:
 * 
 *     List((s1, Some(t1)), (s2, Some(t2)), ..., (sn, None))
 */
type Execution = List[(State, Option[Transition])]

trait UninitializedModel = {
  val spec: TlaModule
  val transitions: List(Transition)
}

trait InitializedModel extends UninitializedModel {
  val constInitPrimed: Map[String, TlaEx]
}

/** An abstract representation of the `CheckerInput`
 *
 * A `Model` includes all static data representing a model.
 * 
 * An `UninitializedModel` is missing the information that would be needed in
 * order to actually explore its symbolic states (such as the initial values of
 * its constants).
 *
 * An `InitializedModel` has all data needed to explore its symbolic states. */
type Model = Either[UninitializedModel, InitializedModel]

/**  The type of errors that can result from failures when loading a spec. */
type LoadErr

/**  The type of errors that can result from failures to assert a constraint. */
type AssertErr

/**  The type of errors that can result from checking satisfiability of a frame. */
type SatError

/**  Maintains session and connection information */
type Connection

trait TransEx {

  /** Used internally */
  private def connection(): Connection

  /** Reset the state of the explorer
   *
   * Returns the explorer to the same state as when the currently loaded model
   * was freshly loaded. Used to restart exploration from a clean slate.
   *
   * [TRANS-EX.1::LOAD.1]
   */
  def reset(): Unit

  /** Load a model for exploration
   *
   * If a model is already loaded, it will be replaced and the state of the exploration
   * [[reset]].
   *
   * [TRANS-EX.1::QCHECK.1]
   * [TRANS-EX.1::LOAD.1]
   * [TRANS-EX.1::SBMC.1::TRANSITIONS.1]
   * 
   * @param spec the root TLA+ module 
   * @param aux auxiliary modules that may be required by the root module
   * @return `Left(LoadErr)` if parsing or loading the model from `spec` goes
   *          wrong, or `Right(UninitializedModel)` if the model is loaded successfully.
   */
  def loadModel(spec: String, aux: List[String] = List()): Either[LoadErr, UninitializedModel]

  /** Initialize the constants of a model
   *
   * This will always also reset an exploration back to its initial frame. */
  def initializeConstants(constants: Map[String, TlaEx]): Either[AssertErr, InitializedModel]

  /** Prepare the loaded modle with the given `transition` */
  def prepareTransition(transition: Transition): Either[AssertErr, Unit]

  /** The transitions that have been prepared. */
  def preparedTransitions(): Set[Transition]

  /** Apply a (previously prepared) transition to the current frame.
   *
   * Without any arguments, a previously prepared transition is selected
   * nondeterministically.
   *
   * When given a `transition`, apply it if it is already prepared, or prepare
   * it and then apply it, if not.
   * 
   * Interfaces to `assumeTransition` and `pickTransition`, followed by
   * `nextState`. */
  def applyTransition(): Either[AssertErr, Unit]
  def applyTransition(transition: Transition): Either[AssertErr, Unit]

  /** Assert a constraint into the current frame
   *
   *  Interface to `assertState` */
  def assert(assertion: TlaEx): Either[AssertErr, Unit]

  /** The example of an execution from the an initial state up to the current symbolic state
   *
   * Additional executions can be onbtained by asserting constraints that alter the
   * search space. */
  def execution: Either[SatErr, Execution]

  /**
   * Check, whether the current context of the symbolic execution is satisfiable.
   *
   * @return Right(true), if the context is satisfiable;
   *         Right(false), if the context is unsatisfiable;
   *         Left(SatErr) inidicating if the solver timed out or reported *unknown*.
   */
  def sat(): Either[SatErr, Boolean]

  /** Terminate the session. */
  def terminate(): Unit
}

object TransEx {
  /**  Create a transition explorer
   *
   * Establishes the connection and a running session
   *
   * The channel is managed by the gRPC framework. */
  def apply(channel: Channel): TransEx = ...
}
</code></pre>
<h4><a class="header" href="#constructing-the-ir" id="constructing-the-ir">Constructing the IR</a></h4>
<p>In order to form assertions (represented in the spec as values of <code>TlaEx</code>),
users will need a way of constructing the Apalache IR. Similarly, they'll need a
way of deconstructing and inspecting the IR in order to extract useful content
from the transitions.</p>
<p>To meet this need, the gRPC libraries we generate for client code will also
include ASTs in the client language along with generated serialization and
deserialization of JSON represents into and out of the AST. This will enable
users to construct and inspect expressions as needed.</p>
<h4><a class="header" href="#protocol" id="protocol">Protocol</a></h4>
<p>We have briefly discussed the following options:</p>
<ul>
<li>Custom protocol on top of HTTP</li>
<li>JSON-rpc</li>
<li>gRPC</li>
</ul>
<p>I propose use of gRPC for the following reasons:</p>
<ul>
<li>It will automate most of the IO and protocol plumbing we'd otherwise have to
do ourselves.</li>
<li>It is battle tested by <a href="https://grpc.io/">industry</a></li>
<li>It is already used in Rust projects within Informal Systems. This should make
it easier to integrate into modelator.</li>
<li>The <a href="https://scalapb.github.io/docs/grpc/">Scala library</a> appears to be well
documented and actively maintained.</li>
<li><a href="https://grpc.io/docs/languages/">Official support</a> is provided in many
popular languages, and we can expect well-maintained library support in most
languages.</li>
<li>The gRPC libraries include both the RPC protocol and plumbing for the
transport layer, and these are decomposable, in case we end up wanting to use
different transport (i.e., sockets) or a different protocol for some purpose
down the line.</li>
</ul>
<p>For a discussion of some comparison between JSON-rpc and gRPC, see</p>
<ul>
<li>https://www.mertech.com/blog/know-your-api-protocols</li>
<li>https://stackoverflow.com/questions/58767467/what-the-difference-between-json-rpc-with-http2-vs-grpc</li>
</ul>
<p>I have asked internally, and engineers on both <code>tendermint-rs</code> and <code>hermes</code> have
vouched for the ease of use and reliability of gRPC.</p>
<p>Using gRPC can help satisfy [TRANS-EX.1::EXTENSIBLE.1] in the following ways:</p>
<ul>
<li>[TRANS-EX.1::EXTENSIBLE.1::CLOUD.1] should be satisfied out of the box, since
HTTP is the default transport for gRPC.</li>
<li>[TRANS-EX.1::EXTENSIBLE.1::CLI.1] can be satisfied by implementing a CLI
client that we can launch via an Apalache subcommand.</li>
</ul>
<h5><a class="header" href="#grpc-example" id="grpc-example">gRPC Example</a></h5>
<p>Here is as simple example of what it would actually look like to configure gRPC
for the server (adapted from <a href="https://scalapb.github.io/docs/grpc/">ScalaPB grpc</a>):</p>
<p>We define our messages in a <code>proto</code> file:</p>
<pre><code class="language-proto">syntax = &quot;proto3&quot;;

package com.trans-ex.protos;

service TransExServer {
        rpc LoadModel (LoadRequest) returns (LoadReply) {}
}

message LoadRequest {
  required string spec = 1;
  optional repeated string aux = 2;
}

message LoadReply {
  enum Result {
    OK = 0;
    PARSE_ERROR = 1;
    TYPE_ERROR = 2;
    // etc...
  };
  
  required Result result;
  required Model model;
}
</code></pre>
<p>The generated Scala will look roughly as follows:</p>
<pre><code class="language-scala">
object TransExGrpc {
  // Abstract class for server
  trait TransEx extends AbstractService {
    def serviceCompanion = TransEx
    def loadModel(request: LoadRequest): Future[LoadReply]
  }

  // Abstract class for block client
  trait TransExBlockingClient {
    def serviceCompanion = TransEx
    def loadModel(request: LoadRequest): LoadReply
  }

  // Abstract classes for asynch client + various other boilerplate
}
</code></pre>
<p>A sketch of implementing a server using the gRPC interface:</p>
<pre><code class="language-scala">
class TransExImpl extends TransExGrpc.Greeter {
  override def loadModel(req: LoadRequest) = {
    val rootModule = req.model
    val auxModules = req.aux
    
    // run incomming specs through parsing passes
    val model : UninitializedModel = Helper.loadModel(rootModule, auxModules)
    
    val reply = LoadReply(result = Ok, model = model)
    Future.successful(reply)
  }
}
</code></pre>
<p>A sketch of using the client (e.g., to implement our CLI client):</p>
<pre><code class="language-scala">// Create a channel
val channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext(true).build
// Make a blocking call
val request = LoadRequest(spec = &lt;loaded module as string&gt;)
val blockingStub = TransExGrpc.blockingStub(channel)
val reply: LoadReply = blockingStub.loadModel(request)

reply.result match {
  ParseError =&gt; // ...
  Ok =&gt;
    val model: UninitializedModel = reply.model
    // ...
}
</code></pre>
<p>NOTE: To ensure that we are able to maintain a stable API, we should version the
API from the start.</p>
<h1><a class="header" href="#adr-011-alternative-smt-encoding-using-arrays" id="adr-011-alternative-smt-encoding-using-arrays">ADR-011: alternative SMT encoding using arrays</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Rodrigo Otoni</td><td align="right">1.8</td></tr>
</tbody></table>
<p>This ADR describes an alternative encoding of the <a href="https://apalache.informal.systems/docs/apalache/kera.html">KerA+</a> fragment of TLA+ into SMT.
Compound data structures, e.g. sets, are currently encoded using the <a href="http://smtlib.cs.uiowa.edu/theories-Core.shtml">core theory</a> of SMT,
with the goal being to encode them using <a href="http://smtlib.cs.uiowa.edu/theories-ArraysEx.shtml">arrays with extensionality</a> instead.
The hypothesis is that this will lead to increased solver performance and more compact SMT instances.
We target the <a href="https://github.com/Z3Prover/z3">Z3</a> solver and will use the <a href="http://smtlib.cs.uiowa.edu/index.shtml">SMT-LIB Standard</a> (<a href="https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">Version 2.6</a>) in conjunction
with Z3-specific operators, e.g. constant arrays.</p>
<p>For an overview of the current encoding check the <a href="https://dl.acm.org/doi/10.1145/3360549">TLA+ Model Checking Made Symbolic</a> paper,
presented at OOPSLA'19. In the remainder of the document the use of the new encoding and the
treatment of different TLA+ operators are described. For further details on the new encoding
check the <a href="https://doi.org/10.1007/978-3-031-30823-9_7">Symbolic Model Checking for TLA+ Made Faster</a> paper, presented at TACAS'23.</p>
<h2><a class="header" href="#1-cli-encoding-option" id="1-cli-encoding-option">1. CLI encoding option</a></h2>
<p>The encoding using arrays is to be an alternative, not a replacement, to the already existing encoding.
Given this, a new option is to be added to the <code>check</code> command of the CLI. The default encoding will be
the existing one. The option description is shown below. The envvar <code>SMT_ENCODING</code> can also be used to
set the encoding, see the <a href="https://apalache.informal.systems/docs/apalache/running.html#model-checker-command-line-parameters">model checking parameters</a> for details. In addition to the <code>arrays</code> encoding,
which uses SMT arrays to encode TLA+ sets and functions, we also have the <code>funArrays</code> encoding, which
restricts itself to encoding only TLA+ functions as SMT arrays.</p>
<pre><code>--smt-encoding : the SMT encoding: oopsla19, arrays (experimental), funArrays (experimental), default: oopsla19 (overrides envvar SMT_ENCODING)
</code></pre>
<h3><a class="header" href="#code-changes" id="code-changes">Code changes</a></h3>
<p>The following changes will be made to implement the new CLI option:</p>
<ul>
<li>Add new string variable to class <code>CheckCmd</code> to enable the new option.</li>
<li>Add new <code>smtEncoding</code> field to <code>SolverConfig</code>.</li>
<li>Add new class <code>SymbStateRewriterImplWithArrays</code>, which extends class <code>SymbStateRewriterImpl</code>.</li>
<li>Use the new option to set the <code>SolverConfig</code> encoding field and select between different <code>SymbStateRewriter</code>
implementations in classes <code>BoundedCheckerPassImpl</code> and <code>SymbStateRewriterAuto</code>.</li>
<li>The infrastructure changes made for the <code>funArrays</code> encoding mirror the ones made for the <code>arrays</code> one.
See <a href="https://github.com/informalsystems/apalache/pull/2027">PR 2027</a> for details.</li>
</ul>
<h2><a class="header" href="#2-testing-the-new-encoding" id="2-testing-the-new-encoding">2. Testing the new encoding</a></h2>
<p>The new encoding should provide the same results as the existing one, the available test suite
will thus be used to test the new encoding. To achieve this, the unit tests needs to be made parametric
w.r.t. the <code>SolverConfig</code> encoding field and the implementations of <code>SymbStateRewriter</code>, and the
integration tests need to be tagged to run with the new encoding.</p>
<h3><a class="header" href="#code-changes-1" id="code-changes-1">Code changes</a></h3>
<p>The following changes will be made to implement the tests for the new encoding:</p>
<ul>
<li>Refactor the classes in <code>tla-bmcmt/src/test</code> to enable unit testing with different configurations
of <code>SolverConfig</code> and implementations of <code>SymbStateRewriter</code>.</li>
<li>Add unit tests for the new encoding, which should be similar to existing tests, but use a
different solver configuration and <code>SymbStateRewriterImplWithArrays</code> instead of <code>SymbStateRewriterImpl</code>.</li>
<li>Add integration tests for the new encoding by tagging existing tests with <code>array-encoding</code>, which
will be run by the CI with envvar <code>SMT_ENCODING</code> set to <code>arrays</code>.</li>
</ul>
<h2><a class="header" href="#3-encoding-sets" id="3-encoding-sets">3. Encoding sets</a></h2>
<p>Sets are currently encoded in an indirect way. Consider a sort <code>some_sort</code> and distinct elements <code>elem1</code>,
<code>elem2</code>, and <code>elem3</code> of type <code>someSort</code>, as defined below.</p>
<pre><code>(declare-sort some_sort 0)
(declare-const elem1 some_sort)
(declare-const elem2 some_sort)
(declare-const elem3 some_sort)

(assert (distinct elem1 elem2 elem3))
</code></pre>
<p>A set <code>set1</code> containing <code>elem1</code>, <code>elem2</code>, and <code>elem3</code> is currently represented by a constant of type 
<code>set_of_some_Sort</code> and three membership predicates, as shown below.</p>
<pre><code>(declare-sort set_of_some_Sort 0)
(declare-const set1 set_of_some_Sort)

(declare-const elem1_in_set1 Bool)
(declare-const elem2_in_set1 Bool)
(declare-const elem3_in_set1 Bool)

(assert elem1_in_set1)
(assert elem3_in_set1)
(assert elem2_in_set1)
</code></pre>
<p>The new encoding has each set encoded directly as an array whose domain and range equal the set's sort
and the Boolean sort, respectively. SMT arrays can be thought of as a functions, as this is exactly how
they are <a href="https://theory.stanford.edu/%7Enikolaj/programmingz3.html#sec-arrays">represented internally in Z3</a>. Set membership of an element <code>elem</code> is thus attained by simply
setting the array at index <code>elem</code> to <code>true</code>.</p>
<p>One important point in the new encoding is the handling of set declarations, since declaring an
empty set requires the setting of all array indexes to false. This can be easily achieved for
finite sets by explicitly setting each index, but falls outside the quantifier-free fragment of
first-order logic in the case of infinite sets, e.g. the set of integers. To handle declarations
of infinite sets we rely on Z3's constant arrays, which map all indexes to a fixed value. Below is
an example using the new encoding.</p>
<pre><code>(declare-const set2_0 (Array some_sort Bool))
(declare-const set2_1 (Array some_sort Bool))
(declare-const set2_2 (Array some_sort Bool))
(declare-const set2_3 (Array some_sort Bool))

(assert (= set2_0 ((as const (Array some_sort Bool)) false)))

(assert (= set2_1 (store set2_0 elem1 true)))
(assert (= set2_2 (store set2_1 elem2 true)))
(assert (= set2_3 (store set2_2 elem3 true)))
</code></pre>
<p>The <code>store</code> operator handles array updates and receives the array to be updated, the index, and the new
value, returning the updated array. For array access, the <code>select</code> operator can be used, which receives
an array and an index and returns the value at the given index, as shown below.</p>
<pre><code>(assert (= (select set2_2 elem1) true)) ; SAT
(assert (= (select set2_2 elem2) true)) ; SAT
(assert (= (select set2_2 elem3) true)) ; UNSAT

(assert (= (select set2_3 elem1) true)) ; SAT
(assert (= (select set2_3 elem2) true)) ; SAT
(assert (= (select set2_3 elem3) true)) ; SAT
</code></pre>
<p>For consistency, the new encoding uses constant arrays to declare both finite and infinite arrays.</p>
<h3><a class="header" href="#code-changes-2" id="code-changes-2">Code changes</a></h3>
<p>The following changes will be made to implement the new encoding of sets:</p>
<ul>
<li>Add alternative rewriting rules for sets when appropriate, by extending the existing rules.
<ul>
<li>All alternative rules will be suffixed with <code>WithArrays</code>.</li>
<li>The new rules will not rely on <code>LazyEquality</code> and will aim to use SMT equality directly.</li>
<li>Only the generation of SMT constraints will be modified by the new rules, the other Arena
elements will remain unchanged.</li>
</ul>
</li>
<li>In class <code>SymbStateRewriterImplWithArrays</code>, add the new rules to <code>ruleLookupTable</code> by overriding
the entries to their older versions.</li>
<li>Add four new Apalache IR operators in <code>ApalacheOper</code>, <code>Builder</code>, <code>ConstSimplifierForSmt</code>, and 
<code>PreproSolverContext</code>, to represent the array operations.
<ul>
<li>The <code>selectInSet</code> IR operator represents the SMT <code>select</code>.</li>
<li>The <code>storeInSet</code> IR operator represents the SMT <code>store</code>.</li>
<li>The <code>unchangedSet</code> IR operator represents an equality between the current and new SSA array
representations. This is required to constraint the array representation as it evolves. It is
important to note that this operator assumes that all arrays are initially empty, so an element
not explicitly added is assumed to not be in the array. To check absence of an element,
<code>selectInSet</code> should be used with negation.</li>
<li>The <code>smtMap</code> IR operator represents the use of SMT map.</li>
</ul>
</li>
<li>In class <code>Z3SolverContext</code>, add/change appropriate methods to handle SMT constraints over arrays.
<ul>
<li>The main changes will de done in <code>declareCell</code> and the new <code>mkSelect</code>, <code>mkStore</code>, and 
<code>mkUnchangedSet</code> methods, as these methods are directly responsible for creating the SMT 
constraints representing sets and set membership.</li>
<li>With the new IR operators, the &quot;in-relation&quot; concept, which underpins <code>declareInPredIfNeeded</code> 
and <code>getInPred</code>, will not be applied to the new encoding. Cases for the new IR operators will 
be added to <code>toExpr</code>, which will default to <code>TlaSetOper.in</code> and <code>TlaSetOper.notin</code> for the 
existing encoding.</li>
<li>The <code>smtMap</code> IR operator will be used to encode the TLA+ set filter operation. It constructs
a temporary array that contains the evaluation of the filter's predicate for each set element
and uses SMT map to compute the intersection of the set being filtered and the set represented
by the temporary array constructed.</li>
<li>Cases for <code>FinSetT</code> and <code>PowSetT</code> will be added to <code>getOrMkCellSort</code>, as these types are no
longer represented by uninterpreted constants.</li>
<li><code>cellCache</code> will be changed to contain a list of cells, in order to handle the effects of
<code>push</code> and <code>pop</code> in the SSA assignment of sets. The following examples illustrates this need.
<pre><code>(assert (= set_0 ((as const (Array Int Bool)) false)))
(assert (= set_1 (store set_0 5 true)))
(push)
(assert (= set_2 (store set_1 6 true)))
(push)
(assert (= set_3 (store set_2 7 true)))
(assert (= (select set_3 7) true))
(pop 2)
(assert (= (select set_1 7) false)) ; Without the list we would query set_3 here 
</code></pre>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#4-encoding-functions-and-sequences" id="4-encoding-functions-and-sequences">4. Encoding functions and sequences</a></h2>
<p>Functions are currently encoded as sets of pairs, with each pair representing a mapping present in
the function. The first element of a pair is a tuple containing some function arguments and the second
element is the return value given by such arguments. The handling of functions is thus given by 
operations over sets and tuples. Sequences of type <code>T</code> are currently encoded as tuples of form
<code>⟨start,end,fun⟩</code>, where <code>start</code> and <code>end</code> are integers and <code>fun</code> is a function from integers to <code>T</code>.
The new encoding of functions will thus encompass sequences, as their tuple representations is
intended to be kept.</p>
<p>The new encoding will, like the current one, also map tuples of arguments to return values, but
will do so natively instead of simply relying on sets. A function will be represented by two SMT
arrays. The first array will store the domain of the function and will be encoded as a standard 
TLA+ set. The second array will store the mappings, having sort <code>&lt;S1,...,Sn&gt;</code> as its domain, with
<code>Si</code> being the sort of argument <code>i</code>, and the sort of the function's codomain as its range. 
The sorts of the array domain and range can be infinite, but the domain of the function itself,
and by implication the number of mappings tuples, will always be finite.</p>
<p>To encode the TLA+ function <code>finSucc = [x \in {1,2,3} |-&gt; x + 1 ]</code>, which computes the successors
of integers from <code>1</code> to <code>3</code>, we first have to declare its domain, as shown below; tuples are
represented here as per the OOPSLA'19 encoding.</p>
<pre><code>(declare-sort Tuple_Int 0) ; Sort of &lt;Int&gt;
(declare-const tuple_with_1 Tuple_Int) ; &lt;1&gt;
(declare-const tuple_with_2 Tuple_Int) ; &lt;2&gt;
(declare-const tuple_with_3 Tuple_Int) ; &lt;3&gt;

(declare-const finSucc_domain_0 (Array Tuple_Int Bool))
(declare-const finSucc_domain_1 (Array Tuple_Int Bool))
(declare-const finSucc_domain_2 (Array Tuple_Int Bool))
(declare-const finSucc_domain_3 (Array Tuple_Int Bool))

(assert (= finSucc_domain_0 ((as const (Array Tuple_Int Bool)) false)))  ; {}
(assert (= finSucc_domain_1 (store finSucc_domain_0 tuple_with_1 true))) ; {&lt;1&gt;}
(assert (= finSucc_domain_2 (store finSucc_domain_1 tuple_with_2 true))) ; {&lt;1&gt;,&lt;2&gt;}
(assert (= finSucc_domain_3 (store finSucc_domain_2 tuple_with_3 true))) ; {&lt;1&gt;,&lt;2&gt;,&lt;3&gt;}
</code></pre>
<p>The array storing the function's domain is used to guard the definition of the array storing the
function's mappings, since mappings should only be present for values in the domain. The array
storing the mappings of <code>finSucc</code> is shown below.</p>
<pre><code>(declare-const finSucc_0 (Array Tuple_Int Int))
(declare-const finSucc_1 (Array Tuple_Int Int))
(declare-const finSucc_2 (Array Tuple_Int Int))
(declare-const finSucc_3 (Array Tuple_Int Int))

(assert (ite (select finSucc_domain_3 tuple_with_1)
             (= finSucc_1 (store finSucc_0 tuple_with_1 2))
             (= finSucc_1 finSucc_0)))
(assert (ite (select finSucc_domain_3 tuple_with_2)
             (= finSucc_2 (store finSucc_1 tuple_with_2 3))
             (= finSucc_2 finSucc_1)))
(assert (ite (select finSucc_domain_3 tuple_with_3)
             (= finSucc_3 (store finSucc_2 tuple_with_3 4))
             (= finSucc_3 finSucc_2)))
</code></pre>
<p>Note that, unlike with the new encoding for sets, we do not use constant arrays. The reason is that
the function's domain cannot be altered, so the array has to constrain only the values in said domain.
Function application can be done by simply accessing the array at the index of the passed arguments.
A function application with arguments outside the function's domain leads to an unspecified result in
TLA+, which is perfectly captured by unconstrained entries in the SMT array. Below are some examples
of function application.</p>
<pre><code>(assert (= (select finSucc_3 tuple_with_1) 2)) ; SAT
(assert (= (select finSucc_3 tuple_with_2) 3)) ; SAT
(assert (= (select finSucc_3 tuple_with_3) 4)) ; SAT

(declare-const tuple_with_4 Tuple_Int) ; &lt;4&gt;
(assert (= (select finSucc_3 tuple_with_4) 16)) ; SAT
</code></pre>
<p>Although a function's domain cannot be altered, its image can be changed via the TLA+ function
update operator. The update will be encoded as a guarded array update, as illustrated below;
attempting to update an entry outside the function's domain will lead to no change happening.</p>
<pre><code>(declare-const finSucc_4 (Array Tuple_Int Int))
(declare-const finSucc_5 (Array Tuple_Int Int))

(assert (ite (select finSucc_domain_3 tuple_with_1) ; [finSucc EXCEPT ![1] = 9]
             (= finSucc_4 (store finSucc_3 tuple_with_1 9))
             (= finSucc_4 finSucc_3)))
(assert (ite (select finSucc_domain_3 tuple_with_4) ; [finSucc EXCEPT ![4] = 25]
             (= finSucc_5 (store finSucc_4 tuple_with_4 25))
             (= finSucc_5 finSucc_4)))

(assert (= (select finSucc_5 tuple_with_1) 2))  ; UNSAT
(assert (= (select finSucc_5 tuple_with_1) 9))  ; SAT
(assert (= (select finSucc_5 tuple_with_4) 16)) ; SAT
</code></pre>
<p>In contrast to the current encoding, which produces a number of constraints that is linear in the
size of the set approximating the function when encoding both function application and update,
the new encoding will produce a single constraint for each operation. This will potentially lead
to a significant increase in solving performance.</p>
<h3><a class="header" href="#code-changes-3" id="code-changes-3">Code changes</a></h3>
<p>The following changes will be made to implement the new encoding of functions:</p>
<ul>
<li>Add alternative rewriting rules for functions when appropriate, by extending the existing rules. The
same caveats stated for the rewriting rules for sets will apply here.
<ul>
<li>The sets of pairs used in the current encoding are the basis for the counter-example generation in
<code>SymbStateDecoder</code>. In order to continue having counter-examples, these sets will keep being produced,
but will not be present in the SMT constraints. They will be carried only as metadata in the <code>Arena</code>.</li>
</ul>
</li>
<li>Update class <code>SymbStateRewriterImplWithArrays</code> with the rules for functions.</li>
<li>Update the <code>storeInSet</code> IR operator to also store function updates. It will have the value resulting
from the update as an optional argument.
<ul>
<li>Since functions will be encoded as SMT arrays, the <code>selectInSet</code>, <code>storeInSet</code>, and <code>unchangedSet</code>
IR operators will be used when handling them. A future refactoring may rename these operators.</li>
</ul>
</li>
<li>Update class <code>Z3SolverContext</code> to handle the new SMT constraints over arrays.
<ul>
<li>A case for <code>FunT</code> will be added to <code>getOrMkCellSort</code>.</li>
<li>In <code>declareCell</code>, functions will be declared as arrays, but will be left unconstrained.</li>
<li>The <code>mkStore</code> method will be updated to also handle functions. It will have an additional
optional argument containing the value to be stored in the range of the array. The new
argument's default value is <code>true</code>, for the handling of sets.</li>
<li>The <code>mkNestedSelect</code> method is added to support set membership in function sets, i.e.,
<code>f \in [S -&gt; T]</code>. The nesting has first <code>funAppRes = f[s \in S]</code>, followed by <code>funAppRes \in T</code>.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#5-encoding-the-remaining-tla-features" id="5-encoding-the-remaining-tla-features">5. Encoding the remaining TLA+ features</a></h2>
<p>The use of SMT arrays will be restricted to TLA+ sets and functions for the moment. The encoding of
additional features using SMT arrays, or potentially ADTs, will be left for the future.</p>
<h1><a class="header" href="#adr-012-adopt-an-adr-template" id="adr-012-adopt-an-adr-template">ADR-012: Adopt an ADR Template</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Shon Feder</td><td align="right">2021-12-05</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/012adr-adopt-adr-template.html#summary">Summary (Overview)</a></li>
<li><a href="adr/012adr-adopt-adr-template.html#context">Context (Problem)</a></li>
<li><a href="adr/012adr-adopt-adr-template.html#options">Options (Alternatives)</a></li>
<li><a href="adr/012adr-adopt-adr-template.html#solution">Solution (Decision)</a></li>
<li><a href="adr/012adr-adopt-adr-template.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>In the context of our development of Apalache
facing the need to communicate and record our significant decisions
we decided for adopting an ADR template adapted from the &quot;Alexandrian Form&quot;
to achieve concise and consistent records of our architectural decisions
accepting the regimentation and loss of unexpected possibility that comes with adopting a template.</p>
<h2><a class="header" href="#context" id="context">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>The development of Apalache is picking up momentum. We have more contributors
joining us immanently, and hope to welcome and support external OSS contributors
soon. As the number of contributors grows, so does the importance of
establishing supports to encourage communication between individuals and accross
time.</p>
<p>Maintaining records of architectural decisions (aka &quot;ADR&quot;s) is advised by
informal.systems company policy, but the details of how such records should be
written, kept, or used, have not been settled. I hypothesize that we have much
to gain by experimenting with a consistent, well reasoned format for our ADRs. I
think it will help us be mindful of their purpose, make them more useful as
diagnostic and prognostic tools, and help reduce the amount of time needed for
drafting and approval.</p>
<h2><a class="header" href="#options" id="options">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<p>While considering approaches to ADRs, I consulted the following resources, and
many of the children links to found therein, :</p>
<ul>
<li>https://adr.github.io/</li>
<li>https://github.com/joelparkerhenderson/architecture-decision-record</li>
<li>https://en.wikipedia.org/wiki/Architectural_decision</li>
</ul>
<p>I was surprised by the amount of literature surrounding this topic, and wanted
to select something that would help focus and clarify our ADRs, while avoiding
any undue burden that might come from associated management or development
practices.</p>
<p>Each approach to ADRs can inspire a family of templates. I found most of them to
be too involved or intimidating, and I opted for the most light weight approach
I could find, while making some changes to clarify the language and content to
support our context and existing styles of communication.</p>
<h2><a class="header" href="#solution" id="solution">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>I propose adopting this simple articulation of ADRs and their purpose as our
guide:</p>
<blockquote>
<p>An architecture decision record (ADR) is a document that captures an important
architecture decision made along with its context and consequences.</p>
</blockquote>
<p>(see
https://github.com/joelparkerhenderson/architecture-decision-record#what-is-an-architecture-decision-record)</p>
<p>Following the <a href="https://github.com/joelparkerhenderson/architecture-decision-record#teamwork-advice">Teamwork
advice</a>
offered in that same document, I propose adopting an ADR template that puts all
emphasis on the key purposes of the communication, leaving it up to each author
to fill in the template with as much or as little detail as they think necessary
to support the particular decision in question.</p>
<p>To this end, I propose <a href="adr/./NNNadr-template.html">this template</a>, which is adapted
from the <a href="https://github.com/joelparkerhenderson/architecture-decision-record/blob/main/templates/decision-record-template-for-alexandrian-pattern/index.md">Alexandrian
pattern</a>.
This template is itself adapted from the so-called <a href="https://wiki.c2.com/?AlexandrianForm">&quot;Alexandrian
form&quot;</a>.  Martin Fowler has a <a href="https://www.martinfowler.com/articles/writingPatterns.html#AlexandrianForm">succinct
summary of its
qualities</a>
in its native context of &quot;design patterns&quot;.</p>
<h2><a class="header" href="#consequences" id="consequences">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h1><a class="header" href="#adr-013-configuration-management-component" id="adr-013-configuration-management-component">ADR-013: Configuration Management Component</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Shon Feder</td><td align="right">2022-08-15</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/013adr-configuration.html#summary">Summary (Overview)</a></li>
<li><a href="adr/013adr-configuration.html#context">Context (Problem)</a></li>
<li><a href="adr/013adr-configuration.html#options">Options (Alternatives)</a></li>
<li><a href="adr/013adr-configuration.html#solution">Solution (Decision)</a></li>
<li><a href="adr/013adr-configuration.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>In the context of using Apalache from other programs, different environments, and
in different planned modes (see, e.g., <a href="https://github.com/informalsystems/apalache/issues/730">#703</a>),<br />
facing the need to supply different configurations for different use cases<br />
we decided for adopting the <a href="https://github.com/pureconfig/pureconfig">PureConfig</a> library and for introducing a small component to
integrate <code>PureConfig</code> with our CLI parsing <br />
in order to achieve maintainable, reasonable, and extensible management of configurations<br />
accepting the additional external dependency and development costs.</p>
<h2><a class="header" href="#context-1" id="context-1">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>As our application grows more flexible, gains more adoption and usage in
programmatic pipelines, and strives to provide more functionality, we inevitably
need to make it more configurable.</p>
<p>Recent additions that have extended configurability include:</p>
<ul>
<li><a href="https://github.com/informalsystems/apalache/pull/1081">#1081</a>, introducing
the <code>run-dir</code> flag.</li>
<li><a href="https://github.com/informalsystems/apalache/pull/1036">#1036</a>, introducing
the <code>write-intermediate</code>, and <code>profiling</code>, <code>out-dir</code> configuration parameters,
exposed both via CLI and configuration file.</li>
<li><a href="https://github.com/informalsystems/apalache/pull/1054">#1054</a>, introducing
the <code>smt-encoding</code> flag.</li>
</ul>
<p>The ongoing work for <a href="https://github.com/informalsystems/apalache/issues/730">the server
mode</a> is expected to
require introducing several more configurable paramters.</p>
<p>As discussed in <a href="https://github.com/informalsystems/apalache/issues/1069">#1069</a>
and <a href="https://github.com/informalsystems/apalache/issues/1929">#1929</a> we have at
least 5 different sources from which we need to load configuration parameters,
and the loading must cascade, with the first listed source taking priority:</p>
<ul>
<li>CLI arguments <strong>OR</strong> data supplied by RPC</li>
<li>environment variables</li>
<li>A local configuration files (perhaps with the location overridden by a CLI
flag)</li>
<li>A global configuration </li>
<li>Predetermined defaults</li>
</ul>
<p>We are currently managing this configuration in an ad hoc way, with a bespoke
configuration loading system, and various ad hoc methods for effecting
overrides.</p>
<h2><a class="header" href="#options-1" id="options-1">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our consideration and the various alternatives
     considered.
-->
<p>The problem can be decomposed into three parts:</p>
<ol>
<li>Reading parameters from CLI and environment variables (currently done through
our CLI library).</li>
<li>Reading parameters from configuration files (currently done in an ad hoc way)</li>
<li>Cascade loading these paramters in the correct order, to end up with the
correct intended configuration.</li>
</ol>
<p>To address (2) and (3), we should use an existing configuration management
library, since this will save us development time, and allow us to take
advantage of other developer's careful engineering around this problem, freeing
us to focus on our core problem domain.</p>
<p>There are some configuration libraries that aim to provide an integrated
solutions to all three problems, but I have dismissed them for reasons described
below.</p>
<h3><a class="header" href="#comparison-of-configuration-management-libraries" id="comparison-of-configuration-management-libraries">Comparison of configuration management libraries</a></h3>
<p>I considered four actively maintained libraries focused on application
configuration. This section reports my findings.</p>
<h4><a class="header" href="#activity" id="activity">Activity</a></h4>
<table><thead><tr><th align="left">Library</th><th align="left">Contributors</th><th align="left">Last Release</th><th>GitHub Stars</th><th>Build Status</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/lightbend/config">config</a></td><td align="left">89</td><td align="left">2020-10-22</td><td>5.5k</td><td>passing</td></tr>
<tr><td align="left"><a href="https://github.com/outr/profig">profig</a></td><td align="left">5</td><td align="left">2021-01-14</td><td>23</td><td>failing</td></tr>
<tr><td align="left"><a href="https://github.com/scalameta/metaconfig">metaconfig</a></td><td align="left">23</td><td align="left">2021-05-31</td><td>29</td><td>passing</td></tr>
<tr><td align="left"><a href="https://github.com/pureconfig/pureconfig">PureConfig</a></td><td align="left">58</td><td align="left">2021-11-21</td><td>1.2k</td><td>passing</td></tr>
</tbody></table>
<h4><a class="header" href="#features" id="features">Features</a></h4>
<table><thead><tr><th align="left">Library</th><th align="left">Formats</th><th align="left">File Merging</th><th>Envvar Fallback</th><th>CLI Arg Merging</th><th>Language</th><th>Typing</th><th>Documentation</th></tr></thead><tbody>
<tr><td align="left"><a href="https://github.com/lightbend/config">config</a></td><td align="left">java properties, JSON, HOCON</td><td align="left">yes</td><td>yes</td><td>manual</td><td>Java</td><td>dynamic</td><td>excellent</td></tr>
<tr><td align="left"><a href="https://github.com/outr/profig">profig</a></td><td align="left">java properties, JSON, YAML, HOCON, XML</td><td align="left">yes</td><td>yes</td><td>automatic</td><td>Scala</td><td>dynamic</td><td>decent</td></tr>
<tr><td align="left"><a href="https://github.com/scalameta/metaconfig">metaconfig</a></td><td align="left">JSON, HOCON</td><td align="left">?</td><td>?</td><td>automatic</td><td>Scala</td><td>static</td><td>poor</td></tr>
<tr><td align="left"><a href="https://github.com/pureconfig/pureconfig">PureConfig</a></td><td align="left">java properties, JSON, HOCON</td><td align="left">yes</td><td>semi</td><td>automatic</td><td>Scala</td><td>static</td><td>excellent</td></tr>
</tbody></table>
<h4><a class="header" href="#additional-notes" id="additional-notes">Additional notes</a></h4>
<ul>
<li>[conifg][]
<ul>
<li>Integrates with Guice</li>
<li>Lots of support due to Java usage</li>
</ul>
</li>
<li><a href="https://github.com/outr/profig">profig</a>
<ul>
<li>only apparent advantage over <a href="https://github.com/lightbend/config">config</a> is automatic CLI parsing, but that
also requires swapping out our CLI library.</li>
</ul>
</li>
<li><a href="https://github.com/scalameta/metaconfig">metaconfig</a>
<ul>
<li>Automatically generates markdown CLI documentation</li>
<li>Reports errors with location in configuration source</li>
<li>Treats CLI args just as another source for configuration data </li>
<li>Maintained by <a href="https://github.com/scalameta">scalameta</a></li>
<li>Used by <a href="https://github.com/scalacenter/scalafix">scalafix</a> and scalafmt</li>
</ul>
</li>
<li><a href="https://github.com/pureconfig/pureconfig">PureConfig</a>
<ul>
<li>Type safe wrapper around <a href="https://github.com/lightbend/config">config</a>, so should inherit all features of that
basis (including Guice integration)</li>
<li>Will automatically merge configs based on a priority list of files.</li>
<li>Support optional configuration fallback</li>
<li>Supports writing out configs (can be used in bug reports or populating
default config to help guide users)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#evaluation" id="evaluation">Evaluation</a></h3>
<p>I discount <a href="https://github.com/outr/profig">profig</a> because it has nothing significant to recommend it over <a href="https://github.com/lightbend/config">config</a>.</p>
<p><a href="https://github.com/scalameta/metaconfig">metaconfig</a> is attractive due its support for type safe configuration,
generation of markdown documentation, but the poor documentation and relatively
small user base counts against it. Those other factors are not sufficiently
attractive to outweigh the risks.</p>
<p>The choice between <a href="https://github.com/lightbend/config">config</a> and <a href="https://github.com/pureconfig/pureconfig">PureConfig</a> is easy: <a href="https://github.com/pureconfig/pureconfig">PureConfig</a>
includes everything provided by <a href="https://github.com/lightbend/config">config</a>, but exposes a types safe,
Scala-native API. Moreover, it's got a substantial user-base and excellent
documentation.</p>
<h2><a class="header" href="#solution-1" id="solution-1">Solution</a></h2>
<p>We will adopt <a href="https://github.com/pureconfig/pureconfig">PureConfig</a> as our configuration management library. It will
enable us to cascade load configuration files from many exernal sources
(including a json blob passed in via CLI inputs) and provide type-safe access to
the configured values.</p>
<p>We will continue to rely on <code>clist</code> for CLI parsing for the time being, which
takes care of loading environment variable settings and CLI arguments with our
desired overriding precedence. This will require we add a thin abstraction that
will ensure the CLI arguments end up overriding the configured values. This
abstraction will replace the more ad hoc process we are currently employing to
this end.</p>
<p>Here's a short example of how basic usage should look (approximately), allowing
us to replace dozens of lines of code in the <code>OutputManager</code> implementing our
current adhoc configuration parsing:</p>
<pre><code class="language-scala">import pureconfig._
import pureconfig.generic.auto._

// Setting a defaul value
case class Port(number: Int = 8080) extends AnyVal

sealed trait SmtEncoding
case class Arrays extends SmtEncoding
case class OOPSLA19 extends SmtEncoding

case class ApalacheConfig(
  runDir: Option[Path] = None,
  serverPort: Port = Port(),
  writeIntermediate: Boolean = false,
  profiling: Boolean = false,
  outDir: Path = Path(&quot;.&quot;),
  smtEncding: SmtEncoding = OOPSLA19,
)

case classs ExampleUseOfConfigs() = {
  val cli = CliParseResults()
  val localConfig = ConfigSource.file(Path.cwd.resolve(&quot;.aplache.config&quot;))
  val globalConfig = ConfigSource.file(ApalacheHome.resolve(&quot;apalache.config&quot;))
  val loadedConfig: ConfigReader.Result[ApalacheConfig] = globalConfig
    .withFallback(localConfig)
    .load[ApalacheConfig]

  // Finally, override with CLI arguments
  // Unfortunatley, I've not found a robust way to automate this yet
  val config = loadedConfig.copy(
    runDir = cli.runDir.getOrElse(loadedConfig.runDir),
    serverPort = cli.runDir.getOrElse(loadedConfig.serverPort),
    // etc..
  )

}
</code></pre>
<p>This <code>ApalacheConfig</code> class can then be passed around to all parts of the
program that need to read such configurations.</p>
<h2><a class="header" href="#consequences-1" id="consequences-1">Consequences</a></h2>
<p>After utilizing the approach proposed here for nearly a year, we were able to
introduce several additional configurations easily, and we found the local
configuration files useful for tweaking program behavior. We subsequently
decided to further extend the configuration system by integrating the CLI within
the configuration system and use it as the basis for statically representing all
program options. See <a href="adr/./022adr-unification-of-configs-and-options.html">ADR 022</a>.</p>
<h1><a class="header" href="#adr-014-precise-type-inference-for-records-and-variants" id="adr-014-precise-type-inference-for-records-and-variants">ADR-014: Precise type inference for records and variants</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">2021-12-12</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/014adr-precise-records.html#summary">Summary (Overview)</a></li>
<li><a href="adr/014adr-precise-records.html#context">Context (Problem)</a></li>
<li><a href="adr/014adr-precise-records.html#options">Options (Alternatives)</a></li>
<li><a href="adr/014adr-precise-records.html#solution">Solution (Decision)</a></li>
<li><a href="adr/014adr-precise-records.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#1-summary" id="1-summary">1. Summary</a></h2>
<p>This ADR extends
<a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR-002</a> on
types and type annotations.</p>
<p>Virtually every user of Snowcat has faced the issue of record type checking
being imprecise. Some people call it &quot;unsound&quot;, though soundness depends on the
type system. This is due to our decision to support the variant pattern that
can be found in untyped TLA+ specifications. In this ADR, we are proposing a
plan of action for introducing precise type inference for records and variants
(discriminated unions) in the type checker. This would deliver the most asked
feature. On the downside, we would have to:</p>
<ol>
<li>
<p>Increase the complexity of the type checker.</p>
</li>
<li>
<p>Slightly update the rewriting rules in the model checker.</p>
</li>
<li>
<p>Require the users to modify their specs to use the variant operators.</p>
</li>
</ol>
<p>As much as possible, we have tried to make the type annotations non-intrusive and compatible with
TLC. After precisely specifying the requirements for the variant
type, we have found that it would be impossible to do sound type checking
without introducing additional operators.</p>
<p>We believe that the benefits outweigh the downsides in the long run. Moreover,
it will improve user experience, as this is the most requested feature.</p>
<h2><a class="header" href="#2-context" id="2-context">2. Context</a></h2>
<p>As discussed in <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR002</a>, the type checker is not checking the record types
precisely. Consider the following operator:</p>
<pre><code class="language-tla">Foo ==
  LET S == {[ type |-&gt; &quot;A&quot;, a |-&gt; 1], [ type |-&gt; &quot;B&quot;, b |-&gt; 2 ]} IN
  \E m \in S:
    m.a &gt; m.b
</code></pre>
<p>The type checker assigns the type <code>Set([type: Str, a: Int, b: Int])</code> to <code>S</code>. As
a result, one can write the expression <code>m.a &gt; m.b</code>, which does not make a lot
of sense. This may lead to unexpected results in a large specification. In the
above example, the model checker would just produce some values for <code>m.a</code> or
<code>m.b</code>, which will probably result in a spurious counterexample.</p>
<p>Further, multiple related issues and potential solutions were underlined in
<a href="https://github.com/informalsystems/apalache/issues/401">#401</a> and <a href="https://github.com/informalsystems/apalache/discussions/789">#789</a>.</p>
<p>There are two main patterns of record use in TLA+:</p>
<ol>
<li>
<p><strong>Plain records</strong>. A record with a fixed number of fields is passed around.</p>
</li>
<li>
<p><strong>Variants</strong>. Records of various shapes are collected in a single
set and passed around. The precise record shape is controlled with a special
field (discriminator), which is usually called <code>type</code> in TLA+ specs.</p>
</li>
</ol>
<h3><a class="header" href="#21-untyped-plain-records" id="21-untyped-plain-records">2.1. Untyped plain records</a></h3>
<p>When it comes to records, it is clear that users expect the type checker to complain about missing record fields. Indeed, it is very
easy to introduce a spurious record field by mistyping the field name. It
happened to all of us.</p>
<p>Interestingly, plain records are used less often than variants.
Perhaps, if records are required, the specification is quite complex already,
so it would also need variants.</p>
<p>Occurences in <a href="https://github.com/tlaplus/Examples">tlaplus-examples</a>:</p>
<ul>
<li><a href="https://members.loria.fr/SMerz/talks/argentina2005/Charpentier/charpov/Teaching/CS-986/TLC/ACP_NB.tla">ACP_NB</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/c1cs/c1cs.tla">c1cs</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/detector_chan96/EnvironmentController.tla">EnvironmentController</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/lamport_mutex/LamportMutex.tla">LamportMutex</a></li>
<li><a href="https://github.com/muratdem/PlusCal-examples/blob/master/VoldemortKV/voldchain.tla">voldchain</a></li>
<li><a href="https://github.com/Starydark/Tencent-Paxos-TLA/blob/master/TPaxos.tla">TPaxos</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/echo/Echo.tla">Echo</a></li>
</ul>
<p><a href="https://github.com/tlaplus/Examples/blob/master/specifications/lamport_mutex/LamportMutex.tla">LamportMutex</a>
is an interesting borderline case, in which the spec uses the variant pattern,
but it could be typed with a single record type. Here are the interesting pieces
in this spec:</p>
<pre><code class="language-tla">ReqMessage(c) == [type |-&gt; &quot;req&quot;, clock |-&gt; c]
AckMessage == [type |-&gt; &quot;ack&quot;, clock |-&gt; 0]
RelMessage == [type |-&gt; &quot;rel&quot;, clock |-&gt; 0]

Message == {AckMessage, RelMessage} \union {ReqMessage(c) : c \in Clock}

...
Broadcast(s, m) ==
  [r \in Proc |-&gt; IF s=r THEN network[s][r] ELSE Append(network[s][r], m)]
...
Request(p) ==
  ...
  /\ network' = [network EXCEPT ![p] = Broadcast(p, ReqMessage(clock[p]))]
  ...
</code></pre>
<p>Although, every message record is accompanied with the field <code>type</code>, all
records have the same shape, namely, they have two fields: A string field
<code>type</code> and an integer field <code>clock</code>.</p>
<h3><a class="header" href="#22-untyped-variants" id="22-untyped-variants">2.2. Untyped variants</a></h3>
<p>Most of the benchmarks stem from the Paxos specification. They all follow the
same pattern. Messages are represented with records of various shapes. Every
record carries the field <code>type</code> that characterizes the record shape. For instance,
here is how records are used in Paxos:</p>
<pre><code class="language-tla">Message ==      [type : {&quot;1a&quot;}, bal : Ballot]
           \cup [type : {&quot;1b&quot;}, acc : Acceptor, bal : Ballot, 
                 mbal : Ballot \cup {-1}, mval : Value \cup {None}]
           \cup [type : {&quot;2a&quot;}, bal : Ballot, val : Value]
           \cup [type : {&quot;2b&quot;}, acc : Acceptor, bal : Ballot, val : Value]
...
Send(m) == msgs' = msgs \cup {m}
...
Phase1b(a) == /\ \E m \in msgs : 
                  /\ m.type = &quot;1a&quot;
                  /\ m.bal &gt; maxBal[a]
                  ...
                  /\ Send([type |-&gt; &quot;1b&quot;, acc |-&gt; a, bal |-&gt; m.bal, 
                            mbal |-&gt; maxVBal[a], mval |-&gt; maxVal[a]])
              ...
</code></pre>
<p>Occurences in <a href="https://github.com/tlaplus/Examples">tlaplus-examples</a>:</p>
<ul>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a></li>
<li><a href="https://github.com/tlaplus/Examples/tree/master/specifications/802.16">802.16</a></li>
<li><a href="https://github.com/byisystems/byihive/blob/master/specifications/tla%2B/VoucherIssue.tla">byihive</a></li>
<li><a href="https://github.com/tbg/caspaxos-tla/blob/master/CASPaxos.tla">CASPaxos</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/cbc_max/cbc_max.tla">cbc_max</a></li>
<li><a href="https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla">EgalitarianPaxos</a></li>
<li><a href="https://github.com/fpaxos/fpaxos-tlaplus/blob/master/FPaxos.tla">FPaxos</a></li>
<li><a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla">raft</a></li>
<li><a href="https://github.com/sanjosh/tlaplus/blob/master/amazon/serializableSnapshotIsolation.tla">SnapshotIsolation</a></li>
<li><a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/PaxosCommit.tla">PaxosCommit</a></li>
</ul>
<p>More advanced code patterns over variants can be found in <a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla">Raft</a>:</p>
<pre><code class="language-tla">Receive(m) ==
    LET i == m.mdest
        j == m.msource
    IN \* Any RPC with a newer term causes the recipient to advance
       \* its term first. Responses with stale terms are ignored.
       \/ UpdateTerm(i, j, m)
       \/ /\ m.mtype = RequestVoteRequest
          /\ HandleRequestVoteRequest(i, j, m)
       \/ /\ m.mtype = RequestVoteResponse
          /\ \/ DropStaleResponse(i, j, m)
             \/ HandleRequestVoteResponse(i, j, m)
       \/ /\ m.mtype = AppendEntriesRequest
          /\ HandleAppendEntriesRequest(i, j, m)
       \/ /\ m.mtype = AppendEntriesResponse
          /\ \/ DropStaleResponse(i, j, m)
             \/ HandleAppendEntriesResponse(i, j, m)
    ...
Next ==
    ...
           \/ \E m \in DOMAIN messages : Receive(m)
           \/ \E m \in DOMAIN messages : DuplicateMessage(m)
           \/ \E m \in DOMAIN messages : DropMessage(m)
    ...
</code></pre>
<h3><a class="header" href="#3-other-issues" id="3-other-issues">3. Other issues</a></h3>
<p>As can be seen from the Paxos example, we should take care of sets of
records that are used as sets of variants:</p>
<pre><code class="language-tla">Message ==      [type : {&quot;1a&quot;}, bal : Ballot]
           \cup [type : {&quot;1b&quot;}, acc : Acceptor, bal : Ballot, 
                 mbal : Ballot \cup {-1}, mval : Value \cup {None}]
           \cup [type : {&quot;2a&quot;}, bal : Ballot, val : Value]
           \cup [type : {&quot;2b&quot;}, acc : Acceptor, bal : Ballot, val : Value]
</code></pre>
<h2><a class="header" href="#4-options" id="4-options">4. Options</a></h2>
<p>There are several solutions to the issue of precise record typing.</p>
<h3><a class="header" href="#41-support-only-plain-records" id="41-support-only-plain-records">4.1. Support only plain records</a></h3>
<p>In this case, we would only allow to mix records that have exactly the same
shape. As a result, when we use variants, we would have to add extra
fields to all of them. This solution is not very different from the current
implementation of record type checking, though it would allow us to quickly
detect spelling errors.</p>
<p><strong>Blocker.</strong> This does not look like a real solution, as it would immediately
render the existing examples invalid. Moreover, they would be no obvious way to
repair these examples.</p>
<h3><a class="header" href="#42-support-plain-records-and-variants-but-no-row-typing" id="42-support-plain-records-and-variants-but-no-row-typing">4.2. Support plain records and variants, but no row typing</a></h3>
<p>In this scenario, the type checker would issue an error, if a record expression
accesses a field that is outside of its type:</p>
<pre><code class="language-tla">FieldAccess ==
  LET m == [ a |-&gt; 2, b |-&gt; &quot;B&quot; ] IN
  /\ m.a &gt; 1        \* type OK
  /\ m.b = &quot;B&quot;      \* type OK
  /\ m.c = { 1, 2 } \* should flag a type error
</code></pre>
<p>Moreover, the following example would require a type annotation:</p>
<pre><code class="language-tla">RowAccess(m) ==
    m.a &gt; 0         \* should flag a type error
</code></pre>
<p>In the above example, the type checker would not be able to infer the type of
<code>m</code> and would require an explicit type annotation:</p>
<pre><code class="language-tla">\* @type: [ a: Int, b: Str ];
RowAccessAnnotated(m) ==
    m.a &gt; 0         \* should not flag a type error
</code></pre>
<p><strong>Blocker.</strong> It is not clear to me, what type we would assign to the record
access operator. Although the type of <code>m</code> in <code>FieldAccess</code> is obvious to a
human reader, as it simply requires us to do the top-to-the-bottom type
propagation, Snowcat constructs a set of equality constraints that are solved
by unification. This approach requires that we capture the record access
operator <code>.</code> as an equality over type variables and types.</p>
<h3><a class="header" href="#43-support-plain-records-and-variants-including-row-typing" id="43-support-plain-records-and-variants-including-row-typing">4.3. Support plain records and variants, including row typing</a></h3>
<p>This solution is inspired by the approach outlined by <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels">Leijen05</a>, but is much more limited. The following features discussed in <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels">Leijen05</a> are neither needed needed nor supported:</p>
<ul>
<li>extension for records</li>
<li>extension for variants</li>
<li>record restriction</li>
<li>scoped labels</li>
</ul>
<p>Our use is limited to a few special cases that give support for subtyping and incremental inference of anonymous record types, in which we cannot know the full set of fields up front. </p>
<h2><a class="header" href="#5-solution" id="5-solution">5. Solution</a></h2>
<p>In the following, we present row types as type terms. We discuss the
user-facing syntax of the type system later in the text.</p>
<h3><a class="header" href="#51-plain-records" id="51-plain-records">5.1. Plain records</a></h3>
<p>By using <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/">Row types</a>, we should be able to infer a polymorphic record type for  <code>m</code> in the unannotated
<code>RowAccess</code> operator:</p>
<pre><code>Rec(RowCons(&quot;a&quot;, Int, z))
</code></pre>
<p>In this example, <code>RowCons(&quot;a&quot;, Int, z)</code> indicates a row indicating that the type of the record enclosing it
has the field <code>a</code> of type <code>Int</code>. On top of that, this row
extends a parametric type <code>z</code>, which either contains a non-empty sequence of
rows, or is an empty sequence, that is, <code>RowNil</code>. Importantly, <code>RowCons</code> is
wrapped with the term <code>Rec</code>, so no additional fields can be added to the type.</p>
<p>The example <code>FieldAccess</code> contains a record constructor
<code>[ a |-&gt; 2, b |-&gt; &quot;B&quot; ]</code>. We can write a general type inference rule for it:</p>
<pre><code>e_1: t_1, ..., e_n: t_n
-------------------------------- [rec]
[ f_1 |-&gt; e_1, ..., f_n |-&gt; e_n]:
  Rec(
    RowCons(f_1, t_1,
      RowCons(f_2, t_2,
        ...
          RowCons(f_n, t_n, RowNil)
      ...)
    )
  )
</code></pre>
<p>In <code>FieldAccess</code>, we use row types to construct a series of type equations
(over free type variables <code>k</code>, ..., <code>q</code>):</p>
<pre><code>// from LET m == [ a |-&gt; 2, b |-&gt; &quot;B&quot; ] IN
m_type = Rec(&quot;a&quot;, Int, RowCons(&quot;b&quot;, Str, RowNil))
// from m.a &gt; 1
m_type = Rec(RowCons(&quot;a&quot;, k, l))
k = Int
// from m.b = &quot;B&quot;
m_type = Rec(RowCons(&quot;b&quot;, m, n))
m = Str
// from m.c = { 1, 2 }
m_type = Rec(RowCons(&quot;c&quot;, p, q))
p = Set(Int)
</code></pre>
<p>To solve the above equations, one has to apply unification rules. Precise
unification rules for rows are given in the paper by <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels">Leijen05</a>. Importantly,
their unification rules allow <code>RowCons(f1, t1, RowCons(f2, t2, r3))</code> to be
unified with <code>RowCons(f2, t2, RowCons(f1, t1, r3))</code>. Hence, fields may bubble
up to the head, and it should be possible to isolate a single field and assign
the rest to a type variable. By partially solving the above equation, we would
arrive at contradiction. This supports our intuition that the operator
<code>FieldAccess</code> is ill-typed.</p>
<p>Hence, we formulate the type inference rule for record access in our type
system as follows:</p>
<pre><code>r: Rec(RowCons(&quot;f&quot;, t_1, t_2))
-------------------------------- [rec_acc]
r.f: t_1
</code></pre>
<p>Note that the above rule can be rewritten into a series of equalities over
types variables and type terms, which is how this would be implemented in the
type checker.</p>
<p>If we only had to deal with records, that would be a complete solution.
Unfortunately, variants introduce additional complexity.</p>
<h3><a class="header" href="#52-variants" id="52-variants">5.2. Variants</a></h3>
<p><strong>Example 5.2.1.</strong> Now we have to figure out how to deal with TLA+ expressions
like:</p>
<pre><code class="language-tla">  { [ tag |-&gt; &quot;1a&quot;, bal |-&gt; 3 ], [ tag |-&gt; &quot;2a&quot;, bal |-&gt; 4, val |-&gt; 0 ] }
</code></pre>
<p>Obviously, we cannot fit both of the records into a single plain record type,
provided that we want to precisely track the fields that are present in a
record. So the type checker should report a type error, if we only implement
type inference for the case explained in Section 5.1. To support this important
pattern, we introduce variants. They are similar to <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types">unions in
TypeScript</a>.
In contrast to TypeScript, we fix one field to designate the record type in a
variant. Also, we are using the word &quot;variant&quot;, to avoid any confusion
with the TLA+ operators <code>UNION</code> and <code>\union</code>.</p>
<p>We reserve the field name <code>tag</code> for the record discriminator.</p>
<p><strong>Variant constructor.</strong> We introduce a special TLA+ operator <code>Variant</code>
that extracts the tag from a record and wraps the record into a variant.
We need this operator to distinguish between plain records and records that
belong to a variant. The operator <code>Variant</code> is defined in TLA+ as follows:</p>
<pre><code class="language-tla">  Variant(r) ==
    \* fallback untyped implementation
    r
</code></pre>
<p>This operator does not change its argument, but it provides the type checker
with a hint that the record should be treated as a member of a variant.</p>
<p>Consider the record constructor of <code>n+1</code> fields, one of them being the field
<code>&quot;tag&quot;</code>:</p>
<pre><code class="language-tla">  [ tag |-&gt; &quot;&lt;TAG&gt;&quot;, f_1 |-&gt; e_1, ..., f_n |-&gt; e_n ]
</code></pre>
<p>Here, <code>&quot;&lt;TAG&gt;&quot;</code> stands for a string literal such as <code>&quot;1a&quot;</code> or <code>&quot;2a&quot;</code>. The
general rule for <code>Variant([ tag |-&gt; &quot;&lt;TAG&gt;&quot;, f_1 |-&gt; e_1, ..., f_n |-&gt; e_n ])</code>
looks as follows:</p>
<pre><code>e_1: t_1, ..., e_n: t_n
z is a fresh type variable
------------------------------------------------------------ [variant]
Variant([ tag |-&gt; &quot;&lt;TAG&gt;&quot;, f_1 |-&gt; e_1, ..., f_n |-&gt; e_n ]):
  Variant(
    RowCons(&quot;&lt;TAG&gt;&quot;,
      Rec(
        RowCons(&quot;tag&quot;, Str,
          RowCons(f_1, t_1,
            ...
              RowNil)...)
      ),
      z
    )
  )
</code></pre>
<p>According to the rule <code>[variant]</code>, the operator <code>Variant</code> wraps a record
constructor that contains a string literal for the field <code>tag</code>. The variant
contains the record that was passed in the constructor, whereas the other
alternatives of the variant are captured with a fresh type variable <code>z</code>, which must
be a row.</p>
<p>Importantly, we use rows at two levels:</p>
<ol>
<li>
<p>To construct a single record, whose shape is defined precisely.</p>
</li>
<li>
<p>To construct a variant, whose only record is known at the time,
while the rest is captured with the type variable <code>z</code>.</p>
</li>
</ol>
<p>Going back to <strong>Example 5.2.1</strong>, the set constructor would produce a set of
equalities:</p>
<pre><code>  a = Set(b)
  a = Set(d)
  b = Variant(RowCons(&quot;1a&quot;,
                Rec(RowCons(&quot;tag&quot;, Str, RowCons(&quot;bal&quot;, Int, RowNil))),
              c))
  d = Variant(RowCons(&quot;2a&quot;,
                Rec(RowCons(&quot;tag&quot;, Str,
                  RowCons(&quot;bal&quot;, Int,
                    RowCons(&quot;val&quot;, Int, RowNil)))),
              e))
</code></pre>
<p>By solving these equalities with unification, we will arrive at the following
variant:</p>
<pre><code>  Set(Variant(RowCons(
               &quot;1a&quot;,
               Rec(RowCons(&quot;tag&quot;, Str, RowCons(&quot;bal&quot;, Int, RowNil))),
               RowCons(
                 &quot;2a&quot;,
                 Rec(RowCons(&quot;tag&quot;, Str,
                       RowCons(&quot;bal&quot;, Int,
                         RowCons(&quot;val&quot;, Int, RowNil)))),
                 t
     ))))
</code></pre>
<p>Note that we still do not know the precise shape of the variant, as it
closes with the type variable <code>t</code>. This is actually what we expect, as the set
may be combined with records of other shapes. Normally, the final shape of a
variant propagates via state variables of the TLA+ specification.</p>
<p><strong>Type annotations for variants.</strong> Snowcat requires that all state variables
are annotated. What shall we write for variants?  We introduce the common type
notation for variants that separates records with a pipe, that is, <code>|</code>. For
instance, consider the following variable declaration in a TLA+ specification:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: Set([ tag: &quot;1a&quot;, bal: Int ] | [ tag: &quot;2a&quot;, bal: Int, val: Int ]);
  msgs
</code></pre>
<p>Note that even though the syntax of individual elements of a variant is very
similar to that of a record, there is small difference: The tag field is not
declared as a string type, but carries the values of the tag itself.</p>
<p>As variants can grow large very quick, it is more convenient to introduce them
via a type alias. For instance:</p>
<pre><code class="language-tla">VARIABLES
  (*
    @typeAlias: MESSAGE =
       [ tag: &quot;1a&quot;, bal: Int ]
     | [ tag: &quot;2a&quot;, bal: Int, val: Int ]);
    @type: Set(MESSAGE);
   *)  
  msgs
</code></pre>
<p><strong>Filter a set of variants.</strong> As we have seen, the following pattern
is quite common in TLA+ specifications, e.g., it is met in Paxos:</p>
<pre><code class="language-tla">  \E m \in msgs:
    /\ m.type = &quot;1a&quot;
    ...
  LET Q1b == { m \in msgs : m.type = &quot;1b&quot; /\ ... }
</code></pre>
<p>We introduce the operator <code>FilterByTag</code> that is a type-safe version of this
pattern:</p>
<pre><code class="language-tla">FilterByTag(Set, tag) == { e \in Set: e.tag = tag }
</code></pre>
<p>We introduce a special type inference rule for <code>FilterByTag</code>:</p>
<pre><code>set: Set(Variant(RowCons(&quot;&lt;TAG&gt;&quot;, r, z)))
------------------------------------------- [variant_filter]
FilterByTag(set, &quot;&lt;TAG&gt;&quot;): Set(r)
</code></pre>
<p>Importantly, <code>FilterByTag</code> returns a set of records that carry the tag <code>&lt;TAG&gt;</code>,
so we can access record fields of every individual record in the set.</p>
<p><strong>Match by tag.</strong> In rare cases, we do not have a set to filter. For instance,
we could have a sequence of log messages:</p>
<pre><code class="language-tla">VARIABLE
  \* @type: Seq([ tag: &quot;EventA&quot;, val: Int ] | [ tag: &quot;EventB&quot;, src: Str ]);
  log
</code></pre>
<p>In this case, we would not be able to easily use <code>FilterByTag</code>. Of course, we
could wrap a variant into a singleton set and then apply <code>FilterByTag</code> to it
and <code>CHOOSE</code> on top of it. However, this looks clunky and does not guarantee
type safety. A much simpler solution is to introduce another special operator:</p>
<pre><code class="language-tla">MatchTag(variant, tag, ThenOper(_), ElseOper(_)) ==
  \* fallback untyped implementation
  IF variant.tag = tag
  THEN ThenOper(variant)
  ELSE ElseOper(variant)
</code></pre>
<p>The idea of <code>MatchTag</code> is that it passes the extracted record to <code>ThenOper</code>,
when its tag value matches <code>tag</code>; otherwise, it passes the reduced variant to
<code>ElseOper</code>. This is precisely captured by the inference rule:</p>
<pre><code>variant: Variant(RowCons(&quot;&lt;TAG&gt;&quot;, r, t))
ThenOper: r =&gt; z
ElseOper: Variant(t) =&gt; z
------------------------------------------------ [variant_match]
MatchTag(variant, &quot;&lt;TAG&gt;&quot;, ThenOper, ElseOper):
  (Variant(RowCons(&quot;&lt;TAG&gt;&quot;, r, t)),
   Str,
   r =&gt; z,
   Variant(t) =&gt; z
  ) =&gt; z
</code></pre>
<p>The above rule looks menacing. Here is an example of matching a record
in the above example with the variable <code>log</code>:</p>
<pre><code class="language-tla">IsDefined(eventAOrB) ==
  LET ElseB(onlyB) ==
    MatchTag(onlyB, &quot;EventB&quot;, LAMBDA b: b.src /= &quot;&quot;, LAMBDA elseValue: FALSE)
  IN  
  MatchTag(event, &quot;EventA&quot;, LAMBDA a: a.val /= -1, ElseB)
</code></pre>
<p>The operator <code>ElseB</code> looks redundant, as we know that <code>onlyB</code> is a singleton
variant. To this end, we introduce the operator <code>MatchOnly</code>:</p>
<pre><code class="language-tla">MatchOnly(variant, ThenOper(_)) ==
  \* fallback untyped implementation
  ThenOper(variant)
</code></pre>
<p>For completeness, we give the inference rule for <code>MatchOnly</code>:</p>
<pre><code>variant: Variant(RowCons(&quot;&lt;TAG&gt;&quot;, r, RowNil))
ThenOper: r =&gt; z
------------------------------------------------ [variant_match_only]
MatchOnly(variant, ThenOper):
  (Variant(RowCons(&quot;&lt;TAG&gt;&quot;, r, RowNil)),
   r =&gt; z
  ) =&gt; z
</code></pre>
<p>It looks like the solution with <code>MatchTag</code> and <code>MatchOnly</code> introduce a lot of
boilerplate. However, this is probably the best solution that we can have,
unless we can extend the grammar of TLA+.</p>
<h3><a class="header" href="#53-changes-in-the-model-checker" id="53-changes-in-the-model-checker">5.3. Changes in the model checker</a></h3>
<p>Having precise types for variants, we have two options:</p>
<ol>
<li>
<p>Keep the current encoding, that is, a variant is encoded as a super-record
that contains all possible fields of the member records. The type checker
will guarantee that we do not access the fields of the super-record that are
not present in the actual record type.</p>
</li>
<li>
<p>Implement the
<a href="https://github.com/informalsystems/apalache/discussions/789#discussioncomment-1592118">suggestion by Shon Feder</a>.</p>
</li>
</ol>
<p>Although Option 2 looks nicer, we prefer keeping Option 1. The reason is that
the current implementation introduces the minimal number of constraints
by mashing all possible fields into a super-record. The alternative solution
(option 2) would introduce additional constraints, when the spec requires us
to extract an element from a set.</p>
<p>Recall the example with a set of messages:</p>
<pre><code class="language-tla">VARIABLES
  (*
    @typeAlias: MESSAGE =
       [ tag: &quot;1a&quot;, bal: Int ]
     | [ tag: &quot;2a&quot;, bal: Int, val: Int ]);
    @type: Set(MESSAGE);
   *)  
  msgs
</code></pre>
<p>Consider an existential quantifier over the variable <code>msgs</code>:</p>
<pre><code class="language-tla">Next ==
  \E m \in msgs:
    P
</code></pre>
<p>In the current encoding, <code>m</code> is a super-record that contains three fields:
<code>tag</code>, <code>bal</code>, and <code>val</code>, even if some of these fields are not required by the
actual type of <code>m</code>. In the alternative encoding, <code>m</code> is a tuple <code>tup</code>,
which equals to one of the following tuples, depending on the value of the
field <code>m.tag</code>:</p>
<pre><code>tup = IF m.tag = &quot;1a&quot;
      THEN &lt;&lt; { [ tag |-&gt; &quot;1a&quot;, bal |-&gt; b ] }, {} &gt;&gt;
      ELSE &lt;&lt; {}, [ tag |-&gt; &quot;2a&quot;, bal |-&gt; b, val |-&gt; v ] }, {} &gt;&gt;
</code></pre>
<p>Since it is impossible to statically compute the actual type of <code>m</code>, the
rewriting rules would have to replicate the structure of both elements of the
tuple <code>tup</code>. This would lead to a blow-up in the number of constraints.</p>
<h3><a class="header" href="#54-additional-requirements" id="54-additional-requirements">5.4. Additional requirements</a></h3>
<p>Given the decisions in Section 5.3, we additionally require that all records in
a variant type have compatible field types. In more detail, if a variant type
contains two record types <code>[ tag: &quot;A&quot;, value: a, ... ]</code> and <code>[ tag: &quot;B&quot;, value: b, ...]</code>, then the types <code>a</code> and <code>b</code> must be unifiable.  In practice, this
often implies that <code>a</code> and <code>b</code> are simply the same type.</p>
<h3><a class="header" href="#55-the-variants-module" id="55-the-variants-module">5.5. The Variants module</a></h3>
<p>We introduce a new module that is called <code>Variants.tla</code>. It contains the
operators <code>Variant</code>, <code>FilterByTag</code>, <code>MatchTag</code>, and <code>MatchOnly</code>. This module
will be distributed with Apalache. As is custom in the TLA+ community, the
users should be also able to copy <code>Variants.tla</code> next to their specification.</p>
<h2><a class="header" href="#6-consequences" id="6-consequences">6. Consequences</a></h2>
<p>This will be a relatively big change in the types and the type checker.
Additionally, it would render many existing specifications ill-typed, as the
proposed solution imposes a stricter typing discipline. On the positive, the
proposed solution is backwards-compatible with TLC, as we are proposing the
default untyped implementation for the operators.</p>
<h1><a class="header" href="#adr-015-informal-trace-format-in-json" id="adr-015-informal-trace-format-in-json">ADR-015: Informal Trace Format in JSON</a></h1>
<table><thead><tr><th>authors</th><th>proposed by</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td>Vitor Enes, Andrey Kupriyanov</td><td align="right">2023-09-14</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/015adr-trace.html#summary">Summary (Overview)</a></li>
<li><a href="adr/015adr-trace.html#context">Context (Problem)</a></li>
<li><a href="adr/015adr-trace.html#options">Options (Alternatives)</a></li>
<li><a href="adr/015adr-trace.html#solution">Solution (Decision)</a></li>
<li><a href="adr/015adr-trace.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>We propose a simple format for counterexamples (traces) in <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>. Although
Apalache already supports serialization to <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> in <a href="https://apalache.informal.systems/docs/adr/005adr-json.html">ADR005</a>, it is a
general serialization format for all the constructs of TLA+ that are supported
by Apalache. This makes tool integration harder. It also make it hard to
communicate counterexamples to engineers who are not familiar with TLA+. This
ADR-015 contains a very simple format that does not require any knowledge of
TLA+ and can be easily integrated into other tools.</p>
<h2><a class="header" href="#revisions" id="revisions">Revisions</a></h2>
<p><strong>Rev. 2023-09-14.</strong> Each integer value <code>num</code> is now represented as <code>{ #bigint: &quot;num&quot; }</code>.
The use of JSON numbers is not allowed anymore. This simplifies custom parsers for ITF,
see <a href="adr/015adr-trace.html#consequences">Consequences</a>.</p>
<h2><a class="header" href="#context-2" id="context-2">Context</a></h2>
<p>A TLA+ execution (called a behavior in TLA+) is a very powerful concept. It can
represent virtually any execution of a state machine, including sequential
programs, concurrent programs, and distributed systems. Counterexamples that
are produced by TLC and Apalache are just executions of a TLA+ state machine.
These counterexamples have two shapes:</p>
<ol>
<li>
<p>A <em>finite execution</em>, that is, a sequence of states.</p>
</li>
<li>
<p>A <em>lasso execution</em>, that is, a finite sequence of states (prefix) followed
by an infinitely repeated sequence of states (loop). Any infinite execution of
a <em>finite-state system</em> can be represented by a lasso.  (In general, executions
of infinite-state systems cannot be represented by lassos.)</p>
</li>
</ol>
<p>Although the concept of an execution in TLA+ is quite simple, it builds upon
the vocabulary of TLA+. Moreover, TLA+ counterexamples are using the expression
language of TLA+.</p>
<p>To illustrate the problem, consider a very simple TLA+ specification of the
MissionariesAndCannibals puzzle (specified by Leslie Lamport). We use a typed
version of this specification, see <a href="https://github.com/informalsystems/apalache/blob/main/test/tla/MissionariesAndCannibalsTyped.tla">MissionariesAndCannibalsTyped</a>. Consider
the following instance of the specification:</p>
<pre><code class="language-tla">------------------- MODULE MC_MissionariesAndCannibalsTyped -----------------    
Missionaries == { &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }
Cannibals == { &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot; }

VARIABLES
    \* @type: Str;
    bank_of_boat,
    \* @type: Str -&gt; Set(PERSON);
    who_is_on_bank

INSTANCE MissionariesAndCannibalsTyped

NoSolution ==
    who_is_on_bank[&quot;E&quot;] /= {}
=============================================================================
</code></pre>
<p>By checking the invariant <code>NoSolution</code>, we obtain the following counterexample
in TLA+:</p>
<pre><code class="language-tla">---------------------------- MODULE counterexample ----------------------------

EXTENDS MC_MissionariesAndCannibalsTyped

(* Constant initialization state *)
ConstInit == TRUE

(* Initial state *)
State0 ==
  bank_of_boat = &quot;E&quot;
    /\ who_is_on_bank
      = &quot;E&quot;
          :&gt; { &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }
        @@ &quot;W&quot; :&gt; {}

(* Transition 0 to State1 *)
State1 ==
  bank_of_boat = &quot;W&quot;
    /\ who_is_on_bank
      = &quot;E&quot; :&gt; { &quot;c1_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot; }
        @@ &quot;W&quot; :&gt; { &quot;c2_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }

(* Transition 0 to State2 *)
State2 ==
  bank_of_boat = &quot;E&quot;
    /\ who_is_on_bank
      = &quot;E&quot; :&gt; { &quot;c1_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }
        @@ &quot;W&quot; :&gt; {&quot;c2_OF_PERSON&quot;}

(* Transition 0 to State3 *)
State3 ==
  bank_of_boat = &quot;W&quot;
    /\ who_is_on_bank
      = &quot;E&quot; :&gt; {&quot;c1_OF_PERSON&quot;}
        @@ &quot;W&quot; :&gt; { &quot;c2_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }

(* Transition 0 to State4 *)
State4 ==
  bank_of_boat = &quot;E&quot;
    /\ who_is_on_bank
      = &quot;E&quot; :&gt; { &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot; }
        @@ &quot;W&quot; :&gt; { &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }

(* Transition 0 to State5 *)
State5 ==
  bank_of_boat = &quot;W&quot;
    /\ who_is_on_bank
      = &quot;E&quot; :&gt; {}
        @@ &quot;W&quot;
          :&gt; { &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; }

(* The following formula holds true in the last state and violates the invariant *)
InvariantViolation == who_is_on_bank[&quot;E&quot;] = {}

================================================================================
(* Created by Apalache on Wed Dec 22 09:18:50 CET 2021 *)
(* https://github.com/informalsystems/apalache *)
</code></pre>
<p>The above counterexample looks very simple and natural, if the reader knows
TLA+. In our experience, these examples look alien to engineers, who are not
familiar with TLA+. It is unfortunate, since the counterexamples have a very
simple shape:</p>
<ol>
<li>
<p>They are simply sequences of states.</p>
</li>
<li>
<p>Every state is a mapping from variable names to expressions that do not
refer to other variables.</p>
</li>
<li>
<p>The expressions are using a very small subset of TLA operators:</p>
</li>
<li>
<p>Integer and string literals.</p>
</li>
<li>
<p>Set constructor, sequence/tuple constructor, record constructor.</p>
</li>
<li>
<p>TLC operators over functions: <code>:&gt;</code> and <code>@@</code>.</p>
</li>
</ol>
<p>In hindsight, the above expressions are not very far from the JSON format.
As many engineers know <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, it seems natural to write these counterexamples
in JSON.</p>
<h2><a class="header" href="#options-2" id="options-2">Options</a></h2>
<ol>
<li>
<p>Use the TLA+ format:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>easy to understand, if you know TLA+.</li>
<li>it looks amazing in PDF.</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>quite hard to understand, if you don't know TLA+.</li>
<li>quite hard to parse automatically.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Use the JSON serialization as in <a href="https://apalache.informal.systems/docs/adr/005adr-json.html">ADR005</a>:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>easy to parse automatically.</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>almost impossible to read.</li>
<li>too detailed and too verbose.</li>
<li>requires the knowledge of Apalache IR and of TLA+.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Use the Informal Trace Format, which is proposed in this ADR:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>almost no introduction is required to read the traces.</li>
<li>relatively compact.</li>
<li>easy to parse automatically.</li>
<li>uses the idioms that are understood by the engineers.</li>
<li>not bound to TLA+.</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>consistency of the format is in conflict with the ease of writing.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#solution-2" id="solution-2">Solution</a></h2>
<p>In this ADR, we propose a very simple format that represents executions of
state machines that follows the concepts of TLA+ and yet avoids complexity of
TLA+. It is so simple that we call it <em>&quot;Informal Trace Format&quot;</em> (ITF).
(Obviously, it is formal enough to be machine-readable).  By convention, the
files in this format should end with the extension <code>.itf.json</code>.</p>
<h3><a class="header" href="#the-itf-format" id="the-itf-format">The ITF Format</a></h3>
<p><strong>Trace object</strong>. A trace in ITF is a JSON object:</p>
<pre><code class="language-js">{
  &quot;#meta&quot;: &lt;optional object&gt;,
  &quot;params&quot;: &lt;optional array of strings&gt;,
  &quot;vars&quot;:  &lt;array of strings&gt;,
  &quot;states&quot;: &lt;array of states&gt;,
  &quot;loop&quot;: &lt;optional int&gt;
}
</code></pre>
<p>The field <code>#meta</code> is an arbitrary JSON object, whose purpose is to provide
the reader with additional comments about the trace. For example, it may look
like:</p>
<pre><code class="language-js">  &quot;#meta&quot;: {
    &quot;description&quot;: &quot;Generated by Apalache&quot;,
    &quot;source&quot;: &quot;MissionariesAndCannibalsTyped.tla&quot;
  }
</code></pre>
<p>The optional field <code>params</code> is an array of names that must be set in the
initial state (if there are any parameters). The parameters play the same role
as <code>CONSTANTS</code> in TLA+. For example, the field may look like:</p>
<pre><code class="language-js">  &quot;params&quot;: [ &quot;Missionaries&quot;, &quot;Cannibals&quot; ]
</code></pre>
<p>The field <code>vars</code> is an array of names that must be set in every state.
For example, the field may look like:</p>
<pre><code class="language-js">  &quot;vars&quot;: [ &quot;bank_of_boat&quot;, &quot;who_is_on_bank&quot; ]
</code></pre>
<p>The field <code>states</code> is an array of state objects (see below). For example,
the field may look like:</p>
<pre><code class="language-js">  &quot;states&quot;: [ &lt;state0&gt;, &lt;state1&gt;, &lt;state2&gt; ]
</code></pre>
<p>The optional field <code>loop</code> specifies the index of the state (in the array of
states) that starts the loop. The loop ends in the last state. For example,
the field may look like:</p>
<pre><code class="language-js">  &quot;loop&quot;: 1
</code></pre>
<p><strong>State object</strong>. A state is a JSON object:</p>
<pre><code class="language-js">  {
    &quot;#meta&quot;: &lt;optional object&gt;,
    &quot;&lt;var1&gt;&quot;: &lt;expr&gt;,
    ...
    &quot;&lt;varN&gt;&quot;: &lt;expr&gt;
  }
</code></pre>
<p>As in the trace object, the field <code>#meta</code> may be an arbitrary object.
Different tools may use this object to write their metadata into this object.</p>
<p>The names <code>&lt;var1&gt;, ..., &lt;varN&gt;</code> are the names of the variables that are
specified in the field <code>vars</code>. Each state must define a value for every specified variable. The syntax of <code>&lt;expr&gt;</code> is specified below. </p>
<p><strong>Expressions.</strong> As usual, expressions are inductively defined. An expression
<code>&lt;expr&gt;</code> is one of the following:</p>
<ol>
<li>
<p>A JSON Boolean: either <code>false</code> or <code>true</code>.</p>
</li>
<li>
<p>A JSON string literal, e.g., <code>&quot;hello&quot;</code>. TLA+ strings are written as strings in this format.</p>
</li>
<li>
<p>A big integer of the following form: <code>{ &quot;#bigint&quot;: &quot;[-][0-9]+&quot; }</code>. We are using this format, as many JSON parsers
impose limits on integer values, see <a href="https://datatracker.ietf.org/doc/html/rfc7159.html">RFC7159</a>. Big and small integers <em>must be</em>
written in this format.</p>
</li>
<li>
<p>A list of the form <code>[ &lt;expr&gt;, ..., &lt;expr&gt; ]</code>. A list is just a JSON array. TLA+ sequences are written as lists in this format.</p>
</li>
<li>
<p>A record of the form <code>{ &quot;field1&quot;: &lt;expr&gt;, ..., &quot;fieldN&quot;: &lt;expr&gt; }</code>. A record is just a JSON object. Field names should not start with <code>#</code>
and hence should not pose any collision with other constructs. TLA+ records are written as records in this format.</p>
</li>
<li>
<p>A tuple of the form <code>{ &quot;#tup&quot;: [ &lt;expr&gt;, ..., &lt;expr&gt; ] }</code>. There is no strict rule about when to use sequences or tuples. Apalache differentiates
between tuples and sequences, and it may produce both forms of expressions.</p>
</li>
<li>
<p>A set of the form <code>{ &quot;#set&quot;: [ &lt;expr&gt;, ..., &lt;expr&gt; ] }</code>. A set is different from a list in that it does not assume any ordering of its elements. However,
it is only a syntax form in our format. Apalache distinguishes between sets and lists and thus it will output sets in the set form. Other tools may
interpret sets as lists.</p>
</li>
<li>
<p>A map of the form <code>{ &quot;#map&quot;: [ [ &lt;expr&gt;, &lt;expr&gt; ], ..., [ &lt;expr&gt;, &lt;expr&gt; ] ] }</code>. That is, a map holds a JSON array of two-element arrays. Each two-element array <code>p</code> is interpreted as follows: <code>p[0]</code> is the map key and
<code>p[1]</code> is the map value. Importantly, a key may be an arbitrary expression. It does not have to be a string or an integer. TLA+ functions are written as maps
in this format.</p>
</li>
<li>
<p>An expression that cannot be serialized: <code>{ &quot;#unserializable&quot;: &quot;&lt;string representation&gt;&quot; }</code>. For instance, the set of all integers is represented with
<code>{ &quot;#unserializable&quot;: &quot;Int&quot; }</code>. This should be a very rare expression, which
should not occur in normal traces. Usually, it indicates some form of an
error.</p>
</li>
</ol>
<h3><a class="header" href="#itf-as-input-to-apalache" id="itf-as-input-to-apalache">ITF as input to Apalache</a></h3>
<p>To be able to read ITF traces, Apalache demands the following:</p>
<ul>
<li>The <code>#meta</code> field must be present</li>
<li>The <code>#meta</code> field must contain a field <code>varTypes</code>, which is an object, the keys of which are the variables declared in <code>vars</code>, and the values are string representations of their types (as defined in <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR002</a>).</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">&quot;#meta&quot;: {
  &quot;varTypes&quot;: { 
    &quot;bank_of_boat&quot;: &quot;Str&quot;, 
    &quot;who_is_on_bank&quot;: &quot;Str -&gt; Set(PERSON)&quot; 
  }
}
</code></pre>
<h3><a class="header" href="#example-4" id="example-4">Example</a></h3>
<p>The counterexample to <code>NoSolution</code> may be written in the ITF format as follows:</p>
<pre><code class="language-json">{
  &quot;#meta&quot;: {
    &quot;source&quot;: &quot;MC_MissionariesAndCannibalsTyped.tla&quot;,
    &quot;varTypes&quot;: { 
      &quot;bank_of_boat&quot;: &quot;Str&quot;, 
      &quot;who_is_on_bank&quot;: &quot;Str -&gt; Set(PERSON)&quot; 
    }
  },
  &quot;vars&quot;: [ &quot;bank_of_boat&quot;, &quot;who_is_on_bank&quot; ],
  &quot;states&quot;: [
    {
      &quot;#meta&quot;: { &quot;index&quot;: 0 },
      &quot;bank_of_boat&quot;: &quot;E&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot;,
                             &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [] } ]
        ]  
      }
    },
    {
      &quot;#meta&quot;: { &quot;index&quot;: 1 },
      &quot;bank_of_boat&quot;: &quot;W&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot; ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [ &quot;c2_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ]
        ]  
      }
    },
    {
      &quot;#meta&quot;: { &quot;index&quot;: 2 },
      &quot;bank_of_boat&quot;: &quot;E&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot;,
                             &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [ &quot;c2_OF_PERSON&quot; ] } ]
        ]  
      }
    },
    {
      &quot;#meta&quot;: { &quot;index&quot;: 3 },
      &quot;bank_of_boat&quot;: &quot;W&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot; ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [ &quot;c2_OF_PERSON&quot;, &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ]
        ]  
      }
    },
    {
      &quot;#meta&quot;: { &quot;index&quot;: 4 },
      &quot;bank_of_boat&quot;: &quot;E&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot; ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [ &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ]
        ]  
      }
    },
    {
      &quot;#meta&quot;: { &quot;index&quot;: 5 },
      &quot;bank_of_boat&quot;: &quot;W&quot;,
      &quot;who_is_on_bank&quot;: {
        &quot;#map&quot;: [
          [ &quot;E&quot;, { &quot;#set&quot;: [ ] } ],
          [ &quot;W&quot;, { &quot;#set&quot;: [ &quot;c1_OF_PERSON&quot;, &quot;c2_OF_PERSON&quot;,
                             &quot;m1_OF_PERSON&quot;, &quot;m2_OF_PERSON&quot; ] } ]
        ]  
      }
    }
  ]
}
</code></pre>
<p>Compare the above trace format with the TLA+ counterexample. The TLA+ example
looks more compact. The ITF example is heavier on the brackets and braces, but
it is also designed with machine-readability and tool automation in mind,
whereas TLA+ counterexamples are not.  However, the example in the ITF format
is also self-explanatory and does not require any understanding of TLA+.</p>
<p>Note that we did not output the operator <code>InvariantViolation</code> of the TLA+
example. This operator is simply not a part of the trace. It could be added in
the <code>#meta</code> object by Apalache.</p>
<h3><a class="header" href="#discussion-2" id="discussion-2">Discussion</a></h3>
<p>Shon Feder @shonfeder flagged important concerns about irregularity of the
proposed format in the <a href="https://github.com/informalsystems/apalache/pull/1190">PR
comments</a>. In a
regular approach we would treat all expressions uniformly. For example:</p>
<pre><code class="language-json">// proposed form:
&quot;hello&quot;
// regular form:
{ &quot;#type&quot;: &quot;string&quot;, &quot;#value&quot;: &quot;hello&quot; }

// proposed form:
{ &quot;#set&quot;: [ 1, 2, 3] }
// regular form:
{ 
  &quot;#type&quot;: &quot;set&quot;,
  &quot;#value&quot;: [
    { &quot;#type&quot;: &quot;int&quot;, &quot;#value&quot;: &quot;1&quot; },
    { &quot;#type&quot;: &quot;int&quot;, &quot;#value&quot;: &quot;2&quot; },
    { &quot;#type&quot;: &quot;int&quot;, &quot;#value&quot;: &quot;3&quot; }
  ]
}
</code></pre>
<p>The more regular approach is less concise. In the future, we might want to add
a flag that lets the user choose between the regular output and the output
proposed in this ADR, which is more ad hoc.</p>
<p>Another suggestion is to use <a href="https://cswr.github.io/JsonSchema/#what-is-json-schema?">JSON
schema</a>.  For the
moment, it seems to be a heavy-weight solution with no obvious value.  However,
we should keep it in mind and use schemas, when the need arises.</p>
<h2><a class="header" href="#consequences-2" id="consequences-2">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>We have found that the ITF format is easy to produce and relatively easy to parse.</p>
<p><strong>Ambiguity in the representation of integers</strong>. As it was brought up in the initial
discussions, the choice between representing integers
as JSON numbers, e.g., <code>123</code> and objects, e.g., <code>{ #bigint: &quot;123&quot; }</code>, makes it harder to
write a parser of custom ITF traces. Hence, we have decided to keep only the object format,
as the more general of the two representations. </p>
<h1><a class="header" href="#adr-16-retla---relational-tla" id="adr-16-retla---relational-tla">ADR-16: ReTLA - Relational TLA</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/016adr-retla.html#summary">Summary (Overview)</a></li>
<li><a href="adr/016adr-retla.html#context">Context (Problem)</a></li>
<li><a href="adr/016adr-retla.html#options">Options (Alternatives)</a></li>
<li><a href="adr/016adr-retla.html#solution">Solution (Decision)</a></li>
<li><a href="adr/016adr-retla.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<!--
  In the context of (use case)\
facing (concern)\
we decided for (option)\
to achieve (quality)\
accepting (downside).\
-->
<p>We propose introducing support for a severely restricted fragment of TLA+, named Relational TLA (reTLA for short), which covers uninterpreted first-order logic. The simplicity of this fragment should allow Apalache to use a more straightforward encoding, both in SMT, as well as potentially in languages suited for alternative backend solvers. </p>
<p>Running Apalache with this encoding would skip the model-checking pass and instead produce a standalone file containing all of the generated constraints, which could be consumed by other tools.</p>
<h2><a class="header" href="#context-3" id="context-3">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>Apalache currently supports almost the full suite of TLA+ operators. Consequently, the standard encoding of TLA+ into SMT is very general, and a lot of effort is spent on encoding data structures, such as sets or records, and their evolution across the states. Additionally, we need to track arenas; bookkeeping auxiliary constructions, which are a byproduct of our encoding approach, not TLA+ logic itself.</p>
<p>However, it is often the case that, with significant effort on the part of the specification author, expressions can be rewritten in a way that avoids using the more complex structures of TLA+. For example, consider the following snippet of a message-passing system:</p>
<pre><code class="language-tla">CONSTANT Values
VARIABLE messages

SendT1(v) == messages \union { [ type |-&gt; &quot;t1&quot;, x |-&gt; v ] }

ReadT1 == 
  \E msg \in messages:
    /\ msg.type = &quot;t1&quot;
    /\ F(msg.x) \* some action

Next ==
  \/ \E v \in Values: SendT1(v)
  \/ ReadT1
</code></pre>
<p>The central object is the set <code>messages</code>, which is modified at each step, and contains records. This makes it one of the more expensive expressions, in terms of the underlying SMT encodings in Apalache. However, as far as the use of <code>messages</code> goes, there is a major insight to be had: <em>it is not necessary to model <code>messages</code> explicitly for <code>ReadT1</code>, we only need to specify the property that certain messages of type &quot;t1&quot; with given payloads have been sent</em>. Naturally, modeling <code>messages</code> explicitly is <em>sufficient</em> for this purpose, but if one wanted to avoid the use of sets and records, one could write the following specification instead:</p>
<pre><code class="language-tla">CONSTANT Values
VARIABLE T1messages

SendT1(v) == [T1messages EXCEPT ![v] = TRUE]

ReadT1 ==
  \E v \in Values:
    /\ T1messages[v]
    /\ F(v) \* some action

Next ==
  \/ \E v \in Values: SendT1(v)
  \/ ReadT1
</code></pre>
<p>By encoding, for example, set membership checks as predicate evaluations, one can write some specifications in a fragment of TLA+ that avoids all complex data structures, sets-of-sets, records, sequences, and so on, and replaces them with predicates (functions).
Rewriting specifications in this way is nontrivial, and shouldn't be expected of engineers, however, should a specification author undertake such a transformation, we should be able to provide some payoff.
If we only limit ourselves to specifications in this restricted fragment (defined explicitly below), the current SMT encoding is needlessly complex. 
We can implement a specialized encoding, which does not use arena logic of any kind, but is much more direct and even lends itself well to multiple kinds of solvers (e.g. IVy or VMT, in addition to standard SMT).</p>
<h2><a class="header" href="#options-3" id="options-3">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<ol>
<li>
<p>Reuse most of the existing implementation and encoding, with a modified language watchdog, then output an SMT file from the context, instead of solving.</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>Little work</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>Locked to the SMT format</li>
<li>Unnecessary additional SMT constraints produced</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Write custom rewriting rules that generate constraints symbolically</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>Fewer constraints</li>
<li>Higher level of abstraction</li>
<li>Can support multiple output formats</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>More work</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#solution-3" id="solution-3">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>We propose option (2), and give the following categorization of the reTLA fragment:</p>
<ul>
<li>Boolean, integer and uninterpreted literals (including strings)</li>
<li>Restricted sets: 
<ul>
<li><code>Int</code>, <code>Nat</code> or <code>BOOLEAN</code>, or </li>
<li><code>CONSTANT</code>-declared and has a type <code>Set(T)</code>, for some uninterpreted type <code>T</code>, or</li>
</ul>
</li>
<li>Boolean operators (<code>/\, \/, =&gt;, &lt;=&gt;, ~</code>)</li>
<li>Quantified expressions (<code>\E x \in S: P, \A x \in S: P</code>), on the condition that <code>P</code> is in reTLA and <code>S</code> is a restricted set.</li>
<li>Functions:
<ul>
<li>Definitions (<code>[x1 \in S1, ..., xn \in Sn |-&gt; e]</code>), on the condition that:
<ul>
<li><code>e</code> is in reTLA and has an <code>Int</code>, <code>Bool</code> or uninterpreted type</li>
<li>All <code>Si</code> are restricted sets.</li>
</ul>
</li>
<li>Updates (<code>[f EXCEPT ![x] = y]</code>), if <code>y</code> is in reTLA</li>
<li>Applications (<code>f[x]</code>)</li>
</ul>
</li>
<li>(In)equality and assignments:
<ul>
<li><code>a = b</code> and <code>a /= b</code> if both <code>a</code> and <code>b</code> are in reTLA</li>
<li><code>x' = v</code> if <code>x</code> is a <code>VARIABLE</code> and <code>v</code> is in reTLA</li>
</ul>
</li>
<li>Control flow:
<ul>
<li><code>IF p THEN a ELSE b</code> if <code>p,a,b</code> are all in reTLA</li>
</ul>
</li>
</ul>
<p>In potential future versions we are likely to also support: </p>
<ul>
<li>Standard integer operators (<code>+, -, u-, *, %, &lt;, &gt;, &lt;=, &gt;=</code>)</li>
<li>ranges <code>a..b</code>, where both <code>a</code> and <code>b</code> are in reTLA.</li>
<li>Tuples</li>
</ul>
<h2><a class="header" href="#consequences-3" id="consequences-3">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>Reserved for the future.</p>
<h1><a class="header" href="#pdr-017-checking-temporal-properties" id="pdr-017-checking-temporal-properties">PDR-017: Checking temporal properties</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Igor Konnov, Philip Offtermatt</td><td align="right">2022-04-01</td></tr>
</tbody></table>
<p><strong>This is a preliminary design document. It will be refined and it will mature
into an ADR later.</strong></p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/017pdr-temporal.html#summary">Summary (Overview)</a></li>
<li><a href="adr/017pdr-temporal.html#context">Context (Problem)</a></li>
<li><a href="adr/017pdr-temporal.html#options">Options (Alternatives)</a></li>
<li><a href="adr/017pdr-temporal.html#solution">Solution (Decision)</a></li>
<li><a href="adr/017pdr-temporal.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-4" id="summary-4">Summary</a></h2>
<p>The &quot;TLA&quot; in TLA+ stands for <em>Temporal Logic of Actions</em>, whereas the plus sign
(+) stands for the rich syntax of this logic. So far, we have been focusing on
the <em>plus</em> of TLA+ in Apalache. Indeed, the repository of <a href="https://github.com/tlaplus/Examples">TLA+ Examples</a>
contains a few occurrences of temporal properties.</p>
<p>In this PDR, we lay out a plan for implementing support for model checking
of temporal properties in Apalache.</p>
<h2><a class="header" href="#context-4" id="context-4">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>Apalache supports checking of several kinds of invariants: <a href="adr/../apalache/principles/invariants.html">state, action, and
trace invariants</a>. Some of the TLA+ users do not want to be limited by
invariants, but want to write temporal properties, which let them express
safety and liveness more naturally. A detailed description of temporal
properties can be found in <a href="https://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a> (Sections 16.2.3-4). In
short, temporal formulas are Boolean combinations of the following kinds of
subformulas:</p>
<ul>
<li>
<p><strong>State predicates</strong>:</p>
<ul>
<li>Boolean formulas that do not contain primes.</li>
</ul>
</li>
<li>
<p><strong>Action predicates</strong>:</p>
<ul>
<li>
<p>Stutter <code>A</code>: <code>[A]_e</code>, for an action formula <code>A</code>
and an expression <code>e</code> (usually a tuple of variables).
This predicate is equivalent to <code>A \/ e' = e</code>.</p>
</li>
<li>
<p>No-stutter <code>A</code>: <code>&lt;A&gt;_e</code>, for an action formula <code>A</code>
and an expression <code>e</code>, which is equivalent to <code>A /\ e' /= e</code>.</p>
</li>
<li>
<p><code>ENABLED A</code>, for an action formula <code>A</code>, is true in a state <code>s</code> if
there is a state <code>t</code> such that <code>s</code> is transformed to <code>t</code> via action <code>A</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Temporal formulas</strong>:</p>
<ul>
<li>
<p>Eventually: <code>&lt;&gt;F</code>, for a temporal formula <code>F</code>.</p>
</li>
<li>
<p>Always: <code>[]F</code>, for a temporal formula <code>F</code>.</p>
</li>
<li>
<p>Weak fairness: <code>WF_e(A)</code>, for an expression <code>e</code> and a formula <code>F</code>,
which is equivalent to <code>[]&lt;&gt;~(ENABLED &lt;A&gt;_e) \/ []&lt;&gt;&lt;A&gt;_e</code>.</p>
</li>
<li>
<p>Strong fairness: <code>SF_e(A)</code>, for an expression <code>e</code> and a formula <code>F</code>,
which is equivalent to <code>&lt;&gt;[]~(ENABLED &lt;A&gt;_e) \/ []&lt;&gt;&lt;A&gt;_e</code>.</p>
</li>
<li>
<p>Leads-to: <code>F ~&gt; G</code>, which is equivalent to <code>[](F =&gt; &lt;&gt;G)</code>.</p>
</li>
</ul>
</li>
</ul>
<p>Technically, TLA+ also contains four other operators that are related to
temporal properties: <code>A \cdot B</code>, <code>\EE x: F</code>, <code>\AA x: F</code>, and <code>F -+-&gt; G</code>. These
very advanced operators appear so rarely that we ignore them in this work.
Most likely, For their semantics, check <a href="https://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a> (Section
16.2.3-4).</p>
<h2><a class="header" href="#design-space" id="design-space">Design space</a></h2>
<p>SAT encodings of bounded model checking for LTL are a textbook material. A
linear encoding for LTL is presented in the paper <a href="https://lmcs.episciences.org/2236">Biere et al. 2006</a>. It is
explained in <a href="https://ebooks.iospress.nl/publication/4999">Handbook of Satisfiability</a> (Chapter 14). Hence, we do not have
to do much research around this. However, we have to adapt the standard
techniques to the domain of TLA+. For instance, we have to understand how to
deal with <code>ENABLED</code>, <code>WF</code>, and <code>SF</code>, which deviate from the standard setting of
model checking.</p>
<p>Viktor Sergeev wrote the <a href="https://github.com/informalsystems/apalache/tree/feature/liveness">first prototype</a> for liveness checking at
University of Lorraine in 2019. Since his implementation was tightly integrated
with the exploration algorithm, which was refactored several times, this
implementation has not been integrated in the main branch. We have learned from
this prototype and discuss our options under this angle.</p>
<p>There are two principally different approaches to the implementation of
temporal model checking:</p>
<ol>
<li>
<p>Tight integration with <a href="adr/./003adr-trex.html">Transition Executor</a>.</p>
<p>In this approach, we would extend the transition executor to incrementally
check LTL properties via the encoding by <a href="https://lmcs.episciences.org/2236">Biere et al. 2006</a>. This
approach would let us implement various optimizations. However, it would be
harder to maintain and adapt, as we have seen from the first prototype.</p>
</li>
<li>
<p>Specification preprocessing.</p>
<p>In this approach, given a specification <code>S</code> and a temporal property <code>P</code>, we
would produce another specification <code>S_P</code> and an invariant <code>I_P</code> that has
the following property: the temporal property <code>P</code> holds on specification
<code>S</code> if and only if the invariant <code>I_P</code> holds on specification <code>S_P</code>.  In
this approach, we encode the constraints by <a href="https://lmcs.episciences.org/2236">Biere et al. 2006</a> directly
in TLA+. The potential downside of this approach is that it may be less
efficient than the tight integration with the transition executor.</p>
</li>
</ol>
<p>We choose the second approach via specification preprocessing. This will
simplify maintenance of the codebase. Additionally, the users will be able to
see the result of preprocessing and optimize it, if needed. When the new
implementation is well understood, we can revisit it and consider Option 1,
once <a href="adr/./010rfc-transition-explorer.html">ADR-010</a> is implemented.</p>
<h2><a class="header" href="#work-plan" id="work-plan">Work plan</a></h2>
<p>The work plan is tracked in the <a href="https://github.com/informalsystems/apalache/issues/488">issue on temporal properties</a>.</p>
<p>We propose to split this work into two big subtasks:</p>
<ul>
<li>
<p><em>Task 1. Temporal operators</em>:
Support for <code>&lt;&gt;P</code>, <code>[]P</code>, <code>&lt;A&gt;_e</code>, and <code>[A]_e</code> via preprocessing.</p>
</li>
<li>
<p><em>Task 2. Fairness</em>:
Support for <code>ENABLED A</code>, <code>WF_e(A)</code>, and <code>SF_e(A)</code> via preprocessing.</p>
</li>
</ul>
<p>The task on <em>Temporal operators</em> is well-understood and poses no technical
risk. By having solved Task 1, we can give users a relatively complete toolset
for safety and liveness checking. Indeed, even fairness properties can be
expressed via <code>&lt;&gt;</code> and <code>[]</code>.</p>
<p>To support temporal reasoning as it was designed by Leslie Lamport, we have to
solve Task 2. Most likely, we will have to introduce additional assumptions
about specifications to solve it.</p>
<h3><a class="header" href="#1-temporal-operators" id="1-temporal-operators">1. Temporal operators</a></h3>
<p>This task boils down to the implementation of the encoding explained in <a href="https://lmcs.episciences.org/2236">Biere
et al. 2006</a>.</p>
<p>In model checking of temporal properties, special attention is paid to lasso
executions. A <em>lasso</em> execution is a sequence of states <code>s[0], s[1], ..., s[l], ..., s[k]</code> that has the following properties:</p>
<ul>
<li>the initial state <code>s[0]</code> satisfies <code>Init</code>,</li>
<li>every pair of states <code>s[i]</code> and <code>s[i+1]</code> satisfies <code>Next</code>, for <code>i \in 0..k-1</code>,
and</li>
<li>the loop closes at index <code>l</code>, that is, <code>s[l] = s[k]</code>.</li>
</ul>
<p>The lasso executions play an important role in model checking, due to the lasso
property of finite-state systems:</p>
<pre><code>Whenever a finite-state transition system `M` violates a temporal property
`F`, this system has a lasso execution that violates `F`.
</code></pre>
<p>You can find a proof in the book on <a href="https://mitpress.mit.edu/books/model-checking-second-edition">Model Checking</a>. As a result, we can
focus on finding a lasso as a counterexample to the temporal property.
Importantly, this property holds only for finite-state systems. For example, if
all variable domains are finite (and bounded), then the specification is
finite-state. However, if a specification contains integer variables, it may
produce infinitely many states. That is, an infinite-state system may still
contain lassos as counterexamples but it does not have to, which makes this
technique incomplete. An extension to infinite-state systems was studied by
<a href="https://link.springer.com/article/10.1007/s10703-021-00377-1">Padon et al. 2021</a>. This is beyond the scope of this task.</p>
<p>There are multiple ways to encode the constraints by <a href="https://lmcs.episciences.org/2236">Biere et al. 2006</a>.
The different ways are demonstrated on the <a href="adr/EWD998.tla">EWD998</a> spec,
which specifies a protocol for termination detection,
using token passing in a ring.</p>
<h4><a class="header" href="#trace-invariants-1" id="trace-invariants-1"><strong>Trace Invariants</strong></a></h4>
<p>The lasso finding problem can be encoded as a <a href="adr/../apalache/principles/invariants.html#trace-invariants">trace invariants</a>. See e.g. the <a href="adr/EWD998_trace.tla">EWD998 protocol with trace invariants</a>.
Roughly, a loop is encoded by demanding there exists a loop index at which point the state is identical to the state at the end of the execution.</p>
<p>Implementation details:</p>
<ul>
<li>Instead of quantifying over indices, one could use an additional Boolean variable starting out FALSE that nondeterministically guesses when the execution enters the loop and is set to TRUE at that point. Experiments suggest this negatively impacts performance, but it can help understand counterexamples, since the loop is immediately visible in the states.</li>
</ul>
<p>Advantages:</p>
<ul>
<li>The predicate in the spec is very close to the semantic meaning of the temporal operators, e.g. <code>[] x &gt;= 2</code> becomes <code>\A step \in DOMAIN hist: hist[step].x &gt;= 2</code></li>
<li>Only very few new variables are added (none, but depending on implementation choices maybe one/two).</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>
<p>Trace invariants require Apalache to pack the sequence of states.
This sometimes produces unnecessary constraints.</p>
</li>
<li>
<p>When a trace invariant is violated, the intermediate definitions
in this invariant are not printed in the counterexample.
This will make printing of the counterexamples to liveness harder, e.g. see an <a href="adr/counterexample_trace.tla#L118">example</a></p>
</li>
</ul>
<h4><a class="header" href="#encoding-with-auxiliary-variables" id="encoding-with-auxiliary-variables"><strong>Encoding with auxiliary variables</strong></a></h4>
<p>The loop finding problem can alternatively be approached
by adding extra variables: One variable <code>InLoop</code> which
determines whether the execution is currently on the loop,
and for each variable <code>foo</code> of the original spec an extra variable <code>loop_foo</code>,
which, once <code>InLoop</code> is true, stores the state of <code>foo</code> at the start of the loop.
Then, the loop has been completed if <code>vars = loop_vars</code>.</p>
<p>Apart from the variables for finding the loop, this approach also needs extra variables for
determining the satisfaction of the temporal property to be checked.
There again exist multiple ways of concretely implementing this:</p>
<h5><a class="header" href="#encoding-with-buchi-automata" id="encoding-with-buchi-automata"><strong>Encoding with Buchi automata</strong></a></h5>
<p>One can extend the spec with a Buchi automaton
which is updated in each step. The Buchi automaton encodes
the negation of the temporal property, thus if the automaton
would accept, the property does not hold.
By checking whether an accepting state of the automaton is seen
on the loop, it can be determined whether the automaton
accepts for a looping execution.
The encoding is described in <a href="http://fmv.jku.at/papers/BiereArthoSchuppan-FMICS02.pdf">Biere et al. 2002</a>
See e.g. the <a href="adr/EWD998_buchi.tla">EWD998 protocol with a Buchi automaton</a>.</p>
<p>Implementation details:</p>
<ul>
<li>An implementation of this encoding would need an implementation of an algorithm for the conversion from LTL to Buchi automata.
This could be an existing tool, e.g. <a href="https://spot.lrde.epita.fr/">Spot</a> or our own implementation.</li>
</ul>
<p>Advantages:</p>
<ul>
<li>Buchi automata for very simple properties can be simple to understand</li>
<li>Underlying automata could be visualized</li>
<li>Only needs few extra variables - the state of the Buchi automaton can easily be encoded as a single integer</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>Can be slow: Buchi automata generally exhibit either nondeterminism or can get very large</li>
<li>Hard to understand: Engineers and even experts have a hard time intuitively understanding Buchi automata for mildly complicated properties</li>
</ul>
<h5><a class="header" href="#tableau-encoding" id="tableau-encoding"><strong>Tableau encoding</strong></a></h5>
<p>One can instead extend the spec with auxiliary Boolean variables
roughly corresponding to all nodes in the syntax tree who have temporal operators
beneath them. The value of each variable in each step corresponds to whether the
formula corresponding to that node in the syntax tree is satisfied from that point forward. The encoding is described in Section 3.2 of <a href="https://lmcs.episciences.org/2236">Biere et al. 2006</a>
See e.g. the <a href="adr/EWD998_tableau.tla">EWD998 protocol encoded with a tableau</a>.</p>
<p>Implementation details:</p>
<ul>
<li>Naming the auxiliary variables is very important, since they are supposed to represent the values of complex formulas (ideally would simple have that formula as a name, but this is not syntactically possible for most formulas), and there can be many of them.</li>
</ul>
<p>Advantages:</p>
<ul>
<li>Very clear counterexamples: In each step, it is clearly visible which subformulas are or are not satisfied.</li>
<li>Relatively intuitive specs: The updates to the auxiliary variables
correlate with the intuitive meaning of their subformulas rather directly
in most cases</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>Many variables are added: The number of variables is linear in the number of operators in the formula</li>
<li>Specifications get long: The encoding is much more verbose than that for Buchi automata</li>
</ul>
<h4><a class="header" href="#decision---which-encoding-should-be-used" id="decision---which-encoding-should-be-used"><strong>Decision - which encoding should be used?</strong></a></h4>
<p>We chose to implement the tableau encoding, since it produces the
clearest counterexamples. Buchi automata are hard to understand. 
For trace invariants, the lack of quality in counterexamples makes it
very hard to debug and understand invariant violations.</p>
<h3><a class="header" href="#2-fairness" id="2-fairness">2. Fairness</a></h3>
<p><code>WF_e(A)</code> and <code>SF_e(A)</code> use <code>ENABLED(A)</code> as part of their definitions. Hence,
<code>ENABLED(A)</code> is of ultimate importance for handling <code>WF</code> and <code>SF</code>. However, we
do not know how to efficiently translate <code>ENABLED(A)</code> into SMT. A
straightforward approach requires to check that for all combinations of state
variables <code>A</code> does not hold.</p>
<p>This work requires further research, which we will do in parallel with the
first part of work. To be detailed later...</p>
<h2><a class="header" href="#consequences-4" id="consequences-4">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h1><a class="header" href="#adr-018-inlining-in-apalache" id="adr-018-inlining-in-apalache">ADR-018: Inlining in Apalache</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th><th>last revised</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">1</td><td>2022-04-21</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/018adr-inlining.html#summary">Summary (Overview)</a></li>
<li><a href="adr/018adr-inlining.html#context">Context (Problem)</a></li>
<li><a href="adr/018adr-inlining.html#options">Options (Alternatives)</a></li>
<li><a href="adr/018adr-inlining.html#solution">Solution (Decision)</a></li>
<li><a href="adr/018adr-inlining.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-5" id="summary-5">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>This ADR defines the various kinds of inlining considered in Apalache and discusses the pros and cons of their implementations.
Since we have recently reworked the inliner in <a href="https://github.com/informalsystems/apalache/pull/1569">#1569</a>, we saw it fit to document exactly how inlining is supposed to work and we have chosen the transformations performed in the inlining pass. </p>
<h2><a class="header" href="#context-5" id="context-5">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>TLA+ allows the user to define their own operators (e.g. <code>A</code>), in addition to the standard ones built into the language itself (e.g. <code>\union</code>).
This can be done either globally, where the module directly contains a definition, or locally via LET-IN, where a local operator is defined within the body of another operator. For example:</p>
<pre><code class="language-tla">GlobalA(p, q) ==
  LET LocalB(r) == r * r
  IN LocalB(p + q)
</code></pre>
<p>defines a global operator <code>GlobalA</code>, within which there is a locally defined <code>LocalB</code>.</p>
<p>Suppose we are given an invariant <code>GlobalA(1,2) = 9</code>. How do we evaluate whether or not this invariant holds? To do that, we need to evaluate 
<code>LET LocalB(r) == r * r IN LocalB(p + q)</code>, and to do <em>that</em>, we need to evaluate <code>LocalB(p + q)</code>. 
However, we cannot evaluate <code>LocalB(p + q)</code> in a vacuum, because <code>p</code> and <code>q</code> are not values we can reason about, but instead formal parameters. 
What we need to do, is determine the value of &quot;<code>LocalB(p + q)</code>, if <code>p = 1</code> and <code>q = 2</code>&quot;. In other words, we need to apply the substitution <code>{p -&gt; 1, q -&gt;2}</code> to <code>LocalB(p + q)</code>, which gives us <code>LocalB(1 + 2)</code>. 
Repeating this process, we apply the substitution <code>{r -&gt; 1 + 2}</code> to 
<code>r * r</code>, the body of <code>LocalB</code>, to obtain the following equivalence:</p>
<pre><code class="language-tla">GlobalA(1,2) = 9 &lt;=&gt; (1 + 2) * (1 + 2) = 9
</code></pre>
<p>The process of applying these substitutions as syntactic transformations is called inlining. </p>
<p>More precisely, suppose we are given a <em>non-recursive</em> operator <code>A</code> with the following definition:</p>
<pre><code class="language-tla">A(p1,...,pn) == body
</code></pre>
<p>The term &quot;inlining&quot; (of <code>A</code>) typically refers to the process of replacing instances of operator application <code>A(e1,...,en)</code> with <code>body[e1/p1,...,en/pn]</code>, i.e. the expression obtained by replacing each instance of <code>pi</code> with <code>ei</code> within <code>body</code>.
We elect to use the term in a broader sense of &quot;replacing an operator with its definition&quot;, and define two &quot;flavors&quot; of inlining:</p>
<ol>
<li>Standard inlining: the instantiation described above
<ol>
<li>Non-nullary inlining: the instantiation described above, except the inlining skips nullary LET-defined operators</li>
</ol>
</li>
<li>Pass-by-name inlining: replacing an operator name <code>A</code> used as an argument to a higher-order operator with a local LET-definition: <code>LET A_LOCAL(p1,...,pn) == A(p1,...,pn) IN A_LOCAL</code></li>
</ol>
<p>The reason for doing (1) is that, at some point, a rewriting rule would have to generate constraints from <code>A(e1,...,en)</code>. 
To do this, we couldn't just separately encode <code>body</code> and <code>e1,...,en</code>, because the richness of the data structures allowed in TLA+ makes it difficult to combine independently generated constraints, in cases where the operator parameters are complex expressions (e.g. <code>e1</code> is some record with varied nested constructs).
This is mostly due to the fact that there is no 1-to-1 correspondence between TLA+ objects and SMT datatypes, so encoding object equality is more complicated (which would be needed to express that <code>ei</code> instantiates <code>pi</code>).
Therefore we must, no later than at the point of the rewriting rule, know <code>body[e1/p1,...,en/pn]</code>. </p>
<p>While inlining non-nullary operators is strictly necessary, inlining nullary operators is not, because nullary operators, by definition, do not have formal parameters. 
Therefore, in a well-constructed expression, all variables appearing in a nullary operator are scoped, i.e. they are  either specification-level variables (defined as <code>VARIABLE</code>), or bound in the context within which the operator is defined, if local. An example of the latter would be <code>i</code> in </p>
<pre><code class="language-tla">\E i \in S: LET i2 == i * i in i2 = 0
</code></pre>
<p>which is not bound in the nullary operator <code>i2</code>, but it is defined in the scope of the <code>\E</code> operator, under which <code>i2</code> is defined. Therefore, any analysis of <code>i2</code> will have <code>i</code> in its scope.
The non-nullary variant of (1) is therefore strictly better for performance, because it allows for a sort of caching, which avoids repetition. Consider for example:</p>
<pre><code class="language-tla">A1(p) == 
  LET pCached == p
  IN F(pCached,pCached)

A2(p) == F(p,p)
</code></pre>
<p>If we apply the substitution <code>{p -&gt; e}</code>, for some complex value <code>e</code>, to the bodies of both operators, the results are </p>
<pre><code class="language-tla">LET pCached == e
IN F(pCached,pCached)
</code></pre>
<p>and</p>
<pre><code>F(e,e)
</code></pre>
<p>In the first case, we can translate <code>pCached</code> to a cell (Apalache's SMT representation of TLA+ values, see <a href="https://dl.acm.org/doi/10.1145/3360549">this
paper</a> for details) and reuse the cell expression twice, whereas in the second, <code>e</code> is rewritten twice, independently.
So in the case that we perform (1), we will always perform the non-nullary variant, because it is strictly more efficient in our cell-arena framework fo rewriting rules.</p>
<p>The reason for doing (2) is more pragmatic; in order to rewrite expressions which feature any of the higher-order (HO) built-in operators, e.g. <code>ApaFoldSet(A, v, S)</code>, we need to know, at the time of rewriting, how to evaluate an application of <code>A</code> (e.g. <code>A(partial, current)</code> for folding). 
Performing (2) allows us to make the rewriting rule local, since the definition becomes available where the operator is used, and frees us from having to track scope in the rewriting rules.</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Suppose we have an operator </p>
<pre><code class="language-tla">A(p,q) == p + 2 * q
</code></pre>
<p>Then, the result of performing (1) for <code>A(1, 2)</code> would be <code>1 + 2 * 2</code>. 
The constant simplification could take the inlined expression and simplify it to <code>5</code>, whereas it could not do this across the application boundary of <code>A(1,2)</code>.</p>
<p>The result of performing (2) for <code>ApaFoldSet(A, 0, {1,2,3})</code> would be</p>
<pre><code class="language-tla">ApaFoldSet(LET A_LOCAL(p,q) == p + 2 * q, 0, {1,2,3})
</code></pre>
<p>While this resulting expression isn't subject to any further simplification, notice that it <em>does</em> contain all the required information to fully translate to SMT, unlike <code>ApaFoldSet(A, 0, {1,2,3})</code>, which requires external information about <code>A</code>.</p>
<h2><a class="header" href="#options-4" id="options-4">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<p>Knowing that we must perform (1) at some point, what remains is to decide whether we perform inlining on-demand as part of rewriting, or whether to isolate it to an independent inlining-pass (or as part of preprocessing), i.e. performing a syntactic transformation on the module, that replaces <code>A(e1,...,en)</code> with <code>body[e1/p1,...,en/pn]</code>, or merely generating rewriting rules that <em>encode</em> <code>A(e1,...,en)</code> equivalently as <code>body[e1/p1,...,en/pn]</code>, while preserving the specification syntax.
Additionally, if we do isolate inlining to a separate pass, we can choose whether or not to perform (2).</p>
<ol>
<li>
<p>Perform no inlining in preprocessing and inline only as needed in the rewriting rules.</p>
<ul>
<li>Pros: Spec intermediate output remains small, since inlining increases the size of the specificaiton</li>
<li>Cons: 
<ul>
<li>Fewer optimizations can be applied, as some are only applicable to the syntactic forms obtained after inlining (e.g. <code>ConstSimplifier</code> can simplify <code>IF TRUE THEN a ELSE b</code>, but not <code>IF p THEN a ELSE b</code>)</li>
<li>Rewriting rules for different encodings have to deal with operators in their generality.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Independently perform only standard (non-nullary) inlining (1), but no pass-by-name inlining (2)</p>
<ul>
<li>Pros: Allows for additional optimizations after inlining (simplification, normalization, keramelization, etc.)</li>
<li>Cons: Rewriting rules still need scope, to resolve higher-order operator arguments in certain built-in operators (e.g. folds)</li>
<li>Recall that the non-nullary variant of (1) is strictly better than the simple one (while being trivial to implement), because nullary inlining is prone to repetition.</li>
</ul>
</li>
<li>
<p>Independently perform non-nullary inlining and pass-by-name inlining</p>
<ul>
<li>Pros: 
<ul>
<li>Enables further optimizations (simplification, normalization, keramelization, etc.)</li>
<li>Using non-nullary inlining has all of the benefits of standard inlining, while additionally being able to avoid repetition (e.g. not inlining <code>A</code> in <code>A + A</code>)</li>
<li>Pass-by-name inlining allows us to keep rewriting rules local</li>
</ul>
</li>
<li>Cons: Implementation is more complex</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#solution-4" id="solution-4">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>We elect to implement option (3), as most of its downsides are developer burdens, not theoretical limitations, and its upsides (in particular the ones of non-nullary inlining) are noticeable performance benefits.
Maintaining local rewriting rules is also a major technical simplification, which avoids potential bugs with improperly tracked scope.</p>
<h2><a class="header" href="#consequences-5" id="consequences-5">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>TBD</p>
<h1><a class="header" href="#adr-019-harmonize-changelog-management" id="adr-019-harmonize-changelog-management">ADR-019: Harmonize changelog management</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Shon Feder</td><td align="right">2022-05-06</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/019adr-harmonize-changelog.html#summary">Summary (Overview)</a></li>
<li><a href="adr/019adr-harmonize-changelog.html#context">Context (Problem)</a></li>
<li><a href="adr/019adr-harmonize-changelog.html#options">Options (Alternatives)</a></li>
<li><a href="adr/019adr-harmonize-changelog.html#solution">Solution (Decision)</a></li>
<li><a href="adr/019adr-harmonize-changelog.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-6" id="summary-6">Summary</a></h2>
<p>In the context of maintaining a changelog to communicate salient changes about
our software, facing the friction caused by frequent merge conflicts in our
<code>UNRELEASED</code> changelog, we decided to find a lightweight, conflict free,
changelog process in order to achieve a smoother development process. We have
accepted the development cost and learning curve required by adopting a new
process.</p>
<h2><a class="header" href="#context-6" id="context-6">Context</a></h2>
<p>We maintain a <a href="https://keepachangelog.com/en/1.0.0/">changelog</a></p>
<blockquote>
<p>to make it easier for users and contributors to see precisely what notable
changes have been made between each release (or version) of the project.</p>
</blockquote>
<p>Any changeset that introduces observable changes to the behavior of our software
should include additions to the changelog.  Currently, <a href="https://github.com/informalsystems/apalache/blob/60e6a14d451cb67c93dfd29cffd0cc0eb9d7922d/CONTRIBUTING.md#changelog">additions are made</a> by
updating the <code>UNRELEASED.md</code> file. The changes recorded there are then added to
the <code>CHANGES.md</code> file during our automated release process.</p>
<p>This process creates a race condition over <code>UNRELEASED.md</code> between any
concurrent pull requests. This consequently results in developers constantly
having to resolve merge conflicts. This busy-work slows down development and
adds no value.</p>
<h2><a class="header" href="#options-5" id="options-5">Options</a></h2>
<p>We now enumerate and consider the various options we've conceived for addressing
this problem.</p>
<p>With the exception of option (0), all of the following options would resolve the
problem of merge conflicts and could be integrated into our existing automated
deployment pipeline.  However each option has different costs w/r/t
dependencies, processes, and learning curve.</p>
<p>All of the following options will likely require ongoing maintenance, even
option (0): this is because we already have a set of scripts that manage our
changelog entries in order to support our fully automated releases. So this is
not a space where we are introducing automation for the first time, but is
instead a situation where we are changing an existing automated system.</p>
<h3><a class="header" href="#0-dont-change-anything" id="0-dont-change-anything">0. Don't change anything</a></h3>
<p>We could do nothing. Developers would continue to resolve changelog conflicts manually.</p>
<h4><a class="header" href="#pros" id="pros">Pros</a></h4>
<ul>
<li>Requires no development time on a solution.</li>
<li>Would require no additional maintenance.</li>
</ul>
<h4><a class="header" href="#cons" id="cons">Cons</a></h4>
<ul>
<li>We'll continue having developer slow-down and busy work when merge conflicts arise.</li>
</ul>
<h3><a class="header" href="#1-use-one-of-the-automated-changelog-generators" id="1-use-one-of-the-automated-changelog-generators">1. Use one of the automated changelog generators</a></h3>
<p>There is a <a href="https://github.com/search?q=changelog+auto">superabundance</a> of tools
for automatically generating changelogs. These tools extract changelogs from
various different sources such as commit messages, issues, or pull requests.</p>
<h4><a class="header" href="#pros-1" id="pros-1">Pros</a></h4>
<ul>
<li>Requires no new development</li>
<li>Would eliminate the need to add changelog entries in a separate file</li>
</ul>
<h4><a class="header" href="#cons-1" id="cons-1">Cons</a></h4>
<ul>
<li>Developers have to learn the annotation format required by the tool, and they
have to remember to deploy it in their commits/PRs/issues.</li>
<li>Infrastructure maintainers have to learn how to configure and maintain the tool.</li>
<li>We pickup a dependency external to both the company and our project</li>
<li>Changelogs are meant to communicate a very specific kind of information to a
specific audience. Git commit messages, pull requests, and issues are for
communicating quite different information to an entirely different audience.
Requiring that these communication channels be overloaded risks degrading the
quality of communications in all the conflated channels.
<ul>
<li>However, it's possible we could work out some conventions to add empty
commits or designate special PR labels to work around this interference?</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#2-use-unclog" id="2-use-unclog">2. Use Unclog</a></h3>
<p><a href="https://github.com/thanethomson">@thanethomson</a> has written the <a href="https://github.com/informalsystems/unclog">unclog</a> utility, which is used in both
<a href="https://github.com/informalsystems/tendermint-rs">informalsystems/tendermint-rs</a> and <a href="https://github.com/informalsystems/ibc-rs">informalsystems/ibc-rs</a>. The tool
stores changelog entries in a directory structure, with each entry in its own
file, ensuring merge conflicts can't arise. </p>
<p>Entries are added via the CLI. E.g.:</p>
<pre><code class="language-sh">unclog add --id some-new-feature \
  --issue 23 \
  --section breaking-changes \
  --message &quot;Some *new* feature&quot;
</code></pre>
<p>If the <code>--messages</code> argument is omitted, it will open your configured editor for
authoring the message.</p>
<p>The tool has subcommands to generate and update the <code>CHANGES.md</code>, and it supports
a variety of options via its TOML configuration.</p>
<h4><a class="header" href="#pros-2" id="pros-2">Pros</a></h4>
<ul>
<li>Requires no new development</li>
<li>It is developed internally to informal</li>
</ul>
<h4><a class="header" href="#cons-2" id="cons-2">Cons</a></h4>
<ul>
<li>Adds cognitive and procedural overhead to adding changelog entries</li>
<li>Would add a rust dependency to our devenv</li>
<li>Requires external contributors to either install a CLI tool or figure out a
relatively complex file and folder structure to add changelog entries</li>
</ul>
<h3><a class="header" href="#3-use-a-custom-git-merge-driver" id="3-use-a-custom-git-merge-driver">3. Use a custom git merge driver</a></h3>
<p>If we wrote a <a href="https://git-scm.com/docs/gitattributes#_defining_a_custom_merge_driver">custom git merge driver</a> to work on the simple changelog format we
could continue our current practice, and just fall back to the custom merge
driver in case of merge conflicts.</p>
<h4><a class="header" href="#pros-3" id="pros-3">Pros</a></h4>
<ul>
<li>Allows us to keep our current process of simply updating a markdown file,
with which, moreover, most devs are already familiar</li>
</ul>
<h4><a class="header" href="#cons-3" id="cons-3">Cons</a></h4>
<ul>
<li>Could require external dependencies to be installed, depending on
implementation.</li>
<li>It's not possible to configure custom merge drivers for github, so we'd either
need to develop a github action or bot to monitor for merge conflicts in the
changelog and merge them automatically, or devs would be back to having to
resolve merge conflicts locally.</li>
</ul>
<h3><a class="header" href="#4-write-some-lightweight-tooling" id="4-write-some-lightweight-tooling">4. Write some lightweight tooling</a></h3>
<p>We could author some simple tooling that would capture the core behavior of
<code>unclog</code>, using files in directories, but neither require external dependencies
nor knowledge of a new CLI.</p>
<h4><a class="header" href="#pros-4" id="pros-4">Pros</a></h4>
<ul>
<li>No new tooling to learn</li>
<li>No external dependencies to integrate</li>
</ul>
<h4><a class="header" href="#cons-4" id="cons-4">Cons</a></h4>
<ul>
<li>Would require some development time (I estimate approx. 1 day, see the design
sketch below for details on the implementation)</li>
<li>Would require contributors to understand the folder structure</li>
</ul>
<h2><a class="header" href="#solution-5" id="solution-5">Solution</a></h2>
<p>We have opted for option 4. Despite the added cost of development, we think the
simplicity of use and maintenance will offset the development cost.</p>
<h3><a class="header" href="#design" id="design">Design</a></h3>
<p>We will introduce a new directory tree to the project:</p>
<pre><code class="language-sh">.unreleased/
├── breaking-changes/
├── bug-fixes/
├── documentation/
└── features/
</code></pre>
<p>Each change will be added as a single markdown file in the appropriate
directory.</p>
<p>Two <code>sbt</code> targets will be added to facilitate our continuous deployment:</p>
<ul>
<li><code>releaseNotes</code>, merges the unreleased notes into a single new file of the expected format in our <code>target</code> directory. This can be used for upload to github releases.</li>
<li><code>changeLog</code> updates <code>CHANGES.md</code> by prepending the output of <code>releaseNotes</code>. It then removes all notes
from the <code>.unreleased</code> directory so that the next iteration of development starts from a clean slate.</li>
</ul>
<h2><a class="header" href="#consequences-6" id="consequences-6">Consequences</a></h2>
<p>TBD</p>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h1><a class="header" href="#adr-020-introduce-static-membership-in-arenas" id="adr-020-introduce-static-membership-in-arenas">ADR-020: Introduce static membership in arenas</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">2022-06-01</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/020adr-arenas.html#summary">Summary (Overview)</a></li>
<li><a href="adr/020adr-arenas.html#context">Context (Problem)</a></li>
<li><a href="adr/020adr-arenas.html#options">Options (Alternatives)</a></li>
<li><a href="adr/020adr-arenas.html#solution">Solution (Decision)</a></li>
<li><a href="adr/020adr-arenas.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-7" id="summary-7">Summary</a></h2>
<p>We discuss an extension of the model checker arenas. The main application of this extension is a more efficient
implementation of powersets and functions sets. Potentially, this extension will let us optimize the number of SMT
constraints and thus improve performance of the model checker in general.</p>
<h2><a class="header" href="#1-context" id="1-context">1. Context</a></h2>
<p>We give only a brief introduction to arenas. A detailed exposition can be found in <a href="https://dl.acm.org/doi/10.1145/3360549">KKT19</a>.</p>
<h3><a class="header" href="#11-short-introduction-to-arenas" id="11-short-introduction-to-arenas">1.1. Short introduction to arenas</a></h3>
<p>The model checker heavily relies on the concept of arenas, which are a static overapproximation of the data structures
produced by symbolic execution of a TLA+ specification. Here we give a very short recap. In a nutshell, all basic values
of TLA+ (such as integers, strings, and Booleans) and data structures
(sets, functions, records, tuples, and sequences) are translated into <em>cells</em>. Cells are SMT constants, which can be
connected to other cells by <em>edges</em>. Currently, we have three kinds of edges:</p>
<ul>
<li>
<p><strong>has</strong>. A membership edge <code>(c_p, c_e)</code> represents that a parent cell <code>c_p</code>
potentially contains an element <code>c_e</code> (e.g., if <code>c_p</code> represents a set). These edges encode many-to-many relations.</p>
</li>
<li>
<p><strong>dom</strong>. A domain edge <code>(c_f, c_d)</code> represents that a function cell <code>c_f</code>
has the domain represented with a cell <code>c_d</code>. These edges encode many-to-one relations.</p>
<p>Likewise, a domain edge <code>(c_F, c_c)</code> represents that a function set cell
<code>c_F</code> has the domain represented with a cell <code>c_c</code>.</p>
</li>
<li>
<p><strong>cdm</strong>. A co-domain edge <code>(c_F, c_c)</code> represents that a function set cell
<code>c_F</code> has the co-domain represented with a cell <code>c_c</code>. These edges encode many-to-one relations.</p>
<p>For historic reasons, functions are also encoded with the edges called
<strong>dom</strong> and <strong>cdm</strong>, though the <strong>cdm</strong> edge points to the function relation, not its co-domain. We would prefer to
call label the relation edge with <strong>rel</strong>, not <strong>cdm</strong>. As these edges are many-to-one, we can map them from their
kinds <code>kind -&gt; (c_p, c_e)</code>. This requires simple refactoring, so we are not going to discuss the <strong>dom</strong> and <strong>cdm</strong>
any further.</p>
</li>
</ul>
<p>There is a need for refactoring and extension of the <strong>has</strong>-edges. We
summarize the issues with the current implementation of this kind of edges:</p>
<ul>
<li>
<p>Originally, every edge <code>(c_S, c_e)</code> of the kind <strong>has</strong> was encoded as a Boolean constant <code>in_${c_e.id}_${c_S.id}</code> in
SMT. Hence, every time we introduce a copy <code>c_T</code> of a set <code>c_S</code>, we introduce a new edge
<code>(c_T, c_e)</code> in the arena, and thus we have to introduce another Boolean constant <code>in_${c_e.id}_${c_T.id}</code> in SMT.
Alternatively, we could use a single Boolean variable both for <code>(c_S, c_e)</code> and <code>(c_T, c_e)</code>.</p>
</li>
<li>
<p>Later, when translating records and tuples, we stopped introducing Boolean constants in SMT for the <strong>has</strong>-edges.
However, we do not track in the arena the fact that these edges are presented only in the arena, not in SMT. Hence, we
have to be careful and avoid expressing membership in SMT when working with these edges.</p>
</li>
<li>
<p>As every <strong>has</strong>-edge directly refers to its parent in the edge name (that is, <code>in_${c_e.id}_${c_S.id}</code>), we cannot
share edges when encoding <code>SUBSET S</code> and <code>[S -&gt; T]</code>. As a result, we have to introduce a massive number of Boolean
constants and constraints, which are not necessary.</p>
</li>
<li>
<p>We keep adding edges and SMT constants to the solver context, even when we know exactly that an element belongs to a
set, e.g., as in <code>{ 1, 2, 3 }</code>.</p>
</li>
</ul>
<h3><a class="header" href="#12-arena-examples" id="12-arena-examples">1.2. Arena examples</a></h3>
<p>To introduce the context in more detail, we give an example of how several TLA+ expressions are represented in arenas
and SMT.</p>
<p>Consider the following expression:</p>
<pre><code class="language-tla">{ a, b, c } \union { d, e }
</code></pre>
<p>Let's denote the arguments of the set union to be <code>S</code> and <code>T</code>. In the current arena representation, the rewriting
rule <code>SetCtorRule</code> creates the following SMT constants (assuming that <code>a, ..., e</code> were translated to arena cells):</p>
<ul>
<li>
<p>Two cells <code>c_l</code> and <code>c_r</code> to represent the sets <code>S</code> and <code>T</code>. These cells are backed with two SMT constants of an
uninterpreted sort, which corresponds to the common type of <code>S</code> and <code>T</code>.</p>
</li>
<li>
<p>Five SMT constants of the Boolean sort that express set membership of <code>a, b, c</code> and <code>d, e</code> in <code>S</code> and <code>T</code>,
respectively. The sets <code>S</code> and <code>T</code> are backed with SMT constants of the sort of <code>S</code> and <code>T</code>.</p>
</li>
<li>
<p>One cell <code>c_u</code> to represent the set <code>S \union T</code>.</p>
</li>
<li>
<p>Five Boolean constants of the Boolean sort that express set membership of
<code>a, b, c, d, e</code> in <code>S \union T</code>.</p>
</li>
</ul>
<p>It is obvious that 10 Boolean constants introduced for set membership are completely unnecessary, as we know for sure
that the respective elements belong to the three sets. Moreover, when constructing <code>S \union T</code>, the rule <code>SetCupRule</code>
creates five SMT constraints:</p>
<pre><code class="language-smt">;; a, b, c belong to the union, when they belong to S
(= in_a_u in_a_l)
(= in_b_u in_b_l)
(= in_c_u in_c_l)
;; d and e belong to the union, when they belong to T
(= in_d_u in_d_r)
(= in_e_u in_e_r)
</code></pre>
<h2><a class="header" href="#2-options" id="2-options">2. Options</a></h2>
<ul>
<li>
<p>Keep things as they are.</p>
</li>
<li>
<p>Implement the extension of membership edges presented below.</p>
</li>
</ul>
<h2><a class="header" href="#3-solution" id="3-solution">3. Solution</a></h2>
<h3><a class="header" href="#31-pointers-to-the-elements" id="31-pointers-to-the-elements">3.1. Pointers to the elements</a></h3>
<p>Instead of the current solution in the arenas, which maps a parent cell to a
list of element cells, we propose to map parent cells to membership pointers of
various kinds. To this end, we introduce an abstract edge (the Scala code can
be found in the package <code>at.forsyte.apalache.tla.bmcmt.arena</code>):</p>
<p>https://github.com/informalsystems/apalache/blob/81e397fadc6f3ce346d8f8a709ebb3715ac57391/tla-bmcmt/src/main/scala/at/forsyte/apalache/tla/bmcmt/arena/ElemPtr.scala#L8-L24</p>
<p>Having an abstract edge, we introduce various case classes. The simplest case
is the <code>FixedElemPtr</code>, which always evaluates to a fixed Boolean value:</p>
<p>https://github.com/informalsystems/apalache/blob/81e397fadc6f3ce346d8f8a709ebb3715ac57391/tla-bmcmt/src/main/scala/at/forsyte/apalache/tla/bmcmt/arena/ElemPtr.scala#L26-L39</p>
<p>Instances of <code>FixedElemPtr</code> may be used in cases, when the membership is
statically known. For instance, set membership for the sets <code>{1, 2, 3}</code> and
<code>1..100</code> is static (always <code>true</code>) and thus it does not require any additional
variables and constraints in SMT. The same applies to records and tuples.</p>
<p>The next case is element membership that is represented via a Boolean constant
in SMT:</p>
<p>https://github.com/informalsystems/apalache/blob/81e397fadc6f3ce346d8f8a709ebb3715ac57391/tla-bmcmt/src/main/scala/at/forsyte/apalache/tla/bmcmt/arena/ElemPtr.scala#L41-L64</p>
<p>Instances of <code>SmtConstElemPtr</code> may be used in cases, when set membership can be
encoded via a Boolean constant. Typically, this is needed when the membership
is either to be defined by the solver, or when this constant caches a complex
SMT constraint. For instance, it can be used by <code>CherryPick</code>.</p>
<p>The most general case is represented via an SMT expression, which is encoded in
TLA+ IR:</p>
<p>https://github.com/informalsystems/apalache/blob/81e397fadc6f3ce346d8f8a709ebb3715ac57391/tla-bmcmt/src/main/scala/at/forsyte/apalache/tla/bmcmt/arena/ElemPtr.scala#L66-L77</p>
<p>Instances of <code>SmtExprElemPtr</code> may be used to encode set membership via SMT
expressions. For instance:</p>
<ul>
<li>
<p>Evaluating an array expression, e.g., via <code>apalacheStoreInFun</code>.</p>
</li>
<li>
<p>Combining several pointers. For instance, when computing <code>{ x \in S: P }</code>,
we would combine set membership in <code>S</code> and the value of <code>P</code> for every <code>x</code>.</p>
</li>
</ul>
<h3><a class="header" href="#32-optimization-1-constant-propagation-via-membership-pointers" id="32-optimization-1-constant-propagation-via-membership-pointers">3.2. Optimization 1: constant propagation via membership pointers</a></h3>
<p>One immediate application of using the new representation is completely SMT-free construction of some of the TLA+
expressions.</p>
<p>Recall the example in <a href="adr/020adr-arenas.html#12-arena-examples">Section 1.2</a>. With the new representation, the set constructor would simply
create five instances of
<code>FixedElemPtr</code> that carry the value <code>true</code>, that is, the elements unconditionally belong to <code>S</code> and <code>T</code>. Further, the
rule <code>SetCupRule</code> would simply copy the five pointers, without propagating anything to SMT.</p>
<p>As a result, we obtain constant propagation of set membership, while keeping the general spirit of the arena-based
encoding.</p>
<h3><a class="header" href="#33-optimization-2-sharing-membership-in-a-powerset" id="33-optimization-2-sharing-membership-in-a-powerset">3.3. Optimization 2: sharing membership in a powerset</a></h3>
<p>Consider the TLA+ operator that constructs the powerset of <code>S</code>, that is, the set
of all subsets of <code>S</code>:</p>
<pre><code class="language-tla">SUBSET S
</code></pre>
<p>Let <code>c_S</code> be the cell that represents the set <code>S</code> and <code>c_1, ..., c_n</code> be the
cells that represent the potential elements of <code>S</code>. Note that in general,
membership of all these cells may be statically unknown. For example, consider
the case when the set <code>S</code> is constructed from the following TLA+ expression:</p>
<pre><code class="language-tla">{
  x \in 1..100:
    \E y \in 1..10:
      y * y = x
}
</code></pre>
<p>In the above example, computation of the predicate is delegated to the SMT solver.</p>
<p>The code in <code>PowSetCtor</code> constructs <code>2^Cardinality(S)</code> sets that contain all subsets of <code>S</code>. The tricky part here is
that some of the elements of <code>S</code> may be outside of <code>S</code>. To deal with that, <code>PowSetCtor</code> constructs cells for each
potential combinations of <code>c_1, ..., c_n</code> and adds membership tests for each of them. For instance, consider the
subset <code>T</code> that is constructed by selecting the indices <code>1, 3, 5</code> of <code>1..n</code>. The constructor will introduce three
constraints:</p>
<pre><code class="language-smt">(= in_c_1_T in_c_1_S)
(= in_c_3_T in_c_3_S)
(= in_c_5_T in_c_5_S)
</code></pre>
<p>Hence, the current encoding introduces <code>2^n</code> SMT constants for the subsets and
<code>n * 2^(n - 1)</code> membership constraints in SMT (thanks to Jure @Kukovec for
telling me the precise formula).</p>
<p>With the new representation, we would simply copy the respective membership
pointers of the set <code>S</code>. This would require us to introduce zero constraints in
the SMT, though we would still introduce <code>2^n</code> SMT constants to represent the
subsets themselves. Note that we would still have to introduce <code>n * 2^(n - 1)</code>
pointers in the arena. But this would be done during the process of rewriting.</p>
<h3><a class="header" href="#34-feature-computing-the-set-of-functions-via-pointer-sharing" id="34-feature-computing-the-set-of-functions-via-pointer-sharing">3.4. Feature: computing the set of functions via pointer sharing</a></h3>
<p>Sometimes, it happens that the model checker has to expand a set of functions
<code>[S -&gt; T]</code>. Such a set contains <code>|T|^|S|</code> functions. Since the model checker works with arenas, it can only construct an arena representation of <code>[S -&gt; T]</code>. To this end, assume that the set <code>S</code> is encoded via cells <code>s_1, ..., s_m</code>,
and the set <code>T</code> is encoded via cells <code>t_1, ..., t_n</code>.</p>
<p>If we wanted to construct <code>[S -&gt; T]</code> in the current encoding, we would have to
introduce a relation for each function in the set <code>[S -&gt; T]</code>. That is, for
every sequence <code>i[1], ..., i[n]</code> over <code>1..n</code>, it would construct the relation
<code>R</code>:</p>
<pre><code>{ &lt;&lt;s_1, t_i[1]&gt;&gt;, ..., &lt;&lt;s_m, t_i[m]&gt;&gt; }
</code></pre>
<p>Let's denote with <code>p_j</code> the pair <code>&lt;&lt;s_j, t_i[j]&gt;&gt;</code> for <code>1 &lt;= j &lt;= m</code>.</p>
<p>Moreover, we would add <code>m</code> membership constraints (per function!) in SMT:</p>
<pre><code>(= in_p_1_R (and in_s_1_S in_t_i[1]_T))
...
(= in_p_m_R (and in_s_m_S in_t_i[m]_T))
</code></pre>
<p>As a result, this encoding would introduce <code>m * n^m</code> constants in SMT and the same number of membership constraints. For
instance, if we have <code>m = 10</code> and <code>n = 5</code>, then we would introduce 90 million constants and constraints!</p>
<p>Using the approach outlined in this ADR, we can simply combine membership pointers of <code>S</code> and <code>T</code> via <code>SmtExprElemPtr</code>.
This would neither introduce SMT constants, nor SMT constraints. Of course, when this set is used in expressions
like <code>\E x \in S: P</code> or <code>\A x \in S: P</code>, the edges will propagate to SMT as constraints.</p>
<h2><a class="header" href="#4-consequences" id="4-consequences">4. Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h1><a class="header" href="#rfc-021-prioritization-of-work" id="rfc-021-prioritization-of-work">RFC-021: Prioritization of Work</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Shon Feder, Gabriela Moreira</td><td align="right">2022-05-24</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/021rfc-prioritization.html#summary">Summary (Overview)</a></li>
<li><a href="adr/021rfc-prioritization.html#context">Context (Problem)</a></li>
<li><a href="adr/021rfc-prioritization.html#options">Options (Alternatives)</a></li>
<li><a href="adr/021rfc-prioritization.html#solution">Solution (Decision)</a></li>
<li><a href="adr/021rfc-prioritization.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-8" id="summary-8">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>In the context of the distributed development of Apalache<br />
facing repeated friction around unplanned work and lack of agreement on priorities<br />
we decided to adopt an Action Priority Matrix<br />
to achieve shared understanding and agreement on prioritization<br />
accepting the additional overhead required by scoring and evaluating our work items.</p>
<h2><a class="header" href="#context-7" id="context-7">Context</a></h2>
<p>In recent months, we have repeatedly encountered conflicts over prioritization
of our work. Different members within our team, or different stakeholders
outside of the team, have voiced opposing views on what work items deserve
focused and urgent attention. In reflecting on these occasions in our meetings,
we have come to agree that these conflicts are due, at least in part, to lack of
a clearly established framework for assessing, communicating, and recording the
priority of work.</p>
<p>In particular, when plans change, or when urgent, unplanned work needs
attention, we would like a lightweight framework for reaching consensus on the
new priorities, and deriving a new ordering of the work to be done.</p>
<p>The decision to adopt an action priority matrix for prioritizing our work was
reached in <a href="https://github.com/informalsystems/apalache/commit/f379a717ca02a559b8f48d503f4413410d0b8abd">December of 2021</a>, but we weren't clear at that time
how to we would determine the scores for each work item. This ADR aims to
outline and codify the approach we will use.</p>
<p>In this document we talk about &quot;items of work&quot; or &quot;work items&quot;. These are just
some division of work into a conceptually unified unit. In general, any work
item can be further divided into smaller units of work. Work items are
represented by &quot;tickets&quot; or &quot;issues&quot; that track the task, e.g., GitHub issues.</p>
<h2><a class="header" href="#options-6" id="options-6">Options</a></h2>
<p>We considered 3 different approaches to prioritization: </p>
<ol>
<li><a href="https://cio-wiki.org/wiki/Action_Priority_Matrix_(APM)">Action Priority Matrix</a>: We score each work item based on the expected
<em>effort</em> it will require to complete and the anticipated <em>impact</em> of the
results.  We then  place these tasks on a matrix and coordinate the scores to
optimize for the highest value delivery with the least effort.</li>
<li><a href="https://kanbanize.com/lean-management/value-waste/cost-of-delay">Cost of Delay (CoD)</a>: Similar to the action priority matrix, this is
based on assigning two scores to work items: <em>value</em> and <em>urgency</em>. These
scores are then correlated to minimize the negatives financial impacts of
delays. It basically works by asking &quot;What is the (financial) impact of this
not being completed today?&quot; </li>
<li>Voting: Finally, we discussed a more subjective strategy based on having
people vote on tasks they think are more important and using that as a basis
for prioritizing.</li>
</ol>
<h3><a class="header" href="#references-1" id="references-1">References</a></h3>
<p>More information on various approaches to prioritization can be found in these
sources we consulted:</p>
<ul>
<li>http://www.tarrani.net/linda/prioritizing.pdf</li>
<li>https://www.mindtools.com/pages/article/newHTE_95.htm</li>
<li>https://www.productplan.com/glossary/action-priority-matrix/</li>
<li>https://cio-wiki.org/wiki/Action_Priority_Matrix_(APM)</li>
<li>https://kanbanize.com/lean-management/value-waste/cost-of-delay</li>
</ul>
<h2><a class="header" href="#solution-6" id="solution-6">Solution</a></h2>
<h3><a class="header" href="#decision" id="decision">Decision</a></h3>
<p>We felt that the CoD approach was too dependent on the need to determine
short-term financial returns. This is hard to square with our role as an open
source, R&amp;D center serving Informal Systems and the aims of correct software
development in the community at large.</p>
<p>We felt that the unstructured voting approach was too subjective. Moreover,
while it would work to surface our individual preferences, it doesn't help
establish a common ground for shared understanding about priorities.</p>
<p>We finally decided to adopt the <em>Action Priority Matrix</em>. We feel that the
process is light-weight enough that we can implement it without slowing down our
development but rigorous enough to root our shared understanding in the
objective needs and constraints we face in our work.</p>
<h3><a class="header" href="#process" id="process">Process</a></h3>
<p>We follow an adapted version of <a href="https://cio-wiki.org/wiki/Action_Priority_Matrix_(APM)">the approach to APM described in the CIO Wiki</a>.</p>
<h4><a class="header" href="#categories" id="categories">Categories</a></h4>
<p>APM leads us to divide work items into four categories, as follows:</p>
<table><thead><tr><th><em>Impact</em> <strong>\</strong> <em>Effort</em></th><th><strong>Low Effort</strong></th><th><strong>High Effort</strong></th></tr></thead><tbody>
<tr><td><strong>High Impact</strong></td><td>&quot;Quick Wins&quot;</td><td>&quot;Major Projects&quot;</td></tr>
<tr><td><strong>Low Impact</strong></td><td>&quot;Fill-ins&quot;</td><td>&quot;Thankless tasks&quot;</td></tr>
</tbody></table>
<p>The category within which a work item falls determines the general approach
taken towards the work:</p>
<table><thead><tr><th>Category</th><th>Approach</th></tr></thead><tbody>
<tr><td>Quick wins</td><td>Do ASAP</td></tr>
<tr><td>Major projects</td><td>Sustain long term focus</td></tr>
<tr><td>Fill-ins</td><td>Do in spare time, but never taking time from above</td></tr>
<tr><td>Thankless tasks</td><td>Avoid, unless there's literally nothing else to do</td></tr>
</tbody></table>
<h4><a class="header" href="#scoring" id="scoring">Scoring</a></h4>
<p>We determine which category a work item falls under based on the <em>impact</em> and
<em>effort</em> scores assigned to the work. We therefore need a shared understanding
of how to assess the impact and effort of a work item. We register only 3 levels
on each axis to keep the cognitive load of reckoning scores minimal.</p>
<p>Scores are recorded by affixing labels to the github issue tracking the work item.</p>
<h5><a class="header" href="#effort" id="effort">Effort</a></h5>
<p>Effort is scored best on a rough estimate of the amount of focused time it would
take to complete a work item:</p>
<table><thead><tr><th>Effort</th><th>Meaning</th><th>Label</th></tr></thead><tbody>
<tr><td>Easy</td><td>Can be completed within about 1 day</td><td><code>effort-easy</code></td></tr>
<tr><td>Medium</td><td>Can be completed within 3 days</td><td><code>effort-medium</code></td></tr>
<tr><td>Difficult</td><td>Will take 5 or more days</td><td><code>effort-hard</code></td></tr>
</tbody></table>
<p>Ideally, as soon as we recognized that an actively planned ticket will take more
than 5 days of focused work, we would factor it into smaller tickets, allowing
us to avoid perpetually prolonged monster tickets. But some people may prefer to
track &quot;major projects&quot; with a single issue rather than a milestone, and this
doesn't pose a significant problem.</p>
<h5><a class="header" href="#impact" id="impact">Impact</a></h5>
<p>Impact is scored based on considering impact in the follow 4 domains:</p>
<ol>
<li><em>User / customer</em>: The benefit of the results of a work item to our users and
customers</li>
<li><em>Mission</em>: Furtherance of our organization's mission and objectives</li>
<li><em>Invention</em>: Advancement of state of the art in formal verification and
specification</li>
<li><em>Development</em>: Improvements to our development capacities and bandwidth
(which supports advancing the other three factors).</li>
</ol>
<p>Here are the meaning of the impact levels, as related to each domains:</p>
<ul>
<li>High:
<ul>
<li>User / customer: Unblocks critical work</li>
<li>Mission: Advances critical organizational objectives</li>
<li>Invention: Opens up novel verification and specifications abilities</li>
<li>Development: Saves &gt; 3 hours per week</li>
</ul>
</li>
<li>Medium:
<ul>
<li>User / customer: Unblocks non-critical work</li>
<li>Mission: Advances non-critical organizational objectives</li>
<li>Invention: Makes incremental improvement to verification and specification
abilities</li>
<li>Development: Saves between 1 to 3 hours per week</li>
</ul>
</li>
<li>Low:
<ul>
<li>User / customer: Improves functionality, but an easy workaround exists</li>
<li>Mission: No significant advance of organizational objectives</li>
<li>Invention: No significant improvement to verification and specification abilities</li>
<li>Development: Saves &lt; 1 hours per week</li>
</ul>
</li>
</ul>
<p>These are the labels to use on issues:</p>
<table><thead><tr><th>Impact</th><th>Label</th></tr></thead><tbody>
<tr><td>Low</td><td><code>impact-low</code></td></tr>
<tr><td>Medium</td><td><code>impact-medium</code></td></tr>
<tr><td>High</td><td><code>impact-high</code></td></tr>
</tbody></table>
<h3><a class="header" href="#prioritization-and-evaluation" id="prioritization-and-evaluation">Prioritization and evaluation</a></h3>
<p>The initial priority of a requirement should be established at the time work is
agreed upon, including when setting plans quarterly and when triaging unplanned
work. All collaborators with a stake in the work are responsible for ensuring
the work is scored in a way that they feel to be correct.</p>
<p>When unplanned work is introduced, the stakeholders involved should determine
its score (using informal language, when needed), and this should be used to
decided whether it is worth interrupting any ongoing or planned work.</p>
<p>When deciding which work item to take on next, we should favor work that is
nearest to scoring minimum effort and maximum impact: (<code>effort-easy</code>,
<code>impact-high</code>). Ties should be resolved based on the worker's inclination or
discussions within other stakeholders.</p>
<p>The priority of work should be re-evaluated as the situation changes. E.g.:</p>
<ul>
<li>When goals change, then impact should be reconsidered.</li>
<li>If we discover work was incorrectly scoped, then the effort should be
reevaluted.</li>
</ul>
<p>We can generate views into the 4 quadrants via filters in our project board, or
any other tooling or visualization we find suitable. </p>
<p>When reviewing work in progress or queued up next at our weekly meetings, we
should always be sure that the highest priority work on the board is being
addressed. We should also take this time to estimate priorities for anything new
that came up on the week before that hasn't been prioritized already.</p>
<h2><a class="header" href="#consequences-7" id="consequences-7">Consequences</a></h2>
<p>TBD</p>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h1><a class="header" href="#adr-022-unify-configuration-management-and-pass-options" id="adr-022-unify-configuration-management-and-pass-options">ADR-022: Unify Configuration Management and &quot;Pass Options&quot;</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Shon Feder</td><td align="right">2022-08-15</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/022adr-unification-of-configs-and-options.html#summary">Summary (Overview)</a></li>
<li><a href="adr/022adr-unification-of-configs-and-options.html#context">Context (Problem)</a></li>
<li><a href="adr/022adr-unification-of-configs-and-options.html#options">Options (Alternatives)</a></li>
<li><a href="adr/022adr-unification-of-configs-and-options.html#solution">Solution (Decision)</a></li>
<li><a href="adr/022adr-unification-of-configs-and-options.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-9" id="summary-9">Summary</a></h2>
<p>In the context of extending Apalache's functionality and adding new features<br />
facing the need to reason about our program configuration and make execution thread safe<br />
we decided for unifying our CLI input with our configuration management system<br />
to achieve a more modular architecture and greater static guarantees<br />
accepting the development costs and possible increased cost of introducing new CLI inputs in the future.</p>
<h2><a class="header" href="#context-8" id="context-8">Context</a></h2>
<p>As work has proceeded on <a href="https://github.com/informalsystems/apalache/milestone/42">Shai</a>, following the design laid out in <a href="adr/./010rfc-transition-explorer.html">RFC 010</a>, it
has been revealed that we can provide value to the MBT team  by exposing the
current command line interface via RPC calls (see <a href="https://github.com/informalsystems/apalache/issues/2013">#2013</a>). This functionality
will require a way of receiving program configuration input from a gRPC call and
forwarding that configuration on to various pass executors.</p>
<p>Additionally, for a long while we have been aware of the limitations and
brittleness of our current system for storing and communicating configured
options throughout the paths of the program (see <a href="https://github.com/informalsystems/apalache/issues/1174">#1174</a>) and we have
recognized the value we might derive by unifying our CLI inputs with our
configuration management system (see <a href="https://github.com/informalsystems/apalache/issues/1177">#1177</a>).</p>
<h2><a class="header" href="#options-7" id="options-7">Options</a></h2>
<p>We considered trying to implement the needed RPCs without addressing <a href="https://github.com/informalsystems/apalache/issues/1174">#1174</a> and
<a href="https://github.com/informalsystems/apalache/issues/1177">#1177</a>, but two factors convinced us that these were legitimate pre-requisites:</p>
<ol>
<li>If we try to expose the current CLI functionality via RPC calls without first
introducing a unifying abstraction, any flag or option introduced on one side
(e.g., for the CLI) will require duplicated work the other side (e.g., for
the RPC). The high maintenance cost is liable to cause the two endpoints to drift.</li>
<li>The current method of communicating configured values to the rest of the
program is through an untyped, mutable, singleton map. This means the
configurations are not thread-safe, since mutation of the option map in a
concurrent RPC could change the configurations of another RPC call in
process.</li>
</ol>
<p>Thus, we resolved to proceed with unifying the CLI with configuration system
described in <a href="adr/./013adr-configuration.html">ADR 013</a>, and replacing the mutable, untyped option map
with an immutable, statically typed data structure representing the possible
configurable of our various routines.</p>
<h2><a class="header" href="#solution-7" id="solution-7">Solution</a></h2>
<p>Following <a href="adr/./013adr-configuration.html">ADR 013</a>, we introduced support for a limited set of configurable
values that could be read from either a config file or the CLI, and recorded in
an instance of the small <code>ApalacheConfig</code> class. However, the most CLI inputs
were fed directly into the options map, without interacting at all with the
configuration system.</p>
<p>To address factor (1) above, we have decided to make the communication of all
configurable inputs pass through an <code>ApalacheConfig</code>. As a special case, the CLI
is reworked to produce an instance of <code>ApalacheConfig</code>, which is then merged
with configurations from other sources, before being passed along to the various
process executors. Requiring that all program configuration be mapped through
the <code>ApalacheConfig</code> will enable us to automatically derive configurations from
incoming RPC data, and since any relevant updates to the CLI inputs will have to
be reflected in changes to the <code>ApalacheConfig</code>, we can be assured that the two
input methods will stay in sync.</p>
<p>To address (2), it would be enough replace the <code>PassOptions</code> map with the
<code>ApalacheConfig</code>, which could then be supplied directly to the process
executors. But two further considerations have lead us to adopt an additional
level of abstraction:</p>
<ol>
<li>In order to support merging of partial configurations (with fallback to
defaults), the values of the <code>ApalacheConfig</code> must all be <code>Optional</code>. However,
before we begin executing a process, we know what data the process will
<strong>require</strong>. If we just pass the <code>ApalacheConfig</code> directly, each process
would have to validate the presence of the needed data every time it wanted
to access a value.</li>
<li>Most processes only require a subset of the settings represented in
<code>ApalacheConfig</code>. If we pass the entire configuration to every process, we
would have no way of reasoning about what configurations affect which
process.</li>
</ol>
<p>To address these considerations, we will introduce a family of case classes
representing the sets of options required for a process. By narrowing down the
interface of the options required for an executor, we can specify statically
which configurations it depends on. In the process of mapping from
<code>ApalacheConfig</code> into the options classes, we can validate that all needed
values are present. As a result, by the time we begin executing the program
logic of a process, we'll have a static guarantee that all needed configurable
values are available.</p>
<p>The following diagram represents the data flow dependencies of the proposed
configuration system:</p>
<p><img src="adr/./022adr-apalache-configuration.drawio.svg" alt="" /></p>
<h2><a class="header" href="#consequences-8" id="consequences-8">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>TBD</p>
<h1><a class="header" href="#adr-023-trace-evaluation" id="adr-023-trace-evaluation">ADR-023: Trace evaluation</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">2022-09-28</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/023adr-trace-evaluation.html#summary">Summary (Overview)</a></li>
<li><a href="adr/023adr-trace-evaluation.html#context">Context (Problem)</a></li>
<li><a href="adr/023adr-trace-evaluation.html#options">Options (Alternatives)</a></li>
<li><a href="adr/023adr-trace-evaluation.html#solution">Solution (Decision)</a></li>
<li><a href="adr/023adr-trace-evaluation.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-10" id="summary-10">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>In the context of improving usability<br />
facing difficulties understanding counterexample traces<br />
we decided to implement trace evaluation<br />
to achieve a better user experience<br />
accepting the development costs.</p>
<h2><a class="header" href="#context-9" id="context-9">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>As explained in <a href="https://github.com/informalsystems/apalache/issues/1845">#1845</a>, one often runs into the problem of unreadable counterexamples; 
for complex specifications, it is often the case that either the state contains many variables, or the invariant contains many conjunctive components (or both).
In that case, trying to determine exactly why e.g. <code>A1 /\ ... /\ An</code> was violated basically boils down to manually evaluating each formula <code>Ai</code> with whatever variables are present in the state.
This is laborious and error-prone, and should be automated.</p>
<h2><a class="header" href="#options-8" id="options-8">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<ol>
<li>Call REPL in each state:
<ul>
<li>No convenient REPL integration at the moment</li>
<li>No clear way of saving outputs</li>
</ul>
</li>
<li>Encode trace traversal as an Apalache problem and use the solver
<ul>
<li>No additional rules or IO needed</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#solution-8" id="solution-8">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>We choose option (2). </p>
<p>Suppose we are given a trace <code>s_0 -&gt; s_1 -&gt; ... -&gt; s_n</code> over variables <code>x_1,...,x_k</code> as well as expressions <code>E_1,...,E_m</code>, such that all free variables of <code>E_1,...,E_m</code> are among <code>x_1,...,x_k</code>. W.l.o.g. assume all constants are inlined.</p>
<p>The above defines a trace <code>t_0 -&gt; t_1 -&gt; ... -&gt; t_n</code> over variables <code>v_1,...,v_m</code>, such that </p>
<pre><code>t_i.v_j = E_j[s_i.x_1/x_1,...,s_i.x_k/x_k]
</code></pre>
<p>for all <code>i \in 0..n, j \in 1..m</code>. In other words, <code>v_j</code> in state <code>t_i</code> is the evaluation of the expression <code>E_j</code> in state <code>s_i</code>.</p>
<p>By using transition filtering instead of a generic Next-decomposition, this can be encoded as a specification free of control-nondeterminism, in-state computation, or invariants, and is thus incredibly efficient to represent in SMT.</p>
<p>Then, the solver will naturally return an ITF trace containing the evaluations of <code>E_1,...,E_m</code> in each state <code>s_0,...,s_n</code> (the values of <code>v_1,...,v_m</code>).</p>
<h2><a class="header" href="#input" id="input">Input</a></h2>
<p>The invocation of the trace evaluation command should look like this:</p>
<pre><code class="language-sh">$ apalache-mc tracee --trace=&lt;trace&gt; --expressions=&lt;exprs&gt; &lt;source&gt;
</code></pre>
<p>where:</p>
<ul>
<li><code>&lt;trace&gt;</code> is a trace produced by apalache, in either <code>.tla</code>, <code>.json</code> or <code>.itf.json</code> formats</li>
<li><code>&lt;exprs&gt;</code> is a comma-separated list of expression names, to be evaluated over the trace provided by <code>--trace</code></li>
<li><source> is a valid apalache input source (`.tla` or `.json`), containing a specification over the same variables as the trace, with all of the expressions provided by `--expressions` as operator declarations
</li>
</ul>
<p>Note that <code>&lt;source&gt;</code> can just be the file used to produce the trace in the first place.</p>
<h2><a class="header" href="#output" id="output">Output</a></h2>
<p>The above command should produce an Apalache trace (in all available formats), with the following properties:</p>
<ul>
<li>The output trace length is equal to the input trace length</li>
<li>If <code>--expressions=E_1,...,E_m</code> is used, the variables of the output trace are <code>E_1,...,E_m</code>.</li>
<li>For all <code>i,j</code>, the value of <code>E_i</code> in state <code>j</code> of the output trace is equal to the evaluation of <code>E_i</code>, as defined in <code>&lt;source&gt;</code>, using the values the variables of the input trace hold in state <code>j</code> of the input trace.</li>
</ul>
<p>Recall that the output trace will only display the expressions <code>E_1,...E_m</code> as the output state variables. Should you wish to view the original trace variables, you need to add an expression, like one of the ones below for example:</p>
<pre><code class="language-tla">E_single == x_1
E_state == [ x1 |-&gt; x_1, ..., xk |-&gt; x_k ]
E_vars == &lt;&lt;x_1, ..., x_k&gt;&gt;
</code></pre>
<p>Optionally, we could investigate one of the following two alternatives to the output format:</p>
<ol>
<li>The output trace variables are <code>x_1,...,x_k,E_1,...,E_m</code> instead, where <code>x_1,...,x_k</code> are the variables of the original trace. The value of each variable from the input trace has the same value in every state of the output trace, as it does in the corresponding state of the input trace.
This is perhaps preferable to use with the <a href="https://github.com/informalsystems/vscode-itf-trace-viewer">ITF trace viewer</a>.</li>
<li>The output contains <em>both</em> the input trace and the output trace (as it would have been produced in the original suggestion) in the same file, but separately.</li>
</ol>
<h2><a class="header" href="#example-5" id="example-5">Example</a></h2>
<p>Assume we are given the source <code>test.tla</code></p>
<details>
<summary>Source</summary>
<pre><code class="language-tla">-------------------------- MODULE test -----------------------------

EXTENDS Integers

VARIABLE
  \* @type: Int;
  x

A == x * x
B == IF x &lt; 3 THEN 0 ELSE 1
C == [y \in {1,2,4} |-&gt; {y} ][x]
D == x % 2 = 0

Init == x = 1
Next == x' = x + 1

Inv == TRUE
  

=========================================================================
</code></pre>
</details>
<p>and trace <code>testTrace.json</code> (length 5, <code>x=1 -&gt; ... -&gt; x=5</code>).</p>
<details>
<summary>Trace</summary>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;ApalacheIR&quot;,
  &quot;version&quot;: &quot;1.0&quot;,
  &quot;description&quot;: &quot;https://apalache.informal.systems/docs/adr/005adr-json.html&quot;,
  &quot;modules&quot;: [
    {
      &quot;kind&quot;: &quot;TlaModule&quot;,
      &quot;name&quot;: &quot;counterexample&quot;,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;ConstInit&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Untyped&quot;,
            &quot;kind&quot;: &quot;ValEx&quot;,
            &quot;value&quot;: {
              &quot;kind&quot;: &quot;TlaBool&quot;,
              &quot;value&quot;: true
            }
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;State0&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;OperEx&quot;,
            &quot;oper&quot;: &quot;AND&quot;,
            &quot;args&quot;: [
              {
                &quot;type&quot;: &quot;Bool&quot;,
                &quot;kind&quot;: &quot;OperEx&quot;,
                &quot;oper&quot;: &quot;EQ&quot;,
                &quot;args&quot;: [
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;NameEx&quot;,
                    &quot;name&quot;: &quot;x&quot;
                  },
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;ValEx&quot;,
                    &quot;value&quot;: {
                      &quot;kind&quot;: &quot;TlaInt&quot;,
                      &quot;value&quot;: 1
                    }
                  }
                ]
              }
            ]
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;State1&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;OperEx&quot;,
            &quot;oper&quot;: &quot;AND&quot;,
            &quot;args&quot;: [
              {
                &quot;type&quot;: &quot;Bool&quot;,
                &quot;kind&quot;: &quot;OperEx&quot;,
                &quot;oper&quot;: &quot;EQ&quot;,
                &quot;args&quot;: [
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;NameEx&quot;,
                    &quot;name&quot;: &quot;x&quot;
                  },
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;ValEx&quot;,
                    &quot;value&quot;: {
                      &quot;kind&quot;: &quot;TlaInt&quot;,
                      &quot;value&quot;: 2
                    }
                  }
                ]
              }
            ]
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;State2&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;OperEx&quot;,
            &quot;oper&quot;: &quot;AND&quot;,
            &quot;args&quot;: [
              {
                &quot;type&quot;: &quot;Bool&quot;,
                &quot;kind&quot;: &quot;OperEx&quot;,
                &quot;oper&quot;: &quot;EQ&quot;,
                &quot;args&quot;: [
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;NameEx&quot;,
                    &quot;name&quot;: &quot;x&quot;
                  },
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;ValEx&quot;,
                    &quot;value&quot;: {
                      &quot;kind&quot;: &quot;TlaInt&quot;,
                      &quot;value&quot;: 3
                    }
                  }
                ]
              }
            ]
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;State3&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;OperEx&quot;,
            &quot;oper&quot;: &quot;AND&quot;,
            &quot;args&quot;: [
              {
                &quot;type&quot;: &quot;Bool&quot;,
                &quot;kind&quot;: &quot;OperEx&quot;,
                &quot;oper&quot;: &quot;EQ&quot;,
                &quot;args&quot;: [
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;NameEx&quot;,
                    &quot;name&quot;: &quot;x&quot;
                  },
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;ValEx&quot;,
                    &quot;value&quot;: {
                      &quot;kind&quot;: &quot;TlaInt&quot;,
                      &quot;value&quot;: 4
                    }
                  }
                ]
              }
            ]
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;State4&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;OperEx&quot;,
            &quot;oper&quot;: &quot;AND&quot;,
            &quot;args&quot;: [
              {
                &quot;type&quot;: &quot;Bool&quot;,
                &quot;kind&quot;: &quot;OperEx&quot;,
                &quot;oper&quot;: &quot;EQ&quot;,
                &quot;args&quot;: [
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;NameEx&quot;,
                    &quot;name&quot;: &quot;x&quot;
                  },
                  {
                    &quot;type&quot;: &quot;Int&quot;,
                    &quot;kind&quot;: &quot;ValEx&quot;,
                    &quot;value&quot;: {
                      &quot;kind&quot;: &quot;TlaInt&quot;,
                      &quot;value&quot;: 5
                    }
                  }
                ]
              }
            ]
          }
        },
        {
          &quot;type&quot;: &quot;() =&gt; Bool&quot;,
          &quot;kind&quot;: &quot;TlaOperDecl&quot;,
          &quot;name&quot;: &quot;InvariantViolation&quot;,
          &quot;formalParams&quot;: [
            
          ],
          &quot;isRecursive&quot;: false,
          &quot;body&quot;: {
            &quot;type&quot;: &quot;Bool&quot;,
            &quot;kind&quot;: &quot;ValEx&quot;,
            &quot;value&quot;: {
              &quot;kind&quot;: &quot;TlaBool&quot;,
              &quot;value&quot;: true
            }
          }
        }
      ]
    }
  ]
}
</code></pre>
</details>
<p>After running <code>tracee --trace=testTrace.json --expressions=A,B,C,D test.tla</code>, we should see</p>
<pre><code>...
Constructing an example run                                       I@16:06:59.450
Check the trace in: &lt;PATH&gt;/example0.tla, ... I@16:06:59.563
The outcome is: NoError                                           I@16:06:59.571
Trace successfully generated.   
</code></pre>
<p>where <code>example0.tla</code> looks like</p>
<details>
<summary>Result</summary>
<pre><code class="language-tla">---------------------------- MODULE counterexample ----------------------------

EXTENDS test

(* Constant initialization state *)
ConstInit == TRUE

(* Initial state *)
State0 == A = 1/\ B = 0/\ C = {1}/\ D = FALSE

(* Transition 0 to State1 *)
State1 == A = 4/\ B = 0/\ C = {2}/\ D = TRUE

(* Transition 1 to State2 *)
State2 == A = 9/\ B = 1/\ C = {}/\ D = FALSE

(* Transition 2 to State3 *)
State3 == A = 16/\ B = 1/\ C = {4}/\ D = TRUE

(* Transition 3 to State4 *)
State4 == A = 25/\ B = 1/\ C = {}/\ D = FALSE

(* The following formula holds true in the last state and violates the invariant *)
InvariantViolation == TRUE

================================================================================
(* Created by Apalache on Mon Oct 17 16:06:59 CEST 2022 *)
(* https://github.com/informalsystems/apalache *)
</code></pre>
</details> 
<h2><a class="header" href="#consequences-9" id="consequences-9">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<p>TBD</p>
<h1><a class="header" href="#adr-024-arena-computation-isolation" id="adr-024-arena-computation-isolation">ADR-024: Arena computation isolation</a></h1>
<table><thead><tr><th>authors</th><th align="right">last revised</th></tr></thead><tbody>
<tr><td>Jure Kukovec</td><td align="right">2023-04-20</td></tr>
</tbody></table>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="adr/024adr-arena-pass.html#summary">Summary (Overview)</a></li>
<li><a href="adr/024adr-arena-pass.html#context">Context (Problem)</a></li>
<li><a href="adr/024adr-arena-pass.html#options">Options (Alternatives)</a></li>
<li><a href="adr/024adr-arena-pass.html#solution">Solution (Decision)</a></li>
<li><a href="adr/024adr-arena-pass.html#consequences">Consequences (Retrospection)</a></li>
</ul>
<h2><a class="header" href="#summary-11" id="summary-11">Summary</a></h2>
<!-- Statement to summarize, following the following formula: -->
<p>In the context of addressing tech debt<br />
facing increasing difficulties understanding and modifying the BMC pass<br />
we decided to decouple arena construction from rewriting rules<br />
to achieve better modularity, readability, and maintainability <br />
accepting a reasonable time investment into refactoring.</p>
<h2><a class="header" href="#context-10" id="context-10">Context</a></h2>
<!-- Communicates the forces at play (technical, political, social, project).
     This is the story explaining the problem we are looking to resolve.
-->
<p>The core of the model checking pass -- the rewriting rules -- have shown to be a significant hurdle to onboarding, maintenance and modification efforts (e.g. <a href="https://github.com/informalsystems/apalache/issues/1774">#1774</a>, <a href="https://github.com/informalsystems/apalache/issues/2338">#2338</a>).
Relevant for this ADR is the fact that rewriting rules do multiple things at once, which are difficult to separate. They:</p>
<ol>
<li>Modify arenas</li>
<li>Push constraints into SMT</li>
<li>Manipulate bindings</li>
</ol>
<p>Most notably, we have an interaction between arenas and SMT; adding edges to an arena sometimes results in the creation of new SMT variables, or the assertion of new SMT constraints.
As a result, arenas are incredibly fragile, as it becomes easy to inadvertently create problematic constraints, e.g. by forgetting to manually create SMT constants before using them, or by omitting an assertion which was expected with a given change to the arena.</p>
<p>However, we observe that this relationship should, theoretically, be unidirectional; access to SMT is not required in order to correctly construct an arena for a given BMC problem (though finding a model, or lack thereof, requires the generation of SMT constraints, based off the arena).</p>
<p>This ADR seeks to explore ways in which arena construction and SMT concerns may be separated.</p>
<h2><a class="header" href="#options-9" id="options-9">Options</a></h2>
<!-- Communicate the options considered.
     This records evidence of our circumspection and documents the various alternatives
     considered but not adopted.
-->
<ol>
<li>Redesign the interface of rewriting rules/arenas/solver contexts, to better identify interactions with mutable state. Rewriting rules only get access to a limited mutable state interface, and all the interactions between SMT and arenas are pushed out of the rules, into the mutable state implementation.</li>
<li>Extract arena generation into a separate static analysis pass. Change the rewriting rules, such that they read from a fixed arena object on demand. Optionally also abstract discharging constraints, to relieve the dependency on Z3-specific constructs.</li>
<li>Compute arenas and generate SMT constraints in a single tree-exploration pass, but stratify the rewriting rules, such that arena generation and SMT operators for a given rule are clearly separated.</li>
</ol>
<h2><a class="header" href="#solution-9" id="solution-9">Solution</a></h2>
<!-- Communicates what solution was decided, and it is expected to solve the
     problem. -->
<p>After initially exploring <a href="adr/024adr-arena-pass.html#consequences">(2)</a>, we have decided to ultimately implement option (3). The reasons for this decision are threefold:</p>
<ul>
<li>Memory: As this exploration traverses the tree exactly once, no persistent storage between passes ever needs to exist, and thus the memory footprint is greatly reduced. Additionally, during performance discussions, we have come to the realization that computing and holding the entire arena in memory, as the current implementation does, is actually unnecessary. In fact, only a sub-arena, describing the relevant relations of the cells belonging to an expression sub-tree is ever needed in the scope of that sub-tree.</li>
<li>Separation of concerns: While arena generation and SMT aren't separated on the level of a pass, they are still clearly separated within each node exploration step, reaping the benefits of readability and maintainability all the same. Additionally, this form allows us to handle SMT encoding variations (e.g. arrays vs non-arrays) much more elegantly.</li>
<li>Reduced refactoring effort: The final form of the new rules will be syntactically much closer to the current rules, and have a much smaller penalty on incremental change, and our ability to compare and evaluate the changes.</li>
</ul>
<h2><a class="header" href="#illustration" id="illustration">Illustration</a></h2>
<p>Let us use an example rewriting rule, and visualize the difference between the approaches. Take, for instance <code>SetCupRule</code>, the rule used in translating the union of two sets.
Currently, the sequence diagram for this rule looks like this (with the OOPSLA19 encoding): 
<img src="adr/seqDiaBefore.png" alt="" /></p>
<p>Of note are the multiple calls needed to mutate and read from <code>SymbState</code>, as well as the <code>PureArenaAdapter</code> wrapper, which connects arena generation to SMT solving.
Observe also, that calls to <code>Z3SolverContext</code> happen at multiple points, in between other code (in part due to <code>PureArenaAdapter</code>).</p>
<p>Under (3), the same rule would look more like this:
<img src="adr/seqDiaAfter.png" alt="" /></p>
<p>Specifically, we would no longer need <code>PureArenaAdapters</code>, and we could drop the parts of <code>SymbState</code>, which are treated as mutable (the <code>TlaEx</code> value). In the above, <code>RewriterScope</code> is what remains of <code>SymbState</code>, when we remove the <code>TlaEx</code> value.</p>
<p>A prototype implementation can be found in <a href="https://github.com/informalsystems/apalache/pull/2554">this PR</a>.</p>
<h2><a class="header" href="#consequences-10" id="consequences-10">Consequences</a></h2>
<!-- Records the results of the decision over the long term.
     Did it work, not work, was changed, upgraded, etc.
-->
<h3><a class="header" href="#isolated-arena-pass" id="isolated-arena-pass">Isolated arena pass</a></h3>
<p>We initially explored option (2), as we believed it best embodied the &quot;separation of concerns&quot; principle. 
Additionally, the idea was that removing arena computation from the rewriting rules should simplify the rules and result in more clarity, readability, and maintainability.
A prototype can be found <a href="https://github.com/informalsystems/apalache/tree/jk/arenaSeparationProto/tla-pp/src/main/scala/at/forsyte/apalache/tla/pp/arenas">here</a>.</p>
<p>However, separating arena computation into its own pass introduced a new issue, the propagation of information between the arena computation pass and the SMT translation pass that would follow it.
In <a href="https://github.com/informalsystems/apalache/pull/2467">Notes</a> one can find a more in-depth explanation of the issue and its solutions.
In a nutshell, the problem was that, to retain information from ephemeral expressions, and tie it back to the original syntax tree, we would need a map-of-maps data structure (in the theoretical sense, there potentially exist more efficient tree-like structures at the level of implementation detail, but not by a significant order of magnitude).
Between the two passes, this data structure needs to be stored either in memory or to a file (and read later).</p>
<p>Compared to that, the single-traversal approach of the current rewriting rules
actually has a much better memory footprint, since only the information relevant to the current sub-tree scope needs to be retained.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="./highlightjs-tlaplus/dist/tlaplus.min.js"></script>
        
        <script type="text/javascript" src="./theme/highlightTla.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
