<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apalache Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/snowcat-tutorial.html"><strong aria-hidden="true">1.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="apalache/index.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="apalache/getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/apalache-or-tlc.html"><strong aria-hidden="true">3.1.</strong> Shall I use Apalache or TLC?</a></li><li class="chapter-item expanded "><a href="apalache/system-reqs.html"><strong aria-hidden="true">3.2.</strong> System Requirements</a></li><li class="chapter-item expanded "><a href="apalache/installation/index.html"><strong aria-hidden="true">3.3.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apalache/installation/jvm.html"><strong aria-hidden="true">3.3.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="apalache/installation/docker.html"><strong aria-hidden="true">3.3.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="apalache/installation/source.html"><strong aria-hidden="true">3.3.3.</strong> Source</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/running.html"><strong aria-hidden="true">3.4.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="apalache/statistics.html"><strong aria-hidden="true">3.5.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="apalache/example.html"><strong aria-hidden="true">3.6.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="apalache/parameters.html"><strong aria-hidden="true">3.7.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="apalache/principles.html"><strong aria-hidden="true">3.8.</strong> Principles of Symbolic Model Checking with Apalache</a></li><li class="chapter-item expanded "><a href="apalache/apalache-mod.html"><strong aria-hidden="true">3.9.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="apalache/profiling.html"><strong aria-hidden="true">3.10.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="apalache/theory.html"><strong aria-hidden="true">3.11.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="apalache/tlc-config.html"><strong aria-hidden="true">4.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="apalache/typechecker-snowcat.html"><strong aria-hidden="true">5.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="apalache/features.html"><strong aria-hidden="true">6.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="apalache/known-issues.html"><strong aria-hidden="true">7.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="apalache/preprocessing.html"><strong aria-hidden="true">8.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="apalache/tuning.html"><strong aria-hidden="true">9.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="apalache/kera.html"><strong aria-hidden="true">10.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded "><a href="apalache/assignments.html"><strong aria-hidden="true">11.</strong> Assignments in Apalache</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="HOWTOs/index.html"><strong aria-hidden="true">12.</strong> Overview</a></li><li class="chapter-item expanded "><a href="HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">13.</strong> How to write type annotations</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">14.</strong> Overview</a></li><li class="chapter-item expanded "><a href="tutorials/snowcat-tutorial.html"><strong aria-hidden="true">15.</strong> The Snowcat‚ùÑüê± Type Checker</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="lang/index.html"><strong aria-hidden="true">16.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="lang/standard-operators.html"><strong aria-hidden="true">17.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/booleans.html"><strong aria-hidden="true">17.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="lang/control-and-nondeterminism.html"><strong aria-hidden="true">17.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="lang/conditionals.html"><strong aria-hidden="true">17.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="lang/integers.html"><strong aria-hidden="true">17.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="lang/sets.html"><strong aria-hidden="true">17.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="lang/logic.html"><strong aria-hidden="true">17.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="lang/functions.html"><strong aria-hidden="true">17.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="lang/records.html"><strong aria-hidden="true">17.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="lang/tuples.html"><strong aria-hidden="true">17.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="lang/sequences.html"><strong aria-hidden="true">17.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="lang/user-operators.html"><strong aria-hidden="true">18.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/user/top-level-operators.html"><strong aria-hidden="true">18.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/let-in.html"><strong aria-hidden="true">18.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="lang/user/higher-order-operators.html"><strong aria-hidden="true">18.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="lang/user/lambdas.html"><strong aria-hidden="true">18.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/recursive-operators.html"><strong aria-hidden="true">18.5.</strong> Recursive operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/local-operators.html"><strong aria-hidden="true">18.6.</strong> Local operator definitions</a></li><li class="chapter-item expanded "><a href="lang/user/recursive-functions.html"><strong aria-hidden="true">18.7.</strong> Recursive functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="idiomatic/index.html"><strong aria-hidden="true">20.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">21.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="idiomatic/001assignments.html"><strong aria-hidden="true">22.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="idiomatic/002primes.html"><strong aria-hidden="true">23.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="adr/002adr-types.html"><strong aria-hidden="true">24.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="adr/004adr-annotations.html"><strong aria-hidden="true">25.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="adr/006rfc-unit-testing.html"><strong aria-hidden="true">26.</strong> RFC-006: unit tests and property-based tests</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>This book collects five related, but independent, sets of documentation:</p>
<ol>
<li><a href="./apalache/index.html">The Apalache User Manual</a></li>
<li><a href="./tutorials/index.html">Apalache Tutorials</a></li>
<li><a href="./HOWTOs/index.html">Apalache HOWTOs</a></li>
<li><a href="./lang/index.html">A TLA+ Language Reference Manual</a></li>
<li><a href="./idiomatic/index.html">Guidelines for Idiomatic TLA+</a></li>
</ol>
<h1><a class="header" href="#tutorial-on-the-snowcat-type-checker" id="tutorial-on-the-snowcat-type-checker">Tutorial on the Snowcat‚ùÑüê± Type Checker</a></h1>
<p>In this tutorial, we introduce the Snowcat ‚ùÑ üê± type checker
We give concrete steps on running the type checker and
annotating a specification with types.</p>
<h2><a class="header" href="#related-documents" id="related-documents">Related documents</a></h2>
<ul>
<li><a href="tutorials/../adr/002adr-types.html">ADR002</a> that introduces Type System 1, which is used by Snowcat.</li>
<li>A more technical <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type annotations</a>.</li>
<li><a href="tutorials/../adr/004adr-annotations.html">ADR004</a> that introduces Java-like annotations in TLA+ comments.</li>
</ul>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>We assume that you have Apalache installed. If not, check the manual page on
<a href="tutorials/../apalache/installation/index.html">Apalache installation</a>. The minimal required version is 0.15.0.</p>
<h2><a class="header" href="#running-example-two-phase-commit" id="running-example-two-phase-commit">Running example: Two-phase commit</a></h2>
<p>As a running example, we are using the well-understood specification of
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit">Two-phase commit</a> by <a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (written by <a href="https://members.loria.fr/Stephan.Merz/">Stephan Merz</a>). We
recommend to reproduce the steps in this tutorial. So, go ahead and download
two specification files: <a href="https://github.com/tlaplus/Examples/blob/911dac1462344337940779a797a5f329a77be98c/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> and <a href="https://github.com/tlaplus/Examples/blob/911dac1462344337940779a797a5f329a77be98c/specifications/transaction_commit/TCommit.tla">TCommit.tla</a>.</p>
<h2><a class="header" href="#step-1-running-snowcat" id="step-1-running-snowcat">Step 1: Running Snowcat</a></h2>
<p>Before we start writing any type annotations, let's run the type checker and
see, whether it complains:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>The tool output is a bit verbose. Below, you can see the important lines of the
output:</p>
<pre><code>...
PASS #1: TypeCheckerSnowcat
 &gt; Running Snowcat .::.
[TwoPhase.tla:51:30-51:31]: Undefined name RM. Introduce a type annotation.
 &gt; Snowcat asks you to fix the types. Meow.
... 
</code></pre>
<h2><a class="header" href="#step-2-annotating-rm" id="step-2-annotating-rm">Step 2: Annotating RM</a></h2>
<p>In Step 1, Snowcat complained about the name <code>RM</code>. The reason
for that is very simple: Snowcat does type analysis for each declaration in
isolation. Hence, it failed, as soon as it met a reference to the constant
<code>RM</code> in the definition of <code>Message</code>:</p>
<pre><code class="language-tla">CONSTANT RM \* The set of resource managers
...

Message ==
  ...
  [type : {&quot;Prepared&quot;}, rm : RM]  \cup  [type : {&quot;Commit&quot;, &quot;Abort&quot;}]
</code></pre>
<p>Indeed, we have not introduced a type annotation for the constant <code>RM</code>, so the
type checker cannot use any meaningful type in the context of the above
expression.</p>
<p>From the comment next to the declaration of <code>RM</code>, we see that <code>RM</code> is supposed
to be a set of resource managers. We have plenty of choices here of what a
resource manager could be. Let's keep it simple and say that a resource manager
is simply a name. Hence, we say that <code>RM</code> is a set of strings. Let's add a 
type annotation:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(Str);
    RM \* The set of resource managers
</code></pre>
<p>Note that we had to put the annotation between the keyword <code>CONSTANT</code> and the
identifier <code>RM</code>. We used the one-line TLA+ comment: <code>\* @type: ...;</code>.
Alternatively, we could use the multi-line comment: <code>(* @type: Set(Str); *)</code>.
Importantly, the type annotation should end with a semi-colon: <code>;</code>.</p>
<p><strong>Warning</strong>. If you want to write a type annotation on multiple lines, write it
in a multi-line comment <code>(* ... *)</code> instead of starting multiple lines with a
single-line comment <code>\* ...</code>. See <a href="https://github.com/informalsystems/apalache/issues/718">issue
718</a>.</p>
<h2><a class="header" href="#step-3-running-snowcat-again" id="step-3-running-snowcat-again">Step 3: Running Snowcat again</a></h2>
<p>Having introduced the type annotation for <code>RM</code>, let's run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>Snowcat does not complain about <code>RM</code> anymore. Now we get another message:</p>
<pre><code>[TwoPhase.tla:68:6-68:12]: Undefined name rmState. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-4-annotating-rmstate" id="step-4-annotating-rmstate">Step 4: Annotating rmState</a></h2>
<p>Similar to Step 2, we are missing a type annotation. This time the type checker
complains about the variable <code>rmState</code>:</p>
<pre><code class="language-tla">VARIABLES
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
</code></pre>
<p>We can get a hint about the type of <code>rmState</code> from the type invariant
<code>TPTypeOK</code>. It should be a function that, given a resource manager, produces
one of the following strings: <code>&quot;working&quot;</code>, <code>&quot;prepared&quot;</code>, <code>&quot;committed&quot;</code>,
<code>&quot;aborted&quot;</code>. So we need the function type: <code>Str -&gt; Str</code>. Add the following
type annotation:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: Str -&gt; Str;
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
</code></pre>
<h2><a class="header" href="#step-5-getting-one-more-type-error-by-snowcat" id="step-5-getting-one-more-type-error-by-snowcat">Step 5: Getting one more type error by Snowcat</a></h2>
<p>Guess what? Run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>Snowcat does not complain about <code>rmState</code> anymore. But we are not done yet:</p>
<pre><code>[TwoPhase.tla:70:6-70:12]: Undefined name tmState. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-6-annotating-tmstate" id="step-6-annotating-tmstate">Step 6: Annotating tmState</a></h2>
<p>This time we need a type annotation for the variable <code>tmState</code>. By inspecting
<code>TPTypeOK</code>, we see that <code>tmState</code> is just a string. Add the following type
annotation:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Str;  
  tmState,       \* The state of the transaction manager.
</code></pre>
<h2><a class="header" href="#step-7-running-snowcat-to-see-another-error" id="step-7-running-snowcat-to-see-another-error">Step 7: Running Snowcat to see another error</a></h2>
<p>Run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>You must have guessed that the type checker complains about the variable
<code>tmPrepared</code>. Indeed, it just needs annotations for all CONSTANTS and
VARIABLES:</p>
<pre><code>[TwoPhase.tla:72:6-72:15]: Undefined name tmPrepared. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-8-annotating-tmprepared" id="step-8-annotating-tmprepared">Step 8: Annotating tmPrepared</a></h2>
<p>At this step, we have to annotate <code>tmPrepared</code>. Let's have a look at the comment
next to the declaration of <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  ...
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<p>Hence, <code>tmPrepared</code> is a set of resource managers. This is what we write as a
type annotation:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Set(Str);
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<h2><a class="header" href="#step-9-running-snowcat-again" id="step-9-running-snowcat-again">Step 9: Running Snowcat again</a></h2>
<p>You know that we have to run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>It is no surprise that it complains about the variable <code>msgs</code> now:</p>
<pre><code>[TwoPhase.tla:74:6-74:9]: Undefined name msgs. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-10-annotating-msgs" id="step-10-annotating-msgs">Step 10: Annotating msgs</a></h2>
<p>In the previous steps, it was quite easy to annotate variables. We would just
look at how the variable is used, or read the comments, and add a type annotation.
Figuring out the type of <code>msgs</code> is a bit harder.</p>
<p>Let's look at the definitions of <code>Messages</code> and <code>TPTypeOK</code>:</p>
<pre><code class="language-tla">Message ==
  ...
  [type : {&quot;Prepared&quot;}, rm : RM]  \cup  [type : {&quot;Commit&quot;, &quot;Abort&quot;}]

TPTypeOK ==  
  ...  
  /\ msgs \subseteq Message
</code></pre>
<p>Now you should be able to see that <code>msgs</code> is a set that may contain three
kinds of records:</p>
<ol>
<li>The record <code>[type |-&gt; &quot;Commit&quot;]</code>,</li>
<li>The record <code>[type |-&gt; &quot;Abort&quot;]</code>,</li>
<li>A record <code>[type |-&gt; &quot;Prepared&quot;, rm |-&gt; r]</code>, for some <code>r \in RM</code>.</li>
</ol>
<p>This looks like an issue for the type checker, as it always requires
the set elements to have the same type. However, the type checker
did not complain about the expressions in <code>Message</code> and <code>TPTypeOK</code>. Why?</p>
<p>Actually, the type checker allows records to be generalized to a type that
contains additional fields. In the above definition of <code>Messages</code>, the set of
records <code>[type: {&quot;Prepared&quot;}, rm: RM]</code> has the type <code>Set([type: Str, rm: Str])</code>.  (Note that the record has the field called &quot;type&quot;, which has nothing
to do with our types.) Likewise, the set of records <code>[type: {&quot;Commit&quot;, &quot;Abort&quot;}]</code> has the type <code>Set([type: Str])</code>. Both of these types can be unified
to the common type:</p>
<pre><code>Set([type: Str, rm: Str])
</code></pre>
<p>The above type is actually what we need for the variable <code>msgs</code>. Let's annotate
the variable with this type:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Set([type: Str, rm: Str]);
  msgs
</code></pre>
<h2><a class="header" href="#step-11-running-snowcat-and-seeing-no-errors" id="step-11-running-snowcat-and-seeing-no-errors">Step 11: Running Snowcat and seeing no errors</a></h2>
<p>Let's see whether Snowcat is happy about our types now:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>The type checker is happy. It has computed the types of all expressions:</p>
<pre><code> &gt; Running Snowcat .::.
 &gt; Your types are great!
 &gt; All expressions are typed
</code></pre>
<h1><a class="header" href="#discussion" id="discussion">Discussion</a></h1>
<p>To see the complete code, check <a href="tutorials/./TwoPhase.tla">TwoPhase.tla</a>. Note that we
have not touched the file <code>TCommit.tla</code> at all! The type checker has figured
out all the types in it by itself. We have added five type annotations for 248
lines of code. Not bad.</p>
<p>It was quite easy to figure out the types of constants and variables in our
example. As a rule, you always have to annotate constants and variables with
types. Hence, we did not have to run the type checker five times to see the
error messages.</p>
<p>Sometimes, the type checker cannot find a unique type of an expression. This
usually happens when you declare an operator of a parameter that can be: a
function, a tuple, a record, or a sequence (or a subset of these four types
that has at least two elements). For instance, here is a definition from
<a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/GameOfLifeTyped.tla">GameOfLifeTyped.tla</a>:</p>
<pre><code class="language-tla">Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<p>Although it is absolutely clear that <code>x</code> and <code>y</code> have the type <code>Int</code>,
the type of <code>&lt;&lt;x, y&gt;&gt;</code> is ambiguous. This expression can either be
a tuple <code>&lt;&lt;Int, Int&gt;&gt;</code>, or a sequence <code>Seq(Int)</code>. In this case, we have to
help the type checker by annotating the operator definition:</p>
<pre><code class="language-tla">\* @type: () =&gt; Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<p>Since it is common to have operators that take no arguments, Snowcat supports
the following syntax sugar:</p>
<pre><code class="language-tla">\* @type: Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>For more advanced type annotations, check the following examples:</p>
<ul>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/CigaretteSmokersTyped.tla">CigaretteSmokersTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/CarTalkPuzzleTyped.tla">CarTalkPuzzleTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/FunctionsTyped.tla">FunctionsTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/QueensTyped.tla">QueensTyped.tla</a>.</li>
</ul>
<p>We have not discussed type aliases, which are a more advanced feature of the
type checker. To learn about type aliases, see <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type
annotations</a>.</p>
<p>If you are experiencing a problem with Snowcat, feel free to <a href="https://github.com/informalsystems/apalache/issues">open an issue</a>
or drop us a message on <a href="https://informal-systems.zulipchat.com/login/#narrow/stream/265309-apalache">Zulip chat</a>.</p>
<h1><a class="header" href="#apalache-manual" id="apalache-manual">Apalache Manual</a></h1>
<p><strong>Authors: Igor Konnov, Jure Kukovec, Andrey Kuprianov, Shon Feder</strong></p>
<p><strong>Contact: {igor,andrey,shon} at informal.systems, jkukovec at forsyte.at</strong></p>
<p>Apalache is a symbolic model checker for
<a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+</a>. (<em>Still looking for a
better tool name.</em>) Our model checker is a recent alternative to
<a href="https://lamport.azurewebsites.net/tla/tools.html?unhideBut=hide-tlc&amp;unhideDiv=tlc">TLC</a>.
Whereas TLC enumerates the states produced by the behaviors of a TLA+
specification, Apalache translates the verification problem to a set of logical
constraints. These constraints are solved by an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT
solver</a>, for
instance, by <a href="https://github.com/Z3Prover/z3">Microsoft's Z3</a>. That is, Apalache
operates on formulas (i.e., <em>symbolicly</em>), not by enumerating states one by one
(i.e., <em>state enumeration</em>).</p>
<p>Apalache is working under the following assumptions:</p>
<ol>
<li>As in TLC, all specification parameters are fixed and finite, i.e., the
system state is initialized with integers, finite sets, and functions of
finite domains and co-domains.</li>
<li>As in TLC, all data structures evaluated during an execution are finite,
e.g., a system specification cannot operate on the set of all integers.</li>
<li>Only finite executions of bounded length are analyzed.</li>
</ol>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This section covers all the basic information you need to get started with the
Apalache model checker.</p>
<p>If you just need to get the model checker up and running, you can jump to</p>
<ul>
<li><a href="apalache/./installation/index.html">Installation</a></li>
<li><a href="apalache/./running.html">Running the Tool</a></li>
</ul>
<h1><a class="header" href="#shall-i-use-apalache-or-tlc" id="shall-i-use-apalache-or-tlc">Shall I use Apalache or TLC?</a></h1>
<p>We recommend starting with TLC. It is mature, well-documented, and
well-integrated into TLA+ Toolbox. Once you have debugged your TLA+
specification, and TLC is still producing too many reachable states, switch to
Apalache. We are using this approach at <a href="https://informal.systems/">Informal
Systems</a>.</p>
<h1><a class="header" href="#system-requirements" id="system-requirements">System requirements</a></h1>
<p>Every commit to <a href="https://github.com/informalsystems/apalache">master</a> and
<a href="https://github.com/informalsystems/apalache/tree/unstable">unstable</a> is built
with <a href="https://github.com/informalsystems/apalache/actions?query=branch%3Aunstable+workflow%3Abuild">GitHub
actions</a>
on MacOS (JDK 1.8.0) and Linux (OpenJDK8). If you would like to run Apalache in
Windows, use a docker image. Check the <a href="https://docs.docker.com/docker-for-windows/">Docker
manual</a> and the section on <a href="apalache/./installation/docker.html">Using
a docker image</a> for details.</p>
<p>As Apalache is using Microsoft Z3 as a backend SMT solver, the required memory
largely depends on Z3. We recommend to allocate at least 4GB of memory for the
tool.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>There are three ways to run Apalache:</p>
<ol>
<li><a href="apalache/installation/./jvm.html">JVM</a>: download a prebuilt package and run it in the JVM.</li>
<li><a href="apalache/installation/./docker.html">Docker</a>: download and run a Docker image.</li>
<li><a href="apalache/installation/./source.html">Source</a>: build Apalache from sources and run the compiled package.</li>
</ol>
<p>If you just want to try the tool, we recommend <a href="apalache/installation/./jvm.html">downloading the
release</a> or <a href="apalache/installation/./docker.html">pulling the docker image</a>. If you would like
to run the tool on a daily basis or <a href="https://github.com/informalsystems/apalache/blob/unstable/CONTRIBUTING.md">contribute</a> to the project, we recommend
<a href="apalache/installation/./source.html">building the project from the source</a>.</p>
<h1><a class="header" href="#running-in-java-virtual-machine" id="running-in-java-virtual-machine">Running in Java Virtual Machine</a></h1>
<p>You have to download and install a Java Virtual Machine first. For instance,
<a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> should work (we tried Apalache with
OpenJDK 11 and OpenJDK 15).</p>
<p>Once you have installed Java, download the <a href="https://github.com/informalsystems/apalache/releases">latest
release</a> and unpack into
a directory of your choice. Depending on your OS, you have two options.</p>
<p><em>Option 1: Linux, MacOS.</em> You can run the script <code>./bin/apalache-mc</code>. It is
that simple.</p>
<p><em>Option 2: Windows.</em> You have to run Java directly:</p>
<ul>
<li>
<p>Check the application name in the directory <code>mod-distribution\target</code>.
It should be called <code>apalache-pkg-X.Y.Z-RELEASE-full.jar</code>, where <code>X.Y.Z</code>
is the release number, for instance, 0.8.0.</p>
</li>
<li>
<p>Run Java as follows:</p>
</li>
</ul>
<pre><code>java.exe -jar mod-distribution\target\apalache-pkg-X.Y.Z-RELEASE-full.jar &lt;args&gt;
</code></pre>
<p>The arguments <code>&lt;args&gt;</code> are explained in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
<p>If you would like to contribute a command-line script for running Apalache in
Windows, please <a href="https://github.com/informalsystems/apalache/blob/unstable/CONTRIBUTING.md#making-a-pull-request">open a pull
request</a>.</p>
<h1><a class="header" href="#using-a-docker-image" id="using-a-docker-image">Using a docker image</a></h1>
<p><strong>We publish Docker images for every release</strong> üòé</p>
<p><a href="https://www.docker.com/">Docker</a> lets you to run Apalache in an isolated container.
All dependencies are already installed in docker. However, you have to install docker.</p>
<p>To get the latest Apalache image, issue the command:</p>
<pre><code class="language-bash">docker pull apalache/mc
</code></pre>
<h2><a class="header" href="#running-the-docker-image" id="running-the-docker-image">Running the docker image</a></h2>
<p>To run an Apalache image, issue the command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache apalache/mc &lt;args&gt;
</code></pre>
<p>The following docker parameters are used:</p>
<ul>
<li>
<p><code>--rm</code> to remove the container on exit</p>
</li>
<li>
<p><code>-v &lt;your-spec-directory&gt;:/var/apalache</code> bind-mounts <code>&lt;your-spec-directory&gt;</code> into
<code>/var/apalache</code> in the container. <strong>This is necessary for
Apalache to access your specification and the modules it
extends.</strong>
From the user perspective, it works as if Apalache was
executing in <code>&lt;your-spec-directory&gt;</code>.
In particular the tool logs are written in that directory.</p>
<p>When using SELinux, you might have to use the modified form of <code>-v</code> option:
<code>-v &lt;your-spec-directory&gt;:/var/apalache:z</code></p>
</li>
<li>
<p><code>apalache/mc</code> is the APALACHE docker image name. By default, the <code>latest</code> stable
version is used; you can also refer to a specific tool version, e.g., <code>apalache/mc:0.6.0</code> or <code>apalache/mc:unstable</code></p>
</li>
<li>
<p><code>&lt;args&gt;</code> are the tool arguments as described in <a href="apalache/installation/../running.html">Running the Tool</a>.</p>
</li>
</ul>
<p>We provide a convenience wrapper for this docker command in
<code>script/run-docker.sh</code>. To run the <code>latest</code> image using the script, execute</p>
<pre><code class="language-bash">$ $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<p>To specify a different image, set <code>APALACHE_TAG</code> like so:</p>
<pre><code class="language-bash">$ APALACHE_TAG=foo $APALACHE_HOME/script/run-docker.sh &lt;args&gt;
</code></pre>
<h2><a class="header" href="#setting-an-alias" id="setting-an-alias">Setting an alias</a></h2>
<p>If you are running Apalache on Linux üêß or MacOS
üçè, you can define this handy alias in your rc file, which runs
Apalache in docker while sharing the working directory:</p>
<pre><code class="language-bash">
###### using the latest stable

$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc'

###### using the latest unstable

$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc:unstable'
</code></pre>
<h2><a class="header" href="#using-the-unstable-version-of-apalache" id="using-the-unstable-version-of-apalache">Using the unstable version of Apalache</a></h2>
<p>The development of Apalache proceeds at a high pace, and we introduce a
substantial number of improvements in the unstable branch before the next stable
release. Please refer to the <a href="https://github.com/informalsystems/apalache/blob/unstable/CHANGES.md">change
log</a> and
<a href="https://github.com/informalsystems/apalache/blob/unstable/docs/src/manual.md">manual</a>
on the unstable branch for the description of the newest features. <strong>We
recommend using the unstable version if you want to try all the exciting new
features of Apalache. But be warned: It is called &quot;unstable&quot; for a reason</strong>. To
use <code>unstable</code>, just type <code>apalache/mc:unstable</code> instead of <code>apalache/mc</code>
everywhere.</p>
<p>Do not forget to pull the docker image from time to time:</p>
<pre><code class="language-bash">docker pull apalache/mc:unstable
</code></pre>
<p>Run it with the following command:</p>
<pre><code class="language-bash">$ docker run --rm -v &lt;your-spec-directory&gt;:/var/apalache apalache/mc:unstable &lt;args&gt;
</code></pre>
<p>To create an alias pointing to the <code>unstable</code> version:</p>
<pre><code class="language-bash">$ alias apalache='docker run --rm -v $(pwd):/var/apalache apalache/mc:unstable'
</code></pre>
<h2><a class="header" href="#building-an-image" id="building-an-image">Building an image</a></h2>
<p>For an end user there is no need to build an Apalache image. If you like to
produce a modified docker image, take into account that it will take about 30
minutes for the image to get built, due to compilation times of Microsoft Z3. To
build a docker image of Apalache, issue the following command in
<code>$APALACHE_HOME</code>:</p>
<pre><code class="language-bash">$ docker image build -t apalache:0.7.0 .
</code></pre>
<h1><a class="header" href="#building-from-source" id="building-from-source">Building from source</a></h1>
<ol>
<li>Install <code>git</code>.</li>
<li>Install <a href="https://openjdk.java.net/install/">OpenJDK8</a> or <a href="https://www.azul.com/downloads/zulu-community/?version=java-8-lts&amp;architecture=x86-64-bit&amp;package=jdk">Zulu JDK8</a>.
<ul>
<li>Apalache currently requires Scala 12.0 so <strong>you must install version 8 of
Java, otherwise Scala will not compile!</strong> See the <a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">compatibility table</a>.</li>
</ul>
</li>
<li>Install <a href="https://maven.apache.org/">Apache Maven</a>.
<ul>
<li>On Debian Linux or Ubuntu: <code>sudo apt-get install maven</code>.</li>
<li>On Arch: <code>sudo pacman -Syu maven</code></li>
</ul>
</li>
<li>Clone the git repository: <code>git clone https://github.com/informalsystems/apalache.git</code>.</li>
<li>Change into the project directory: <code>cd apalache</code>.</li>
<li>Run <code>make</code>.
<ul>
<li>For a slightly faster build, you can run <code>make apalache-jar</code></li>
</ul>
</li>
<li><em>Optionally</em> install <a href="https://direnv.net/">direnv</a> and run <code>direnv allow</code></li>
<li>Confirm you can run the executable. It should print the inline CLI help message.
<ul>
<li>If you used <code>direnv</code>, then <code>apalache-mc</code> will be in your path.</li>
<li>Otherwise, run <code>./bin/apalache-mc</code>.</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#running-the-tool" id="running-the-tool">Running the Tool</a></h1>
<p><strong>Opt-in statistics programme</strong>: if you opt-in for statistics collection (off by default), then every run of Apalache
will submit anonymized statistics to
<code>tlapl.us</code>. See the details in <a href="apalache/./statistics.html">TLA+ Anonymized Execution Statistics</a>.</p>
<h2><a class="header" href="#model-checker-command-line-parameters" id="model-checker-command-line-parameters">Model checker command-line parameters</a></h2>
<p>The model checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache check [--config=filename] [--init=Init] [--cinit=ConstInit] \
    [--next=Next] [--inv=Inv] [--length=10] [--algo=(incremental|offline)] \
    [--discard-disabled] [--no-deadlock] [--tuning=filename] [--tune-here=options] \
    &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>
<p>General parameters:</p>
<ul>
<li><code>--config</code> specifies the <a href="apalache/./tlc-config.html">TLC configuration file</a>, the default name is <code>&lt;myspec&gt;.cfg</code></li>
<li><code>--init</code> specifies the initialization predicate, <em><code>Init</code> by default</em></li>
<li><code>--next</code> specifies the transition predicate, <em><code>Next</code> by default</em></li>
<li><code>--cinit</code> specifies the constant initialization predicate, <em>optional</em></li>
<li><code>--inv</code> specifies the invariant to check, <em>optional</em></li>
<li><code>--length</code> specifies the maximal number of <code>Next</code> steps, <em>10 by default</em></li>
</ul>
</li>
<li>
<p>Advanced parameters:</p>
<ul>
<li><code>--algo</code> lets you to choose the search algorithm: <code>incremental</code> is using the incremental SMT solver, <code>offline</code> is
using the non-incremental
(offline) SMT solver</li>
<li><code>--discard-disabled</code> does a pre-check on transitions and discard the disabled ones at every step. If you know that
many transitions are always enabled, set it to false. Sometimes, this pre-check may be slower than checking the
invariant. Default: true.</li>
<li><code>--no-deadlock</code> disables deadlock-checking, when <code>--discard-disabled=false</code> is on. When <code>--discard-disabled=true</code>,
deadlocks are found in any case.</li>
<li><code>--tuning</code> specifies the properties file that stores the options for
<a href="apalache/tuning.html">fine tuning</a></li>
<li><code>--tuning-options=key1=val1:key2=val2:...</code> pass the tuning options right in the command line as a single string.
The options that are passed with the option <code>--tuning-options</code>
have priority over the options that are passed with the option <code>--tuning</code>.</li>
</ul>
</li>
</ul>
<p>If an initialization predicate, transition predicate, or invariant is specified both in the configuration file, and on
the command line, the command line parameters take precedence over those in the configuration file.</p>
<h3><a class="header" href="#bounded-model-checking" id="bounded-model-checking">Bounded model checking</a></h3>
<p>By default, Apalache performs <em>bounded model checking</em>, that is, it encodes a symbolic execution of length <code>k</code> and an
invariant violation in SMT:</p>
<pre><code class="language-tla">/\ Init[v_0/v]
/\ Next[v_0/v, v_1/v'] /\ Next[v_1/v, v_2/v'] /\ ... /\ Next[v_{k-1}/v, v_k/v']
/\ ~Inv[v_0/v] \/ ~Inv[v_1/v] \/ ... \/ ~Inv[v_k/v]
</code></pre>
<p>Here an expression <code>Inv[v_i/v]</code> means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the
state <code>i</code>. Likewise, <code>Next[v_i/v,v_{i+1}/v']</code>
means that the state variables <code>v</code> are replaced with their copies <code>v_i</code> for the state <code>i</code>, whereas the state
variables <code>v'</code> are replaced with their copies
<code>v_{i+1}</code> for the state <code>i+1</code>.</p>
<h4><a class="header" href="#bounded-model-checking-is-an-incomplete-technique" id="bounded-model-checking-is-an-incomplete-technique">Bounded model checking is an incomplete technique</a></h4>
<p>If Apalache finds a bug in this symbolic execution (by querying z3), then it reports a counterexample. Otherwise, it
reports that no bug was found up to the given length. If a bug needs a long execution to get revealed, bounded model
checking may miss it!</p>
<h3><a class="header" href="#checking-an-inductive-invariant" id="checking-an-inductive-invariant">Checking an inductive invariant</a></h3>
<p>To check executions of arbitrary lengths, one usually finds a formula that satisfies the two following properties:</p>
<pre><code class="language-tla">/\ Init =&gt; TypeOK /\ IndInv
/\ TypeOK /\ IndInv /\ Next =&gt; TypeOK' /\ IndInv'
</code></pre>
<p>In normal words: (1) The initial states satisfy the constraint <code>TypeOK /\ IndInv</code>, and (2) whenever the specification makes a step when starting in a state that satisfies <code>TypeOK /\ IndInv</code>, it
ends up in a state that again satisfies <code>TypeOK /\ IndInv</code>.</p>
<p>Note that we usually check <code>IndInv</code> in conjunction with <code>TypeOK</code>, as we have to constrain the variable values. In
the <code>y2k</code> example, our inductive invariant is actually constraing the variables. In fact, such an inductive invariant is
usually called <code>TypeOK</code>.</p>
<p>To check an inductive invariant <code>IndInv</code> in Apalache, you run two commands that check the above two formulas:</p>
<ul>
<li>
<p><strong>IndInit</strong>: Check that the initial states satisfy <code>IndInv</code>:</p>
<pre><code class="language-bash">$ apalache check --init=Init --inv=IndInv --length=0 &lt;myspec&gt;.tla
</code></pre>
</li>
<li>
<p><strong>IndNext</strong>: Check that <code>Next</code> does not drive us outside of <code>IndInv</code>:</p>
<pre><code class="language-bash">$ apalache check --init=IndInv --inv=IndInv --length=1 &lt;myspec&gt;.tla
</code></pre>
</li>
</ul>
<p>Usually, you look for an inductive invariant to check a safety predicate. For
example, if you have found an inductive invariant <code>IndInv</code> and want to check a
safety predicate <code>Safety</code>, you have to run Apalache once again:</p>
<ul>
<li>
<p><strong>IndProp</strong>: Check that all states captured with <code>IndInv</code> satisfy the predicate <code>Safety</code>:</p>
<pre><code class="language-bash">$ apalache check --init=IndInv --inv=Safety --length=0 &lt;myspec&gt;.tla
</code></pre>
</li>
</ul>
<p>It may happen that your inductive invariant <code>IndInv</code> is too weak and it
violates <code>Safety</code>. In this case, you would have to add additional constraints to <code>IndInv</code>.
Then you would have to check the queries IndInit, IndNext, and IndProp again.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#checking-safety-up-to-20-steps" id="checking-safety-up-to-20-steps">Checking safety up to 20 steps</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache check --length=20 --inv=Safety y2k_override.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. If <code>Safety</code> is not violated, your spec
might still have a bug that requires a computation longer than 20 steps to manifest.</p>
<h3><a class="header" href="#checking-an-inductive-invariant-1" id="checking-an-inductive-invariant-1">Checking an inductive invariant:</a></h3>
<pre><code class="language-bash">$ cd test/tla
$ apalache check --length=0 --init=Init --inv=Inv y2k_override.tla
$ apalache check --length=1 --init=Inv  --inv=Inv y2k_override.tla
</code></pre>
<p>The first call to apalache checks, whether the initial states satisfy the invariant. The second call to apalache checks,
whether a single specification step satisfies the invariant, when starting in a state that satisfies the invariant. (
That is why these invariants are called inductive.)</p>
<h3><a class="header" href="#using-a-constant-initializer" id="using-a-constant-initializer">Using a constant initializer:</a></h3>
<pre><code class="language-bash">$ cd test/tla
apalache check --cinit=ConstInit --length=20 --inv=Safety y2k_cinit.tla
</code></pre>
<p>This command checks, whether <code>Safety</code> can be violated in 20 specification steps. The constants are initialized with the
predicate
<code>ConstInit</code>, defined in <code>y2k_cinit.tla</code> as:</p>
<pre><code class="language-tla">ConstInit == BIRTH_YEAR \in 0..99 /\ LICENSE_AGE \in 10..99
</code></pre>
<p>In this case, Apalache finds a safety violation, e.g., for
<code>BIRTH_YEAR=89</code> and <code>LICENSE_AGE=10</code>. A complete counterexample is printed in <code>counterexample.tla</code>.</p>
<p>The final lines in the file clearly indicate the state that violates the invariant:</p>
<pre><code class="language-tla">State14 ==
/\ BIRTH_YEAR = 89
/\ LICENSE_AGE = 10
/\ hasLicense = TRUE
/\ year = 0

(* The following formula holds true in the last state and violates the invariant *)

InvariantViolation == hasLicense /\ year - BIRTH_YEAR &lt; LICENSE_AGE
</code></pre>
<p><a name="lookup"></a></p>
<h2><a class="header" href="#module-lookup" id="module-lookup">Module lookup</a></h2>
<p>Apalache uses <a href="https://lamport.azurewebsites.net/tla/tools.html">the SANY parser</a>, which is the standard parser of TLC
and TLA+ Toolbox. By default, SANY is looking for the modules in the current working directory and in the Java package
<code>tla2sany.StandardModules</code>, which is usually provided by the <code>tla2tools.jar</code> that is included in the Java classpath.</p>
<p>In addition to the modules in the current working directory, Appalache provides</p>
<ul>
<li>a small standard library (located in <code>$APALACHE_HOME/src/tla</code>), and</li>
<li>support for additional source directories specified in the environment variable <code>TLA_PATH</code>. <code>TLA_PATH</code> should be a
list of paths to directories separated by <code>:</code>.</li>
</ul>
<p>(Directories in the <code>TLA_PATH</code> are provided to SANY via the <code>TLA-Library</code> Java system variable.)</p>
<p>So the module lookup order in Apalache is as follows:</p>
<ol>
<li>The current working directory.</li>
<li>The directory <code>$APALACHE_HOME/src/tla</code>.</li>
<li>The directories specified in the environment variable <code>TLA_PATH</code>.</li>
<li>The Java package <code>tla2sany.StandardModules</code>.</li>
</ol>
<p><strong>Note:</strong> To let TLA+ Toolbox and TLC know about the Apalache modules, include
<code>$APALACHE_HOME/src/tla</code> in the lookup directories, as explained by Markus Kuppe for
the <a href="https://github.com/tlaplus/CommunityModules">TLA+ Community Modules</a>.</p>
<p><a name="detailed"></a></p>
<h2><a class="header" href="#detailed-output" id="detailed-output">Detailed output</a></h2>
<p>The tool will display only important messages on stdout, but a detailed log can be found in <code>detailed.log</code>.</p>
<p>Additionally, each pass of the model checker produces an intermediate TLA+ file in the run-specific
directory <code>x/hh.mm-DD.MM.YYYY-&lt;id&gt;</code>:</p>
<ul>
<li>File <code>out-parser.tla</code> is produced as a result of parsing and importing into the intermediate representation, Apalache
TLA IR.</li>
<li>File <code>out-parser.json</code> is produced as a result of converting the Apalache TLA IR representation of the input into JSON
format.</li>
<li>File <code>out-config.tla</code> is produced as a result of substituting CONSTANTS, as described
in <a href="apalache/./parameters.html">Setting up specification parameters</a>.</li>
<li>File <code>out-inline.tla</code> is produced as a result of inlining operator definitions and <code>LET-IN</code> definitions.</li>
<li>File <code>out-priming.tla</code> is produced as a result of replacing constants and variables in <code>ConstInit</code> and <code>Init</code> with
their primed versions.</li>
<li>File <code>out-vcgen.tla</code> is produced as a result of extracting verification conditions, e.g., invariants to check.</li>
<li>File <code>out-prepro.tla</code> is produced as a result of running all preprocessing steps.</li>
<li>File <code>out-transition.tla</code> is produced as a result of finding assignments and symbolic transitions.</li>
<li>File <code>out-opt.tla</code> is produced as a result of expression optimizations.</li>
<li>File <code>out-analysis.tla</code> is produced as a result of analysis, e.g., marking Skolemizable expressions and expressions to
be expanded.</li>
</ul>
<p><a name="parsing"></a></p>
<h2><a class="header" href="#parsing-and-pretty-printing" id="parsing-and-pretty-printing">Parsing and pretty-printing</a></h2>
<p>If you'd like to check that your TLA+ specification is syntactically correct, without running the model checker, you can
run the following command:</p>
<pre><code class="language-bash">$ apalache parse &lt;myspec&gt;.tla
</code></pre>
<p>In this case, Apalache performs the following steps:</p>
<ol>
<li>
<p>It parses the specification with <a href="https://lamport.azurewebsites.net/tla/tools.html">SANY</a>.</p>
</li>
<li>
<p>It translates SANY semantic nodes
into <a href="https://github.com/informalsystems/apalache/blob/master/tlair/src/main/scala/at/forsyte/apalache/tla/lir/package.scala">Apalache IR</a>
.</p>
</li>
<li>
<p>It pretty-prints the IR into <code>out-parser.tla</code>, see <a href="apalache/running.html#detailed">Detailed output</a>.</p>
</li>
</ol>
<h1><a class="header" href="#tla-anonymized-execution-statistics" id="tla-anonymized-execution-statistics">TLA+ Anonymized Execution Statistics</a></h1>
<p>Apalache participates in the optional <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a> along
with <a href="http://lamport.azurewebsites.net/tla/toolbox.html">TLA+ Toolbox</a>, TLC (which is part of the Toolbox), and <a href="https://marketplace.visualstudio.com/items?itemName=alygin.vscode-tlaplus">Visual Studio
Code Plugin for TLA+</a>.</p>
<p>The statistics collection is <strong>never enabled by default</strong>. You have to <strong>opt-in</strong>
for the programme either in TLA+ Toolbox, or in Apalache. When statistics
collection is enabled by the user, it is submitted to <code>tlapl.us</code> via the
util.<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.java">ExecutionStatisticsCollector</a>, which is part of <code>tla2tools.jar</code>. Apalache
accesses this class in at.forsyte.apalache.tla.<a href="https://github.com/informalsystems/apalache/blob/unstable/mod-tool/src/main/scala/at/forsyte/apalache/tla/Tool.scala">Tool</a>.</p>
<p>As explained in <a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/util/ExecutionStatisticsCollector.md">anonymized statistics programme</a>, if you never create the file
<code>$HOME/.tlaplus/esc.txt</code>, then the statistics is not submitted to <code>tlapl.us</code>.
If you opt-in for the programme and later remove the file, then the statistics
will not be submitted too.</p>
<h2><a class="header" href="#why-do-we-ask-you-to-help-us" id="why-do-we-ask-you-to-help-us">Why do we ask you to help us</a></h2>
<p>There are several reasons:</p>
<ul>
<li>
<p>Although our project is open source, developing Apalache is our main job.
We are grateful to <a href="https://informal.systems">Informal Systems</a> for supporting us and to <a href="https://www.tuwien.at/">TU Wien</a>,
<a href="https://www.wwtf.at/index.php?lang=EN">Vienna Science and Technology Fund</a>, and <a href="https://www.inria.fr/en/centre-inria-nancy-grand-est">Inria Nancy/LORIA</a>, who
supported us in the past.  It is easier to convince our decision makers to
continue the development, if we have clear feedback on how many people
<strong>use and need Apalache</strong>.</p>
</li>
<li>
<p>We would like to know which features you are using most, so we can focus on
them.</p>
</li>
<li>
<p>We would like to know which operating systems and Java versions need care
and better be included in automated test suites.</p>
</li>
</ul>
<h2><a class="header" href="#how-to-opt-in-and-opt-out" id="how-to-opt-in-and-opt-out">How to opt-in and opt-out</a></h2>
<p>To opt-in in the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=true
</code></pre>
<p>As a result of this command, a random identifier is written in
<code>$HOME/.tlaplus/esc.txt</code>. This identifier is used by the execution statistics
code.</p>
<p>To opt-out from the statistics collection, execute the following command:</p>
<pre><code class="language-sh">./apalache-mc config --enable-stats=false
</code></pre>
<h2><a class="header" href="#what-exactly-is-submitted-to-tlaplus" id="what-exactly-is-submitted-to-tlaplus">What exactly is submitted to tlapl.us</a></h2>
<p>You can check the daily log at <a href="https://exec-stats.tlapl.us/">exec-stats.tlapl.us</a>.</p>
<p>The following data is submitted for each run, if you have opted in:</p>
<ul>
<li>Total number of CPU cores and cores assigned
(the latter is 1 for now, but will change soon)</li>
<li>Java heap memory size (in Megabytes)</li>
<li>Apalache version (semantic version + build)</li>
<li>Command mode: <code>parse</code>, <code>check</code>, or <code>typecheck</code></li>
<li>Name, version, and architecture of the OS</li>
<li>Vendor, version, and architecture of JVM</li>
<li>Timestamp + salt (a random number to make time less precise)</li>
<li>An installation ID that is stored in <code>$HOME/.tlaplus/esc.txt</code></li>
</ul>
<h1><a class="header" href="#an-example-of-a-tla-specification" id="an-example-of-a-tla-specification">An example of a TLA+ specification</a></h1>
<p>To illustrate the features of Apalache, we use the following TLA+ specification,
which can be found in <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a>:</p>
<pre><code class="language-tla">-------------------------------- MODULE y2k --------------------------------
(*
 * A simple specification of a year counter that is subject to the Y2K problem.
 * In this specification, a registration office keeps records of birthdays and
 * issues driver's licenses. As usual, a person may get a license, if they
 * reached a certain age, e.g., age of 18. The software engineers never thought
 * of their program being used until the next century, so they stored the year
 * of birth using only two digits (who would blame them, the magnetic tapes
 * were expensive!). The new millenium came with new bugs.
 *
 * This is a made up example, not reflecting any real code.
 * To learn more about Y2K, check: https://en.wikipedia.org/wiki/Year_2000_problem
 *
 * Igor Konnov, January 2020
 *)

EXTENDS Integers
 
CONSTANT
    \* @type: Int;
    BIRTH_YEAR, \* the year to start with, between 0 and 99
    \* @type: Int;
    LICENSE_AGE    \* the minimum age to obtain a license
         
ASSUME(BIRTH_YEAR \in 0..99)              
ASSUME(LICENSE_AGE \in 1..99)              
 
VARIABLE
    \* @type: Int;
    year,
    \* @type: Bool;
    hasLicense

Age == year - BIRTH_YEAR 

Init ==
    /\ year = BIRTH_YEAR
    /\ hasLicense = FALSE
    
NewYear ==
    /\ year' = (year + 1) % 100 \* the programmers decided to use two digits
    /\ UNCHANGED hasLicense
    
IssueLicense ==
    /\ Age &gt;= LICENSE_AGE
    /\ hasLicense' = TRUE
    /\ UNCHANGED year
    
Next ==
    \/ NewYear
    \/ IssueLicense

\* The somewhat &quot;obvious&quot; invariant, which is violated    
Safety ==
    hasLicense =&gt; (Age &gt;= LICENSE_AGE)
</code></pre>
<pre><code></code></pre>
<h1><a class="header" href="#setting-up-specification-parameters" id="setting-up-specification-parameters">Setting up specification parameters</a></h1>
<p>Similar to TLC, Apalache requires the specification parameters to be restricted
to finite values. In contrast to TLC, there is a way to initialize parameters
by writing a symbolic constraint, see <a href="apalache/parameters.html#ConstInit">Section 5.3</a>.</p>
<h2><a class="header" href="#using-instance" id="using-instance">Using INSTANCE</a></h2>
<p>You can set the specification parameters, using the standard <code>INSTANCE</code>
expression of TLA+. For instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_instance.tla"><code>y2k_instance.tla</code></a>,
which instantiates <code>y2k.tla</code>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_instance ----------------------------
(*
 * Another way to instantiate constants for apalache is to
 * use INSTANCE.
 *)
 
VARIABLE
    \* @type: Int;
    year,
    \* @type: Bool;
    hasLicense
</code></pre>
<p>The downside of this approach is that you have to declare the variables of the
extended specification. This is easy with only two variables, but can quickly
become unwieldy.</p>
<h2><a class="header" href="#convention-over-configuration" id="convention-over-configuration">Convention over configuration</a></h2>
<p>Alternatively, you can extend the base module and use overrides:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_override ----------------------------
(*
 * One way to instantiate constants for apalache is to use the OVERRIDE prefix. 
 *)
 
EXTENDS y2k

OVERRIDE_BIRTH_YEAR == 80
OVERRIDE_LICENSE_AGE == 18

=============================================================================
</code></pre>
<p><a name="ConstInit"></a></p>
<h2><a class="header" href="#constinit-predicate" id="constinit-predicate">ConstInit predicate</a></h2>
<p>This approach is similar to the <code>Init</code> operator, but applied to the
constants. We define a special operator, e.g., called <code>ConstInit</code>. For
instance, below is the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_cinit.tla"><code>y2k_cinit.tla</code></a>:</p>
<pre><code class="language-tla">---------------------------- MODULE y2k_cinit ----------------------------
(*
 * Another way to instantiate constants for apalache is give it constraints
 * on the constants.
 *)
 
EXTENDS y2k

ConstInit ==
    /\ BIRTH_YEAR \in 0..99
    /\ LICENSE_AGE \in 10..99

=============================================================================
</code></pre>
<p>To use <code>ConstInit</code>, pass it as the argument to <code>apalache</code>. For instance, for
<code>y2k_cinit</code>, we would run the model checker as follows:</p>
<pre><code class="language-tla">$ cd $APALACHE_HOME/test/tla
$ apalache check --inv=Safety \
  --length=20 --cinit=ConstInit y2k_cinit.tla
</code></pre>
<h3><a class="header" href="#parameterized-initialization" id="parameterized-initialization">Parameterized initialization</a></h3>
<p>As a bonus of this approach, Apalache allows one to check a specification over a
bounded set of parameters. For example:</p>
<pre><code class="language-tla">CONSTANT N, Values

ConstInit ==
  /\ N \in 3..10
  /\ Values \in SUBSET 0..4
  /\ Values /= {}
</code></pre>
<p>The model checker will try the instances for all the combinations of
the parameters specified in <code>ConstInit</code>, that is, in our example, it will
consider <code>N \in 3..10</code> and all non-empty value sets that are subsets of <code>0..4</code>.</p>
<h3><a class="header" href="#limitation" id="limitation">Limitation</a></h3>
<p><code>ConstInit</code> should be a conjunction of assignments and possibly of additional
constraints on the constants. For instance, you should not write <code>N = 10 \/ N = 20</code>. However, you can write <code>N \in {10, 20}</code>.</p>
<h2><a class="header" href="#tlc-configuration-file" id="tlc-configuration-file">TLC configuration file</a></h2>
<p>We support configuring Apalache via TLC configuration files; these files are
produced automatically by TLA Toolbox, for example. TLC configuration files
allow one to specify which initialization predicate and transition predicate to
employ, which invariants to check, as well as to initialize specification
parameters. Some features of the TLC configuration files are not supported yet.
Check the manual page on <a href="apalache/./tlc-config.html">&quot;Syntax of TLC Configuration Files&quot;</a>.</p>
<p><em>If you are checking a file <code>&lt;myspec&gt;.tla</code>, and the file <code>&lt;myspec&gt;.cfg</code> exists in
the same directory, it will be picked up by Apalache automatically. You can also
explicitly specify which configuration file to use via the <code>--config</code> option.</em></p>
<h1><a class="header" href="#principles-of-symbolic-model-checking-with-apalache" id="principles-of-symbolic-model-checking-with-apalache">Principles of Symbolic Model Checking with Apalache</a></h1>
<p>In order to take advantage of Apalache's symbolic model checking, there are a
few principles one must bear in mind when writing TLA.</p>
<p><a name="assignments"></a>
<a name="symbolicTransitions"></a></p>
<h2><a class="header" href="#assignments-and-symbolic-transitions" id="assignments-and-symbolic-transitions">Assignments and symbolic transitions</a></h2>
<p>Let us go back to the example <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k.tla"><code>test/tla/y2k.tla</code></a> and
run <code>apalache</code> against <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/y2k_override.tla"><code>test/tla/y2k_override.tla</code></a>:</p>
<pre><code class="language-console">$ apalache check y2k_override.tla
</code></pre>
<p>We can check the detailed output of the <code>TransitionFinderPass</code> in the file
<code>x/&lt;timestamp&gt;/out-transition.tla</code>, where <code>&lt;timestamp&gt;</code> looks like
<code>09.03-10.03.2020-508266549191958257</code>:</p>
<pre><code class="language-tla">----- MODULE y2k_override -----
VARIABLE year
VARIABLE hasLicense
ASSUME(80 \in 0 .. 99)
ASSUME(18 \in 1 .. 99)

Init$0 == year' := 80 /\ hasLicense' := FALSE
Next$0 == year' := ((year + 1) % 100) /\ (hasLicense' := hasLicense)
Next$1 == year - 80 &gt;= 18 /\ hasLicense' := TRUE /\ (year' := year)
===============
</code></pre>
<p>As you can see, the model checker did two things:</p>
<ol>
<li>It has translated several expressions that look like <code>x' = e</code> into <code>x' := e</code>.
For instance, you can see <code>year' := 80</code> and <code>hasLicense' := FALSE</code> in
<code>Init$0</code>. We call these expressions <strong>assignments</strong>.</li>
<li>It has factored the operator <code>Next</code> into two operators <code>Next$0</code> and <code>Next$1</code>.
We call these operators <strong>symbolic transitions</strong>.</li>
</ol>
<p>Pure TLA+ does not have the notions of assignments and symbolic
transitions.  However, TLC sometimes treats expressions <code>x' = e</code> and <code>x' \in S</code>
as if they were assigning a value to the variable <code>x'</code>. TLC does so
dynamically, during the breadth-first search. Apalache looks statically for assignments
among the expressions <code>x' = e</code> and <code>x' \in S</code>.</p>
<p>When factoring out operators into symbolic transitions, Apalache splits the
action operators <code>Init</code> and <code>Next</code> into disjunctions (e.g., <code>A_0 \/ ... \/ A_n</code>),
represented in the concrete syntax as a sequence of operator definitions of the
form</p>
<pre><code class="language-tla">A$0 == ...
...
A$n == ...
</code></pre>
<p>The main contract between the assignments and symbolic transitions is as
follows:</p>
<blockquote>
<p>For every variable <code>x</code> declared with <code>VARIABLE</code>, there is exactly one
assignment of the form <code>x' := e</code> in every symbolic transition <code>A_n</code>.</p>
</blockquote>
<p>If Apalache cannot find expressions with the above properties, it fails.
Consider the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Assignments20200309.tla"><code>test/tla/Assignments20200309.tla</code></a>:</p>
<pre><code class="language-tla">----- MODULE Assignments20200309 -----
VARIABLE a
\* this specification fails, as it has no expression
\* that can be treated as an assignment
Init == TRUE
Next == a' = a
Inv == FALSE
===============
</code></pre>
<p>Running the checker with</p>
<pre><code class="language-bash">apalache check Assignments20200309.tla
</code></pre>
<p>Apalache reports an error as follows:</p>
<pre><code class="language-console">...
PASS #6: TransitionFinderPass                                     I@09:39:33.527
To understand the error, check the manual:
[https://apalache.informal.systems/docs/apalache/assignments.html]
Assignment error: Failed to find assignments and symbolic transitions in InitPrimed E@09:39:33.676
It took me 0 days  0 hours  0 min  1 sec                          I@09:39:33.678
Total time: 1.88 sec                                              I@09:39:33.678
EXITCODE: ERROR (99)
</code></pre>
<p>This error is cryptic. It does not indicate which parts of the specification
have caused the problem. In the future, we will add better diagnostic in the
assignment finder, see <a href="https://github.com/informalsystems/apalache/issues/111">the open
issue</a>. Our current approach is
to debug assignments by running TLC first. If running TLC takes too long, you
may try to comment out parts of the specification to find the problematic
action. Although this is tedious, it allows one to find missing assignments
rather quickly.</p>
<p>If you are interested in the technique for finding the assignments and symbolic
transitions implemented in Apalache, check our <a href="http://forsyte.at/wp-content/uploads/abz2018_full.pdf">paper at
ABZ'18</a>.  The <a href="http://dx.doi.org/https://doi.org/10.1016/j.scico.2019.102361">journal
version</a> is
unfortunately behind the Elsevier paywall, which will be lifted after the
two-year embargo period.</p>
<p><a name="types"></a></p>
<h2><a class="header" href="#type-annotations" id="type-annotations">Type annotations</a></h2>
<p><strong>NOTE 1</strong>: <a href="https://forsyte.at/people/kukovec/">Jure Kukovec</a> is developing
a completely automatic type inference engine. As soon as it is ready, type
annotations will no longer be required. Until that happy day, refer to <a href="apalache/types-and-annotations.html">type
annotations</a>.</p>
<p><strong>NOTE 2</strong>: We are currently working on a better syntax for type annotations
and a better type checker. Hence, the syntax will change in the future.</p>
<p>Apalache requires two kinds of type annotations:</p>
<ul>
<li>type annotations for empty sets and sequences, and</li>
<li>type annotations for records and sets of records.</li>
</ul>
<h3><a class="header" href="#empty-sets-and-sequences" id="empty-sets-and-sequences">Empty sets and sequences</a></h3>
<p>Consider the following example <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/NeedForTypes.tla"><code>NeedForTypes.tla</code></a>:</p>
<pre><code class="language-tla">------------------------ MODULE NeedForTypes ------------------------------
(**
 * This simple example transforms a set into a sequence.
 *)
EXTENDS Integers, Sequences, FiniteSets

CONSTANTS InSet     \* an input set
VARIABLES Left,     \* a storage for the yet untransformed elements
          OutSeq    \* the output sequence

ConstInit == InSet = 1..4

Init ==
    /\ OutSeq = &lt;&lt; &gt;&gt;
    /\ Left = InSet

Next ==
    IF Left = {}
    THEN UNCHANGED &lt;&lt;Left, OutSeq&gt;&gt;
    ELSE \E x \in Left:
          /\ OutSeq' = Append(OutSeq, x)
          /\ Left' = Left \ {x}

Inv == InSet = Left \union { OutSeq[i]: i \in DOMAIN OutSeq }
===========================================================================
</code></pre>
<p>While this example is perfectly fine for TLC, Apalache has to assign types to
the variables, in order to construct SMT constraints. In some cases, Apalache
can infer types completely automatically, e.g., as in the <code>y2k</code> example (see
<a href="apalache/./example.html">the example</a>). However, if you run <code>apalache check --cinit=ConstInit NeedForTypes.tla</code>, the tool will complain:</p>
<pre><code>Step 0, level 0: checking if 1 transition(s) are enabled and violate the invariant I@15:17:14.313
Step 0, level 1: collecting 1 enabled transition(s)               I@15:17:14.360
Step 1, level 1: checking if 2 transition(s) are enabled and violate the invariant I@15:17:14.374
NeedForTypes.tla:18:8-18:16, =(...), type error: Expected equal types: FinSet[Int] and FinSet[Unknown] E@15:17:14.379
The outcome is: Error                                             I@15:17:14.388
</code></pre>
<p>In a somewhat obfuscated way, Apalache tells us the following. It has inferred
that <code>Left</code> is a set of integers, that is, <code>FinSet[Int]</code>. First, it found that
<code>InSet</code> is a set of integers, by applying <code>ConstInit</code>. Second, as <code>Left = InSet</code>
in <code>Init</code>, it inferred that <code>Left</code> is also a set of integers. Third, when
applying <code>Next</code>, it processed <code>{}</code>, which is an empty set of any kind of
objects. Hence, <code>{}</code> was assigned the type <code>FinSet[Unknown]</code>, that is, a set of
some type. Finally, it found the expression <code>Left = {}</code>, and here the type
checker has failed.</p>
<p>To help the type checker, we have to introduce a few type annotations. But
before doing that, we introduce the notation for type annotations in the
specification.</p>
<h4><a class="header" href="#syntax-for-type-annotations" id="syntax-for-type-annotations">Syntax for type annotations</a></h4>
<p>Apalache reads any expression formed with the <code>&lt;:</code> operator as an annotation of
the value of the left hand side with the type on the right. E.g.,</p>
<pre><code class="language-tla">v &lt;: T
</code></pre>
<p>means &quot;value <code>v</code> has type <code>T</code>&quot;.</p>
<p>However, other tools (such as TLC and TLAPS) have no support for these
annotations. To tell them to ignore type annotations, we maintain the convention
that any file using Apalache type annotations begins with the following definition:</p>
<pre><code class="language-tla">v &lt;: T == v
</code></pre>
<p>With this in place, Apalache can parse out the type annotations in the rest of
the file, but other tools are told to simply read any occurrence of <code>v &lt;: T</code> as
<code>v</code>, effectively erasing the type ascription.</p>
<p>Now we can help the type checker by rewriting the condition in <code>Next</code> as follows:</p>
<h4><a class="header" href="#example-of-using-type-annotations" id="example-of-using-type-annotations">Example of using type annotations</a></h4>
<pre><code class="language-tla">Next ==
    IF Left = {} &lt;: {Int}
    THEN ...
    ELSE ...
</code></pre>
<p>Now the type checker treats the expression <code>{}</code> as a set of integers. However,
it complains about another line:</p>
<pre><code>Step 0, level 0: checking if 1 transition(s) are enabled and violate the invariant I@15:43:35.932
Step 0, level 1: collecting 1 enabled transition(s)               I@15:43:35.977
Step 1, level 1: checking if 2 transition(s) are enabled and violate the invariant I@15:43:35.992
NeedForTypes.tla:23:24-23:40, x$1, type error: Expected type Unknown, found Int E@15:43:36.012
NeedForTypes.tla:23:24-23:40, Append(...), type error: Expected a type, found: None E@15:43:36.018
NeedForTypes.tla:23:11-24:31, /\(...), type error: Expected a Boolean, found: None E@15:43:36.020
The outcome is: Error
</code></pre>
<p>Here the type checker stumbles upon the sequence operator <code>Append(OutSeq, x)</code>
and complains about the type mismatch. Similar to <code>{}</code>, it has treated
the expression <code>&lt;&lt; &gt;&gt;</code> as a sequence of an unknown type. (In case of <code>&lt;&lt;1, 2&gt;&gt;</code>
it would be even worse, as the type checker would not know, whether <code>&lt;&lt;1, 2&gt;&gt;</code>
should be treated as a sequence or a tuple). Again, we help the type checker
by modifying <code>Init</code> as follows:</p>
<pre><code class="language-tla">Init ==
    /\ OutSeq = &lt;&lt; &gt;&gt; &lt;: Seq(Int)
    ...
</code></pre>
<p>Having these two annotations, the type checker stops complaining. You can find
the annotated specification in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/NeedForTypesWithTypes.tla"><code>test/tla/NeedForTypesWithTypes.tla</code></a>.</p>
<h3><a class="header" href="#records-and-sets-of-records" id="records-and-sets-of-records">Records and sets of records</a></h3>
<p>Consider the following example in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Handshake.tla"><code>test/tla/Handshake.tla</code></a>:</p>
<pre><code class="language-tla">------------------------ MODULE Handshake ------------------------
(**
 * A TCP-like handshake protocol:
 * https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment
 *
 * Igor Konnov, 2020
 *)
EXTENDS Integers

VARIABLES msgs,     \* the set of all messages
          iseqno,   \* Initiator's sequence number
          rseqno,   \* Receiver's sequence number
          istate,   \* Initiator's state
          rstate    \* Receiver's state

a &lt;: b == a

Init ==
    /\ msgs = {}
    /\ iseqno = 0
    /\ rseqno = 0
    /\ istate = &quot;INIT&quot;
    /\ rstate = &quot;LISTEN&quot;

SendSyn ==
    /\ istate = &quot;INIT&quot;
    /\ \E no \in Nat:
        /\ msgs' = msgs \union {[syn |-&gt; TRUE,
                                 ack |-&gt; FALSE, seqno |-&gt; no]}
        /\ iseqno' = no + 1
        /\ istate' = &quot;SYN-SENT&quot;
        /\ UNCHANGED &lt;&lt;rseqno, rstate&gt;&gt;

SendSynAck ==
    /\ rstate = &quot;LISTEN&quot;
    /\ \E seqno, ackno \in Nat:
        /\ [syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; seqno] \in msgs
        /\ msgs' = msgs \union {[syn |-&gt; TRUE, ack |-&gt; TRUE,
                                 seqno |-&gt; seqno + 1,
                                 ackno |-&gt; ackno]}
        /\ rseqno' = ackno + 1
        /\ rstate' = &quot;SYN-RECEIVED&quot;
        /\ UNCHANGED &lt;&lt;iseqno, istate&gt;&gt;

SendAck ==
    /\ istate = &quot;SYN-SENT&quot;
    /\ \E ackno \in Nat:
        /\ [syn |-&gt; TRUE, ack |-&gt; TRUE,
            seqno |-&gt; iseqno, ackno |-&gt; ackno] \in msgs
        /\ istate' = &quot;ESTABLISHED&quot;
        /\ msgs' = msgs \union {[syn |-&gt; FALSE, ack |-&gt; TRUE,
                                 seqno |-&gt; iseqno,
                                 ackno |-&gt; ackno + 1]}
        /\ UNCHANGED &lt;&lt;iseqno, rseqno, rstate&gt;&gt;

RcvAck ==
    /\ rstate = &quot;SYN-RECEIVED&quot;
    /\ \E seqno \in Nat:
        /\ ([syn |-&gt; FALSE, ack |-&gt; TRUE,
             seqno |-&gt; seqno, ackno |-&gt; rseqno]) \in msgs
        /\ rstate' = &quot;ESTABLISHED&quot;
        /\ UNCHANGED &lt;&lt;msgs, iseqno, rseqno, istate&gt;&gt;


Next == SendSyn \/ SendSynAck \/ SendAck \/ RcvAck

Inv == (rstate = &quot;ESTABLISHED&quot; =&gt; istate = &quot;ESTABLISHED&quot;)
======================================================================
</code></pre>
<p>As we have seen before, the type checker complains about the set <code>msgs</code>,
which is initialized as <code>{}</code>. So we have to specify the type of <code>{}</code>. But which
type shall we use for the empty set?</p>
<p>In our example, the set <code>msgs</code> may contain records of three kinds:</p>
<ul>
<li>a <strong>SYN</strong> request that is modeled as a record
<code>[ack |-&gt; FALSE, syn |-&gt; TRUE, seqno |-&gt; i]</code> for some number <code>i</code>,</li>
<li>a <strong>SYN-ACK</strong> reply that is modeled as a record
<code>[ack |-&gt; TRUE, syn |-&gt; TRUE, seqno |-&gt; i, ackno |-&gt; j]</code>
for some numbers <code>i</code> and <code>j</code>,</li>
<li>an <strong>ACK</strong> reply that is modeled as a record
<code>[ack |-&gt; TRUE, syn |-&gt; FALSE, seqno |-&gt; i, ackno |-&gt; j]</code>
for some numbers <code>i</code> and <code>j</code>.</li>
</ul>
<p>From the perspective of the type checker, the three records shown above have
three different types. Although we would love to reject this example as an
ill-typed one, mixing records of different types is a widely-accepted idiom in
TLA+, for instance, see <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Lamport's specification of
Paxos</a>.
Think of records as of C unions, rather than C structs!</p>
<p>To help the type checker, we first introduce a handy operator for the type that
contains the fields of the three records:</p>
<pre><code class="language-tla">MT == [syn |-&gt; BOOLEAN, ack |-&gt; BOOLEAN, seqno |-&gt; Int, ackno |-&gt; Int]
</code></pre>
<p>Then we add annotations as follows:</p>
<pre><code class="language-tla">Init ==
  /\ msgs = {} &lt;: {MT}
    ...

SendSyn ==
  ...
  /\ \E no \in Nat:
    /\ msgs' = msgs \union {[syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; no] &lt;: MT}
  ...

SendSynAck ==
  ...
  /\ \E seqno, ackno \in Nat:
    /\ ([syn |-&gt; TRUE, ack |-&gt; FALSE, seqno |-&gt; seqno] &lt;: MT) \in msgs
    ...

SendAck ==
  ...
  /\ \E ackno \in Nat:
    ...
</code></pre>
<p>As you can see, we have to annotate only those records that do not have all
four fields of <code>MT</code>. As soon as we have added the annotations, the type checker
stopped complaining and let the model checker to run. The annotated code can be
found in
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/HandshakeWithTypes.tla"><code>test/tla/HandshakeWithTypes.tla</code></a>.</p>
<p>Type annotations can be also applied to sets of records. For example:</p>
<pre><code class="language-tla">[syn |-&gt; BOOLEAN, ack |-&gt; BOOLEAN, seqno |-&gt; Int] &lt;: {MT}
</code></pre>
<p>You can find more details on the simple type inference algorithm and the type
annotations in <a href="apalache/types-and-annotations.html">type annotations</a>.</p>
<h3><a class="header" href="#naturals" id="naturals">Naturals</a></h3>
<p>If you look carefully at the <a href="apalache/types-and-annotations.html">type annotations</a>, you
will find that there is no designated type for naturals. Indeed, one can just
use the type <code>Int</code>, whenever a natural number is required. If we introduced a
special type for naturals, that would cause a lot of confusion for the type
checker. What would be the type of the literal <code>42</code>? That depends on, whether
you extend <code>Naturals</code> or <code>Integers</code>. And if you extend <code>Naturals</code> and later
somebody else extends your module and also <code>Integers</code>, should be the type
of <code>42</code> be an integer?</p>
<p>Apalache still allows you to extend <code>Naturals</code>. However, it will treat all
number-like literals as integers. This is consistent with the view that the naturals are
a subset of the integers, and the integers are a subset of the reals.  Classically, one
would not define subtraction for naturals. However, the module <code>Naturals</code>
defines binary minus, which can easily drive a variable outside of <code>Nat</code>. For
instance, see the following example:</p>
<pre><code class="language-tla">----------------------------- MODULE NatCounter ------------------------
EXTENDS Naturals

VARIABLE x

Init == x = 3

\* a natural counter can go below zero, and this is expected behavior
Next == x' = x - 1

Inv == x &gt;= 0
========================================================================
</code></pre>
<p>Given that you will need the value <code>Int</code> for a type annotation, it probably
does not make a lot of sense to extend <code>Naturals</code> in your own specifications,
as you will have to extend <code>Integers</code> for the type annotation too.  We are
currently working on a different kind of type annotations, which would not
require <code>Int</code>.</p>
<p><a name="recursion"></a></p>
<h2><a class="header" href="#recursive-operators-and-functions" id="recursive-operators-and-functions">Recursive operators and functions</a></h2>
<p><a name="rec-op"></a></p>
<h3><a class="header" href="#recursive-operators" id="recursive-operators">Recursive operators</a></h3>
<p>In the preprocessing phase, Apalache replaces every application of a user
operator with its body. We call this process &quot;operator inlining&quot;.
This cannot be done for recursive operators, for two reasons:</p>
<ol>
<li>
<p>A recursive operator may be non-terminating (although a non-terminating
operator is useless in TLA+);</p>
</li>
<li>
<p>A terminating call to an operator may take an unpredicted number of iterations.</p>
</li>
</ol>
<p>However, in practice, when one fixes specification parameters (that is,
<code>CONSTANTS</code>), it is usually easy to find a bound on the number of operator
iterations. For instance, consider the following specification:</p>
<pre><code class="language-tla">--------- MODULE Rec6 -----------------
CONSTANTS N
VARIABLES set, count

RECURSIVE Sum(_)

Sum(S) ==
  IF S = {}
  THEN 0
  ELSE LET x == CHOOSE x \in S: TRUE IN
    x + Sum(S \ {x})

Init ==
  /\ set = {}
  /\ count = 0

Next ==
  \E x \in (1..N) \ set:
    /\ count' = count + x
    /\ set' = set \union {x}

Inv == count = Sum(set)
=======================================
</code></pre>
<p>It is clear that the expression <code>Sum(S)</code> requires the number of iterations that
is equal to <code>Cardinality(S) + 1</code>. Moreover, the expression <code>set \subseteq 1..N</code> is an invariant, and thus every call <code>Sum(set)</code> requires up to <code>N+1</code>
iterations.</p>
<p>When we can find an upper bound on the number of iterations, Apalache can
unroll the recursive operator up to this bound. To this end, we define two
additional operators. For instance:</p>
<pre><code class="language-tla">--------- MC_Rec6 ----------
VARIABLES set, count

INSTANCE Rec6 WITH N &lt;- 3

UNROLL_TIMES_Sum == 4
UNROLL_DEFAULT_Sum == 0
============================
</code></pre>
<p>In this case, Apalache unrolls every call to <code>Sum</code> exactly <code>UNROLL_TIMES_Sum</code>
times, that is, four times. On the default branch, Apalache places
<code>UNROLL_DEFAULT_Sum</code>, that is, 0.</p>
<p>All recursively defined operators should follow this convention where, for every such operator <code>Oper</code>, the user defines both <code>UNROLL_TIMES_Oper</code>, which expands to a positive integer value, and <code>UNROLL_DEFAULT_Oper</code>, which expands to some default value <code>Oper(args*)</code> should take, if the computation would require more than <code>UNROLL_TIMES_Oper</code> recursive calls.
At present, we only support literals (e.g. <code>4</code>) or primitive arithmetic expressions (e.g. <code>2 + 2</code>) in the body of <code>UNROLL_TIMES_Oper</code>.</p>
<p><a name="rec-fun"></a></p>
<h4><a class="header" href="#recursive-functions" id="recursive-functions">Recursive functions</a></h4>
<p>Apalache offers limited support for recursive functions. However, read the
warning below on why you should not use recursive functions. The restrictions
are as follows:</p>
<ol>
<li>
<p>Apalache supports recursive functions that return an integer or a Boolean.</p>
</li>
<li>
<p>As Apalache's simple type checker is not able to find the type of a
recursive function, all uses of a recursive function should come with a type
annotation.</p>
</li>
<li>
<p>As in TLC, the function domain must be a finite set.</p>
</li>
</ol>
<p>The example below shows a recursive function that computes the factorial of <code>n</code>.</p>
<pre><code class="language-tla">------------------------------ MODULE Rec8 ------------------------------------
EXTENDS Integers

VARIABLES n, factSpec, factComp

\* the syntax for type annotations
a &lt;: b == a

\* the type of the factorial function
FactT == [Int -&gt; Int]

(*
 Defining a recursive function on a finite domain. Although it is rather
 unnatural to define factorial on a finite set, both Apalache and TLC
 require finite domains. As is usual for function application, the result
 of the application is not defined on the elements outside of the function
 domain.
 *)
Fact[k \in 1..20] ==
    IF k &lt;= 1
    THEN 1
    ELSE k * (Fact &lt;: FactT)[k - 1]

Init ==
    /\ n = 1
    /\ factSpec = Fact[n]
    /\ factComp = 1

Next ==
    /\ n' = n + 1
    /\ factSpec' = Fact[n']
    /\ factComp' = n' * factComp

Inv ==
    factComp = factSpec
===============================================================================
</code></pre>
<p>Check other examples in
<a href="https://github.com/informalsystems/apalache/tree/unstable/test/tla"><code>test/tla</code></a> that
start with the prefix <code>Rec</code>.</p>
<p><strong>Why you should avoid recursive functions.</strong> Sometimes, recursive functions
concisely describe the function that you need. The nice examples are the
factorial function (see above) and Fibonacci numbers (see
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Rec3.tla">Rec3</a>).
However, when you define a recursive function over sets, the complexity gets
ugly really fast.</p>
<p>Consider the example
<a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/Rec9.tla">Rec9</a>,
which computes set cardinality. Here is a fragment of the spec:</p>
<pre><code class="language-tla"> The set cardinality function. It needs an upper bound on the set size.
 Although this function looks nice, be warned that this definition requires us
 to construct the powerset SUBSET NUMS and then write down the constraints
 for the function Card. This encoding is (at least) double-exponential.
 *)
Card[S \in SUBSET NUMS] ==
    IF S = {}
    THEN 0
    ELSE LET i == CHOOSE j \in S: TRUE IN
        1 + Card[S \ {i}]

Init ==
    /\ set = {}
    /\ size = 0
</code></pre>
<p>Since we cannot fix the order, in which the set elements are evaluated, we
define function <code>Card</code> over <code>SUBSET NUMS</code>, that is, all possible subsets of
<code>NUMS</code>. Apalache translates the function in a quantifier-free theory of SMT.
Hence, in this case, Apalache expands <code>SUBSET NUMS</code>, so it introduces
<code>2^|NUMS|</code> sets! Further, Apalache writes down the SMT constraints for the
domain of <code>Card</code>. As a result, it produces <code>NUMS * 2^|NUMS|</code> constraints.
As you can see, recursive functions over sets explode quite fast.</p>
<p>It is usually a good idea to use recursive operators over sets rather than
recursive functions. The downside is that you have to provide an upper bound on
the number of the operator iterations. The upside is that recursive operators
are usually unrolled more efficiently. (If they contain only constant
expressions, they are even computed by the translator!) For instance, set
cardinality does not require <code>2^|NUMS|</code> constraints, when using a recursive
operator.</p>
<h1><a class="header" href="#the-apalache-module" id="the-apalache-module">The Apalache Module</a></h1>
<p>Similar to the <code>TLC</code> module, we provide the module called <code>Apalache</code>, which can
be found in
<a href="https://github.com/informalsystems/apalache/tree/unstable/src/tla">src/tla</a>.
Most of the operators in that modules are introduced internally by Apalache,
when it is rewriting a TLA+ specification.  It is useful to read the comments
to the operators defined in <code>Apalache.tla</code>, as they will help you in
understanding the <a href="apalache/./running.html#detailed">detailed output</a> produced by the tool, see.
Perhaps, the most interesting operator in <code>Apalache</code> is the type assignment
operator that is defined as follows:</p>
<pre><code class="language-tla">x := e == x = e
</code></pre>
<p>See the <a href="apalache/./principles.html#assignments">discussion</a> on the role of assignments in Apalache.</p>
<h1><a class="header" href="#profiling-your-specification" id="profiling-your-specification">Profiling Your Specification</a></h1>
<p><strong>Warning:</strong> Profiling only works in the incremental SMT mode, that is, when the model checker is run
with <code>--algo=incremental</code>, or without the option
<code>--algo</code> specified.</p>
<p>As Apalache translates the TLA+ specification to SMT, it often defeats our intuition about the standard bottlenecks that
one learns about when running TLC. For instance, whereas TLC needs a lot of time to compute the initial states for the
following specification, Apalache can check the executions of length up to ten steps in seconds:</p>
<pre><code class="language-tla">---------------------------- MODULE powerset ----------------------------
EXTENDS Integers
VARIABLE S

Init ==
    /\ S \in SUBSET (1..50)
    /\ 3 \notin S

Next ==
    \/ \E x \in S:
        S' = S \ {x}
    \/ UNCHANGED S

Inv ==
    3 \notin S
=========================================================================
</code></pre>
<p>Apalache has its own bottlenecks. As it's using the SMT solver z3,
we cannot precisely profile your TLA+ specification. However, we can profile
the number of SMT variables and constraints that Apalache produces for different
parts of your specification. To activate this profiling mode, use the option
<code>--smtprof</code>:</p>
<pre><code class="language-sh">apalache check --smtprof powerset.tla
</code></pre>
<p>The profiling data is written in the file <code>profiler.csv</code>:</p>
<pre><code># weight,nCells,nConsts,nSmtExprs,location
4424,2180,2076,28460,powerset.tla:11:5-13:18
4098,2020,1969,12000,powerset.tla:12:9-12:20
4098,2020,1969,12000,powerset.tla:12:14-12:20
...
</code></pre>
<p>The meaning of the columns is as follows:</p>
<ul>
<li>
<p><code>weight</code> is the weight of the expression.
Currently it is computed as <code>nCells + nConsts + sqrt(nSmtExprs)</code>.
We may change this formula in the future.</p>
</li>
<li>
<p><code>nCells</code> is the number of arena cells that are created during the translation.
Intuitively, the cells are used to keep the potential shapes of the data structures
that are captured by the expression.</p>
</li>
<li>
<p><code>nConsts</code> is the number of SMT constants that are produced by the translator.</p>
</li>
<li>
<p><code>nSmtExprs</code> is the number of SMT expressions that are produced by the translator.
We also include all subexpressions, when counting this metric.</p>
</li>
<li>
<p><code>location</code> is the location in the source code where the expression
was found, indicated by the file name correlated with a range of <code>line:column</code> pairs.</p>
</li>
</ul>
<p>To visualize the profiling data, you can use the script <code>script/heatmap.py</code>:</p>
<pre><code class="language-sh">$APALACHE_HOME/script/heatmap.py profile.csv heatmap.html
</code></pre>
<p>The produced file <code>heatmap.html</code> looks as follows:</p>
<p><img src="apalache/./img/profiler2.png" alt="Here you should see a heatmap" title="A heatmap" /></p>
<p>The heatmap may give you an idea about the expression that are hard for Apalache.
The following picture highlights one part of the Raft specification that produces
a lot of constraints:</p>
<p><img src="apalache/./img/profiler.png" alt="Here you should see a heatmap" title="A heatmap of Raft" /></p>
<h1><a class="header" href="#five-minutes-of-theory" id="five-minutes-of-theory">Five minutes of theory</a></h1>
<p><strong>You can safely skip this section</strong></p>
<p>Given a TLA+ specification, with all parameters fixed, our model checker
performs the following steps:</p>
<ol>
<li>
<p>It automatically extracts symbolic transitions from the specification. This
allows us to partition the action <code>Next</code> into a disjunction of simpler actions
<code>A_1, ..., A_n</code>.</p>
</li>
<li>
<p>Apalache translates operators <code>Init</code> and <code>A_1, ..., A_n</code> to SMT formulas.
This allows us to explore bounded executions with an SMT solver (we are using
<a href="https://github.com/Z3Prover/z3">Microsoft's Z3</a>). For instance, a sequence of
<code>k</code> steps <code>s_0, s_1, ..., s_k</code>, all of which execute action <code>A_1</code>, is encoded
as a formula <code>Run(k)</code> that looks as follows:</p>
</li>
</ol>
<pre><code class="language-tla">[[Init(s_0)]] /\ [[A_1(s_0, s_1)]] /\ ... /\ [[A_1(s_(k-1), s_k)]]
</code></pre>
<p>To find an execution of length <code>k</code> that violates an invariant <code>Inv</code>, the tool
adds the following constraint to the formula <code>Run(k)</code>:</p>
<pre><code class="language-tla">[[~Inv(s_0)]] \/ ... \/ [[~Inv(s_k)]]
</code></pre>
<p>Here, <code>[[_]]</code> is the translator from TLA+ to SMT. Importantly, the values for
the states <code>s_0</code>, ..., <code>s_k</code> are not enumerated as in TLC, but have to be found
by the SMT solver.</p>
<p>If you would like to learn more about theory behind Apalache, check the <a href="https://dl.acm.org/doi/10.1145/3360549">paper
delivered at OOPSLA19</a>.</p>
<h1><a class="header" href="#syntax-of-tlc-configuration-files" id="syntax-of-tlc-configuration-files">Syntax of TLC Configuration Files</a></h1>
<p><strong>Author:</strong> Igor Konnov, 2020</p>
<p>This file presents the syntax of
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a> configuration files
in <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> and
comments on the treatment of its sections in
<a href="https://github.com/informalsystems/apalache">Apalache</a>. A detailed discussion
on using the config files with TLC can be found in Leslie Lamport's
<a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>,
Chapter 14 and in
<a href="https://lamport.azurewebsites.net/tla/current-tools.pdf">Current Versions of the TLA+ Tools</a>.
In particular, the TLA+ specification of TLC configuration files
is given in Section 14.7.1. The standard parser can be found in
<a href="https://github.com/tlaplus/tlaplus/blob/master/tlatools/org.lamport.tlatools/src/tlc2/tool/impl/ModelConfig.java"><code>tlc2.tool.impl.ModelConfig</code></a>.
As the configuration files have simple syntax, we implement our own parser in
Apalache.</p>
<pre><code class="language-ebnf">// The configuration file is a non-empty sequence of configuration options.
config ::=
    options+

// Possible options, in no particular order, all of them are optional.
// Apalache expects Init after Next, or Next after Init.
options ::=
    Init
  | Next
  | Specification
  | Constants
  | Invariants
  | Properties
  | StateConstraints
  | ActionConstraints
  | Symmetry
  | View
  | Alias
  | Postcondition
  | CheckDeadlock

// Set the initialization predicate (over unprimed variables), e.g., Init.
Init ::=
    &quot;INIT&quot; ident

// Set the next predicate (over unprimed and primed variables), e.g., Next.
Next ::=
    &quot;NEXT&quot; ident

// Set the specification predicate, e.g., Spec.
// A specification predicate usually looks like Init /\ [][Next]_vars /\ ...
Specification ::=
    &quot;SPECIFICATION&quot; ident

// Set the constants to specific values or substitute them with other names.
Constants ::=
    (&quot;CONSTANT&quot; | &quot;CONSTANTS&quot;) (replacement | assignment)*

// Replace the constant in the left-hand side
// with the identifier in the right-hand side.
replacement ::=
    ident &quot;&lt;-&quot; ident

// Replace the constant in the left-hand side
// with the constant expression in the right-hand side.
assignment ::=
    ident &quot;=&quot; constExpr

// A constant expression that may appear in
// the right-hand side of an assignment.
constExpr ::=
    modelValue
  | integer
  | string
  | boolean
  | &quot;{&quot; &quot;}&quot;
  | &quot;{&quot; constExpr (&quot;,&quot; constExpr)* &quot;}&quot;

// The name of a model value, see Section 14.5.3 of Specifying Systems.
// A model value is essentially an uninterpreted constant.
// All model values are distinct from one another. Moreover, they are
// not equal to other values such as integers, strings, sets, etc.
// Apalache treats model values as strings, which it declares as
// uninterpreted constants in SMT.
modelValue ::= ident

// An integer (no bit-width assumed)
integer ::=
      &lt;string matching regex [0-9]+&gt;
    | &quot;-&quot; &lt;string matching regex [0-9]+&gt;

// A string, starts and ends with quotes,
// a restricted set of characters is allowed (pre-UTF8 era, Paxon scripts?)
string ::=
    '&quot;' &lt;string matching regex [a-zA-Z0-9_~!@#\$%^&amp;*-+=|(){}[\],:;`'&lt;&gt;.?/ ]*&gt; '&quot;'

// A Boolean literal
boolean ::= &quot;FALSE&quot; | &quot;TRUE&quot;

// Set an invariant (over unprimed variables) to be checked against
// every reachable state.
Invariants ::=
    (&quot;INVARIANT&quot; | &quot;INVARIANTS&quot;) ident*

// Set a temporal property to be checked against the initial states.
// Temporal properties reason about finite or infinite computations,
// which are called behaviors in TLA+. Importantly, the computations
// originate from the initial states.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Properties ::=
    (&quot;PROPERTY&quot; | &quot;PROPERTIES&quot;) ident*

// Set a state predicate (over unprimed variables)
// that restricts the state space to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
StateConstraints ::=
    (&quot;CONSTRAINT&quot; | &quot;CONSTRAINTS&quot;) ident*

// Set an action predicate (over unprimed and primed variables)
// that restricts the transitions to be explored.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
ActionConstraints ::=
    (&quot;ACTION-CONSTRAINT&quot; | &quot;ACTION-CONSTRAINTS&quot;) ident*

// Set the name of an operator that produces a set of permutations
// for symmetry reduction.
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Symmetry ::=
    &quot;SYMMETRY&quot; ident

// Set the name of an operator that produces a state view
// (some form of abstraction).
// See Section 14.3.3 in Specifying Systems.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
View ::=
    &quot;VIEW&quot; ident

// Whether the tools should check for deadlocks.
// APALACHE IGNORES THIS CONFIGURATION OPTION.
CheckDeadlock ::=
    &quot;CHECK_DEADLOCK&quot; (&quot;FALSE&quot; | &quot;TRUE&quot;)

// Recent feature: https://lamport.azurewebsites.net/tla/current-tools.pdf
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Postcondition ::=
    &quot;POSTCONDITION&quot; ident

// Very recent feature: https://github.com/tlaplus/tlaplus/issues/485
// APALACHE IGNORES THIS CONFIGURATION OPTION.
Alias ::=
    &quot;ALIAS&quot; ident

// A TLA+ identifier, must be different from the above keywords.
ident ::=
    &lt;string matching regex [a-zA-Z_]([a-zA-Z0-9_])*&gt;

</code></pre>
<h2><a class="header" href="#the-new-type-checker-snowcat" id="the-new-type-checker-snowcat">The new type checker Snowcat</a></h2>
<p><strong>WARNING:</strong> Snowcat is our type checker starting with Apalache version 0.15.0.
If you are using Apalache prior to version 0.15.0, check the chapter on
<a href="apalache/./types-and-annotations.html">old type annotations</a>.</p>
<hr />
<h3><a class="header" href="#how-to-write-type-annotations" id="how-to-write-type-annotations">How to write type annotations</a></h3>
<p>Check the <a href="apalache/../HOWTOs/howto-write-type-annotations.html">HOWTO</a>.  You can find
detailed syntax of type annotations in <a href="apalache/../adr/002adr-types.html">ADR002</a>. </p>
<h3><a class="header" href="#how-to-run-the-type-checker" id="how-to-run-the-type-checker">How to run the type checker</a></h3>
<p>The type checker can be run as follows:</p>
<pre><code class="language-bash">$ apalache typecheck [--infer-poly=&lt;bool&gt;] &lt;myspec&gt;.tla
</code></pre>
<p>The arguments are as follows:</p>
<ul>
<li>General parameters:
<ul>
<li><code>--infer-poly</code> controls whether the type checker should infer polymorphic
types. As many specs do not need polymorphism, you can set this option
to <code>false</code>. The default value is <code>true</code>.</li>
</ul>
</li>
</ul>
<p>There is not much to explain about running the tool. When it successfully finds
the types of all expressions, it reports:</p>
<pre><code> &gt; Running Snowcat .::..
 &gt; Your types are great!
  ...
Type checker [OK]
</code></pre>
<p>When the type checker finds an error, it explains the error like that:</p>
<pre><code> &gt; Running Snowcat .::.
[QueensTyped.tla:42:44-42:61]: Mismatch in argument types. Expected: (Seq(Int)) =&gt; Bool
[QueensTyped.tla:42:14-42:63]: Error when computing the type of Solutions
 &gt; Snowcat asks you to fix the types. Meow.
Type checker [FAILED]
</code></pre>
<p>Here is the list of the TLA+ language features that are currently supported by Apalache, following the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of TLA+</a>.</p>
<h2><a class="header" href="#safety-vs-liveness" id="safety-vs-liveness">Safety vs. Liveness</a></h2>
<p>At the moment, Apalache is able to check invariants and inductive invariants.
It means that you can only check safety with Apalache, unless you employ
<a href="https://www.sciencedirect.com/science/article/pii/S1571066104804109?via%3Dihub">liveness-to-safety</a> transformation in your spec. It does not support
liveness properties.  If you really like to see liveness implemented, upvote
the <a href="https://github.com/informalsystems/apalache/issues/488">liveness feature</a>.</p>
<h2><a class="header" href="#language" id="language">Language</a></h2>
<h3><a class="header" href="#module-level-constructs" id="module-level-constructs">Module-Level constructs</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>EXTENDS module</code></td><td align="center">‚úî</td><td align="center">-</td><td>As soon as SANY imports the module. Some standard modules are not supported yet</td></tr>
<tr><td><code>CONSTANTS C1, C2</code></td><td align="center">‚úî</td><td align="center">-</td><td>Either define a <code>ConstInit</code> operator to initialize the constants, or declare operators instead of constants, e.g., C1 == 111</td></tr>
<tr><td><code>VARIABLES x, y, z</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>ASSUME P</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parsed, but not propagated to the solver</td></tr>
<tr><td><code>F(x1, ..., x_n) == exp</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Every application of <code>F</code> is replaced with its body. Recursive operators need <a href="apalache/./principles.html#recursive-operators">unrolling annotations</a>.</td></tr>
<tr><td><code>f[x ‚àà S] == exp</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Only recursive functions that return integers or Booleans are supported.</td></tr>
<tr><td><code>INSTANCE M WITH ...</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>No special treatment for <code>~&gt;</code>, <code>\cdot</code>, <code>ENABLED</code></td></tr>
<tr><td><code>N(x1, ..., x_n) == INSTANCE M WITH...</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parameterized instances are not supported</td></tr>
<tr><td><code>THEOREM P</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Parsed but not used</td></tr>
<tr><td><code>LOCAL def</code></td><td align="center">‚úî</td><td align="center">-</td><td>Replaced with local LET-IN definitions</td></tr>
</tbody></table>
<h3><a class="header" href="#the-constant-operators" id="the-constant-operators">The constant operators</a></h3>
<h4><a class="header" href="#logic" id="logic">Logic</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>/\</code>, <code>\/</code>, <code>~</code>, <code>=&gt;</code>, <code>&lt;=&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>TRUE</code>, <code>FALSE</code>, <code>BOOLEAN</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>\A x \in S: p</code>, <code>\E x \in S : p</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>CHOOSE x \in S : p</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Similar to TLC, we implement a non-deterministic choice. We will add a deterministic version in the future.</td></tr>
<tr><td><code>CHOOSE x : x \notin S</code></td><td align="center">‚úñ</td><td align="center">?</td><td>That is a commonly used idiom</td></tr>
<tr><td><code>\A x : p, \E x : p</code></td><td align="center">‚úñ</td><td align="center"><strong>NEVER</strong></td><td>Use the versions above</td></tr>
<tr><td><code>CHOOSE x : p</code></td><td align="center">‚úñ</td><td align="center"><strong>NEVER</strong></td><td>Use the version above</td></tr>
</tbody></table>
<h4><a class="header" href="#sets" id="sets">Sets</a></h4>
<p><strong>Note:</strong> only finite sets are supported. Additionally, existential
quantification over <code>Int</code> and <code>Nat</code> is supported, as soon as it can be
replaced with a constant.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>=</code>, <code>/=</code>, <code>\in</code>, <code>\notin</code>, <code>\intersect</code>, <code>\union</code>, <code>\subseteq</code>, <code>\</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e_1, ..., e_n}</code></td><td align="center">‚úî</td><td align="center">-</td><td>Empty sets <code>{}</code> require <a href="apalache/types-and-annotations.html">type annotations</a></td></tr>
<tr><td><code>{x \in S : p}</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>{e : x \in S}</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>SUBSET S</code></td><td align="center">‚úî</td><td align="center">-</td><td>Sometimes, the powersets are expanded</td></tr>
<tr><td><code>UNION S</code></td><td align="center">‚úî</td><td align="center">-</td><td>Provided that S is expanded</td></tr>
</tbody></table>
<h4><a class="header" href="#functions" id="functions">Functions</a></h4>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>f[e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>DOMAIN f</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ x \in S ‚Ü¶ e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ S -&gt; T ]</code></td><td align="center">‚úî</td><td align="center">-</td><td>Sometimes, the functions sets are expanded</td></tr>
<tr><td><code>[ f EXCEPT ![e1] = e2 ]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#records" id="records">Records</a></h4>
<p><em>Use <a href="apalache/types-and-annotations.html">type annotations</a> to help the model checker in finding the right types.</em>
Note that our type system distinguishes records from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e.h</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>r[e]</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Provided that e is a constant expression.</td></tr>
<tr><td><code>[ h1 ‚Ü¶ e1, ..., h_n ‚Ü¶ e_n]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ h1 : S1, ..., h_n : S_n]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ r EXCEPT !.h = e]</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h4><a class="header" href="#tuples" id="tuples">Tuples</a></h4>
<p><em>Use <a href="apalache/types-and-annotations.html">type annotations</a> to help the model checker in finding the right types.</em>
Note that our type system distinguishes tuples from general functions.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e[i]</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
<tr><td><code>&lt;&lt; e1, ..., e_n &gt;&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>By default, a tuple is constructed. Use a <a href="apalache/types-and-annotations.html">type annotation</a> to construct a sequence of proper type.</td></tr>
<tr><td><code>S1 \X ... \X S_n</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[ t EXCEPT ![i] = e]</code></td><td align="center">‚úî/‚úñ</td><td align="center">-</td><td>Provided that <code>i</code> is a constant expression</td></tr>
</tbody></table>
<h4><a class="header" href="#strings-and-numbers" id="strings-and-numbers">Strings and numbers</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&quot;c1...c_n&quot;</code></td><td align="center">‚úî</td><td align="center">-</td><td>A string is always mapped to a unique uninterpreted constant</td></tr>
<tr><td><code>STRING</code></td><td align="center">‚úñ</td><td align="center">-</td><td>It is an infinite set. We cannot handle infinite sets.</td></tr>
<tr><td><code>d1...d_n</code></td><td align="center">‚úî</td><td align="center">-</td><td>As long as the SMT solver (Z3) accepts that large number</td></tr>
<tr><td><code>d1...d_n.d_n+1...d_m</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Technical issue. We will implement it upon a user request.</td></tr>
</tbody></table>
<h4><a class="header" href="#miscellaneous-constructs" id="miscellaneous-constructs">Miscellaneous Constructs</a></h4>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IF p THEN e1 ELSE e2</code></td><td align="center">‚úî</td><td align="center">-</td><td>Provided that both e1 and e2 have the same type</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n [] OTHER -&gt; e</code></td><td align="center">‚úî</td><td align="center">-</td><td>See the comment above</td></tr>
<tr><td><code>CASE p1 -&gt; e1 [] ... [] p_n -&gt; e_n</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Introduce the default arm with <code>OTHER</code>.</td></tr>
<tr><td><code>LET d1 == e1 ... d_n == e_n IN e</code></td><td align="center">‚úî</td><td align="center"></td><td>All applications of <code>d1</code>, ..., <code>d_n</code> are replaced with the expressions <code>e1</code>, ... <code>e_n</code> respectively. LET-definitions without arguments are kept in place.</td></tr>
<tr><td>multi-line <code>/\</code> and <code>\/</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-action-operators" id="the-action-operators">The Action Operators</a></h3>
<table><thead><tr><th>Construct</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>e'</code></td><td align="center">‚úî</td><td align="center">-</td><td></td></tr>
<tr><td><code>[A]_e</code></td><td align="center">‚úñ</td><td align="center">-</td><td>It does not matter for safety</td></tr>
<tr><td><code>&lt; A &gt;_e</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
<tr><td><code>ENABLED A</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
<tr><td><code>UNCHANGED &lt;&lt;e_1, ..., e_k&gt;&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>Always replaced with <code>e_1' = e_1 /\ ... /\ e_k' = e_k</code></td></tr>
<tr><td><code>A ‚àô B</code></td><td align="center">‚úñ</td><td align="center">-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#the-temporal-operators" id="the-temporal-operators">The Temporal Operators</a></h3>
<p>The model checker assumes that the specification has the form <code>Init /\ [][Next]_e</code>. Given an invariant candidate <code>Inv</code>, the tool checks, whether
<code>Inv</code> is violated by an execution whose length is bounded by the given
argument.</p>
<p>Except the standard form <code>Init /\ [][Next]_e</code>, no temporal operators are supported.</p>
<h2><a class="header" href="#standard-modules" id="standard-modules">Standard modules</a></h2>
<h3><a class="header" href="#integers-and-naturals" id="integers-and-naturals">Integers and Naturals</a></h3>
<p>For the moment, the model checker does not differentiate between integers and naturals. They are all translated as integers in SMT.</p>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td align="center">‚úî</td><td align="center">-</td><td>These operators are translated into integer arithmetic of the SMT solver. Linear integer arithmetic is preferred.</td></tr>
<tr><td><code>\div</code>, <code>%</code></td><td align="center">‚úî</td><td align="center">-</td><td>Integer division and modulo</td></tr>
<tr><td><code>a^b</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Provided a and b are constant expressions</td></tr>
<tr><td><code>a..b</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Sometimes, <code>a..b</code> needs a constant upper bound on the range.  When Apalache complains, use <code>{x \in A..B : a &lt;= x /\ x &lt;= b}</code>, provided that <code>A</code> and <code>B</code> are constant expressions.</td></tr>
<tr><td><code>Int</code>, <code>Nat</code></td><td align="center">‚úî / ‚úñ</td><td align="center">-</td><td>Supported in <code>\E x \in Nat: p</code> and <code>\E x \in Int: p</code>, if the expression is not located under <code>\A</code> and <code>~</code>. We also support assignments like <code>f' \in [S -&gt; Int]</code> and tests <code>f \in [S -&gt; Nat]</code></td></tr>
<tr><td><code>/</code></td><td align="center">‚úñ</td><td align="center">-</td><td>Real division, not supported</td></tr>
</tbody></table>
<h3><a class="header" href="#sequences" id="sequences">Sequences</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;...&gt;&gt;</code>, <code>Head</code>, <code>Tail</code>, <code>Len</code>, <code>SubSeq</code>, <code>Append</code>, <code>\o</code>, <code>f[e]</code></td><td align="center">‚úî</td><td align="center">-</td><td>The sequence constructor <code>&lt;&lt;...&gt;&gt;</code> needs a <a href="apalache/types-and-annotations.html">type annotation</a>.</td></tr>
<tr><td><code>EXCEPT</code></td><td align="center">‚úñ</td><td align="center"></td><td>If you need it, let us know, issue #324</td></tr>
<tr><td><code>Seq(S)</code></td><td align="center">‚úñ</td><td align="center">-</td><td>If you need it, let us know, issue #314</td></tr>
<tr><td><code>SelectSeq</code></td><td align="center">‚úñ</td><td align="center">-</td><td>will not be supported in the near future</td></tr>
</tbody></table>
<h3><a class="header" href="#finitesets" id="finitesets">FiniteSets</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>IsFinite</code></td><td align="center">‚úî</td><td align="center">-</td><td>Always returns true, as all the supported sets are finite</td></tr>
<tr><td><code>Cardinality</code></td><td align="center">‚úî</td><td align="center">-</td><td>Try to avoid it, as Cardinality(S) produces <code>O(n^2)</code> constraints in SMT for cardinality <code>n</code></td></tr>
</tbody></table>
<h3><a class="header" href="#tlc" id="tlc">TLC</a></h3>
<table><thead><tr><th>Operator</th><th align="center">Supported?</th><th align="center">Milestone</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>f @@ a :&gt; b</code></td><td align="center">‚úî</td><td align="center">-</td><td>Extends the function relation with the pair <code>&lt;&lt;a, b&gt;&gt;</code></td></tr>
</tbody></table>
<h3><a class="header" href="#reals" id="reals">Reals</a></h3>
<p>Not supported, not a priority</p>
<h1><a class="header" href="#known-issues" id="known-issues">Known issues</a></h1>
<p>This page collects known issues that were reported by the users.</p>
<h2><a class="header" href="#deadlock-detection" id="deadlock-detection">Deadlock detection</a></h2>
<p>Deadlock detection is imprecise. It may report false negatives, see <a href="https://github.com/informalsystems/apalache/issues/711">Issue
711</a>.</p>
<p><strong>Affected versions:</strong> &lt;= 0.15.x</p>
<p><strong>Planned fix:</strong> <a href="https://github.com/informalsystems/apalache/issues/712">Issue 712</a></p>
<h1><a class="header" href="#preprocessing-in-apalache" id="preprocessing-in-apalache">Preprocessing in APALACHE</a></h1>
<p>Before translating a specification into SMT, <code>apalache</code> performs a number of
preprocessing steps:</p>
<ul>
<li><code>InlinerOfUserOper</code>: replaces every call to a user-defined operator with the operator's body.</li>
<li><code>LetInExpander</code>: replaces every call to a let-in defined operator of arity at least 1 with the operator's body</li>
<li><code>PrimingPass</code>: adds primes to variables in <code>Init</code> and <code>ConstInit</code> (required by <code>TransitionPass</code>)</li>
<li><code>VCGen</code>: extracts verification conditions from the invariant candidate.</li>
<li><code>Desugarer</code>: removes syntactic sugar like short-hand expressions in <code>EXCEPT</code>.</li>
<li><code>Normalizer</code>: rewrites all expressions in <a href="https://en.wikipedia.org/wiki/Negation_normal_form">negation-normal form</a>.</li>
<li><code>Keramelizer</code>: translates TLA+ expressions into the kernel language <a href="apalache/./kera.html">KerA</a>.</li>
<li><code>ExprOptimizer</code>: statically computes select expressions (e.g. record field access from a known record)</li>
<li><code>ConstSimplifier</code>: propagates constants</li>
</ul>
<h2><a class="header" href="#keramelizer" id="keramelizer">Keramelizer</a></h2>
<p>Keramelizer rewrites TLA+ expressions into <a href="apalache/./kera.html">KerA</a>. For many TLA+ expressions
this translation is clear, however, some expressions cannot be easily translated. Below
we discuss such expressions and the decisions that we have made.</p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li>Leslie Lamport. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers.
Addison-Wesley Professional, 2004. <a name="spec2004"></a></li>
</ul>
<h1><a class="header" href="#parameters-for-fine-tuning" id="parameters-for-fine-tuning">Parameters for fine tuning</a></h1>
<p>The parameters for fine tuning can be passed to the checker in a properties
file.  Its name is given with the command-line option <code>--tuning=my.properties.</code>
This file supports variable substitution, e.g., <code>${x}</code> is replaced with the
value of <code>x</code>, if it was previously declared.</p>
<p>Alternatively, you can pass the tuning options right in the command-line by
passing the option <code>--tune-here</code> that has the following format:</p>
<pre><code>```
--tune-here=key1=val1
--tune-here=key1=val1:key2=val2
...
```
</code></pre>
<ol>
<li>
<p><strong>Randomization</strong>: <code>smt.randomSeed=&lt;int&gt;</code> passes the random seed to <code>z3</code>
(via <code>z3</code>'s parameters <code>sat.random_seed</code> and <code>smt.random_seed</code>).</p>
</li>
<li>
<p><strong>Timeouts</strong>: <code>search.smt.timeout=&lt;seconds&gt;</code> defines the timeout to the
SMT solver in seconds. The default value is <code>0</code>, which stands for the unbounded
timeout.  For instance, the timeout is used in the following cases: checking if
a transition is enabled, checking an invariant, checking for deadlocks.  If the
solver times out, it reports 'UNKNOWN', and the model checker reports a runtime
error.</p>
</li>
<li>
<p><strong>Invariant mode</strong>: <code>search.invariant.mode=(before|after)</code> defines the
moment when the invariant is checked. In the <code>after</code> mode, all transitions are
first translated, one of them is picked non-deterministically and then the
invariant is checked. Although this mode reduces the number of SMT queries, it
usually requires more memory than the <code>before</code> mode. In the <code>before</code> mode, the
invariant is checked for every enabled transition independently. The <code>before</code>
mode may drastically reduce memory consumption, but it may take longer than the
<code>after</code> mode, provided that Apalache has enough memory. The default mode is
<code>before</code>.</p>
</li>
<li>
<p><strong>Guided search</strong>: <code>search.transitionFilter=&lt;regex&gt;</code>.
Restrict the choice of symbolic transitions at every step with a regular expression.
The regular expression should recognize words over of the form 's-&gt;t', where <code>s</code>
is a regular expression over step numbers and <code>t</code> is a regular expression over
transition numbers. For instance,
<code>search.transitionFilter=(0-&gt;0|1-&gt;5|2-&gt;2|3-&gt;3|[4-9]-&gt;.*|[1-9][0-9]+-&gt;.*)</code>
requires to start with the 0th transition, continue with the 5th transition,
then execute either the 2nd or the 3rd transition and after that execute
arbitrary transitions until the <code>length.</code> Note that there is no direct correspondence
between the transition numbers and the actions in the TLA+ spec. Check the
transition numbers in <code>./x/**/out-transition.tla</code>: 0th transition is called <code>Next$0</code>, 1st transition is called <code>Next$1</code>, etc.</p>
</li>
<li>
<p><strong>Invariant checking at certain steps</strong>: <code>search.invariantFilter=regex</code>.
Check the invariant only at the steps that satisfy the regular expression.
For instance, <code>search.invariantFilter=10|15|20</code> tells the model checker to
check the invariant only <em>after</em> exactly 10, 15, or 20 step were made. Step 0 corresponds
to the initialization with <code>Init</code>, step 1 is the first step with <code>Next</code>, etc.
This option is useful for checking consensus algorithms, where the decision
cannot be revoked. So instead of checking the invariant after each step, we can
do that after the algorithm has made a good number of steps.</p>
</li>
<li>
<p><strong>Translation to SMT</strong>:</p>
</li>
<li>
<p><strong>Short circuiting</strong>: <code>rewriter.shortCircuit=(false|true)</code>. When <code>rewriter.shortCircuit=true</code>, <code>A \/ B</code> and <code>A /\ B</code> are translated to SMT as if-then-else expressions, e.g., <code>(ite A true B)</code>. Otherwise, disjunctions and conjunctions are directly translated to <code>(or ...)</code> and <code>(and ...)</code> respectively. By default, <code>rewriter.shortCircuit=false</code>.</p>
</li>
<li>
<p><strong>Lazy short circuiting</strong>: <code>rewriter.lazyCircuit=(false|true)</code>. Given <code>A /\ B</code>, first check with the solver, whether <code>A</code> is satisfiable. If not, return reduce to <code>false</code> immediately; otherwise, rewrite <code>B</code>. By default, <code>rewriter.lazyCircuit=false</code>.</p>
</li>
</ol>
<h1><a class="header" href="#kera-kernel-logic-of-actions" id="kera-kernel-logic-of-actions">KerA: kernel logic of actions</a></h1>
<p>See <a href="https://dl.acm.org/citation.cfm?id=3360549">TLA+ model checking made symbolic</a>.</p>
<h1><a class="header" href="#assignments-in-apalache" id="assignments-in-apalache">Assignments in Apalache</a></h1>
<p>Any run of Apalache requires an operator name as the value for the parameter <code>--next</code> (by default, this value is <code>&quot;Next&quot;</code>). We refer to this operator as the <em>transition operator</em> (or <em>transition predicate</em>).</p>
<h2><a class="header" href="#actions-slices-and-minimal-actions" id="actions-slices-and-minimal-actions">Actions, Slices and Minimal Actions</a></h2>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>In TLA+, an <em>action</em> is any Boolean-valued expression or operator, that contains primed variables (e.g. <code>Next</code>). For the sake of this definition, assume <code>UNCHANGED x</code> is just syntactic sugar for <code>x' = x</code>.
Intuitively, actions are used to define the values of state variables after a transition, for example:</p>
<pre><code class="language-tla">VARIABLE x
...

Next == x' = x + 1
</code></pre>
<p>The state transition described by <code>Next</code> is fairly obvious; if <code>x</code> has the value of <code>4</code> in the current state, it will have the value of <code>5</code> in any successor state.
This brings us to the first natural requirement by Apalache: <em>the transition operator must be an action.</em></p>
<h3><a class="header" href="#successor-state-encodings" id="successor-state-encodings">Successor State Encodings</a></h3>
<p>Unfortunately, the notion of an action is too broad to be a sufficient requirement for the transition operator.
Consider this slight modification of the above example:</p>
<pre><code class="language-tla">VARIABLE x, y (* new variable *)
...

Next == x' = x + 1
</code></pre>
<p>Just as in the first example, the expression <code>x' = x + 1</code> is, by definition, an action.
However, since the second example defines a state variable <code>y</code>, this action is
no longer a sufficient description of a relation between a current state and a successor state; it does not determine a successor value <code>y'</code>.
This brings us to the second requirement: <em>the transition operator must allow Apalache to directly encode the relation between two successive states.</em>
This captures two sub-requirements: firstly, we disallow transition operators which fail to specify the value of one or more variables in the successor states, like the one in the example above. Secondly, we also disallow transition operators where the value of a successor state variable is determined only by implicit equations. Consider the following two cases:</p>
<pre><code class="language-tla">VARIABLE y
...

A == y' = 1
B == y' * y' - 2 * y' + 1 = 0
</code></pre>
<p>Using some basic math, we see that action <code>B</code> can be equivalently written as <code>(y' - 1)*(y' - 1) = 0</code>, so it describes the exact same successor state, in which the new value of <code>y</code> is <code>1</code>.
What makes it different from action <code>A</code> is the fact that this is far from immediately obvious from the syntax.
The fact that there happened to be a closed-form solution for which gave us an integer value for <code>y'</code>, is a lucky coincidence, as <code>B</code> could have been, for example, <code>y' * y' + 1 = 0</code>, with no real roots.
To avoid cases like this, we require that transition operators explicitly declare the values of state variables in successor states.</p>
<p>We call syntactic forms, which explicitly represent successor state values, <em>assignment candidates</em>. An assignment candidate for <code>x</code> is a TLA+ expression that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <a href="https://github.com/informalsystems/apalache/blob/unstable/src/tla/Apalache.tla">Apalache.tla</a>)</li>
</ul>
<p>So to reformulate the second requirement: the transition operator must contain at least one assignment candidate for each variable declared in the specification.</p>
<h3><a class="header" href="#control-flow-minimal-and-compound-actions" id="control-flow-minimal-and-compound-actions">Control Flow: Minimal and Compound Actions</a></h3>
<p>When writing non-trivial specifications, authors often end up with something similar to the following:</p>
<pre><code class="language-tla">EventA == ...
EventB == ...
...

Next == \/ EventA
        \/ EventB
</code></pre>
<p>Specifically, <code>EventA</code> and <code>EventB</code> often represent mutually exclusive possibilities of execution.
Just like before, the basic definition of an action is not sufficient to explain the relation of <code>EventA</code> or <code>EventB</code> and <code>Next</code>;
if <code>EventA</code> is an action and <code>EventB</code> is an action, then <code>Next</code> is also an action.
To more accurately describe this scenario, we observe that the operator or ( <code>\/</code>) sometimes serves as a kind of parallel composition operator (<code>||</code>) in process algebra - it connects two (or more) actions into a larger one.</p>
<p>There are only two operators in TLA+ that could be considered control-flow operators in this way, the or (<code>\/</code>) operator and the if-then-else operator.
We distinguish their uses as action- and as value operators:</p>
<pre><code class="language-tla">
A == x = 1 \/ x = 2 (* arguments are not actions *)
B == x' = 1 \/ x' = 2 (* arguments are actions *)
</code></pre>
<p>Simply put, if all arguments to an operator <code>\/</code> are actions, then that operator is an action-or, otherwise it is a value-or. Similarly, if both the <code>THEN _</code> and <code>ELSE _</code> subexpressions of if-then-else are actions, it is an action-ITE, otherwise it is a value-ITE (in particular, a value-ITE can be non-Boolean).</p>
<p>Using these two operators we can define the following terms:
A <em>minimal action</em> is an action which contains no action-or and no action-ITE.
Conversely, a <em>compound action</em> is an action which contains at least one action-or or at least one action-ITE.</p>
<h3><a class="header" href="#slices" id="slices">Slices</a></h3>
<p>Given a transition operator, which is most commonly a compound action, we can decompose it into as many minimal actions as possible. We call this process <em>slicing</em> and the resulting minimal actions <em>slices</em>.
This allows us to write transition operators in the following equivalent way:</p>
<pre><code class="language-tla">Next == \/ Slice1
        \/ Slice2
        ...
        \/ SliceN
</code></pre>
<p>Where each <code>Slice[i]</code> is a minimal action.</p>
<p>The details of slicing are nuanced and depend on operators other than or (<code>\/</code>) and if-then-else, but we give two examples here:</p>
<p>If a formula <code>A</code> has the shape <code>A1 \/ ... \/ An</code> (where <code>A1</code>, ... <code>An</code> are actions), then a slice of A has the shape <code>Si</code>, where <code>Si</code> is a slice of some <code>Ai</code>.</p>
<p>If a formula <code>A</code> has the shape <code>IF p THEN A1 ELSE A2</code> (where <code>A1</code>, <code>A2</code> are actions), then a slice of A has the shape
<code>p /\ S1</code> or <code>\neg p /\ S2</code>, where <code>S1</code> is a slice of <code>A1</code> and <code>S2</code> is a slice of <code>S2</code>.</p>
<p>Slices allow us to formulate the final requirement: the transition operator must be such, that we can select one assignment candidate for each variable in each of its slices (minimal actions) as an <em>assignment</em>. The process and conditions of selecting assignments from assignment candidates is described in the next section.</p>
<h2><a class="header" href="#a-idasgn--assignments-and-assignment-candidates" id="a-idasgn--assignments-and-assignment-candidates"><a id='asgn' /> Assignments and Assignment Candidates</a></h2>
<p>Recall, an <em>assignment candidate</em> for <code>x</code> is a TLA+ expression that has one of the following forms:</p>
<ul>
<li><code>x' = e</code>,</li>
<li><code>x' \in S</code>,</li>
<li><code>UNCHANGED x</code>, or</li>
<li><code>x' := e</code> (note that <code>:=</code> is the operator defined in <code>Apalache.tla</code>)</li>
</ul>
<p>While a transition operator may contain multiple assignment candidates for the same variable, not all of them are chosen as <em>assignments</em> by Apalache. The subsections below describe how the assignments are selected.</p>
<h3><a class="header" href="#minimality" id="minimality">Minimality</a></h3>
<p>Assignments aren't spurious; each variable must have at least one assignment per transition operator, but no more than necessary to satisfy all of the additional constraints below (i.e. no more than one assignment per slice).</p>
<p>If all possible slices fail to assign one or more variables, an error, like the one below, is reported:</p>
<pre><code>Assignment error: No assignments found for: x, z
</code></pre>
<p>Such errors are usually the result of adding a <code>VARIABLE</code> without any accompanying TLA+ code relating to it.
The case where at least one transition, but not all of them, fails to assign a variable is shown below.</p>
<h3><a class="header" href="#syntax-order" id="syntax-order">Syntax Order</a></h3>
<p>For the purpose of evaluating assignments, Apalache considers the left-to-right syntax order of and-operator (<code>/\</code>) arguments.
Therefore, as many assignments as possible are selected from the first (w.r.t. syntax order) argument of and (<code>/\</code>), then from the second, and so on.</p>
<p>Example:</p>
<pre><code class="language-tla">Next == x' = 1 /\ x' = 2
</code></pre>
<p>In the above example, <code>x' = 1</code> would be chosen as an assignment to <code>x</code>, over <code>x' = 2</code>.</p>
<h3><a class="header" href="#assignment-before-use-convention" id="assignment-before-use-convention">Assignment-before-use Convention</a></h3>
<p>If, in the syntax order defined above, an expression containing a primed variable <code>x'</code> syntactically precedes an assignment to <code>x</code>, the assignment finder throws an exception of the following shape:</p>
<pre><code>Assignment error: test.tla:10:16-10:17: x' is used before it is assigned.
</code></pre>
<p>notifying the user of any variables used before assignment. In particular, right-hand-sides of assignment candidates ( e.g. <code>x' + 2</code> in <code>y' = x' + 2</code> )are subject to this restriction as well. Consider:</p>
<pre><code class="language-tla">A == x' &gt; 0 /\ x' = 1
B == y' = x' + 2 /\ x' = 1
</code></pre>
<p>In <code>A</code>, the expression <code>x' &gt; 0</code> precedes any assignment to <code>x</code> and in <code>B</code>, while <code>y' = x' + 2</code> is an assignment candidate for <code>y</code>, it precedes any assignment to <code>x</code>, so both expressions are inadmissible (and would trigger exceptions).</p>
<p>Note that this only holds true if <code>A</code> (resp. <code>B</code>) is chosen as the transition operator. If <code>A</code> is called inside another transition operator, for example in <code>Next == x' = 1 /\ A</code>, no error is reported.</p>
<h3><a class="header" href="#balance" id="balance">Balance</a></h3>
<p>In cases of the or-operator (<code>\/</code>), all arguments must have assignments for the same set of variables. In particular, if one argument contains an assignment candidate and another does not, such as in this example:</p>
<pre><code>\/ y = 1
\/ y' = 2
</code></pre>
<p>the assignment finder will report an error, like the one below:</p>
<pre><code>Assignment error: test.tla:10:15-10:19: Missing assignments to: y
</code></pre>
<p>notifying the user of any variables for which assignments exist in some, but not all, arguments to <code>\/</code>.
Note that if we correct and extend the above example to</p>
<pre><code class="language-tla">/\ \/ y' = 1
   \/ y' = 2
/\ y' = 3
</code></pre>
<p>the assignments to <code>y</code> would be <code>y' = 1</code> and <code>y' = 2</code>, but not <code>y' = 3</code>; minimality prevents us from selecting all three, the syntax order constraint forces us to select assignments in <code>y' = 1 \/ y' = 2</code> before <code>y' = 3</code> and balance requires that we select both <code>y' = 1</code> and <code>y' = 2</code>.
On the other hand, if we change the example to</p>
<pre><code class="language-tla">/\ y' = 3
/\ \/ y = 1
   \/ y' = 2
</code></pre>
<p>the only assignment has to be <code>y' = 3</code>. While one of the disjuncts is an assignment candidate and the other is not, the balance requirement is not violated here, since neither disjunct is chosen as an assignment.</p>
<p>Similar rules apply to if-then-else: both the <code>THEN _</code> and <code>ELSE _</code> branch must assign the same variables, however, the <code>IF _</code> condition is ignored when determining assignments.</p>
<h3><a class="header" href="#assignment-free-expressions" id="assignment-free-expressions">Assignment-free Expressions</a></h3>
<p>Not all expressions may contain assignments.
While Apalache permits the use of all assignment candidates, except ones defined with <code>:=</code>(details <a href="apalache/assignments.html#manual">here</a>), inside other expressions, some of these candidates will never be chosen as assignments, based on the syntactic restrictions outlined below:</p>
<p>Given a transition operator <code>A</code>, based on the shape of <code>A</code>, the following holds:</p>
<ul>
<li>If <code>A</code> has the shape <code>A_1 /\ ... /\ A_n</code>, then assignments are selected from <code>A_1, ... , A_n</code> sequentially, subject to the syntax-order rule.</li>
<li>If <code>A</code> has the shape <code>A_1 \/ ... \/ A_n</code>, then assignments are selected in all <code>A_1, ... , A_n</code> independently, subject to the balance rule.</li>
<li>If <code>A</code> has the shape <code>IF p THEN A_1 ELSE A_2</code>, then:
<ul>
<li><code>p</code> may not contain assignments. Any assignment candidates in <code>p</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in both <code>A_1</code> and <code>A_n</code> independently, subject to the balance rule.</li>
</ul>
</li>
<li>If <code>A</code> has the shape <code>\E x \in S: A_1</code>, then:
<ul>
<li><code>S</code> may not contain assignments. Any assignment candidates in <code>S</code> are subject to the assignment-before-use rule.</li>
<li>Assignments are selected in <code>A_1</code></li>
</ul>
</li>
<li>In any other case, <code>A</code> may not contain assignments, however, any assignment candidates in <code>A</code> are subject to the assignment-before-use rule.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-tla">A == /\ x' = 2
     /\ \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Operator <code>A</code> contains assignments to both <code>x</code> and <code>y</code>; while <code>x' &gt; t</code> uses <code>x'</code>, it does not violate the assignment-before-use rule, since the assignment to <code>x</code> precedes the expression, w.r.t. syntax order.</p>
<pre><code class="language-tla">(* INVALID *)
B == \E s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>In operator <code>B</code>, the assignment to <code>x</code> is missing, therefore <code>x' &gt; t</code> produces an error, as it violates assignment-before-use.</p>
<pre><code class="language-tla">C == /\ x' = 1
     /\ IF x' = 0 /\ 2 \in {x', x' + 2, 0}
        THEN y' = 1
        ELSE y' = 2
</code></pre>
<p>The case in <code>C</code> is similar to <code>A</code>; conditions of the if-then-else operator may not contain assignments to <code>x</code>, so <code>x' = 0</code> can never be one, but they may use <code>x'</code>, since a preceding expression (<code>x' = 1</code>) qualifies as an assignment.</p>
<pre><code class="language-tla">(* INVALID *)
D == IF x' = 0
     THEN y' = 1
     ELSE y' = 2
</code></pre>
<p>The operator <code>D</code> produces an error, for the same reason as <code>B</code>; even though <code>x' = 0</code> is an assignment candidate, if-conditions are assignment-free, so <code>x' = 0</code> cannot be chosen as an assignment to <code>x</code>.</p>
<pre><code class="language-tla">(* INVALID *)
E == /\ x' = 2
     /\ \A s \in { t \in 1..10 : x' &gt; t }: y' = s
</code></pre>
<p>Lastly, while <code>E</code> looks almost identical to <code>A</code>, the key difference is that expressions under universal quantifiers may not contain assignments. Therefore, <code>y' = s</code> is <em>not</em> an assignment to <code>y</code> and thus violates assignment-before-use.</p>
<h2><a class="header" href="#a-idmanual--manual-assignments" id="a-idmanual--manual-assignments"><a id='manual' /> Manual Assignments</a></h2>
<p>Users may choose, but aren't required, to use manual assignments <code>x' := e</code> in place of <code>x' = e</code>.
While the use of this operator does not change Apalache's internal search for assignments (in particular, using manual assignment annotations is <em>not</em> a way of circumventing the syntax order requirement), we encourage the use of manual assignments for clarity.</p>
<p>Unlike other shapes of assignment candidates, whenever a manual assignment is used in a position where the assignment candidate would not be chosen as an assignment (either within assignment-free expressions or in violation of, for example, the syntax order rule) an error, like one of the two below, is reported:</p>
<pre><code>Assignment error: test.tla:10:12-10:18: Manual assignment is spurious, x is already assigned!
</code></pre>
<p>or</p>
<pre><code>Assignment error: test.tla:10:15-10:21: Illegal assignment inside an assignment-free expression.
</code></pre>
<p>The benefit of using manual assignments, we believe, lies in synchronizing the user's and the tool's understanding of where assignments happen.
This helps prevent unexpected results, where the user's expectations or intuition regarding assignment positions are incorrect.</p>
<p>Note: To use manual assignments where the assignment candidate has the shape of <code>x' \in S</code> use <code>\E s \in S: x' := s</code>.</p>
<h1><a class="header" href="#overview-1" id="overview-1">Overview</a></h1>
<ol>
<li><a href="HOWTOs/./howto-write-type-annotations.html">How to write type annotations</a></li>
</ol>
<h1><a class="header" href="#how-to-write-type-annotations-1" id="how-to-write-type-annotations-1">How to write type annotations</a></h1>
<p><strong>Warning:</strong> <em>This HOWTO discusses how to write type annotations for the new
type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a>, which is used in Apalache since version 0.15.0.</em></p>
<p>This HOWTO gives you concrete steps to extend TLA+ specifications with type
annotations. You can find the detailed syntax of type annotations in
<a href="HOWTOs/../adr/002adr-types.html">ADR002</a>. The first rule of writing type annotations:</p>
<p><em>Do not to write any annotations at all, until the type checker <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> is
asking you to write a type annotation.</em></p>
<p>Of course, there must be an exception to this rule. You have to write type
annotations for CONSTANTS and VARIABLES. This is because Snowcat infers types
of declarations in isolation instead of analyzing the whole specification.
The good news is that the type checker finds the types of many operators
automatically. </p>
<h2><a class="header" href="#recipe-1-recipe-variables" id="recipe-1-recipe-variables">Recipe 1: Recipe variables</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla">HourClock.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">---------------------- MODULE HourClock ----------------------
\* This is a local copy of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/RealTime/HourClock.tla
EXTENDS Naturals
VARIABLE
    \* @type: Int;
    hr

HCini  ==  hr \in (1 .. 12)
HCnxt  ==  hr' = IF hr # 12 THEN hr + 1 ELSE 1
HC  ==  HCini /\ [][HCnxt]_hr

TypeOK == hr \in (1 .. 12)
</code></pre>
<p>Without thinking much about the types, run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck HourClock.tla
</code></pre>
<p>The type checker complains about not knowing the type of the variable <code>hr</code>:</p>
<pre><code>...
[HourClock.tla:6:12-6:13]: Undefined name hr. Introduce a type annotation.
...
</code></pre>
<p>Annotate the type of variable <code>hr</code> as below. Note carefully that the type
annotation should be <em>between</em> the keyword <code>VARIABLE</code> and the variable name.
This is because variable declarations may declare several variables at once.
In this case, you have to write one type annotation per name.</p>
<pre><code class="language-tla">VARIABLE
  \* @type: Int;
  hr
</code></pre>
<p>Run the type checker again. You should see the following message:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-2-annotating-constants" id="recipe-2-annotating-constants">Recipe 2: Annotating constants</a></h2>
<p>Consider the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla">Channel.tla</a> from <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a>:</p>
<pre><code class="language-tla">
-------------------------- MODULE Channel -----------------------------
\* This is a typed version of the example from Specifying Systems:
\* https://github.com/tlaplus/Examples/blob/master/specifications/SpecifyingSystems/FIFO/Channel.tla
EXTENDS Naturals
CONSTANT Data
VARIABLE chan 

TypeInvariant  ==  chan \in [val : Data,  rdy : {0, 1},  ack : {0, 1}]
-----------------------------------------------------------------------
Init  ==  /\ TypeInvariant
          /\ chan.ack = chan.rdy 

Send(d) ==  /\ chan.rdy = chan.ack
            /\ chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]

Rcv     ==  /\ chan.rdy # chan.ack
            /\ chan' = [chan EXCEPT !.ack = 1 - @]

Next  ==  (\E d \in Data : Send(d)) \/ Rcv

Spec  ==  Init /\ [][Next]_chan
-----------------------------------------------------------------------
THEOREM Spec =&gt; []TypeInvariant
=======================================================================

</code></pre>
<p>Run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck Channel.tla
</code></pre>
<p>The type checker does not know the type of the variable <code>chan</code>:</p>
<pre><code>[Channel.tla:6:20-6:23]: Undefined name chan. Introduce a type annotation.
</code></pre>
<p>According to <code>TypeInvariant</code>, the variable <code>chan</code> is a record that has three
fields: <code>val</code>, <code>rdy</code>, and <code>ack</code>. The field <code>val</code> ranges over a set <code>Data</code>,
which is actually defined as <code>CONSTANT</code>. In principle, we can annotate the
constant <code>Data</code> with a set of any type, e.g., <code>Set(Int)</code> or <code>Set(BOOLEAN)</code>.
Since the specification is not using any operators over <code>Data</code> except equality,
we can use an <em>uninterpreted type</em> as a type for set elements, e.g.,
we can define <code>Data</code> to have the type <code>Set(DATUM)</code>. Uninterpreted types are
always written in CAPITALS. Now we can annotate <code>Data</code> and <code>chan</code> as follows:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(DATUM);
    Data
VARIABLE
    \* @type: [val: DATUM, rdy: Int, ack: Int];
    chan 
</code></pre>
<p>Note carefully that the type annotation should be <em>between</em> the keyword
<code>CONSTANT</code> and the constant name. This is because constant declarations may
declare several constants at once. In this case, you have to write one type
annotation per name.</p>
<p>Run the type checker again. You should see the following message:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-3-annotating-operators" id="recipe-3-annotating-operators">Recipe 3: Annotating operators</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CarTalkPuzzle/CarTalkPuzzle.tla">CarTalkPuzzle.tla</a> from the repository of TLA+
examples. This example has 160 lines of code, so we do not inline it here.
By running the type checker as in previous sections, you should figure out
that the constants <code>N</code> and <code>P</code> should be annotated with the type <code>Int</code>.
Annotate <code>N</code> and <code>P</code> with <code>Int</code> and run the type checker:</p>
<pre><code class="language-sh">$ apalache typecheck CarTalkPuzzle.tla
</code></pre>
<p>Now you should see the following error:</p>
<pre><code>[CarTalkPuzzle.tla:57:9-57:12]: Need annotation. Arguments match
2 operator signatures: (((a56 -&gt; a57), a56) =&gt; a57) and ((Seq(a56), Int) =&gt; a56)
</code></pre>
<p>Although the error message may look confusing, the reason is simple: The type
checker cannot figure out, whether the operator <code>Sum</code> expects a sequence
or a function of integers as its first parameter. By looking carefully at
the definition of <code>Sum</code>, we can see that it expects: (1) a function from
integers to integers as its first parameter, (2) a set of integers
as its second parameter, and (3) an integer as a result. Hence, we annotate
<code>Sum</code> as follows:</p>
<pre><code class="language-tla">RECURSIVE Sum(_,_)
\* type: (Int -&gt; Int, Set(Int)) =&gt; Int;
Sum(f,S) ==
    ...
</code></pre>
<p>Note that the annotation has to be written between <code>RECURSIVE Sum(_, _)</code> and
the definition of <code>Sum</code>. This might change later, see <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> at tlaplus.</p>
<p>After providing the type checker with the annotation for <code>Sum</code>, we get one
more type error:</p>
<pre><code>[CarTalkPuzzle.tla:172:23-172:26]: Need annotation. Arguments match
2 operator signatures: (((p -&gt; q), p) =&gt; q) and ((Seq(p), Int) =&gt; p)
</code></pre>
<p>This time the type checker cannot choose between two options for the second
parameter of <code>Image</code>: It could be a function, or a sequence. We help the
type checker by writing that the second parameter should be a function
of integers to integers, that is, <code>Int -&gt; Int</code>:</p>
<pre><code class="language-tla">      \* @type: (Set(Int), Int -&gt; Int) =&gt; Set(Int);
      Image(S, B) == {B[x] : x \in S}
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<h2><a class="header" href="#recipe-4-annotating-records" id="recipe-4-annotating-records">Recipe 4: Annotating records</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> from the repository of TLA+ examples. This
example has 176 lines of code, so we do not inline it here.</p>
<p>As you probably expected, the type checker complains about not knowing
the types of constants and variables. As for constant <code>RM</code>, we opt for using
an uninterpreted type that we call <code>RM</code>. That is:</p>
<pre><code class="language-tla">CONSTANT
        \* @type: Set(RM);
        RM
</code></pre>
<p>By looking at the spec, it is easy to guess the types of the variables
<code>rmState</code>, <code>tmState</code>, and <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: RM -&gt; Str;
  rmState,
  \* @type: Str;
  tmState,
  \* @type: Set(RM);
  tmPrepared
</code></pre>
<p>The type of the variable <code>msgs</code> is less obvious. We can check the definitions
of <code>TPTypeOK</code> and <code>Message</code> to get the idea about the type of <code>msgs</code>:</p>
<pre><code class="language-tla">Message ==
  ({[type |-&gt; t, rm |-&gt; r]: t \in {&quot;Prepared&quot;}, r \in RM }
   \cup
   {[type |-&gt; t] : t \in {&quot;Commit&quot;, &quot;Abort&quot;}})

TPTypeOK ==
  ...
  /\ msgs \in SUBSET Message
</code></pre>
<p>From these definitions, you can see that <code>msgs</code> is a set that contains records
of two types: <code>[type: Str]</code> and <code>[type: Str, rm: RM]</code>. When you have a set of
heterogeneous records, you have to choose the type of a super-record that
contains the fields of all records that could be put in the set. That is:</p>
<pre><code class="language-tla">  \* @type: Set([type: Str, rm: RM]);
  msgs           
</code></pre>
<p>A downside of this approach is that <a href="HOWTOs/../apalache/typechecker-snowcat.html">Snowcat</a> will not help you in finding
an incorrect field access. We probably will introduce more precise types for
records later. See <a href="https://github.com/informalsystems/apalache/issues/401">Issue 401</a>.</p>
<p><a id="funAsSeq"></a></p>
<h2><a class="header" href="#recipe-5-functions-as-sequences" id="recipe-5-functions-as-sequences">Recipe 5: functions as sequences</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/N-Queens/Queens.tla">Queens.tla</a> from the repository of TLA+ examples.  It has
85 lines of code, so we do not include it here. Similar to the previous
sections, we annotate constants and variables:</p>
<pre><code class="language-tla">CONSTANT 
         \* @type: Int;
         N
...         
VARIABLES
    \* @type: Set(Seq(Int));
    todo,
    \* @type: Set(Seq(Int));
    sols
</code></pre>
<p>After having inspected the type errors reported by Snowcat, we annotate the
operators <code>Attacks</code>, <code>IsSolution</code>, and <code>vars</code> as follows:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j) == ...

\* @type: Seq(Int) =&gt; Bool;
IsSolution(queens) == ...

\* @type: &lt;&lt;Set(Seq(Int)), Set(Seq(Int))&gt;&gt;;
vars == &lt;&lt;todo,sols&gt;&gt;
</code></pre>
<p>Now we run the type checker and receive the following type error:</p>
<pre><code>[Queens.tla:47:21-47:38]: Mismatch in argument types.
Expected: ((Seq(Int)) =&gt; Bool)
</code></pre>
<p>Let's have a closer look at the problematic operator definition of <code>Solutions</code>:</p>
<pre><code class="language-tla">Solutions ==
    { queens \in [1..N -&gt; 1..N]: IsSolution(queens) }
</code></pre>
<p>This looks funny: <code>IsSolution</code> is expecting a sequence, whereas <code>Solutions</code> is
clearly producing a set of functions. Of course, it is not a problem in the
untyped TLA+. In fact, it is a well-known idiom: Construct a function by using
function operators and then apply sequence operators to it. In Apalache we have
to explicitly write that a function should be reinterpreted as a sequence.  To
this end, we have to use the operator <code>FunAsSeq</code> from the module
<a href="https://github.com/informalsystems/apalache/blob/unstable/src/tla/Apalache.tla">Apalache.tla</a>. Hence, we add <code>Apalache</code> to the <code>EXTENDS</code> clause and
apply the operator <code>FunAsSeq</code> as follows:</p>
<pre><code class="language-tla">EXTENDS Naturals, Sequences, Apalache
...
Solutions ==
  LET Queens == { queens \in [1..N -&gt; 1..N] : FunAsSeq(queens, N) } IN
  { FunAsSeq(queens, N): queens \in Queens }
</code></pre>
<p>This time the type checker can find the types of all expressions:</p>
<pre><code> &gt; Your types are great!
</code></pre>
<p><a id="typeAliases"></a></p>
<h2><a class="header" href="#recipe-6-type-aliases" id="recipe-6-type-aliases">Recipe 6: type aliases</a></h2>
<p>Check the example <a href="https://github.com/tlaplus/Examples/blob/master/specifications/MissionariesAndCannibals/MissionariesAndCannibals.tla">MissionariesAndCannibals.tla</a> from the repository of TLA+
examples. </p>
<p>We can annotate constants as follows:</p>
<pre><code class="language-tla">CONSTANTS
    \* @type: Set(PERSON);
    Missionaries,
    \* @type: Set(PERSON);
    Cannibals 
</code></pre>
<p>If we continue annotating other declarations in the specification, we will see
that the type <code>Set(PERSON)</code> is used quite a lot. Would not it be great to
introduce a shortcut for this type?</p>
<p>We can do that by declaring a type alias as follows:</p>
<pre><code class="language-tla">CONSTANTS
    \* @typeAlias: PERSONS = Set(PERSON);
    \* @type: PERSONS;
    Missionaries,
    \* @type: PERSONS;
    Cannibals 
</code></pre>
<p>The basic rule is that we can introduce a type alias with <code>@typeAlias</code> in the
same place, where we can write a <code>@type</code> annotation. For more precise rules,
check <a href="HOWTOs/../adr/002adr-types.html">ADR002</a>.  Having defined the type alias, we can use it in the later
definitions:</p>
<pre><code class="language-tla">VARIABLES
    \* @type: Str;
    bank_of_boat,
    \* @type: Str -&gt; PERSONS;
    who_is_on_bank 
</code></pre>
<p>Surely, we did not gain much by writing <code>PERSONS</code> instead of <code>Set(PERSON)</code>.  If
your specification has complex types, e.g., records, aliases may help you in
minimizing the burden of specification maintenance. When you add one more field
to the record type, it suffices to change the definition of the type alias,
instead of changing the record type everywhere.</p>
<h2><a class="header" href="#recipe-7-multi-line-annotations" id="recipe-7-multi-line-annotations">Recipe 7: Multi-line annotations</a></h2>
<p>A type annotation may span over multiple lines. You may use both the <code>(* ... *)</code> syntax as well as the single-line syntax <code>\* ...</code>. All three examples below
are accepted by the parser:</p>
<pre><code class="language-tla">VARIABLES
   (*
    @type: Int
            =&gt; Bool;
    *)           
    f,
    \* @type:
    \*       Int
    \*          =&gt; Bool;
    g,
    \* @type(&quot;Int
    \*          =&gt; Bool
    \*       &quot;)
    h
</code></pre>
<p>Note that the parser removes the leading strings <code>&quot;    \*&quot;</code> from the annotations,
similar to how multi-line strings are treated in modern programming languages.</p>
<h2><a class="header" href="#recipe-8-comments-in-annotations" id="recipe-8-comments-in-annotations">Recipe 8: Comments in annotations</a></h2>
<p>Sometimes, it helps to document the meaning of type components. Consider the following
example from <a href="HOWTOs/howto-write-type-annotations.html#funAsSeq">Recipe 5</a>:</p>
<pre><code class="language-tla">\* @type: (Seq(Int), Int, Int) =&gt; Bool;
Attacks(queens,i,j)
</code></pre>
<p>If you think that an explanation of the arguments would help, you can do that as follows:</p>
<pre><code class="language-tla">(*
  @type:
    (
      // the column of an n-th queen, for n in the sequence domain
      Seq(Int),
      // the index (line number) of the first queen
      Int,
      // the index (line number) of the second queen
      Int
    ) =&gt; Bool;
*)
Attacks(queens,i,j)
</code></pre>
<p>You don't have to do that, but if you feel that types can also help you in documenting
your specification, you have this option.</p>
<h2><a class="header" href="#known-issues-1" id="known-issues-1">Known issues</a></h2>
<h3><a class="header" href="#annotations-of-local-operators" id="annotations-of-local-operators">Annotations of LOCAL operators</a></h3>
<p>In contrast to all other cases, a local operator definition does require
a type annotation before the keyword <code>LOCAL</code>, not after it. For example:</p>
<pre><code class="language-tla">\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1
</code></pre>
<p>This may change later, when the tlaplus <a href="https://github.com/tlaplus/tlaplus/issues/578">Issue 578</a> is resolved.</p>
<h1><a class="header" href="#overview-2" id="overview-2">Overview</a></h1>
<ol>
<li><a href="tutorials/./snowcat-tutorial.html">Tutorial on the Type Checker Snowcat</a></li>
</ol>
<h1><a class="header" href="#tutorial-on-the-snowcat-type-checker-1" id="tutorial-on-the-snowcat-type-checker-1">Tutorial on the Snowcat‚ùÑüê± Type Checker</a></h1>
<p>In this tutorial, we introduce the Snowcat ‚ùÑ üê± type checker
We give concrete steps on running the type checker and
annotating a specification with types.</p>
<h2><a class="header" href="#related-documents-1" id="related-documents-1">Related documents</a></h2>
<ul>
<li><a href="tutorials/../adr/002adr-types.html">ADR002</a> that introduces Type System 1, which is used by Snowcat.</li>
<li>A more technical <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type annotations</a>.</li>
<li><a href="tutorials/../adr/004adr-annotations.html">ADR004</a> that introduces Java-like annotations in TLA+ comments.</li>
</ul>
<h2><a class="header" href="#setup-1" id="setup-1">Setup</a></h2>
<p>We assume that you have Apalache installed. If not, check the manual page on
<a href="tutorials/../apalache/installation/index.html">Apalache installation</a>. The minimal required version is 0.15.0.</p>
<h2><a class="header" href="#running-example-two-phase-commit-1" id="running-example-two-phase-commit-1">Running example: Two-phase commit</a></h2>
<p>As a running example, we are using the well-understood specification of
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit">Two-phase commit</a> by <a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (written by <a href="https://members.loria.fr/Stephan.Merz/">Stephan Merz</a>). We
recommend to reproduce the steps in this tutorial. So, go ahead and download
two specification files: <a href="https://github.com/tlaplus/Examples/blob/911dac1462344337940779a797a5f329a77be98c/specifications/transaction_commit/TwoPhase.tla">TwoPhase.tla</a> and <a href="https://github.com/tlaplus/Examples/blob/911dac1462344337940779a797a5f329a77be98c/specifications/transaction_commit/TCommit.tla">TCommit.tla</a>.</p>
<h2><a class="header" href="#step-1-running-snowcat-1" id="step-1-running-snowcat-1">Step 1: Running Snowcat</a></h2>
<p>Before we start writing any type annotations, let's run the type checker and
see, whether it complains:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>The tool output is a bit verbose. Below, you can see the important lines of the
output:</p>
<pre><code>...
PASS #1: TypeCheckerSnowcat
 &gt; Running Snowcat .::.
[TwoPhase.tla:51:30-51:31]: Undefined name RM. Introduce a type annotation.
 &gt; Snowcat asks you to fix the types. Meow.
... 
</code></pre>
<h2><a class="header" href="#step-2-annotating-rm-1" id="step-2-annotating-rm-1">Step 2: Annotating RM</a></h2>
<p>In Step 1, Snowcat complained about the name <code>RM</code>. The reason
for that is very simple: Snowcat does type analysis for each declaration in
isolation. Hence, it failed, as soon as it met a reference to the constant
<code>RM</code> in the definition of <code>Message</code>:</p>
<pre><code class="language-tla">CONSTANT RM \* The set of resource managers
...

Message ==
  ...
  [type : {&quot;Prepared&quot;}, rm : RM]  \cup  [type : {&quot;Commit&quot;, &quot;Abort&quot;}]
</code></pre>
<p>Indeed, we have not introduced a type annotation for the constant <code>RM</code>, so the
type checker cannot use any meaningful type in the context of the above
expression.</p>
<p>From the comment next to the declaration of <code>RM</code>, we see that <code>RM</code> is supposed
to be a set of resource managers. We have plenty of choices here of what a
resource manager could be. Let's keep it simple and say that a resource manager
is simply a name. Hence, we say that <code>RM</code> is a set of strings. Let's add a 
type annotation:</p>
<pre><code class="language-tla">CONSTANT
    \* @type: Set(Str);
    RM \* The set of resource managers
</code></pre>
<p>Note that we had to put the annotation between the keyword <code>CONSTANT</code> and the
identifier <code>RM</code>. We used the one-line TLA+ comment: <code>\* @type: ...;</code>.
Alternatively, we could use the multi-line comment: <code>(* @type: Set(Str); *)</code>.
Importantly, the type annotation should end with a semi-colon: <code>;</code>.</p>
<p><strong>Warning</strong>. If you want to write a type annotation on multiple lines, write it
in a multi-line comment <code>(* ... *)</code> instead of starting multiple lines with a
single-line comment <code>\* ...</code>. See <a href="https://github.com/informalsystems/apalache/issues/718">issue
718</a>.</p>
<h2><a class="header" href="#step-3-running-snowcat-again-1" id="step-3-running-snowcat-again-1">Step 3: Running Snowcat again</a></h2>
<p>Having introduced the type annotation for <code>RM</code>, let's run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>Snowcat does not complain about <code>RM</code> anymore. Now we get another message:</p>
<pre><code>[TwoPhase.tla:68:6-68:12]: Undefined name rmState. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-4-annotating-rmstate-1" id="step-4-annotating-rmstate-1">Step 4: Annotating rmState</a></h2>
<p>Similar to Step 2, we are missing a type annotation. This time the type checker
complains about the variable <code>rmState</code>:</p>
<pre><code class="language-tla">VARIABLES
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
</code></pre>
<p>We can get a hint about the type of <code>rmState</code> from the type invariant
<code>TPTypeOK</code>. It should be a function that, given a resource manager, produces
one of the following strings: <code>&quot;working&quot;</code>, <code>&quot;prepared&quot;</code>, <code>&quot;committed&quot;</code>,
<code>&quot;aborted&quot;</code>. So we need the function type: <code>Str -&gt; Str</code>. Add the following
type annotation:</p>
<pre><code class="language-tla">VARIABLES
  \* @type: Str -&gt; Str;
  rmState,       \* $rmState[rm]$ is the state of resource manager RM.
</code></pre>
<h2><a class="header" href="#step-5-getting-one-more-type-error-by-snowcat-1" id="step-5-getting-one-more-type-error-by-snowcat-1">Step 5: Getting one more type error by Snowcat</a></h2>
<p>Guess what? Run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>Snowcat does not complain about <code>rmState</code> anymore. But we are not done yet:</p>
<pre><code>[TwoPhase.tla:70:6-70:12]: Undefined name tmState. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-6-annotating-tmstate-1" id="step-6-annotating-tmstate-1">Step 6: Annotating tmState</a></h2>
<p>This time we need a type annotation for the variable <code>tmState</code>. By inspecting
<code>TPTypeOK</code>, we see that <code>tmState</code> is just a string. Add the following type
annotation:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Str;  
  tmState,       \* The state of the transaction manager.
</code></pre>
<h2><a class="header" href="#step-7-running-snowcat-to-see-another-error-1" id="step-7-running-snowcat-to-see-another-error-1">Step 7: Running Snowcat to see another error</a></h2>
<p>Run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>You must have guessed that the type checker complains about the variable
<code>tmPrepared</code>. Indeed, it just needs annotations for all CONSTANTS and
VARIABLES:</p>
<pre><code>[TwoPhase.tla:72:6-72:15]: Undefined name tmPrepared. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-8-annotating-tmprepared-1" id="step-8-annotating-tmprepared-1">Step 8: Annotating tmPrepared</a></h2>
<p>At this step, we have to annotate <code>tmPrepared</code>. Let's have a look at the comment
next to the declaration of <code>tmPrepared</code>:</p>
<pre><code class="language-tla">VARIABLES
  ...
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<p>Hence, <code>tmPrepared</code> is a set of resource managers. This is what we write as a
type annotation:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Set(Str);
  tmPrepared,    \* The set of RMs from which the TM has received $&quot;Prepared&quot;$
                 \* messages.
</code></pre>
<h2><a class="header" href="#step-9-running-snowcat-again-1" id="step-9-running-snowcat-again-1">Step 9: Running Snowcat again</a></h2>
<p>You know that we have to run the type checker again:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>It is no surprise that it complains about the variable <code>msgs</code> now:</p>
<pre><code>[TwoPhase.tla:74:6-74:9]: Undefined name msgs. Introduce a type annotation.
</code></pre>
<h2><a class="header" href="#step-10-annotating-msgs-1" id="step-10-annotating-msgs-1">Step 10: Annotating msgs</a></h2>
<p>In the previous steps, it was quite easy to annotate variables. We would just
look at how the variable is used, or read the comments, and add a type annotation.
Figuring out the type of <code>msgs</code> is a bit harder.</p>
<p>Let's look at the definitions of <code>Messages</code> and <code>TPTypeOK</code>:</p>
<pre><code class="language-tla">Message ==
  ...
  [type : {&quot;Prepared&quot;}, rm : RM]  \cup  [type : {&quot;Commit&quot;, &quot;Abort&quot;}]

TPTypeOK ==  
  ...  
  /\ msgs \subseteq Message
</code></pre>
<p>Now you should be able to see that <code>msgs</code> is a set that may contain three
kinds of records:</p>
<ol>
<li>The record <code>[type |-&gt; &quot;Commit&quot;]</code>,</li>
<li>The record <code>[type |-&gt; &quot;Abort&quot;]</code>,</li>
<li>A record <code>[type |-&gt; &quot;Prepared&quot;, rm |-&gt; r]</code>, for some <code>r \in RM</code>.</li>
</ol>
<p>This looks like an issue for the type checker, as it always requires
the set elements to have the same type. However, the type checker
did not complain about the expressions in <code>Message</code> and <code>TPTypeOK</code>. Why?</p>
<p>Actually, the type checker allows records to be generalized to a type that
contains additional fields. In the above definition of <code>Messages</code>, the set of
records <code>[type: {&quot;Prepared&quot;}, rm: RM]</code> has the type <code>Set([type: Str, rm: Str])</code>.  (Note that the record has the field called &quot;type&quot;, which has nothing
to do with our types.) Likewise, the set of records <code>[type: {&quot;Commit&quot;, &quot;Abort&quot;}]</code> has the type <code>Set([type: Str])</code>. Both of these types can be unified
to the common type:</p>
<pre><code>Set([type: Str, rm: Str])
</code></pre>
<p>The above type is actually what we need for the variable <code>msgs</code>. Let's annotate
the variable with this type:</p>
<pre><code class="language-tla">VARIABLES
  (* ... *)
  \* @type: Set([type: Str, rm: Str]);
  msgs
</code></pre>
<h2><a class="header" href="#step-11-running-snowcat-and-seeing-no-errors-1" id="step-11-running-snowcat-and-seeing-no-errors-1">Step 11: Running Snowcat and seeing no errors</a></h2>
<p>Let's see whether Snowcat is happy about our types now:</p>
<pre><code class="language-sh">$ apalache typecheck TwoPhase.tla
</code></pre>
<p>The type checker is happy. It has computed the types of all expressions:</p>
<pre><code> &gt; Running Snowcat .::.
 &gt; Your types are great!
 &gt; All expressions are typed
</code></pre>
<h1><a class="header" href="#discussion-1" id="discussion-1">Discussion</a></h1>
<p>To see the complete code, check <a href="tutorials/./TwoPhase.tla">TwoPhase.tla</a>. Note that we
have not touched the file <code>TCommit.tla</code> at all! The type checker has figured
out all the types in it by itself. We have added five type annotations for 248
lines of code. Not bad.</p>
<p>It was quite easy to figure out the types of constants and variables in our
example. As a rule, you always have to annotate constants and variables with
types. Hence, we did not have to run the type checker five times to see the
error messages.</p>
<p>Sometimes, the type checker cannot find a unique type of an expression. This
usually happens when you declare an operator of a parameter that can be: a
function, a tuple, a record, or a sequence (or a subset of these four types
that has at least two elements). For instance, here is a definition from
<a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/GameOfLifeTyped.tla">GameOfLifeTyped.tla</a>:</p>
<pre><code class="language-tla">Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<p>Although it is absolutely clear that <code>x</code> and <code>y</code> have the type <code>Int</code>,
the type of <code>&lt;&lt;x, y&gt;&gt;</code> is ambiguous. This expression can either be
a tuple <code>&lt;&lt;Int, Int&gt;&gt;</code>, or a sequence <code>Seq(Int)</code>. In this case, we have to
help the type checker by annotating the operator definition:</p>
<pre><code class="language-tla">\* @type: () =&gt; Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<p>Since it is common to have operators that take no arguments, Snowcat supports
the following syntax sugar:</p>
<pre><code class="language-tla">\* @type: Set(&lt;&lt;Int, Int&gt;&gt;);
Pos ==
    {&lt;&lt;x, y&gt;&gt;: x, y \in 1..N}
</code></pre>
<h2><a class="header" href="#further-reading-1" id="further-reading-1">Further reading</a></h2>
<p>For more advanced type annotations, check the following examples:</p>
<ul>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/CigaretteSmokersTyped.tla">CigaretteSmokersTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/CarTalkPuzzleTyped.tla">CarTalkPuzzleTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/FunctionsTyped.tla">FunctionsTyped.tla</a>,</li>
<li><a href="https://github.com/informalsystems/apalache/blob/d5138a33fce3d77abc07a39bfb4f448942e6f641/test/tla/QueensTyped.tla">QueensTyped.tla</a>.</li>
</ul>
<p>We have not discussed type aliases, which are a more advanced feature of the
type checker. To learn about type aliases, see <a href="tutorials/../HOWTOs/howto-write-type-annotations.html">HOWTO on writing type
annotations</a>.</p>
<p>If you are experiencing a problem with Snowcat, feel free to <a href="https://github.com/informalsystems/apalache/issues">open an issue</a>
or drop us a message on <a href="https://informal-systems.zulipchat.com/login/#narrow/stream/265309-apalache">Zulip chat</a>.</p>
<h1><a class="header" href="#tla-language-reference-manual-" id="tla-language-reference-manual-">TLA+ Language Reference Manual üìó</a></h1>
<p>In this manual, we summarize our knowledge about TLA+ and about its treatment
with the <a href="https://github.com/informalsystems/apalache">Apalache model checker</a>. This is not the manual on Apalache, which
can be found in <a href="lang/../.">Apalache manual</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video Course</a> by Leslie Lamport is
an excellent starting point, if you are new to TLA+. For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html#book">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. There are plenty of interesting talks on TLA+ at <a href="https://www.youtube.com/channel/UCLHtwjeqBxVSEhjV0clKblA/videos">TLA
Channel</a> of Markus Kuppe. This manual completely ignores Pluscal -- a
higher-level language on top of TLA+.  If you are interested in learning
Pluscal, check <a href="https://learntla.com">LearnTla.com</a> by Hillel Wayne.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ol>
<li><a href="lang/./standard-operators.html">The standard operators of TLA+</a> üîå</li>
<li><a href="lang/./user-operators.html">User-defined operators</a> üí°</li>
<li><a href="lang/./modules.html">Modules and instances</a>: MODULE, EXTENDS and INSTANCES ‚úÇ</li>
</ol>
<h1><a class="header" href="#the-standard-operators-of-tla" id="the-standard-operators-of-tla">The standard operators of TLA+</a></h1>
<p>In this document, we summarize the standard TLA+ operators in a form that is
similar to manuals on programming languages. The purpose of this document is to
provide you with a quick reference, whenever you are looking at the <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary of
TLA</a>. The <a href="http://lamport.azurewebsites.net/video/videos.html">TLA+ Video
Course</a> by Leslie Lamport
is an excellent starting point, if you are new to TLA+.  For a comprehensive
description and philosophy of the language, check <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and the
<a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+ Home Page</a>. You can find handy extensions of the standard library in
<a href="https://github.com/tlaplus/CommunityModules">Community Modules</a>.</p>
<p>We explain the semantics of the operators under the lenses of the <a href="https://github.com/informalsystems/apalache">Apalache
model checker</a>.  Traditionally, the emphasis was put on the temporal operators
and action operators, as they build the foundation of TLA. We focus on the &quot;+&quot;
aspect of the language, which provides you with a language for writing a single
step by a state machine.  This part of the language is absolutely necessary for
writing and reading system specifications.  Moreover, we treat equally the
&quot;core&quot; operators of TLA+ and the &quot;library&quot; operators: This distinction is less
important to the language users than to the tool developers.</p>
<p>In this document, we present the semantics of TLA+, as if it was executed on a
computer that is equipped with an additional device that we call an <em>oracle</em>.
Most of the TLA+ operators are understood as deterministic operators, so they
can be executed on your computer. A few operators are non-deterministic, so
they require the oracle to resolve non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>. This is one of the most important features that makes TLA+
distinct from programming languages.  Wherever possible, we complement the
English semantics with code in <a href="https://www.python.org/">Python</a>. Although our
semantics are more restrictive than the denotational semantics in Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, they are very close to the treatment of TLA+ by the model
checkers: <a href="https://github.com/informalsystems/apalache">Apalache</a> and
<a href="http://lamport.azurewebsites.net/tla/tools.html">TLC</a>. Our relation between
TLA+ operators and Python code bears some resemblance to
<a href="https://github.com/Viasat/salt">SALT</a> and
<a href="https://github.com/tlaplus/PlusPy">PlusPy</a>.</p>
<p><em>Here, we are using the ASCII notation of TLA+, as this is what you
type. We give the nice LaTeX notation in the detailed description.  The
translation table between the LaTeX notation and ASCII can be found in <a href="https://lamport.azurewebsites.net/tla/summary.pdf">Summary
of TLA</a>.</em></p>
<h2><a class="header" href="#the--operators-in-tla" id="the--operators-in-tla">The &quot;+&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#booleans-" id="booleans-">Booleans üö•</a></h3>
<p><em>Good old Booleans</em>. <a href="lang/./booleans.html">Learn more...</a></p>
<ul>
<li>Boolean algebra:
<ul>
<li><a href="lang/./booleans.html#const"><code>FALSE</code></a> and <a href="lang/./booleans.html#const"><code>TRUE</code></a>,</li>
<li><a href="lang/./booleans.html#and"><code>A /\ B</code></a> (also <code>A \land B</code>),</li>
<li><a href="lang/./booleans.html#or"><code>A \/ B</code></a> (also <code>A \lor B</code>),</li>
<li><a href="lang/./booleans.html#not"><code>~A</code></a> (also <code>\lnot A</code> and <code>\neg A</code>),</li>
<li><a href="lang/./booleans.html#implies"><code>A =&gt; B</code></a>,</li>
<li><a href="lang/./booleans.html#equiv"><code>A &lt;=&gt; B</code></a> (also <code>A \equiv B</code>)</li>
</ul>
</li>
<li>Boolean set: <a href="lang/./booleans.html#const"><code>BOOLEAN</code></a></li>
</ul>
<h3><a class="header" href="#control-flow-and-non-determinism-" id="control-flow-and-non-determinism-">Control flow and non-determinism üîÄ</a></h3>
<p><em>Hidden powers of TLA+</em>. <a href="lang/./control-and-nondeterminism.html">Learn more...</a></p>
<ul>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetOr"><code>A_1 \/ ... \/ A_n</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetExists"><code>\E x \in S: P</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetIte"><code>IF p THEN e_1 ELSE e_2</code></a></li>
<li>Non-determinism with <a href="lang/./control-and-nondeterminism.html#nondetCase"><code>CASE</code> and <code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#deterministic-conditionals-" id="deterministic-conditionals-">Deterministic conditionals üöï</a></h3>
<p><em>You need them less often than you think</em>. <a href="lang/./conditionals.html">Learn more...</a></p>
<ul>
<li>Deterministic <a href="lang/./conditionals.html#ite"><code>IF-THEN-ELSE</code></a></li>
<li>Deterministic <a href="lang/./conditionals.html#case"><code>CASE</code></a> and <a href="lang/./conditionals.html#caseOther"><code>CASE-OTHER</code></a></li>
</ul>
<h3><a class="header" href="#integers-" id="integers-">Integers üî¢</a></h3>
<p><em>Unbounded integers like in Python.</em> <a href="lang/./integers.html">Learn more...</a></p>
<ul>
<li>Integer algebra:
<ul>
<li><a href="lang/./integers.html#uminus"><code>-i</code></a>, <a href="lang/./integers.html#plus"><code>i + k</code></a>,
<a href="lang/./integers.html#minus"><code>i - k</code></a>,</li>
<li><a href="lang/./integers.html#mult"><code>i * k</code></a>,
<a href="lang/./integers.html#div"><code>i \div k</code></a>, <a href="lang/./integers.html#mod"><code>i % k</code></a>,
<a href="lang/./integers.html#pow"><code>i^k</code></a></li>
</ul>
</li>
<li>Integer predicates:
<ul>
<li><a href="lang/./integers.html#lt"><code>i &lt; k</code></a>, <a href="lang/./integers.html#gt"><code>i &gt; k</code></a>,</li>
<li><a href="lang/./integers.html#lte"><code>i &lt;= k</code></a> (also <code>i =&lt; k</code> and <code>i \leq k</code>),
<a href="lang/./integers.html#gte"><code>i &gt;= k</code></a> (also <code>i \geq k</code>)</li>
</ul>
</li>
<li>Integer sets: <a href="lang/./integers.html#range"><code>i..k</code></a>,
<a href="lang/./integers.html#const"><code>Int</code></a>, <a href="lang/./integers.html#const"><code>Nat</code></a></li>
</ul>
<h3><a class="header" href="#strings-" id="strings-">Strings üî°</a></h3>
<p><em>String constants</em>. You learned it!</p>
<ul>
<li>String literals, e.g., <code>&quot;hello&quot;</code> and <code>&quot;TLA+ is awesome&quot;</code>.
<ul>
<li>In Apalache, the literals have the type <code>Str</code>.</li>
</ul>
</li>
<li>Set of all finite strings: <code>STRING</code>.
<ul>
<li>In Apalache, the set <code>STRING</code> has the type <code>Set(Str)</code>.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#sets-" id="sets-">Sets üç£</a></h3>
<p><em>Like frozen sets in Python, but cooler</em> <a href="lang/./sets.html">Learn more...</a></p>
<ul>
<li>Set constructors:
<ul>
<li>Enumeration: <a href="lang/./sets.html#setEnum"><code>{ e_1, ..., e_n }</code></a></li>
<li>Filter: <a href="lang/./sets.html#filter"><code>{ x \in S: p }</code></a></li>
<li>Map: <a href="lang/./sets.html#map"><code>{ e: x \in S }</code></a></li>
<li>Powers: <a href="lang/./sets.html#powerset"><code>SUBSET S</code></a> and <a href="lang/./sets.html#flatten"><code>UNION S</code></a></li>
</ul>
</li>
<li>Set algebra:
<ul>
<li>Union: <a href="lang/./sets.html#union"><code>S \union T</code></a> (also <code>S \cup T</code>),</li>
<li>Intersection: <a href="lang/./sets.html#intersect"><code>S \intersect T</code></a> (also <code>S \cap T</code>),</li>
<li>Difference: <a href="lang/./sets.html#setminus"><code>S \ T</code></a></li>
</ul>
</li>
<li>Set predicates:
<ul>
<li>Membership: <a href="lang/./sets.html#in"><code>x \in S</code></a> and <a href="lang/./sets.html#notin"><code>x \notin S</code></a>,</li>
<li>Subsets: <a href="lang/./sets.html#subset"><code>S \subset T</code></a>,
<a href="lang/./sets.html#subseteq"><code>S \subseteq T</code></a>,
<a href="lang/./sets.html#supset"><code>S \supset T</code></a>,
<a href="lang/./sets.html#supseteq"><code>S \supseteq T</code></a></li>
<li>Finiteness: <a href="lang/./sets.html#finite"><code>IsFinite</code></a></li>
</ul>
</li>
<li>Cardinality of a finite set: <a href="lang/./sets.html#card"><code>Cardinality</code></a></li>
</ul>
<h3><a class="header" href="#logic-" id="logic-">Logic üêô</a></h3>
<p><em>How logicians write loops</em>. <a href="lang/./logic.html">Learn more...</a></p>
<ul>
<li>Equality:
<a href="lang/./logic.html#eq"><code>=</code></a> and <a href="lang/./logic.html#neq"><code>/=</code></a> (also <code>#</code>)</li>
<li>Bounded quantifiers:
<a href="lang/./logic.html#forallBounded"><code>\A x \in S: p</code></a> and <a href="lang/./logic.html#existsBounded"><code>\E x \in S: p</code></a></li>
<li>Unbounded quantifiers:
<a href="lang/./logic.html#forall"><code>\A x: p</code></a> and <a href="lang/./logic.html#exists"><code>\E x: p</code></a></li>
<li>Choice:
<a href="lang/./logic.html#chooseBounded"><code>CHOOSE x \in S: p</code></a> and <a href="lang/./logic.html#choose"><code>CHOOSE x: p</code></a></li>
</ul>
<h3><a class="header" href="#functions-" id="functions-">Functions üíπ</a></h3>
<p><em>Like frozen dictionaries in Python, but cooler</em>. <a href="lang/./functions.html">Learn more...</a></p>
<ul>
<li><a href="lang/./functions.html#funCtor">Function constructor</a>: <code>[ x \in S |-&gt; e ]</code></li>
<li><a href="lang/./functions.html#funSetCtor">Set of functions</a>: <code>[S -&gt; T]</code></li>
<li><a href="lang/./functions.html#funApp">Function application</a>: <code>f[e]</code></li>
<li><a href="lang/./functions.html#except">Function replacement</a>: <code>[ f EXCEPT ![e_1] = e_2 ]</code></li>
<li><a href="lang/./functions.html#domain">Function domain</a>: <code>DOMAIN f</code></li>
</ul>
<h3><a class="header" href="#records-" id="records-">Records üìö</a></h3>
<p><em>Records like everywhere else</em>. <a href="lang/./records.html">Learn more...</a></p>
<ul>
<li><a href="lang/./records.html#recCtor">Record constructor</a>: <code>[ h_1 |-&gt; e_1, ..., h_n |-&gt; e_n ]</code></li>
<li><a href="lang/./records.html#recSetCtor">Set of records</a>: <code>[ h_1: S_1, ..., h_n: S_n ]</code></li>
<li><a href="lang/./records.html#recApp">Access by field name</a>: <code>e.h</code></li>
<li>Records are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#tuples-" id="tuples-">Tuples üìê</a></h3>
<p><em>Well, tuples</em>, indexed with 1, 2, 3... <a href="lang/./tuples.html">Learn more...</a></p>
<ul>
<li><a href="lang/./tuples.html#tuple">Tuple constructor</a>: <code>&lt;&lt; e_1, ..., e_n &gt;&gt;</code></li>
<li><a href="lang/./tuples.html#times">Cartesian product</a>: <code>S_1 \X ... \X S_n</code> (also <code>S_1 \times ... \times S_n</code>)</li>
<li>Tuples are functions. All operators of <a href="lang/./functions.html">functions</a> are supported.</li>
</ul>
<h3><a class="header" href="#sequences-" id="sequences-">Sequences üêç</a></h3>
<p><em>Functions that pretend to be lists, indexed with 1, 2, 3,...</em></p>
<ul>
<li>Add to end: <a href="lang/./sequences.html#append"><code>Append(s, e)</code></a></li>
<li>First and rest: <a href="lang/./sequences.html#head"><code>Head(s)</code></a> and <a href="lang/./sequences.html#tail"><code>Tail(s)</code></a></li>
<li>Length: <a href="lang/./sequences.html#len"><code>Len(s)</code></a></li>
<li>Concatenation: <a href="lang/./sequences.html#concat"><code>s \o t</code></a> (also <code>s \circ t</code>)</li>
<li>Subsequence: <a href="lang/./sequences.html#subseq"><code>SubSeq(s, i, k)</code></a></li>
<li>Sequence filter: <a href="lang/./sequences.html#filter"><code>SelectSeq(s, Test)</code></a></li>
<li>Set of finite sequences over <code>S</code>: <a href="lang/./sequences.html#seq"><code>Seq(S)</code></a></li>
<li>Sequences are functions.
All operators of <a href="lang/./functions.html">functions</a> and <a href="lang/./tuples.html">tuples</a> are supported.</li>
</ul>
<h3><a class="header" href="#bags-" id="bags-">Bags üëú</a></h3>
<ul>
<li>TBD</li>
</ul>
<h3><a class="header" href="#reals-" id="reals-">Reals üç≠</a></h3>
<p><em>Like &quot;reals&quot; in your math classes, not floating point</em></p>
<ul>
<li>
<p>All operators of <code>Integers</code> but interpreted over reals</p>
</li>
<li>
<p><code>a / b</code>, <code>Real</code>, <code>Infinity</code></p>
</li>
</ul>
<h3><a class="header" href="#naturals-" id="naturals-">Naturals üêæ</a></h3>
<p><em>If you are Indiana Jones...</em></p>
<ul>
<li>All operators of <code>Integers</code> except: unary minus <code>-a</code> and <code>Int</code></li>
</ul>
<h2><a class="header" href="#the-a-operators-in-tla" id="the-a-operators-in-tla">The &quot;A&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#action-operators-" id="action-operators-">Action operators üèÉ</a></h3>
<p><em>Taking a step</em></p>
<ul>
<li>Prime: <code>e'</code></li>
<li>Preservation: <code>UNCHANGED e</code></li>
<li>Stuttering: <code>[A]_e</code> and <code>&lt;A&gt;_e</code></li>
<li>Action enablement: <code>ENABLED A</code></li>
<li>Sequential composition: <code>A \cdot B</code></li>
</ul>
<h2><a class="header" href="#the-tl-operators-in-tla" id="the-tl-operators-in-tla">The &quot;TL&quot; Operators in TLA+</a></h2>
<h3><a class="header" href="#temporal-operators-" id="temporal-operators-">Temporal operators üîú</a></h3>
<p><em>Talking about computations, finite and infinite</em></p>
<ul>
<li>Always: <code>[]F</code></li>
<li>Eventually: <code>&lt;&gt;F</code></li>
<li>Weak fairness: <code>WF_e(A)</code></li>
<li>Strong fairness: <code>SF_e(A)</code></li>
<li>Leads-to: <code>F ~&gt; G</code></li>
<li>Guarantee: <code>F -+-&gt; G</code></li>
<li>Temporal hiding: <code>\EE x: F</code></li>
<li>Temporal universal quantification: <code>\AA x: F</code></li>
</ul>
<h1><a class="header" href="#booleans" id="booleans">Booleans</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>You find these operators in every programming language and every textbook on
logic. These operators form <em>propositional logic</em>.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants" id="constants">Constants</a></h2>
<p>TLA+ contains three special constants: <code>TRUE</code>, <code>FALSE</code>, and <code>BOOLEAN</code>.
The constant <code>BOOLEAN</code> is defined as the set <code>{FALSE, TRUE}</code>.</p>
<p>In Apalache, <code>TRUE</code>, <code>FALSE</code>, and <code>BOOLEAN</code> have the types <code>Bool</code>, <code>Bool</code>,
and <code>Set(Bool)</code>, respectively.</p>
<p>A note for set-theory purists: In theory, <code>TRUE</code> and <code>FALSE</code> are also sets, but
in practice they are treated as indivisible values. For instance, Apalache and
TLC will report an error, if you try to treat <code>FALSE</code> and <code>TRUE</code> as sets.</p>
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<p><strong>Warning</strong>: Below, we discuss Boolean operators in terms of the way they are usually
defined in programming languages. However, it is important to understand that the
disjunction operator <code>F \/ G</code> induces a nondeterministic effect when <code>F</code> or <code>G</code> contain
the prime operator  (<code>'</code>), or when they are used inside the initialization predicate <code>Init</code>.
We discuss this effect <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<hr />
<p><a name="and"></a></p>
<h3><a class="header" href="#and-conjunction" id="and-conjunction">And (conjunction)</a></h3>
<p><strong>Notation:</strong> <code>F /\ G</code> or <code>F \land G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/land.png" alt="land" /></p>
<p><strong>Arguments:</strong> Two or more arbitrary expressions.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> The binary case <code>F /\ G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>FALSE</code>,
or <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 /\ ... /\ F_n</code> can be understood by evaluating
the expression <code>F_1 /\ (F_2 /\ ... /\ (F_{n-1} /\ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> Deterministic, if the arguments are deterministic.  Otherwise,
the possible effects of non-determinism of each argument are combined.  See
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined if either conjunct evaluates to
a non-Boolean value (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  /\ TRUE    \* TRUE
FALSE /\ TRUE    \* FALSE
TRUE  /\ FALSE   \* FALSE
FALSE /\ FALSE   \* FALSE
FALSE /\ 1       \* FALSE in TLC, type error in Apalache
    1 /\ FALSE   \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; True  and True
True
&gt;&gt;&gt; False and True
False
&gt;&gt;&gt; True  and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; False and 1 # 1 is cast to True
False
&gt;&gt;&gt; 1 and False # 1 is cast to True
False

</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, conjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  /\ F_1
    /\ G_1
    ...
    /\ G_k
  /\ F_2
  ...
  /\ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>/\</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 /\ (G_1 /\ ... /\ G_k) /\ F_2 /\ ... /\ F_n
</code></pre>
<hr />
<p><a name="or"></a></p>
<h3><a class="header" href="#or-disjunction" id="or-disjunction">Or (disjunction)</a></h3>
<p><strong>Notation:</strong> <code>F \/ G</code> or <code>F \lor G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lor.png" alt="lor" /></p>
<p><strong>Arguments:</strong> Two or more Boolean expressions.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong></p>
<p>The binary case <code>F \/ G</code> evaluates to:</p>
<ul>
<li>
<p><code>FALSE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>TRUE</code>,
or <code>F</code> evaluates to <code>FALSE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
</ul>
<p>The general case <code>F_1 \/ ... \/ F_n</code> can be understood by evaluating
the expression <code>F_1 \/ (F_2 \/ ... \/ (F_{n-1} \/ F_n)...)</code>.</p>
<p><strong>Determinism:</strong> deterministic, if the arguments may not update primed
variables.  If the arguments may update primed variables, disjunctions may
result in non-determinism, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if a non-Boolean argument
is involved in the evaluation (the evaluation is lazy).  In this
case, Apalache statically reports a type error, whereas TLC reports a runtime
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">TRUE  \/ TRUE    \* TRUE
FALSE \/ TRUE    \* TRUE
TRUE  \/ FALSE   \* TRUE
FALSE \/ FALSE   \* FALSE
TRUE  \/ 1       \* TRUE in TLC, type error in Apalache
    1 \/ TRUE    \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; True  or True
True
&gt;&gt;&gt; False or True
True
&gt;&gt;&gt; True  or False
True
&gt;&gt;&gt; False or False
False

</code></pre>
<p><strong>Special syntax form:</strong> To minimize the number of parentheses, disjunction can
be written in the indented form:</p>
<pre><code class="language-tla">  \/ F_1
    \/ G_1
    ...
    \/ G_k
  \/ F_2
  ...
  \/ F_n
</code></pre>
<p>Similar to scopes in Python, the TLA+ parser groups the expressions according
to the number of spaces in front of <code>\/</code>. The formula in the above example
is equivalent to:</p>
<pre><code class="language-tla">  F_1 \/ (G_1 \/ ... \/ G_k) \/ F_2 \/ ... \/ F_n
</code></pre>
<p>The indented form allows you to combine conjunctions and disjunctions:</p>
<pre><code class="language-tla">  \/ /\ F
     /\ G
  \/ \/ H
     \/ J
</code></pre>
<p>The above formula is equivalent to:</p>
<pre><code class="language-tla">  (F /\ G) \/ (H \/ J)
</code></pre>
<hr />
<p><a name="not"></a></p>
<h3><a class="header" href="#negation" id="negation">Negation</a></h3>
<p><strong>Notation:</strong> <code>~F</code> or <code>\neg F</code> or <code>\lnot F</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/lnot.png" alt="lnot" /></p>
<p><strong>Arguments:</strong> One argument that should evaluate to a Boolean value.</p>
<p><strong>Apalache type:</strong> <code>Bool =&gt; Bool</code></p>
<p><strong>Effect:</strong></p>
<p>The value of <code>~F</code> is computed as follows:</p>
<ul>
<li>if <code>F</code> is evaluated to <code>FALSE</code>, then <code>~F</code> is evaluated to <code>TRUE</code>,</li>
<li>if <code>F</code> is evaluated to <code>TRUE</code>, then <code>~F</code> is evaluated to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if the argument evaluates to
a non-Boolean value. In this case, Apalache statically reports a type error,
whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">~TRUE    \* FALSE
~FALSE   \* TRUE
~(1)     \* error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True

</code></pre>
<hr />
<p><a name="implies"></a></p>
<h3><a class="header" href="#implication" id="implication">Implication</a></h3>
<p><strong>Notation:</strong> <code>F =&gt; G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/implies.png" alt="implies" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code>. Note that the <code>=&gt;</code> operator at the type level expresses the relation of inputs types to output types for operators, and as opposed to the <code>=&gt;</code> expressing the implication relation at the value level.</p>
<p><strong>Effect:</strong> <code>F =&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if <code>F</code> evaluates to <code>FALSE</code>, or
<code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>TRUE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if <code>F</code> evaluates to <code>TRUE</code> and <code>G</code> evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE =&gt; TRUE    \* TRUE
TRUE  =&gt; TRUE    \* TRUE
FALSE =&gt; FALSE   \* TRUE
TRUE  =&gt; FALSE   \* FALSE
FALSE =&gt; 1       \* TRUE in TLC, type error in Apalache
TRUE  =&gt; 1       \* runtime error in TLC, type error in Apalache
1     =&gt; TRUE    \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Recall that <code>A =&gt; B</code> is equivalent to <code>~A \/ B</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; (not False) or True
True
&gt;&gt;&gt; (not True)  or True
True
&gt;&gt;&gt; (not False) or False
True
&gt;&gt;&gt; (not True)  or False
False

</code></pre>
<hr />
<p><a name="equiv"></a></p>
<h3><a class="header" href="#equivalence" id="equivalence">Equivalence</a></h3>
<p><strong>Notation:</strong> <code>F &lt;=&gt; G</code> or <code>F \equiv G</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/equiv.png" alt="equiv" /> or <img src="lang/./img/equiv2.png" alt="equiv2" /></p>
<p><strong>Arguments:</strong> Two arguments. Although they can be arbitrary expressions, the
result is only defined when both arguments are evaluated to Boolean values.</p>
<p><strong>Apalache type:</strong> <code>(Bool, Bool) =&gt; Bool</code></p>
<p><strong>Effect:</strong> <code>F &lt;=&gt; G</code> evaluates to:</p>
<ul>
<li>
<p><code>TRUE</code>, if both <code>F</code> and <code>G</code> evaluate to <code>TRUE</code>,
or both <code>F</code> and <code>G</code> evaluate to <code>FALSE</code>.</p>
</li>
<li>
<p><code>FALSE</code>, if one of the arguments evaluates to <code>TRUE</code>,
while the other argument evaluates to <code>FALSE</code>.</p>
</li>
</ul>
<p>How is <code>F &lt;=&gt; G</code> different from <code>F = G</code>? Actually, <code>F &lt;=&gt; G</code> is equality
that is defined only for Boolean values. In other words, if <code>F</code> and <code>G</code> are
evaluated to Boolean values, then <code>F &lt;=&gt; G</code> and <code>F = G</code> are evaluated to the
same Boolean value. We prefer <code>F &lt;=&gt; G</code> to <code>F = G</code>, as <code>F &lt;=&gt; G</code> clearly
indicates the intended types of <code>F</code> and <code>G</code> and thus makes the logical
structure more obvious.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-Boolean value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">FALSE &lt;=&gt; TRUE   \* FALSE
TRUE  &lt;=&gt; TRUE   \* TRUE
FALSE &lt;=&gt; FALSE  \* TRUE
TRUE  &lt;=&gt; FALSE  \* TRUE
FALSE &lt;=&gt; 1      \* runtime error in TLC, type error in Apalache
1     &lt;=&gt; TRUE   \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>Assuming that both expressions are Boolean, <code>F &lt;=&gt; G</code> is equivalent to <code>F = G</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; False == True
False
&gt;&gt;&gt; True  == True
True
&gt;&gt;&gt; False == False
True
&gt;&gt;&gt; True  == False
False

</code></pre>
<h1><a class="header" href="#control-flow-and-non-determinism-in-tla" id="control-flow-and-non-determinism-in-tla">Control Flow and Non-determinism in TLA+</a></h1>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<p><strong>Author:</strong> Igor Konnov</p>
<p><strong>Peer review:</strong> Shon Feder, Jure Kukovec</p>
<p>Non-determinism is one of the TLA+ features that makes it different from
mainstream programming languages. However, it is very easy to overlook it: There is no
special syntax for expressing non-determinism. In pure TLA+, whether your
specification is deterministic or not depends on the evaluation of the initial
predicate and of the transition predicate. These are usually called <code>Init</code> and
<code>Next</code>, respectively. In the following, we first intuitively explain what non-determinism
means in the mathematical framework of TLA+, and then proceed with the
explanation that is friendly to computers and software engineers.</p>
<h2><a class="header" href="#explaining-non-determinism-to-humans" id="explaining-non-determinism-to-humans">Explaining non-determinism to humans</a></h2>
<p><strong>States, transitions, actions, computations.</strong> Every TLA+ specification comes
with a set of state variables. For instance, the following specification
declares two state variables <code>x</code> and <code>y</code>:</p>
<pre><code class="language-tla">-------- MODULE coord ----------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ y' = y + 1
================================
</code></pre>
<p>A <em>state</em> is a mapping from state variables to TLA+ values. We do not go into
the mathematical depths of precisely defining TLA+ values. Due to the
background theory of ZFC, this set is well-defined and is not subject to
logical paradoxes. Basically, the values are Booleans, integers, strings, sets,
functions, etc.</p>
<p>In the above example, the operator <code>Init</code> evaluates to <code>TRUE</code> on exactly one
state, which we can conveniently write using the record constructor as follows:
<code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>The operator <code>Next</code> contains primes (<code>'</code>) and thus represents pairs of states,
which we call <em>transitions</em>. An operator over unprimed and primed variables
is called an <em>action</em> in TLA+. Intuitively, the operator <code>Next</code> in our example
evaluates to <code>TRUE</code> on infinitely many pairs of states. For instance, <code>Next</code>
evaluates to <code>TRUE</code> on the following pairs:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; 0, y |-&gt; 0], [x |-&gt; 1, y |-&gt; 1]&gt;&gt;
&lt;&lt;[x |-&gt; 1, y |-&gt; 1], [x |-&gt; 2, y |-&gt; 2]&gt;&gt;
&lt;&lt;[x |-&gt; 2, y |-&gt; 2], [x |-&gt; 3, y |-&gt; 3]&gt;&gt;
...
</code></pre>
<p>In our example, the second state of every transition matches the first state
of the next transition in the list. This is because the above sequence of
transitions describes the following sequence of states:</p>
<pre><code class="language-tla">[x |-&gt; 0, y |-&gt; 0]
[x |-&gt; 1, y |-&gt; 1]
[x |-&gt; 2, y |-&gt; 2]
[x |-&gt; 3, y |-&gt; 3]
...
</code></pre>
<p>Actually, we have just written a computation of our specification.
A <em>finite computation</em> is a finite sequence of states <code>s_0, s_1, ..., s_k</code>
that satisfies the following properties:</p>
<ul>
<li>The operator <code>Init</code> evaluates to <code>TRUE</code> on state <code>s_0</code>, and</li>
<li>The operator <code>Next</code> evaluates to <code>TRUE</code> on every pair of states <code>&lt;&lt;s_i, s_j&gt;&gt;</code>
for <code>0 &lt;= i &lt; k</code> and <code>j = i + 1</code>.</li>
</ul>
<p>We can also define an <em>infinite computation</em> by considering an infinite
sequence of states that are connected via <code>Init</code> and <code>Next</code> as above, but
without stopping at any index <code>k</code>.</p>
<p>Below we plot the values of <code>x</code> and <code>y</code> in the first 16 states with red dots.
Not surprisingly, we just get a line.</p>
<p><img src="lang/./img/diagonal.png" alt="diagonal" /></p>
<p><strong>Note:</strong> In the above examples, we only showed transitions that could be
produced by computations, which (by our definition) originate from the initial
states. These transitions contain <em>reachable</em> states. In principle, <code>Next</code> may
also describe transitions that contain unreachable states. For instance, the
operator <code>Next</code> from our example evaluates to <code>TRUE</code> on the following pairs as
well:</p>
<pre><code class="language-tla">&lt;&lt;[x |-&gt; -100, y |-&gt; -100], [x |-&gt; -99, y |-&gt; -99]&gt;&gt;
&lt;&lt;[x |-&gt; -100, y |-&gt; 100], [x |-&gt; -99, y |-&gt; 101]&gt;&gt;
&lt;&lt;[x |-&gt; 100, y |-&gt; -100], [x |-&gt; 101, y |-&gt; -99]&gt;&gt;
...
</code></pre>
<p>There is no reason to restrict transitions only to the reachable states
(and it would be hard to do, technically). This feature is often used to reason
about inductive invariants.</p>
<p><strong>Determinism and non-determinism.</strong> Our specification is quite boring: It
describes exactly one initial state, and there is no variation in computing the
next states.  We can make it a bit more interesting:</p>
<pre><code class="language-tla">------------ MODULE coord2 ---------------
VARIABLES x, y
Init == x = 0 /\ (y = 0 \/ y = 1 \/ y = 2)
Next == x' = x + 1 /\ y' = y + 1
==========================================
</code></pre>
<p>Now our plot has a bit more variation. It presents three computations
that are starting in three different initial states: <code>[x |-&gt; 0, y |-&gt; 0]</code>,
<code>[x |-&gt; 0, y |-&gt; 1]</code>, and <code>[x |-&gt; 0, y |-&gt; 2]</code>.</p>
<p><img src="lang/./img/diagonal3.png" alt="diagonal3" /></p>
<p>However, there is still not much variation in <code>Next</code>. For every state <code>s</code>,
we can precisely say which state follows <code>s</code> according to <code>Next</code>. We can
define <code>Next</code> as follows (note that <code>Init</code> is defined as in <code>coord</code>):</p>
<pre><code class="language-tla">------------ MODULE coord3 -----------------
VARIABLES x, y
Init == x = 0 /\ y = 0
Next == x' = x + 1 /\ (y' = x \/ y' = x + 1)
============================================
</code></pre>
<p>The following plot shows the states that are visited by the computations
of the specification <code>coord3</code>:</p>
<p><img src="lang/./img/diag2.png" alt="diag2" /></p>
<p>Notice that specification <code>coord</code> describes one infinite computation (and
infinitely many finite computations that are prefixes of the infinite
computation).  Specification <code>coord2</code> describes three infinite computations.
Specification <code>coord3</code> describes infinitely many infinite computations: At
every step, <code>Next</code> may choose between <code>y' = x</code> or <code>y' = x + 1</code>.</p>
<p>Why are these specifications so different? The answer lies in non-determinism.
Specification <code>coord</code> is completely deterministic: There is just one state that
evaluates <code>Init</code> to <code>TRUE</code>, and every state is the first component of exactly
one transition, as specified by <code>Next</code>. Specification <code>coord2</code> has
non-determinism in the operator <code>Init</code>. Specification <code>coord3</code> has
non-determinism in the operator <code>Next</code>.</p>
<p><strong>Discussion.</strong>
So far we have been talking about the intuition. If you would like to know more about
the logic behind TLA+ and the semantics of TLA+, check Chapter 16 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> and <a href="https://members.loria.fr/SMerz/papers/tla+logic2008.pdf">The Specification Language TLA+</a>.</p>
<p>When we look at the operators like <code>Init</code> and <code>Next</code> in our examples, we can
guess the states and transitions. If we could ask our logician friend to guess
the states and transitions for us every time we read a TLA+ specification, that
would be great. But this approach does not scale well.</p>
<p><strong>Can we explain non-determinism to a computer?</strong> It turns out that we can.
In fact, many model checkers support non-determinism in their input languages.
For instance, see <a href="https://github.com/boogie-org/boogie">Boogie</a> and <a href="http://spinroot.com/spin/whatispin.html">Spin</a>.
Of course, this comes with constraints on the structure of the specifications.
After all, people are much better at solving certain logical puzzles than
computers, though people get bored much faster than computers.</p>
<p>To understand how TLC enumerates states, check Chapter 14 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying
Systems</a>. In the rest of this document, we focus on treatment of
non-determinism that is close to the approach in Apalache.</p>
<h2><a class="header" href="#explaining-non-determinism-to-computers" id="explaining-non-determinism-to-computers">Explaining non-determinism to computers</a></h2>
<p>To see how a program could evaluate a TLA+ expression, we need two more
ingredients: bindings and oracles.</p>
<p><strong>Bindings.</strong> We generalize states to bindings: Given a set of names <code>N</code>, a
<em>binding</em> maps every name from <code>N</code> to a value.  When <code>N</code> is the set of all
state variables, a binding describes a state.  However, a binding does not have
to assign values to all state variables.  Moreover, a binding may assign values
to names that are not the names of state variables. In the following, we are
using bindings over subsets of names that contain: (1) names of the state
variables, and (2) names of the primed state variables.</p>
<p>To graphically distinguish bindings from states, we use parentheses and arrows
to define bindings. For instance, <code>(x -&gt; 1, x' -&gt; 3)</code> is a binding that maps
<code>x</code> to 1 and <code>x'</code> to 3. (This is our notation, not a common TLA+ notation.)</p>
<p><strong>Evaluating deterministic expressions.</strong> Consider the specification <code>coord</code>,
which was given above.  By starting with the empty binding <code>()</code>, we can see how
to automatically evaluate the body of the operator <code>Init</code>:</p>
<pre><code class="language-tla">x = 0 /\ y = 0
</code></pre>
<p>By following <a href="lang/./booleans.html">semantics of conjunction</a>, we see that <code>/\</code> is
evaluated from left-to-right. The left-hand side equality <code>x = 0</code> is treated as
an assignment to <code>x</code>, since <code>x</code> is not assigned a value in the empty binding
<code>()</code>, which it is evaluated against.  Hence, the expression <code>x = 0</code> produces
the binding <code>(x -&gt; 0)</code>. When applied to this binding, the right-hand side
equality <code>y = 0</code> is also treated as an assignment to <code>y</code>. Hence, the expression
<code>y = 0</code> results in the binding <code>(x -&gt; 0, y -&gt; 0)</code>. This binding is defined over
all state variables, so it gives us the only initial state <code>[x |-&gt; 0, y |-&gt; 0]</code>.</p>
<p>Let's see how to evaluate the body of the operator <code>Next</code>:</p>
<pre><code class="language-tla">x' = x + 1 /\ y' = y + 1
</code></pre>
<p>As we have seen, <code>Next</code> describes pairs of states. Thus, we will produce
bindings over non-primed and primed variables, that is, over <code>x, x', y, y'</code>.
Non-primed variables represent the state before a transition fires, whereas
primed variables represent the state after the transition has been fired.</p>
<p>Consider evaluation of <code>Next</code> in the state <code>[x |-&gt; 3, y |-&gt; 3]</code>, that is, the
evaluation starts with the binding <code>(x -&gt; 3, y -&gt; 3)</code>.  Similar to the
conjunction in <code>Init</code>, the conjunction in <code>Next</code> first produces the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4)</code> and then the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 4, y' -&gt; 4)</code>.  Moreover, <code>Next</code> evaluates to <code>TRUE</code> when it is evaluated against the
binding <code>(x -&gt; 3, y -&gt; 3)</code>. Hence, the state <code>[x |-&gt; 3, y |-&gt; 3]</code> has the only
successor <code>[x |-&gt; 4, y |-&gt; 4]</code>, when following the transition predicate <code>Next</code>.</p>
<p>In contrast, if we evaluate <code>Next</code> when starting with the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, the result will be <code>FALSE</code>, as the left-hand side of
the conjunction <code>x' = x + 1</code> evaluates to <code>FALSE</code>.  Indeed, <code>x'</code> has value <code>1</code>,
whereas <code>x</code> has value <code>3</code>, so <code>x' = x + 1</code> is evaluated as <code>1 = 3 + 1</code> against
the binding <code>(x -&gt; 3, y -&gt; 3, x' -&gt; 1, y' -&gt; 1)</code>, which gives us <code>FALSE</code>.
Hence, the pair of states <code>[x |-&gt; 3, y |-&gt; 3]</code> and <code>[x |-&gt; 1, y |-&gt; 1]</code> is not
a valid transition as represented by <code>Next</code>.</p>
<p>So far, we only considered unconditional operators. Let's have a look at the
operator <code>A</code>:</p>
<pre><code class="language-tla">A ==
  y &gt; x /\ y' = x /\ x' = x
</code></pre>
<p>Evaluation of <code>A</code> against the binding <code>(x -&gt; 3, y -&gt; 10)</code> produces the binding
<code>(x -&gt; 3, y -&gt; 10, x' -&gt; 3, y' -&gt; 3)</code> and the result <code>TRUE</code>.  However, in the
evaluation of <code>A</code> against the binding <code>(x -&gt; 10, y -&gt; 3)</code>, the leftmost
condition <code>y &gt; x</code> evaluates to <code>FALSE</code>, so <code>A</code> evaluates to <code>FALSE</code> against the
binding <code>(x -&gt; 10, y -&gt; 3)</code>. Hence, no next state can be produced from the
the state <code>[x |-&gt; 3, y |-&gt; 10]</code> by using operator <code>A</code>.</p>
<p>Until this moment, we have been considering only deterministic examples, that is,
there was no &quot;branching&quot; in our reasoning. Such examples can be easily put into
a program. What about the operators, where we can choose from multiple options
that are simultaneously enabled? We introduce an oracle to resolve this issue.</p>
<p><strong>Oracles.</strong> For multiple choices, we introduce an external device that we call
an oracle. More formally, we assume that there is a device called <code>GUESS</code> that
has the following properties:</p>
<ol>
<li>For a non-empty set <code>S</code>, a call <code>GUESS S</code> returns
some value <code>v \in S</code>.</li>
<li>A call <code>GUESS {}</code> halts the evaluation.</li>
<li>There are no assumptions about fairness of <code>GUESS</code>. It is free to return
elements in any order, produce duplicates and ignore some elements.</li>
</ol>
<p>Why do we call it a device? We cannot call it a function, as functions are
deterministic by definition. For the same reason, it is not a TLA+
operator. In logic, we would say that <code>GUESS</code> is simply a binary relation on
sets and their elements, which would be no different from the membership
relation <code>\in</code>.</p>
<p>Why do we need <code>GUESS S</code> and cannot use <code>CHOOSE x \in S: TRUE</code> instead?
Actually, <code>CHOOSE x \in S: TRUE</code> is <em>deterministic</em>. It is guaranteed to return
the same value, when it is called on two equals sets: if <code>S = T</code>, then
<code>(CHOOSE x \in S: TRUE) = (CHOOSE x \in T: TRUE)</code>. Our <code>GUESS S</code> does not have
this guarantee. It is free to return an arbitrary element of <code>S</code> each time
we call it.</p>
<p>How to implement <code>GUESS S</code>? There is no general answer to this question.
However, we know of multiple sources of non-determinism in computer science. So
we can think of <code>GUESS S</code> as being one of the following implementations:</p>
<ol>
<li>
<p><code>GUESS S</code> can be a remote procedure call in a distributed system.  Unless,
we have centralized control over the distributed system, the returned value of
RPC may be non-deterministic.</p>
</li>
<li>
<p><code>GUESS S</code> can be simply the user input. In this case, the user resolves
non-determinism.</p>
</li>
<li>
<p><code>GUESS S</code> can be controlled by an adversary, who is trying to break the
system.</p>
</li>
<li>
<p><code>GUESS S</code> can pick an element by calling a pseudo-random number generator.
However, note that RNG is a very special way of resolving non-determinism: It
assumes probabilistic distribution of elements (usually, it is close to the
<a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution">uniform
distribution</a>).
Thus, the probability of producing an unfair choice of elements with RNG will
be approaching 0.</p>
</li>
</ol>
<p>As you see, there are multiple sources of non-determinism. With <code>GUESS S</code> we can
model all of them. As TLA+ does not introduce special primitives for different
kinds of non-determinism, neither do we fix any implementation of <code>GUESS S</code>.</p>
<p><strong>Halting.</strong> Note that <code>GUESS {}</code> halts the evaluation. What does it mean? The
evaluation cannot continue. It does not imply that we have found a deadlock in
our TLA+ specification. It simply means that we made wrong choices on the way.
If we would like to enumerate all possible state successors, like TLC does, we
have to backtrack (though that needs fairness of <code>GUESS</code>). In general, the
course of action depends on the program analysis that you implement. For
instance, a random simulator could simply backtrack and randomly choose another
value.</p>
<p><a name="nondetExists"></a></p>
<h3><a class="header" href="#non-determinism-in-e-x-in-s-p" id="non-determinism-in-e-x-in-s-p">Non-determinism in <code>\E x \in S: P</code></a></h3>
<p>We only have to consider the following case: <code>\E x \in S: P</code> is evaluated against
a binding <code>s</code>, and there is a primed state variable <code>y'</code> that satisfies two
conditions:</p>
<ol>
<li>The predicate <code>P</code> refers to <code>y'</code>, that is, <code>P</code> has to assign a value to <code>y'</code>.</li>
<li>The value of <code>y'</code> is not defined yet, that is, binding <code>s</code> does not have a
value for the name <code>y'</code>.</li>
</ol>
<p>If the above assumptions do not hold true, the expression <code>\E x \in S: P</code> does
not have non-determinism and it can be evaluated by following the standard
deterministic semantics of exists, see <a href="lang/./logic.html">Logic</a>.</p>
<p><strong>Note:</strong> We do not consider action operators like <code>UNCHANGED y</code>. They can be
translated into an equivalent form, e.g., <code>UNCHANGED x</code> is equivalent to <code>y' = y</code>.</p>
<p>Now it is very easy to evaluate <code>\E x \in S: P</code>. We simply evaluate the
following expression:</p>
<pre><code class="language-tla">  LET x == GUESS S IN P
</code></pre>
<p>It is the job of <code>GUESS S</code> to tell us what value of <code>x</code> should be
evaluated. There are three possible outcomes:</p>
<ol>
<li>Predicate <code>P</code> evaluates to <code>TRUE</code> when using the provided value of <code>x</code>.
In this case, <code>P</code> assigns the value of an expression <code>e</code> to <code>y'</code> as soon as
the evaluator meets the expression <code>y' = e</code>.
The evaluation may continue.</li>
<li>Predicate <code>P</code> evaluates to <code>FALSE</code> when using the provided value of <code>x</code>.
Well, that was a wrong guess. According to our semantics, the evaluation
halts. See the above discussion on &quot;halting&quot;.</li>
<li>The set <code>S</code> is empty, and <code>GUESS S</code> halts.  See the above discussion on
&quot;halting&quot;.</li>
</ol>
<p><strong>Example.</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLE x
Init == x = 0
Next ==
  \E i \in Int:
    i &gt; x /\ x' = i
</code></pre>
<p>It is easy to evaluate <code>Init</code>: It does not contain non-determinism and it
produces the binding <code>(x -&gt; 0)</code> and the state <code>[x |-&gt; 0]</code>, respectively. When
evaluating <code>Next</code> against the binding <code>(x -&gt; 0)</code>, we have plenty of choices.
Actually, we have infinitely many choices, as the set <code>Int</code> is infinite.  TLC
would immediately fail here. But there is no reason for our evaluation to fail.
Simply ask the oracle. Below we give three examples of how the evaluation
works:</p>
<pre><code>1. (GUESS Int) returns 10. (LET i == 10 IN i &gt; x /\ x' = i) is TRUE, x' is assigned 10.
2. (GUESS Int) returns 0. (LET i == 0 IN i &gt; x /\ x' = i) is FALSE. Halt.
3. (GUESS Int) returns -20. (LET i == -20 IN i &gt; x /\ x' = i) is FALSE. Halt.
</code></pre>
<p><a name="nondetOr"></a></p>
<h3><a class="header" href="#non-determinism-in-disjunctions" id="non-determinism-in-disjunctions">Non-determinism in disjunctions</a></h3>
<p>Consider a disjunction that comprises <code>n</code> clauses:</p>
<pre><code class="language-tla">  \/ P_1
  \/ P_2
  ...
  \/ P_n
</code></pre>
<p>Assume that we evaluate the disjunction against a binding <code>s</code>. Further,
let us say that <code>Unassigned(s)</code> is the set of variables that are not
defined in <code>s</code>. For every <code>P_i</code> we construct the set of state variables
<code>Use_i</code> that contains every variable <code>x'</code> that is mentioned in <code>P_i</code>.
There are three cases to consider:</p>
<ol>
<li>All sets <code>Use_i</code> agree on which variables are to be assigned.
Formally, <code>Use_i \intersect Unassigned(s) = Use_j \intersect Unassigned(s) /= {}</code>
for <code>i, j \in 1..n</code>. This is the case that we consider below.</li>
<li>Two clauses disagree on the set of variables to be assigned.
Formally, there is a pair <code>i, j \in 1..n</code> that satisfy the inequality:
<code>Use_i \intersect Unassigned(s) /= Use_j \intersect Unassigned(s)</code>.
In this case, the specification is ill-structured. TLC would
raise an error when it found a binding like this.
Apalache would detect this problem when preprocessing the specification.</li>
<li>The clauses do not assign values to the primed variables.
Formally, <code>Use_i \intersect Unassigned(s) = {}</code> for <code>i \in 1..n</code>.
This is the deterministic case. It can be evaluated by using the
deterministic semantics of <a href="lang/./booleans.html">Boolean operators</a>.</li>
</ol>
<p>We introduce a fresh variable to contain the choice of the clause.  Here we
call it <code>choice</code>. In a real implementation of an evaluator, we would have to
give it a unique name. Now we evaluate the following <em>conjunction</em>:</p>
<pre><code class="language-tla">LET choice == GUESS 1..n IN
  /\ (choice = 1) =&gt; P_1
  /\ (choice = 2) =&gt; P_2
  ...
  /\ (choice = n) =&gt; P_n
</code></pre>
<p>Importantly, at most one clause in the conjunction will be actually evaluated.
As a result, we cannot produce conflicting assignments to the primed variables.</p>
<p><strong>Example:</strong> Consider the following specification:</p>
<pre><code class="language-tla">VARIABLES x, y
Init == x == 0 /\ y == 0
Next ==
    \/ x &gt;= 0 /\ y' = x /\ x' = x + 1
    \/ x &lt;= 0 /\ y' = -x /\ x' = -(x + 1)
</code></pre>
<p>As you can see, the operator <code>Next</code> is non-deterministic since both clauses may
be activated when <code>x = 0</code>.</p>
<p>First, let's evaluate <code>Next</code> against the binding <code>(x -&gt; 3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE, x' is assigned 4, y' is assigned 3.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is FALSE. Halt.
</code></pre>
<p>Second, evaluate <code>Next</code> against the binding <code>(x -&gt; -3, y -&gt; 3)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is FALSE. Halt.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned 4, y' is assigned -3.
</code></pre>
<p>Third, evaluate <code>Next</code> against the binding <code>(x -&gt; 0, y -&gt; 0)</code>:</p>
<pre><code>1. (GUESS 1..2) returns 1. (LET i == 1 IN Next) is TRUE. x' is assigned 1, y' is assigned 0.
2. (GUESS 1..2) returns 2. (LET i == 2 IN Next) is TRUE, x' is assigned -1, y' is assigned 0.
</code></pre>
<p><em>Important note. In contrast to <a href="lang/./booleans.html">short-circuiting of
disjunction</a> in the deterministic case, we have
non-deterministic choice here. Hence, short-circuiting does not apply to
non-deterministic disjunctions.</em></p>
<p><a name="nondetIte"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-if-then-else" id="non-determinism-in-boolean-if-then-else">Non-determinism in Boolean <code>IF-THEN-ELSE</code></a></h3>
<p>For the deterministic use of <code>IF-THEN-ELSE</code>, see <a href="lang/./conditionals.html">Deterministic
conditionals</a>.</p>
<p>Consider an <code>IF-THEN-ELSE</code> expression to be evaluated in a partial state <code>s</code>:</p>
<pre><code class="language-tla">IF A THEN B ELSE C
</code></pre>
<p>In Apalache, this operator has the polymorphic type <code>(Bool, a, a) =&gt; a</code>,
where <code>a</code> can be replaced with a concrete type. Here, we consider the case
<code>(Bool, Bool, Bool) =&gt; Bool</code>.</p>
<p>Here we assume that both <code>B</code> and <code>C</code> produce Boolean results and <code>B</code> and <code>C</code>
refer to at least one primed variable <code>y'</code> that is undefined in <code>s</code>. Otherwise, the
expression can be evaluated as a <a href="lang/./conditionals.html">deterministic
conditional</a>.</p>
<p>In this case, <code>IF-THEN-ELSE</code> can be evaluated as the equivalent expression:</p>
<pre><code class="language-tla">  \/  A /\ B
  \/ ~A /\ C
</code></pre>
<p><em>We do not recommend you to use IF-THEN-ELSE with non-determinism. The structure
of the disjunction provides a clear indication that the expression may
assign to variables as a side effect. IF-THEN-ELSE has two thinking
steps: what is the expected result, and what are the possible side effects.</em></p>
<p><strong>Warning:</strong> While it is technically possible to write <code>x' = e</code> inside the
condition, the effect of <code>x' = e</code> is not obvious when <code>x'</code> is not assigned a
value.</p>
<p><a name="nondetCase"></a></p>
<h3><a class="header" href="#non-determinism-in-boolean-case" id="non-determinism-in-boolean-case">Non-determinism in Boolean <code>CASE</code></a></h3>
<p>For the deterministic use of <code>CASE</code>,
see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p><strong>CASE without OTHER.</strong>
Consider a <code>CASE</code> expression:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
</code></pre>
<p>Here, we assume that <code>e_1, ..., e_n</code> produce Boolean results.  Or, in terms of
Apalache types, this expression has the type: <code>(Bool, Bool, ..., Bool, Bool) =&gt; Bool</code>.  Otherwise, see <a href="lang/./conditionals.html">Deterministic conditionals</a>.</p>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
</code></pre>
<p><em>Similar to IF-THEN-ELSE, we do not recommend using CASE for expressing
non-determinism. When you are using disjunction, the Boolean result and
possible side effects are expected.</em></p>
<p><strong>CASE with OTHER.</strong> The more general form of <code>CASE</code> is like follows:</p>
<pre><code class="language-tla">CASE P_1 -&gt; e_1
  [] P_2 -&gt; e_2
  ...
  [] P_n -&gt; e_n
  [] OTHER -&gt; e_other
</code></pre>
<p>This operator is equivalent to the following disjunction:</p>
<pre><code class="language-tla">\/ P_1 /\ e_1
\/ P_2 /\ e_2
...
\/ P_n /\ e_n
\/ ~P_1 /\ ... /\ ~P_n /\ e_other
</code></pre>
<p><em>The use of CASE with OTHER together with non-determinism is quite rare.
It is not clear why would one need a fallback option in the Boolean formula.
We recommend you to use the disjunctive form instead.</em></p>
<p><a href="lang/./standard-operators.html">Back to all operators</a></p>
<h1><a class="header" href="#deterministic-conditionals" id="deterministic-conditionals">Deterministic conditionals</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, we consider the instances of <code>IF-THEN-ELSE</code> and <code>CASE</code> that
may not update primed variables. For the case, when the operators inside
<code>IF-THEN-ELSE</code> or <code>CASE</code> can be used to do non-deterministic assignments, see
<a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Warning:</strong> Because frequent use of <code>IF-THEN-ELSE</code> is very common in most
programming languages, TLA+ specification authors with programming experience
often default to writing expressions such as <code>IF A THEN B ELSE C</code>.  We
encourage those authors to use this construct more sparingly.  In our
experience, the use of <code>IF-THEN-ELSE</code> is rarely required.  Many things can be
done with <a href="lang/./booleans.html">Boolean operators</a>, which provide more structure in
TLA+ code than in programming languages.  We recommend using <code>IF-THEN-ELSE</code> to
compute predicate-dependent values, not to structure code.</p>
<p><strong>Warning 2:</strong> <code>CASE</code> is considered deterministic in this
section, as it is defined with the <code>CHOOSE</code> operator in
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, Section 16.1.4.
For this reason, <code>CASE</code> should only be used when all of its guards are mutually exclusive.
Given all the intricacies of <code>CASE</code>,
we recommend using nested <code>IF-THEN-ELSE</code> instead.</p>
<hr />
<p><a name="ite"></a></p>
<h2><a class="header" href="#deterministic-if-then-else" id="deterministic-if-then-else">Deterministic IF-THEN-ELSE</a></h2>
<p><em>Use it when choosing between two values, not to structure your code.</em></p>
<p><strong>Notation:</strong> <code>IF A THEN B ELSE C</code></p>
<p><strong>LaTeX notation:</strong> the same</p>
<p><strong>Arguments:</strong> a Boolean expression <code>A</code> and two expressions <code>B</code> and <code>C</code></p>
<p><strong>Apalache type:</strong> <code>(Bool, a, a) =&gt; a</code>.  Note that <code>a</code> can be replaced with
<code>Bool</code>. If <code>a</code> is <code>Bool</code>, and only in that case, the expression <code>IF A THEN B ELSE C</code> is equivalent to <code>(A =&gt; B) /\ (~A =&gt; C)</code>.</p>
<p><strong>Effect:</strong> <code>IF A THEN B ELSE C</code> evaluates to:</p>
<ul>
<li>The value of <code>B</code>, if <code>A</code> evaluates to <code>TRUE</code>.</li>
<li>The value of <code>C</code>, if <code>A</code> evaluates to <code>FALSE</code>.</li>
</ul>
<p><strong>Determinism:</strong> This is a deterministic version. For the non-deterministic
version, see <a href="lang/control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> If <code>A</code> evaluates to a non-Boolean value, the result is undefined.
TLC raises an error during model checking. Apalache raises a type error when
preprocessing. Additionally, if <code>B</code> and <code>C</code> may evaluate to values of different
types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> Consider the following TLA+ expression:</p>
<pre><code class="language-tla">IF x THEN 100 ELSE 0
</code></pre>
<p>As you most likely expected, this expression evaluates to <code>100</code>, when <code>x</code>
evaluates to <code>TRUE</code>; and it evaluates to <code>0</code>, when <code>x</code> evaluates to <code>FALSE</code>.</p>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">100 if x else 0
</code></pre>
<p>Note that we are using the expression syntax for <code>if-else</code> in python.
This is because we write an expression, not a series of statements that assign
values to variables!</p>
<p><a name="case"></a></p>
<h2><a class="header" href="#deterministic-case" id="deterministic-case">Deterministic CASE</a></h2>
<p><em>Read the description and never use this operator</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case.png" alt="case" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_1, ..., e_n</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool, a, Bool, a, ..., Bool, a) =&gt; a</code>, for some type <code>a</code>.
If <code>a</code> is <code>Bool</code>, then the case operator can be a part of a Boolean formula.</p>
<p><strong>Effect:</strong> Given a state <code>s</code>, define the set <code>I \subseteq 1..n</code> as follows:
The set <code>I</code> includes the index <code>j \in 1..n</code> if
and only if <code>p_j</code> evaluates to <code>TRUE</code> in the state <code>s</code>.
Then the above <code>CASE</code> expression evaluates to:</p>
<ul>
<li>the value of the expression <code>e_i</code> for some <code>i \in I</code>, if <code>I</code> is not empty; or</li>
<li>an undefined value, if the set <code>I</code> is empty.</li>
</ul>
<p>As you can see, when several predicates <code>{p_i: i \in I}</code> are evaluated
to <code>TRUE</code> in the state <code>s</code>, then the result of <code>CASE</code> is equal to one of the
elements in the set <code>{e_i: i \in I}</code>. Although the result should be stable,
the exact implementation is unknown.</p>
<p>Whenever <code>I</code> is a singleton set, the result is easy to define: Just take the
only element of <code>I</code>. <em>Hence, when <code>p_1, ..., p_n</code> are mutually exclusive,
the result is deterministic and implementation-agnostic.</em></p>
<p>Owing to the flexible semantics of simultaneously enabled predicates,
TLC interprets the above <code>CASE</code> operator as a chain of <code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE TLC!Assert(FALSE)
</code></pre>
<p><em>As TLC fixes the evaluation order, TLC may miss a bug in an arm that is never
activated in this order!</em></p>
<p>Note that the last arm of the ITE-series ends with <code>Assert(FALSE)</code>, as the
result is undefined, when no predicate evaluates to <code>TRUE</code>. As the type
of this expression cannot be precisely defined, Apalache does not support <code>CASE</code>
expressions, but only supports <code>CASE-OTHER</code> expressions (see below), which
it treats as a chain of <code>IF-THEN-ELSE</code> expressions.</p>
<p><strong>Determinism.</strong> The result of <code>CASE</code> is deterministic, if there are no primes
inside.  For the non-deterministic version, see <a href="lang/control-and-nondeterminism.html">[Control Flow and
Non-determinism]</a>.  When the predicates are
mutually exclusive, the evaluation result is clearly specified. When the predicates are
not mutually exclusive, the operator is still deterministic, but only one of
the simultaneously enabled branches is evaluated.
Which branch is evaluated depends on the <code>CHOOSE</code> operator, see <a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing. Additionally, if <code>e_1</code>, ..., <code>e_n</code>
may evaluate to values of different types, Apalache raises a type error.</p>
<p><strong>Example in TLA+:</strong> The following expression classifies an integer variable
<code>n</code> with one of the three strings: &quot;negative&quot;, &quot;zero&quot;, or &quot;positive&quot;.</p>
<pre><code class="language-tla">  CASE n &lt; 0 -&gt; &quot;negative&quot;
    [] n = 0 -&gt; &quot;zero&quot;
    [] n &gt; 0 -&gt; &quot;positive&quot;
</code></pre>
<p>Importantly, the predicates <code>n &lt; 0</code>, <code>n = 0</code>, and <code>n &gt; 0</code> are mutually
exclusive.</p>
<p>The following expression contains non-exclusive predicates:</p>
<pre><code class="language-tla">  CASE n % 2 = 0 -&gt; &quot;even&quot;
    [] (\A k \in 2..(1 + n \div 2): n % k /= 0) -&gt; &quot;prime&quot;
    [] n % 2 = 1 -&gt; &quot;odd&quot;

</code></pre>
<p>Note that by looking at the specification, we cannot tell, whether this
expression returns &quot;odd&quot; or &quot;prime&quot;, when <code>n = 17</code>. We only know that the
case expression should consistently return the same value, whenever it is
evaluated with <code>n = 17</code>.</p>
<p><strong>Example in Python:</strong> Consider our first example in TLA+. Similar to TLC, we
give executable semantics for the fixed evaluation order of the predicates.</p>
<pre><code class="language-python">def case_example(n):
    if n &lt; 0:
        return &quot;negative&quot;
    elif n == 0:
        return &quot;zero&quot;
    elif n &gt; 0:
        return &quot;positive&quot;
</code></pre>
<p><a name="caseOther"></a></p>
<h2><a class="header" href="#deterministic-case-other" id="deterministic-case-other">Deterministic CASE-OTHER</a></h2>
<p><em>Better use IF-THEN-ELSE.</em></p>
<p><strong>Notation:</strong></p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] OTHER -&gt; e_0
</code></pre>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/case-other.png" alt="case-other" /></p>
<p><strong>Arguments:</strong> Boolean expressions <code>p_1, ..., p_n</code> and expressions <code>e_0, e_1, ..., e_n</code>.</p>
<p><strong>Apalache type:</strong> <code>(Bool, a, Bool, a, ..., Bool, a, a) =&gt; a</code>, for some type <code>a</code>.
If <code>a</code> is <code>Bool</code>, then the case operator can be a part of a Boolean formula.</p>
<p><strong>Effect:</strong> This operator is equivalent to the following version of <code>CASE</code>:</p>
<pre><code class="language-tla">CASE p_1 -&gt; e_1
  [] p_2 -&gt; e_2
  ...
  [] p_n -&gt; e_n
  [] ~(p_1 \/ p_2 \/ ... \/ p_n) -&gt; e_0
</code></pre>
<p>Both TLC and Apalache interpret this <code>CASE</code> operator as a chain of
<code>IF-THEN-ELSE</code> expressions:</p>
<pre><code class="language-tla">  IF p_1 THEN e_1
  ELSE IF p_2 THEN e_2
  ...
  ELSE IF p_n THEN e_n
  ELSE e_0
</code></pre>
<p>All the idiosyncrasies of <code>CASE</code> apply to <code>CASE-OTHER</code>. Hence, we recommend
using <code>IF-THEN-ELSE</code> instead of <code>CASE-OTHER</code>. Although <code>IF-THEN-ELSE</code>
is a bit more verbose, its semantics are precisely defined.</p>
<p><strong>Determinism.</strong> The result of <code>CASE-OTHER</code> is deterministic, if <code>e_0</code>, <code>e_1</code>,
..., <code>e_n</code> may not update primed variables.  For the non-deterministic version,
see <a href="lang/control-and-nondeterminism.html">[Control Flow and Non-determinism]</a>.  When
the predicates are mutually exclusive, the semantics is clearly specified. When
the predicates are not mutually exclusive, the operator is still deterministic,
but only one of the simultaneously enabled branches is evaluated. The choice of
the branch is implemented with the operator <code>CHOOSE</code>, see
<a href="lang/./logic.html">[Logic]</a>.</p>
<p><strong>Errors:</strong> If one of <code>p_1, ..., p_n</code> evaluates to a non-Boolean value, the
result is undefined.  TLC raises an error during model checking. Apalache
raises a type error when preprocessing.  Additionally, if <code>e_0</code>, <code>e_1</code>, ...,
<code>e_n</code> may evaluate to values of different types, Apalache raises a type error.</p>
<h1><a class="header" href="#integers" id="integers">Integers</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>The integer literals belong to the core language. They are written by
using the standard syntax: 0, 1, -1, 2, -2, 3, -3, ... Importantly, TLA+
integers are unbounded. They do not have any fixed bit width, and they cannot
overflow. In Apalache, these literals have the type <code>Int</code>.</p>
<p>The integer operators are defined in the standard module <code>Integers</code>. To use
it, write the <code>EXTENDS</code> clause in the first lines of your module. Like this:</p>
<pre><code class="language-tla">---- MODULE MyArithmetics ----
EXTENDS Integers
...
==============================
</code></pre>
<h2><a class="header" href="#integers-in-apalache-and-smt" id="integers-in-apalache-and-smt">Integers in Apalache and SMT</a></h2>
<p>Although you can write arbitrary expressions over integers in TLA+, Apalache
translates these expressions as constraints in
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>.  Some
expressions are easier to solve than the others. For instance, the expression
<code>2 * x &gt; 5</code> belongs to linear integer arithmetic, which can be solved more
efficiently than general arithmetic.  For state variables <code>x</code> and <code>y</code>, the
expression <code>x * y &gt; 5</code> belongs to non-linear integer arithmetic, which is
harder to solve than linear arithmetic.</p>
<p>When your specification is using only integer literals, e.g., <code>1</code>, <code>2</code>, <code>42</code>,
but none of the operators from the <code>Integers</code> module, the integers can
be avoided altogether.  For instance, you can replace the integer constants
with string constants, e.g., <code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;42&quot;</code>. The string constants are
translated as constants in the SMT constraints. This simple trick may bring
your specification into a much simpler theory. Sometimes, this trick allows z3
to use parallel algorithms.</p>
<p><a name="const"></a></p>
<h2><a class="header" href="#constants-1" id="constants-1">Constants</a></h2>
<p>The module <code>Integers</code> defines two constant sets (technically, they are
operators without arguments):</p>
<ul>
<li>The set <code>Int</code> that consists of all integers. <em>This set is infinite.</em>
In Apalache, the set <code>Int</code> has the type <code>Set(Int)</code>.
A bit confusing, right? üòé</li>
<li>The set <code>Nat</code> that consists of all natural numbers, that is,
<code>Nat</code> contains every integer <code>x</code> that has the property <code>x &gt;= 0</code>.
<em>This set is infinite.</em>
In Apalache, the set <code>Nat</code> has the type... <code>Set(Int)</code>.</li>
</ul>
<hr />
<h2><a class="header" href="#operators-1" id="operators-1">Operators</a></h2>
<p><a name="range"></a></p>
<h3><a class="header" href="#integer-range" id="integer-range">Integer range</a></h3>
<p><strong>Notation:</strong> <code>a..b</code></p>
<p><strong>LaTeX notation:</strong> <code>a..b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Set(Int)</code>.</p>
<p><strong>Effect:</strong> <code>a..b</code> evaluates to the finite set <code>{i \in Int: a &lt;= i /\ i &lt;= b}</code>,
that is, the set of all integers in the range from <code>a</code> to <code>b</code>, including <code>a</code>
and <code>b</code>.  If <code>a &gt; b</code>, then <code>a..b</code> is the empty set <code>{}</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if one of the arguments
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  0..10    \* { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  -5..3    \* { -5, -4, -3, -2, -1, 0, 1, 2, 3 }
  10..0    \* { }
  &quot;a&quot;..&quot;z&quot; \* runtime error in TLC, type error in Apalache
  {1}..{3} \* runtime error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> <code>a..b</code> can be written as <code>set(range(a, b + 1))</code> in
python.</p>
<pre><code class="language-python">&gt;&gt;&gt; set(range(0, 10 + 1))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
&gt;&gt;&gt; set(range(10, 2))
set()

</code></pre>
<hr />
<p><a name="uminus"></a></p>
<h3><a class="header" href="#unary-integer-negation" id="unary-integer-negation">Unary integer negation</a></h3>
<p><strong>Notation:</strong> <code>-i</code></p>
<p><strong>LaTeX notation:</strong> <code>-i</code></p>
<p><strong>Arguments:</strong> One argument. The result is only defined when the argument
evaluates to an integer.</p>
<p><strong>Apalache type:</strong> <code>Int =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>-i</code> evaluates to the negation of <code>i</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if the argument
evaluates to a non-integer value. In this case, Apalache statically reports a
type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  -(5)    \* -5, note that '-5' is just a literal, not operator application
  -(-5)   \* 5
  -x      \* negated value of x
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; -(5)
-5
&gt;&gt;&gt; -(-5)
5

</code></pre>
<hr />
<p><a name="plus"></a></p>
<h3><a class="header" href="#integer-addition" id="integer-addition">Integer addition</a></h3>
<p><strong>Notation:</strong> <code>a + b</code></p>
<p><strong>LaTeX notation:</strong> <code>a + b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a + b</code> evaluates to the sum of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 + 3     \* 8
  (-5) + 3  \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 + 3
8
&gt;&gt;&gt; (-5) + 3
-2

</code></pre>
<hr />
<p><a name="minus"></a></p>
<h3><a class="header" href="#integer-subtraction" id="integer-subtraction">Integer subtraction</a></h3>
<p><strong>Notation:</strong> <code>a - b</code></p>
<p><strong>LaTeX notation:</strong> <code>a - b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a - b</code> evaluates to the difference of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 - 3         \* 2
  (-5) - 3      \* -8
  (-5) - (-3)   \* -2
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 - 3
2
&gt;&gt;&gt; (-5) - 3
-8
&gt;&gt;&gt; (-5) - (-3)
-2

</code></pre>
<hr />
<p><a name="mult"></a></p>
<h3><a class="header" href="#integer-multiplication" id="integer-multiplication">Integer multiplication</a></h3>
<p><strong>Notation:</strong> <code>a * b</code></p>
<p><strong>LaTeX notation:</strong> <code>a * b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a * b</code> evaluates to the product of <code>a</code> and <code>b</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5 * 3     \* 15
  (-5) * 3  \* -15
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 * 3
15
&gt;&gt;&gt; (-5) * 3
-15

</code></pre>
<hr />
<p><a name="div"></a></p>
<h3><a class="header" href="#integer-division" id="integer-division">Integer division</a></h3>
<p><strong>Notation:</strong> <code>a \div b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/div.png" alt="div" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a \div b</code> is defined as follows:</p>
<ol>
<li>When <code>a &gt;= 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &gt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(b-1)</code>.</li>
<li>When <code>a &gt;= 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
<li>When <code>a &lt; 0</code> and <code>b &lt; 0</code>, then the result of <code>a \div b</code> is
the integer <code>c</code> that has the property: <code>a = b * c + d</code>
for some <code>d</code> in <code>0..(-b-1)</code>.</li>
</ol>
<p><em>When <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer division <code>a \div b</code> according to the TLA+ definition is different from the integer division <code>a / b</code> in the programming languages (C, Java, Scala, Rust).  See the
table below.</em></p>
<table><thead><tr><th>¬†  C (clang 12)</th><th>Scala 2.13</th><th>Rust</th><th>Python 3.8.6</th><th>TLA+ (TLC)</th><th>SMT (z3 4.8.8)</th></tr></thead><tbody>
<tr><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 / 3 == 33</td><td>100 // 3 == 33</td><td>(100 \div 3) = 33</td><td>(assert (= 33 (div 100 3)))</td></tr>
<tr><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 / 3 == -33</td><td>-100 // 3 == -34</td><td>((-100) \div 3) = -34</td><td>(assert (= (- 0 34) (div (- 0 100) 3)))</td></tr>
<tr><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 / (-3) == -33</td><td>100 // (-3) == -34</td><td>(100 \div (-3)) = -34</td><td>(assert (= (- 0 33) (div 100 (- 0 3))))</td></tr>
<tr><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 / (-3) == 33</td><td>-100 // (-3) == 33</td><td>((-100) \div (-3)) = 33</td><td>(assert (= 34 (div (- 0 100) (- 0 3))))</td></tr>
</tbody></table>
<p><em>Unfortunately, <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a> only gives us the definition for the case
<code>b &gt; 0</code> (that is, cases 1-2 in our description). The implementation in SMT and
TLC produce incompatible results for <code>b &lt; 0</code>. See <a href="https://github.com/informalsystems/apalache/issues/331">issue #331 in
Apalache</a>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a \div b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs
(according to TLC):</p>
<pre><code class="language-tla">    100  \div   3   \*  33
  (-100) \div   3   \* -34
    100  \div (-3)  \* -34 in TLC
  (-100) \div (-3)  \*  33 in TLC
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">&gt;&gt;&gt; 100    //   3
33
&gt;&gt;&gt; -100   //   3
-34
&gt;&gt;&gt; 100    // (-3)
-34
&gt;&gt;&gt; (-100) // (-3)
33

</code></pre>
<hr />
<p><a name="mod"></a></p>
<h3><a class="header" href="#integer-remainder" id="integer-remainder">Integer remainder</a></h3>
<p><strong>Notation:</strong> <code>a % b</code></p>
<p><strong>LaTeX notation:</strong> <code>a % b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and the second argument is different from 0.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a % b</code> is the number <code>c</code> that has the property:
<code>a = b * (a \div b) + c</code>.</p>
<p><em>Note that when <code>a &lt; 0</code> or <code>b &lt; 0</code>, the result of the integer remainder <code>a % b</code>
according to the TLA+ definition is different from the integer remainder <code>a % b</code> in the programming languages (C, Python, Java, Scala, Rust).  See the
examples below.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error. The value
of <code>a % b</code> is undefined for <code>b = 0</code>.</p>
<p><strong>Example in TLA+:</strong> Here are the examples for the four combinations of signs:</p>
<pre><code class="language-tla">  100  % 3      \* 1
  -100 % (-3)   \* 2
  100  % (-3)   \* 1
  -100 % 3      \* 2
</code></pre>
<p><strong>Example in Python:</strong> Here are the examples for the four combinations of signs
to produce the same results as in TLA+:</p>
<pre><code class="language-python">&gt;&gt;&gt; 100 % 3
1
&gt;&gt;&gt; -100 % (-3) + 3
2
&gt;&gt;&gt; 100 % (-3) + 3
1
&gt;&gt;&gt; -100 % 3
2

</code></pre>
<hr />
<p><a name="pow"></a></p>
<h3><a class="header" href="#integer-exponentiation" id="integer-exponentiation">Integer exponentiation</a></h3>
<p><strong>Notation:</strong> <code>a^b</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exp.png" alt="exp" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values, and these values fall into one of the several
cases:</p>
<ol>
<li><code>b &gt; 0</code>,</li>
<li><code>b = 0</code> and <code>a /= 0</code>.</li>
</ol>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Int</code>.</p>
<p><strong>Effect:</strong> <code>a^b</code> evaluates to <code>a</code> raised to the <code>b</code>-th power:</p>
<ul>
<li>If <code>b = 1</code>, then <code>a^b</code> is defined as <code>a</code>.</li>
<li>If <code>a = 0</code> and <code>b &gt; 0</code>, then <code>a^b</code> is defined as <code>0</code>.</li>
<li>If <code>a /= 0</code> and <code>b &gt; 1</code>, then <code>a^b</code> is defined as <code>a * a^(b-1)</code>.</li>
<li>In all other cases, <code>a^b</code> is undefined.</li>
</ul>
<p>In TLA+, <code>a^b</code> extends to reals, see Chapter 18 in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.
For instance, <code>3^(-5)</code> is defined on reals. However, reals are supported
neither by TLC, nor by Apalache.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  5^3       \* 125
  (-5)^3    \* -125
  0^3       \* 0
  1^5       \* 1
  (-1)^5    \* -1
  0^0       \* undefined on integers, TLC reports a runtime error
  5^(-3)    \* undefined on integers, TLC reports a runtime error
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 5 ** 3
125
&gt;&gt;&gt; (-5) ** 3
-125
&gt;&gt;&gt; 0 ** 3
0
&gt;&gt;&gt; 1 ** 5
1
&gt;&gt;&gt; (-1) ** 5
-1
&gt;&gt;&gt; 0 ** 0
1
&gt;&gt;&gt; 5 ** (-3)
0.008

</code></pre>
<hr />
<p><a name="lt"></a></p>
<h3><a class="header" href="#integer-less-than" id="integer-less-than">Integer less-than</a></h3>
<p><strong>Notation:</strong> <code>a &lt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &lt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &lt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is less than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt; 5     \* TRUE
  5 &lt; 5     \* FALSE
  5 &lt; 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &lt; 5
True
&gt;&gt;&gt; 5 &lt; 5
False
&gt;&gt;&gt; 5 &lt; 1
False

</code></pre>
<hr />
<p><a name="lte"></a></p>
<h3><a class="header" href="#integer-less-than-or-equal" id="integer-less-than-or-equal">Integer less-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &lt;= b</code> or <code>a =&lt; b</code> or <code>a \leq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/leq.png" alt="leq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &lt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &lt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &lt;= 5     \* TRUE
  5 &lt;= 5     \* TRUE
  5 &lt;= 1     \* FALSE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &lt;= 5
True
&gt;&gt;&gt; 5 &lt;= 5
True
&gt;&gt;&gt; 5 &lt;= 1
False

</code></pre>
<hr />
<p><a name="gt"></a></p>
<h3><a class="header" href="#integer-greater-than" id="integer-greater-than">Integer greater-than</a></h3>
<p><strong>Notation:</strong> <code>a &gt; b</code></p>
<p><strong>LaTeX notation:</strong> <code>a &gt; b</code></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &gt; b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a</code> is greater than <code>b</code>,</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt; 5     \* FALSE
  5 &lt; 5     \* FALSE
  5 &gt; 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &gt; 5
False
&gt;&gt;&gt; 5 &gt; 5
False
&gt;&gt;&gt; 5 &gt; 1
True

</code></pre>
<hr />
<p><a name="gte"></a></p>
<h3><a class="header" href="#integer-greater-than-or-equal" id="integer-greater-than-or-equal">Integer greater-than-or-equal</a></h3>
<p><strong>Notation:</strong> <code>a &gt;= b</code> or <code>a \geq b</code></p>
<p><strong>LaTeX notation:</strong>  <img src="lang/./img/geq.png" alt="geq" /></p>
<p><strong>Arguments:</strong> Two arguments. The result is only defined when both arguments
are evaluated to integer values.</p>
<p><strong>Apalache type:</strong> <code>(Int, Int) =&gt; Bool</code>.</p>
<p><strong>Effect:</strong> <code>a &gt;= b</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>a &gt; b</code> or <code>a = b</code>.</li>
<li><code>FALSE</code>, otherwise.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No overflow is possible. In pure TLA+, the result is undefined, if
one of the arguments evaluates to a non-integer value. In this case, Apalache
statically reports a type error, whereas TLC reports a runtime error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  1 &gt;= 5     \* FALSE
  5 &gt;= 5     \* TRUE
  5 &gt;= 1     \* TRUE
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 1 &gt;= 5
False
&gt;&gt;&gt; 5 &gt;= 5
True
&gt;&gt;&gt; 5 &gt;= 1
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality" id="equality-and-inequality">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+ and thus they are
not defined in the module <code>Integers</code>, see <a href="lang/./logic.html">Logic</a>.</p>
<h1><a class="header" href="#sets-1" id="sets-1">Sets</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Sets are the foundational data structure in TLA+. (Similar to what lists are in
Lisp and Python). The other TLA+ data structures can be all expressed with
sets: functions, records, tuples, sequences. In theory, even Booleans and
integers can be expressed with sets. In practice, TLA+ tools treat Booleans and
integers as special values that are different from sets. It is important to
understand TLA+ sets well. In contrast to programming languages, there is no
performance penalty for using sets instead of sequences: TLA+ does not have a
compiler, the efficiency is measured in the time it takes the human brain to
understand the specification.</p>
<p><strong>Immutability.</strong> In TLA+, a set is an <em>immutable</em> data structure that stores
its elements in <em>no particular order</em>. All elements of a set are unique. In
fact, those two sentences do not make a lot of sense in TLA+. We have written
them to build the bridge from a programming language to TLA+, as TLA+ does not
have a memory model. üòâ</p>
<p>Sets may be constructed by enumerating values in <em>some order</em>, allowing for
duplicates:</p>
<pre><code class="language-tla">  { 1, 2, 3, 2, 4, 3 }
</code></pre>
<p>Note that the above set is equal to the sets <code>{ 1, 2, 3, 4 }</code> and <code>{ 4, 3, 2, 1 }</code>. They are actually the same set, though they are constructed by passing
various number of arguments in different orders.</p>
<p>The most basic set operation is the set membership that checks, whether a set
contains a value:</p>
<pre><code class="language-tla">  3 \in S
</code></pre>
<p>TLA+ sets are similar to
<a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset</code></a> in
Python and immutable <code>Set[Object]</code> in Java.  In contrast to programming
languages, set elements do not need hashes, as implementation efficiency is not
an issue in TLA+.</p>
<p><strong>Types.</strong> In pure TLA+, sets may contain any kinds of elements. For instance,
a set may mix integers, Booleans, and other sets:</p>
<pre><code class="language-tla">  { 2020, { &quot;is&quot; }, TRUE, &quot;fail&quot; }
</code></pre>
<p>TLC restricts set elements to comparable values. See Section 14.7.2 of
<a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. In a nutshell, if you do not mix the following five
kinds of values in a single set, TLC would not complain about your sets:</p>
<ol>
<li>Booleans,</li>
<li>integers,</li>
<li>strings,</li>
<li>sets,</li>
<li>functions, tuples, records, sequences.</li>
</ol>
<p>Apalache requires set elements to have the same type, that is, <code>Set(a)</code> for
some type <code>a</code>. This is enforced by the type checker.  (Records are an exception
to this rule, as some records can be unified to a common type.)</p>
<hr />
<h2><a class="header" href="#operators-2" id="operators-2">Operators</a></h2>
<p><a name="setEnum"></a></p>
<h3><a class="header" href="#set-constructor-by-enumeration" id="set-constructor-by-enumeration">Set constructor by enumeration</a></h3>
<p><strong>Notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>LaTeX notation:</strong> <code>{e_1, ..., e_n}</code></p>
<p><strong>Arguments:</strong> Any number of arguments, <code>n &gt;= 0</code>.</p>
<p><strong>Apalache type:</strong> <code>(a, ..., a) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Produce the set that contains the values of the expressions <code>e_1, ..., e_n</code>, in no particular order, and only these values. If <code>n = 0</code>, the
empty set is constructed.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the set elements. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC only allows a user to construct sets out of elements that are comparable. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further and requires that all set elements have the same type.
If this is not the case, the type checker flags an error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 1, 2, 3 }               \* a flat set of integers
  { { 1, 2 }, { 2, 3 } }    \* a set of sets of integers
  { FALSE, 1 }              \* a set of mixed elements.
                            \* Model checking error in TLC, type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; {1, 2, 3}
{1, 2, 3}
&gt;&gt;&gt; {frozenset({2, 3}), frozenset({1, 2})}
{frozenset({2, 3}), frozenset({1, 2})}
&gt;&gt;&gt; {False, 1}
{False, 1}

</code></pre>
<hr />
<p><a name="in"></a></p>
<h3><a class="header" href="#set-membership" id="set-membership">Set membership</a></h3>
<p><strong>Notation:</strong> <code>e \in S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/in-set.png" alt="in" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(a, Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>FALSE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> If you are using the special form <code>x' \in S</code>, this operator may
assign a value to <code>x'</code> as a side effect. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic, unless you are using the special form <code>x' \in S</code> to assign a value to <code>x'</code>, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \in { 1, 2, 3 }        \* TRUE
  10 \in { 1, 2, 3 }        \* FALSE
  {} \in { {1}, {2} }       \* FALSE
   1 \in { &quot;a&quot;, &quot;b&quot; }       \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>in</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1 in {1, 2, 3}
True
&gt;&gt;&gt; 10 in {1, 2, 3}
False
&gt;&gt;&gt; 1 in {&quot;a&quot;, &quot;b&quot;}
False

</code></pre>
<hr />
<p><a name="notin"></a></p>
<h3><a class="header" href="#set-non-membership" id="set-non-membership">Set non-membership</a></h3>
<p><strong>Notation:</strong> <code>e \notin S</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/notin-set.png" alt="notin" /></p>
<p><strong>Arguments:</strong> Two arguments.  If the second argument is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(a, Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>FALSE</code>, if <code>S</code> is a set that contains an element that is equal to the value
of <code>e</code>; and</li>
<li><code>TRUE</code>, if <code>S</code> is a set and all of its elements are not equal to the
value of <code>e</code>.</li>
</ul>
<p><em>Warning:</em> In contrast to <code>x' \in S</code>, the expression <code>x' \notin T</code>,
which is equivalent to <code>~(x' \in T)</code> is never
treated as an assignment in Apalache and TLC.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that <code>e</code> cannot be compared to the
elements of <code>S</code>. Apalache produces a static type error, if the type of <code>e</code> is
incompatible with the type of elements of <code>S</code>, or if <code>S</code> is not a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">   1 \notin { 1, 2, 3 }     \* FALSE
  10 \notin { 1, 2, 3 }     \* TRUE
  {} \notin { {1}, {2} }    \* TRUE
   1 \notin { &quot;a&quot;, &quot;b&quot; }    \* model checking error in TLC,
                            \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>not in</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; 1 not in {1, 2, 3}
False
&gt;&gt;&gt; 10 not in {1, 2, 3}
True
&gt;&gt;&gt; 1 not in {&quot;a&quot;, &quot;b&quot;}
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality-and-inequality-1" id="equality-and-inequality-1">Equality and inequality</a></h3>
<p>The operators <code>a = b</code> and <code>a /= b</code> are core operators of TLA+,
see <a href="lang/./logic.html">Logic</a>.</p>
<hr />
<p><a name="subseteq"></a></p>
<h3><a class="header" href="#set-inclusion" id="set-inclusion">Set inclusion</a></h3>
<p><strong>Notation:</strong> <code>S \subseteq T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/subseteq.png" alt="subseteq" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to:</p>
<ul>
<li><code>TRUE</code>, if <code>S</code> and <code>T</code> are sets, and every element of <code>S</code> is a member of <code>T</code>;</li>
<li><code>FALSE</code>, if <code>S</code> and <code>T</code> are sets, and there is an element of <code>S</code> that
is not a member of <code>T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">     { 1, 2 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2, 3 }     \* TRUE
  { 1, 2, 3 } \subseteq { 1, 2 }        \* FALSE
      { {1} } \subseteq { 1, 2, 3 }     \* FALSE, model checking error in TLC
                                        \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>&lt;=</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {1, 2} &lt;= {1, 2, 3}
True
&gt;&gt;&gt; {1, 2, 3} &lt;= {1, 2, 3}
True
&gt;&gt;&gt; {1, 2, 3} &lt;= {1, 2}
False
&gt;&gt;&gt; {frozenset({1})} &lt;= {1, 2, 3}
False

</code></pre>
<hr />
<p><a name="union"></a></p>
<h3><a class="header" href="#binary-set-union" id="binary-set-union">Binary set union</a></h3>
<p><strong>Notation:</strong> <code>S \union T</code> or <code>S \cup T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cup.png" alt="cup" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains the elements
of <code>S</code> <strong>as well</strong> as the elements of <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \union { 1, 2, 3 } \* { 0, 1, 2, 3 }
          { } \union { 1, 2, 3 } \* { 1, 2, 3 }
  { 1, 2, 3 } \union { }         \* { 1, 2, 3 }
      { {1} } \union { 1, 2 }    \* { {1}, 1, 2 }, model checking error in TLC
                                 \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>union</code>
that can be written as <code>|</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} | {1, 2, 3}
{0, 1, 2, 3}
&gt;&gt;&gt; set() | {1, 2, 3}
{1, 2, 3}
&gt;&gt;&gt; {1, 2, 3} | set()
{1, 2, 3}
&gt;&gt;&gt; {frozenset({1})} | {1, 2}
{1, frozenset({1}), 2}

</code></pre>
<hr />
<p><a name="intersect"></a></p>
<h3><a class="header" href="#set-intersection" id="set-intersection">Set intersection</a></h3>
<p><strong>Notation:</strong> <code>S \intersect T</code> or <code>S \cap T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/cap.png" alt="cap" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>also</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \intersect { 1, 2, 3 } \* { 1, 2 }
          { } \intersect { 1, 2, 3 } \* { }
  { 1, 2, 3 } \intersect { }         \* { }
      { {1} } \intersect { 1, 2 }    \* { }, model checking error in TLC
                                     \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>intersection</code>, which
can be also written as <code>&amp;</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} &amp; {1, 2, 3}
{1, 2}
&gt;&gt;&gt; set() &amp; {1, 2, 3}
set()
&gt;&gt;&gt; {1, 2, 3} &amp; set()
set()
&gt;&gt;&gt; {frozenset({1})} &amp; {1, 2}
set()

</code></pre>
<hr />
<p><a name="setminus"></a></p>
<h3><a class="header" href="#set-difference" id="set-difference">Set difference</a></h3>
<p><strong>Notation:</strong> <code>S \ T</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/setminus.png" alt="setminus" /></p>
<p><strong>Arguments:</strong> Two arguments.  If both arguments are not sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to the set that contains only those elements
of <code>S</code> that <strong>do not</strong> belong to <code>T</code>, and no other values.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, when it discovers that elements of <code>S</code> cannot be compared
to the elements of <code>T</code>. Apalache produces a static type error, <code>S</code> and <code>T</code> are
either not sets, or sets of incompatible types.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 0, 1, 2 } \ { 1, 2, 3 }     \* { 0 }
          { } \ { 1, 2, 3 }     \* { }
  { 1, 2, 3 } \ { }             \* { 1, 2, 3 }
      { {1} } \ { 1, 2 }        \* { {1} }, model checking error in TLC
                                \* static type error in Apalache
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us <code>difference</code>, which
can be also written as <code>-</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; {0, 1, 2} - {1, 2, 3}
{0}
&gt;&gt;&gt; set() - {1, 2, 3}
set()
&gt;&gt;&gt; {1, 2, 3} - set()
{1, 2, 3}
&gt;&gt;&gt; {frozenset({1})} - {1, 2}
{frozenset({1})}

</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#set-filter" id="set-filter">Set filter</a></h3>
<p><strong>Notation:</strong> <code>{ x \in S: P }</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/filter.png" alt="filter" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name (or a tuple of names, see
<strong>Advanced syntax</strong>), a set, and an expression.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>{ x \in S: P }</code> has the type <code>Set(a)</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator constructs a new set <code>F</code> as follows.  For every
element <code>e</code> of <code>S</code>, do the following (we give a sequence of steps to ease
the understanding):</p>
<ol>
<li>Bind the element <code>e</code> to variable <code>x</code>,</li>
<li>Evaluate the predicate <code>P</code>,</li>
<li>If <code>P</code> evaluates to <code>TRUE</code> under the binding <code>[x |-&gt; e]</code>,
then insert the element of <code>e</code> into set <code>F</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use a tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ &lt;&lt;x, y&gt;&gt; \in S: P }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The filter expression constructs the set of elements (tuples) that make
<code>P</code> evaluate to <code>TRUE</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { x \in {1, 2, 3, 4}: x &gt; 2 }             \* { 3, 4 }
  { x \in {1, 2, 3, 4}: x &gt; 10 }            \* { }
  \* check the section on tuples to understand the following syntax
  { &lt;&lt;x, y&gt;&gt; \in (1..4) \X (1..4): y = 3 }  \* {&lt;&lt;1, 3&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;, &lt;&lt;4, 3&gt;&gt;}
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; { x for x in S if x &gt; 2 }
{3, 4}
&gt;&gt;&gt; { x for x in S if x &gt; 10 }
set()
&gt;&gt;&gt; S2 = {(x, y) for x in S for y in S}
&gt;&gt;&gt; {(x, y) for (x, y) in S2 if y == 3}
{(2, 3), (3, 3), (1, 3), (4, 3)}

</code></pre>
<hr />
<p><a name="map"></a></p>
<h3><a class="header" href="#set-map" id="set-map">Set map</a></h3>
<p><strong>Notation:</strong> <code>{ e: x \in S }</code> or <code>{ e: x \in S, y \in T }</code>, or more arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/map.png" alt="map" /></p>
<p><strong>Arguments:</strong> At least three arguments: a mapping expression,
a variable name (or a tuple of names, see <strong>Advanced syntax</strong>),
a set. Additional arguments are variables names and sets, interleaved.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description for the one-argument case:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>e</code> has the type <code>b</code>, for some type <code>b</code>,</li>
<li>the expression <code>{ e: x \in S }</code> has the type <code>Set(b)</code>.</li>
</ul>
<p><strong>Effect:</strong> We give the semantics for two arguments.
We write it as a sequence of steps to ease understanding.
This operator constructs a new set <code>M</code> as follows.
For every element <code>e_1</code> of <code>S</code> and every element <code>e_2</code> of <code>T</code>:</p>
<ol>
<li>Bind the element <code>e_1</code> to variable <code>x</code>,</li>
<li>Bind the element <code>e_2</code> to variable <code>y</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; e_1, y |-&gt; e_2]</code>,</li>
<li>Insert the value <code>e</code> into the set <code>M</code>.</li>
</ol>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>e</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>{ x + y: &lt;&lt;x, y&gt;&gt; \in S }</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The map expression constructs the set of expressions that are computed
under this binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { 2 * x: x \in { 1, 2, 3, 4 } }          \* { 2, 4, 6, 8 }
  { x + y: x \in 1..2, y \in 1..2 }        \* { 2, 3, 4 }
  \* check the section on tuples to understand the following syntax
  { x + y: &lt;&lt;x, y&gt;&gt; \in (1..2) \X (1..2) } \* { 2, 3, 4 }
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us the set comprehension
syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = frozenset({1, 2, 3, 4})
&gt;&gt;&gt; {2 * x for x in S}
{8, 2, 4, 6}
&gt;&gt;&gt; T = {1, 2}
&gt;&gt;&gt; {x + y for x in T for y in T}
{2, 3, 4}
&gt;&gt;&gt; T2 = {(x, y) for x in T for y in T}
&gt;&gt;&gt; T2
{(1, 1), (1, 2), (2, 1), (2, 2)}
&gt;&gt;&gt; {x + y for (x, y) in T2}
{2, 3, 4}

</code></pre>
<hr />
<p><a name="powerset"></a></p>
<h3><a class="header" href="#powerset" id="powerset">Powerset</a></h3>
<p><strong>Notation:</strong> <code>SUBSET S</code></p>
<p><strong>LaTeX notation:</strong> <code>SUBSET S</code></p>
<p><strong>Arguments:</strong> One argument. If it is not a set, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Set(Set(a))</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator computes the set of all subsets of <code>S</code>.
That is, the set <code>T</code> the has the following properties:</p>
<ul>
<li>If <code>X \in T</code>, then <code>X \subseteq S</code>.</li>
<li>If <code>X \subseteq S</code>, then <code>X \in T</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set.  Apalache
produces a static type error, if the type of <code>S</code> is not a set type.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SUBSET { 0, 1, 2 }
  \* { {}, {0}, {1}, {2}, {0, 1}, {1, 2}, {0, 2}, {0, 1, 2} }
</code></pre>
<p><strong>Example in Python:</strong> An implementation of <code>SUBSET S</code> in Python is not trivial.
To appreciate the power of TLA+, see <a href="lang/./examples/subset.py">subset.py</a>.</p>
<hr />
<p><a name="flatten"></a></p>
<h3><a class="header" href="#set-flattening" id="set-flattening">Set flattening</a></h3>
<p><strong>Notation:</strong> <code>UNION S</code></p>
<p><strong>LaTeX notation:</strong> <code>UNION S</code></p>
<p><strong>Warning:</strong> Do not confuse <code>UNION S</code> with <code>S \union T</code>. These are two
different operators, which unfortunately have similar-looking names.</p>
<p><strong>Arguments:</strong> One argument. If it is not a set of sets, the result
is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(Set(a)) =&gt; Set(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> Given that <code>S</code> is a set of sets, this operator computes the set
<code>T</code> that contains all elements of elements of <code>S</code>:</p>
<ul>
<li>If <code>X \in S</code>, then <code>X \subseteq T</code>.</li>
<li>If <code>y \in T</code>, then there is a set <code>Y \in S</code> that contains <code>y</code>,
that is, <code>y \in Y</code>.</li>
</ul>
<p>In particular, <code>UNION</code> flattens the powerset that is produced by <code>SUBSET</code>. That
is, <code>(UNION (SUBSET S)) = S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set of sets.
Apalache produces a static type error, if the type of <code>S</code> is different from a
set of sets.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  UNION { {0, 1}, {1, 2}, {3} }
  \* { 0, 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong> In contrast to <code>SUBSET S</code>, an implementation of <code>UNION S</code>
in Python is quite simple:</p>
<pre><code class="language-python">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; s = { frozenset({0, 1}), frozenset({1, 2}), frozenset({3}) }
&gt;&gt;&gt; reduce((lambda x, y: x | y), s, set())
{0, 1, 2, 3}

</code></pre>
<hr />
<p><a name="card"></a></p>
<h3><a class="header" href="#set-cardinality" id="set-cardinality">Set cardinality</a></h3>
<p><strong>Notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Cardinality(S)</code></p>
<p><strong>Warning:</strong> <code>Cardinality(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, or <code>S</code> is an infinite set,
the result is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Int</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> <code>Cardinality(S)</code> evaluates to the number of (unique) elements in
<code>S</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set, or when it is an
infinite set.  Apalache produces a static type error, if the type of <code>S</code> is
different from a finite set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  Cardinality({ 1, 2, 3 })
  \* 3
</code></pre>
<p><strong>Example in Python:</strong> In Python, we just use the set size:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = { 1, 2, 3 }
&gt;&gt;&gt; len(S)
3

</code></pre>
<hr />
<p><a name="finite"></a></p>
<h3><a class="header" href="#set-finiteness" id="set-finiteness">Set finiteness</a></h3>
<p><strong>Notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>IsFinite(S)</code></p>
<p><strong>Warning:</strong> <code>IsFinite(S)</code> is defined in the module <code>FiniteSets</code>.</p>
<p><strong>Arguments:</strong> One argument. If <code>S</code> is not a set, the result is undefined.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> <code>IsFinite(S)</code> evaluates to:</p>
<ul>
<li><code>TRUE</code>, when <code>S</code> is a finite set,</li>
<li><code>FALSE</code>, when <code>S</code> is an infinite set.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator argument.  TLC flags a
model checking error, when it discovers that <code>S</code> is not a set. Apalache
produces a static type error, if the type of <code>S</code> is different from a set.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  EXTENDS FiniteSets
  ...
  IsFiniteSet({ 1, 2, 3 })      \* TRUE
  IsFiniteSet(BOOLEAN)          \* TRUE
  IsFiniteSet(Nat)              \* FALSE
  IsFiniteSet(Int)              \* FALSE
  IsFiniteSet(STRING)           \* FALSE
</code></pre>
<p><strong>Example in Python:</strong> We can construct only finite sets in Python.</p>
<h1><a class="header" href="#logic-1" id="logic-1">Logic</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>In this section, you find the operators that, together with <a href="lang/./sets.html">Sets</a>
form the foundation of TLA+. It is a bit strange that we call this section
&quot;Logic&quot;, as the whole language of TLA+ is a logic. However, the operators
of this section are often seen in first-order logic, as opposed to
propositional logic (see <a href="lang/./booleans.html">Booleans</a>).</p>
<p>Note that the special form <code>\E y \in S: x' = y</code> is often used to express
non-determinism in TLA+. See <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>. In this
section, we only consider the deterministic use of the existential quantifier.</p>
<hr />
<p><a name="forallBounded"></a></p>
<h3><a class="header" href="#bounded-universal-quantifier" id="bounded-universal-quantifier">Bounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall-bounded.png" alt="forall-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined. You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>\A x \in S: P</code> has the type <code>Bool</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\A x \in S: P</code> evaluates to <code>TRUE</code>, if for every element <code>e</code> of <code>S</code>, the
expression <code>P</code> evaluates to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\A x \in S: P</code> evaluates to <code>FALSE</code>, if there exists an element
<code>e</code> of <code>S</code> that makes the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\A x \in S: P</code> evaluates to
<code>TRUE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\A x \in S: P</code> evaluates to <code>TRUE</code>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type
of <code>x</code> that is expected in the predicate <code>P</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\A &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\A x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\A x \in S: \A y \in T: P</code>. Similarly, <code>\A x, y \in S: P</code> is syntax sugar for
<code>\A x \in S: \A y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \A x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \A x \in {1, 2, 3, 4}:
    x &gt; 2
  \* FALSE
  \* check the section on tuples to understand the following syntax
  \A &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; all(x &gt; 0 for x in S)
True
&gt;&gt;&gt; all(x &gt; 2 for x in S)
False
&gt;&gt;&gt; T2 = {(x, y) for x in [1, 2] for y in [3, 4]}
&gt;&gt;&gt; all(x &lt; y for (x, y) in T2)
True

</code></pre>
<hr />
<p><a name="existsBounded"></a></p>
<h3><a class="header" href="#bounded-existential-quantifier" id="bounded-existential-quantifier">Bounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists-bounded.png" alt="exists-bounded" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name, a set, and an
expression. As usual in TLA+, if the second argument is not a set, the result is
undefined.You can also use multiple variables and tuples, see <strong>Advanced
syntax</strong>.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>\E x \in S: P</code> has the type <code>Bool</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. We explain
semantics only for a single variable:</p>
<ul>
<li><code>\E x \in S: P</code> evaluates to <code>TRUE</code>, if there is an element <code>e</code> of <code>S</code>
that makes the expression <code>P</code> evaluate to <code>TRUE</code> against the binding
<code>[x |-&gt; e]</code>.</li>
<li>Conversely, <code>\E x \in S: P</code> evaluates to <code>FALSE</code>, if for all elements
<code>e</code> of <code>S</code>, the expression <code>P</code> evaluate to <code>FALSE</code> against the
binding <code>[x |-&gt; e]</code>.</li>
</ul>
<p><em>Importantly, when <code>S = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to
<code>FALSE</code>, independently of what is written in <code>P</code>. Likewise, when <code>{x \in S: P} = {}</code>, the expression <code>\E x \ in S: P</code> evaluates to <code>FALSE</code>.</em></p>
<p>As you probably have noticed, <code>\E x \in S: P</code> is equivalent to <code>~(\A x \in S: ~P)</code>, and <code>\A x \in S: P</code> is equivalent to <code>~(\E x \in S: ~P)</code>. This is called
<em>duality</em> in logic. But take care!  If <code>\E x \in S: P</code> may act as a
non-deterministic assignment, duality does not work anymore!  See <a href="lang/./control-and-nondeterminism.html">Control
Flow and Non-determinism</a>.</p>
<p><strong>Determinism:</strong> Deterministic when <code>P</code> contains no action operators (including
the prime operator <code>'</code>).  For the non-deterministic case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and
Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible in the context of <code>P</code>
when an element of <code>S</code> is bound to <code>x</code>.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, you can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>\E &lt;&lt;x, y&gt;&gt; \in S: P</code>. In this case, for every
element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound to
<code>e[2]</code>. The predicate <code>P</code> is evaluated against this binding.</p>
<p>Moreover, instead of introducing one variable, one can quantify over several
sets. For instance, you can write: <code>\E x \in S, y \in T: P</code>. This form is
simply syntax sugar for the form with nested quantifiers: <code>\E x \in S: \E y \in T: P</code>. Similarly, <code>\E x, y \in S: P</code> is syntax sugar for <code>\E x \in S: \E y \in S: P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  \E x \in {1, 2, 3, 4}:
    x &gt; 0
  \* TRUE
  \E x \in {1, 2, 3, 4}:
    x &gt; 2
  \* TRUE
  \* check the section on tuples to understand the following syntax
  \E &lt;&lt;x, y&gt;&gt; \in { 1, 2 } \X { 3, 4 }:
    x &lt; y
  \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python conveniently offers us a concise syntax:</p>
<pre><code class="language-python">&gt;&gt;&gt; S = {1, 2, 3, 4}
&gt;&gt;&gt; any(x &gt; 0 for x in S)
True
&gt;&gt;&gt; any(x &gt; 2 for x in S)
True
&gt;&gt;&gt; T2 = {(x, y) for x in [1, 2] for y in [3, 4]}
&gt;&gt;&gt; any(x &lt; y for (x, y) in T2)
True

</code></pre>
<hr />
<p><a name="eq"></a></p>
<h3><a class="header" href="#equality" id="equality">Equality</a></h3>
<p><em>A foundational operator in TLA+</em></p>
<p><strong>Notation:</strong> <code>e_1 = e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/eq.png" alt="eq" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Apalache type:</strong> <code>(a, a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It tests the values
of <code>e_1</code> and <code>e_2</code> for structural equality. The exact effect depends on the
values of <code>e_1</code> and <code>e_2</code>. Let <code>e_1</code> and <code>e_2</code> evaluate to the values
<code>v_1</code> and <code>v_2</code>. Then <code>e_1 = e_2</code> evaluates to:</p>
<ul>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are Booleans, then <code>e_1 = e_2</code> evaluates to <code>v_1 &lt;=&gt; v_2</code>.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are integers, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same integers.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are strings, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if <code>v_1</code> and <code>v_2</code> are exactly the same strings.</p>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are sets, then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">v_1 \subseteq v_2 /\ v_2 \subseteq v_1
</code></pre>
</li>
<li>
<p>If <code>v_1</code> and <code>v_2</code> are functions, tuples, records, or sequences,
then <code>e_1 = e_2</code> evaluates to <code>TRUE</code>
if and only if the following expression evaluates to <code>TRUE</code>:</p>
<pre><code class="language-tla">  DOMAIN v_1 = DOMAIN v_2 /\ \A x \in DOMAIN v_1: v_1[x] = v_2[x]
</code></pre>
</li>
<li>
<p>In other cases, <code>e_1 = e_2</code> evaluates to <code>FALSE</code> if the values have comparable types.</p>
</li>
<li>
<p>TLC and Apalache report an error, if the values have incomparable types.</p>
</li>
</ul>
<p><strong>Determinism:</strong> Deterministic, unless <code>e_1</code> has the form <code>x'</code>, which can be
interpreted as an assignment to the variable <code>x'</code>.  For the non-deterministic
case, see <a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments. TLC flags a
model checking error, if <code>e_1</code> and <code>e_2</code> evaluate to incomparable values.
Apalache produces a static type error, if the types of <code>e_1</code> and <code>e_2</code> do not
match.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  FALSE = FALSE         \* TRUE
  FALSE = TRUE          \* FALSE
  10 = 20               \* FALSE
  15 = 15               \* TRUE
  &quot;Hello&quot; = &quot;world&quot;     \* FALSE
  &quot;Hello&quot; = &quot;hello&quot;     \* FALSE
  &quot;Bob&quot; = &quot;Bob&quot;         \* TRUE
  { 1, 2 } = { 2, 3}    \* FALSE
  { 1, 2 } = { 2, 1}    \* TRUE
  { 1 } \ { 1 } = { &quot;a&quot; } \ { &quot;a&quot; } \* TRUE in pure TLA+ and TLC,
                                    \* type error in Apalache
  { { 1, 2 } } = { { 1, 2, 2, 2 } } \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;a&quot;&gt;&gt;           \* TRUE
  &lt;&lt;1, &quot;a&quot;&gt;&gt; = &lt;&lt;1, &quot;b&quot;&gt;&gt;           \* FALSE
  &lt;&lt;1, FALSE&gt;&gt; = &lt;&lt;2&gt;&gt;              \* FALSE in pure TLA+ and TLC,
                                    \* type error in Apalache
  &lt;&lt;1, 2&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;            \* FALSE in pure TLA+ and TLC,
                                    \* FALSE in Apalache, when both values
                                    \* are treated as sequences
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1, b |-&gt; 3 ]           \* TRUE
  [ a |-&gt; 1, b |-&gt; 3 ] = [ a |-&gt; 1 ]                    \* FALSE
  [ x \in 2..2 |-&gt; x + x ] = [ x \in {2} |-&gt; 2 * x ]    \* TRUE
  [ x \in 2..3 |-&gt; x + x ] = [ x \in {2, 3} |-&gt; 2 * x ] \* TRUE
</code></pre>
<p><strong>Example in Python:</strong> The standard data structures also implement
structural equality in Python, though we have to be careful to
use <code>==</code> instead of <code>=</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; False == False
True
&gt;&gt;&gt; False == True
False
&gt;&gt;&gt; 10 == 20
False
&gt;&gt;&gt; 15 == 15
True
&gt;&gt;&gt; &quot;Hello&quot; == &quot;world&quot;
False
&gt;&gt;&gt; &quot;Hello&quot; == &quot;hello&quot;
False
&gt;&gt;&gt; &quot;Bob&quot; == &quot;Bob&quot;
True
&gt;&gt;&gt; { 1, 2 } == { 2, 3 }
False
&gt;&gt;&gt; { 1, 2 } == { 2, 1 }
True
&gt;&gt;&gt; { 1 } - { 1 } == { &quot;a&quot; } - { &quot;a&quot; }
True
&gt;&gt;&gt; { frozenset({ 1, 2 }) } == { frozenset({ 1, 2, 2, 2 }) }
True
&gt;&gt;&gt; (1, &quot;a&quot;) == (1, &quot;a&quot;)
True
&gt;&gt;&gt; (1, &quot;a&quot;) == (1, &quot;b&quot;)
False
&gt;&gt;&gt; (1, False) == (2, )
False
&gt;&gt;&gt; (1, 2) == (1, 2, 3)
False
&gt;&gt;&gt; { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1, &quot;b&quot;: 3 }
True
&gt;&gt;&gt; { &quot;a&quot;: 1, &quot;b&quot;: 3 } == { &quot;a&quot;: 1 }
False
&gt;&gt;&gt; { x: (x + x) for x in { 2 } } == { x: (x * x) for x in { 2 } }
True
&gt;&gt;&gt; { x: (x + x) for x in { 2, 3 } } == { x: 2 * x for x in { 2, 3 } }
True

</code></pre>
<hr />
<p><a name="neq"></a></p>
<h3><a class="header" href="#inequality" id="inequality">Inequality</a></h3>
<p><strong>Notation:</strong> <code>e_1 /= e_2</code> or <code>e_1 # e_2</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/ne.png" alt="ne" /></p>
<p><strong>Arguments:</strong> Two arguments.</p>
<p><strong>Apalache type:</strong> <code>(a, a) =&gt; Bool</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> This operator is syntax sugar for <code>~(e_1 = e_2)</code>. Full stop.</p>
<hr />
<p><a name="chooseBounded"></a></p>
<h3><a class="header" href="#bounded-choice" id="bounded-choice">Bounded Choice</a></h3>
<p><em>This operator causes a lot of confusion. Read carefully!</em></p>
<p><strong>Notation:</strong> <code>CHOOSE x \in S: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/choose-bounded.png" alt="choose-bounded" /></p>
<p><strong>Arguments:</strong> Three arguments: a variable name, a set, and an
expression.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>P</code> has the type <code>Bool</code>,</li>
<li>the expression <code>CHOOSE x \in S: P</code> has the type <code>a</code>.</li>
</ul>
<p><strong>Effect:</strong> This operator implements a black-box algorithm that <em>somehow</em> picks
one element from the set <code>{x \in S: P}</code>.  Is it an algorithm? Yes! <code>CHOOSE x \in S: P</code> is deterministic.  When you give it two equal sets and two equivalent
predicates, <code>CHOOSE</code> produces the same value. Formally, the only known property
of <code>CHOOSE</code> is as follows (which is slightly more general than what we wrote
above):</p>
<pre><code class="language-tla">  {x \in S: P} = {y \in T: Q} =&gt;
      (CHOOSE x \in S: P) = (CHOOSE y \in T: Q)
</code></pre>
<p>Importantly, when <code>{x \in S: P} = {}</code>, the expression <code>CHOOSE x \ in S: P</code>
evaluates to an undefined value.</p>
<p>How does <code>CHOOSE</code> actually work? TLA+ does not fix an algorithm for <code>CHOOSE</code> by
design. Maybe it returns the first element of the set? Sets are not ordered, so
there is no first element.</p>
<p>Why should you use <code>CHOOSE</code>? Actually, you should not. Unless you have no other
choice üéÄ</p>
<p>There are two common use cases, where the use of <code>CHOOSE</code> is well justified:</p>
<ul>
<li>
<p><em>Use case 1:</em> Retrieving the only element of a singleton set. If you know
that <code>Cardinality({x \in S: P}) = 1</code>, then <code>CHOOSE x \in S: P</code> returns
the only element of <code>{x \in S: P}</code>. No magic.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L63-L64">Min and Max in FiniteSetsExt</a>.</p>
</li>
<li>
<p><em>Use case 2:</em> Enumerating set elements in a fixed but unknown order.
For instance, see: <a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/FiniteSetsExt.tla#L5-L17">ReduceSet in FiniteSetsExt</a>.</p>
</li>
</ul>
<p>In other cases, we believe that <code>CHOOSE</code> is bound to do <a href="https://en.wikipedia.org/wiki/Program_synthesis">Program synthesis</a>.
So TLC does some form of synthesis by brute force when it has to evaluate
<code>CHOOSE</code>.</p>
<p><strong>Determinism:</strong> Deterministic. Very much deterministic. Don't try to model
non-determinism with <code>CHOOSE</code>. For non-determinism, see:
<a href="lang/./control-and-nondeterminism.html">Control Flow and Non-determinism</a>.</p>
<p>Apalache picks a set element that satisfies the predicate <code>P</code>, but it does not
guarantee the repeatability property of CHOOSE. It does not guarantee
non-determinism either. Interestingly, this behavior does not really make a
difference for the use cases 1 and 2. If you believe that this causes a problem
in your specification, <a href="https://github.com/informalsystems/apalache/issues/new/choose">open an issue...</a></p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the operator arguments.  TLC flags a
model checking error, if <code>S</code> is infinite.  Apalache produces a static type
error, if the type of elements of <code>S</code> is not compatible with the type of <code>x</code>
as expected in <code>P</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  CHOOSE x \in 1..3: x &gt;= 3
  \* 3
  CHOOSE x \in 1..3:
    \A y \in 1..3: y &gt;= x
  \* 1, the minimum
  CHOOSE f \in [ 1..10 -&gt; BOOLEAN ]:
    \E x, y \in DOMAIN f:
      f[x] /\ ~f[y]
  \* some Boolean function from 1..10 that covers FALSE and TRUE
</code></pre>
<p><strong>Example in Python:</strong> Python does not have anything similar to <code>CHOOSE</code>.
The closest possible solution is to sort the filtered set by the string values
and pick the first one (or the last one). So we have introduced a particular
way of implementing CHOOSE, see <a href="lang/./examples/choose.py">choose.py</a>:</p>
<pre><code class="language-python"># A fixed implementation of CHOOSE x \in S: TRUE
# that sorts the set by the string representation and picks the head
def choose(s):
    lst = sorted([(str(e), e) for e in s], key=(lambda pair: pair[0]))
    (_, e) = lst[0]
    return e


if __name__ == &quot;__main__&quot;:
    s = { 1, 2, 3}
    print(&quot;CHOOSE {} = {}&quot;.format(s, choose(s)))
    s2 = { frozenset({1}), frozenset({2}), frozenset({3})}
    print(&quot;CHOOSE {} = {}&quot;.format(s2, choose(s2)))
</code></pre>
<hr />
<p><a name="forall"></a></p>
<h3><a class="header" href="#unbounded-universal-quantifier" id="unbounded-universal-quantifier">Unbounded universal quantifier</a></h3>
<p><strong>Notation:</strong> <code>\A x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/forall.png" alt="forall" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when every element in the logical universe makes the expression <code>P</code> evaluate to
<code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to consider
only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="exists"></a></p>
<h3><a class="header" href="#unbounded-existential-quantifier" id="unbounded-existential-quantifier">Unbounded existential quantifier</a></h3>
<p><strong>Notation:</strong> <code>\E x: P</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/exists.png" alt="exists" /></p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to a Boolean value. It evaluates to <code>TRUE</code>,
when at least one element in the logical universe makes the expression <code>P</code>
evaluate to <code>TRUE</code> against the binding <code>[x |-&gt; e]</code>. More precisely, we have to
consider only the elements that produced a defined result when evaluating <code>P</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe. It requires a first-order logic solver. This operator may be useful
when writing proofs with <a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a>.</p>
<hr />
<p><a name="choose"></a></p>
<h3><a class="header" href="#unbounded-choose" id="unbounded-choose">Unbounded CHOOSE</a></h3>
<p><strong>Notation:</strong> <code>CHOOSE x: P</code></p>
<p><strong>LaTeX notation:</strong> CHOOSE x: P</p>
<p><strong>Arguments:</strong> At least two arguments: a variable name and an
expression.</p>
<p><strong>Effect:</strong> This operator evaluates to some value <code>v</code> in the logical universe
that evaluates <code>P</code> to <code>TRUE</code> against the binding <code>[x |-&gt; v]</code>.</p>
<p>Neither TLC, nor Apalache support this operator. It is impossible to give
operational semantics for this operator, unless we explicitly introduce the
universe and introduce a fixed rule for enumerating its elements.</p>
<p>Congratulations! You have reached the bottom of this page. If you want to learn
more about unbounded <code>CHOOSE</code>, read Section 16.1.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<h1><a class="header" href="#functions-1" id="functions-1">Functions</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p><strong>Contributors:</strong> @konnov, @shonfeder, @Kukovec, @Alexander-N</p>
<p>Functions are probably the second most used TLA+ data structure after sets. TLA+
functions are not like functions in programming languages. In programming
languages, functions contain code that calls other functions. Although it is
technically possible to use functions when constructing a function in TLA+,
functions are more often used like tables or dictionaries: they are simple maps from a set of inputs to a set of outputs. For instance, in
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/transaction_commit/TwoPhase.tla">Two-phase commit</a>, the function <code>rmState</code> stores the transaction state for
each process:</p>
<table><thead><tr><th>argument</th><th>rmState[argument]</th></tr></thead><tbody>
<tr><td>&quot;process1&quot;</td><td>&quot;working&quot;</td></tr>
<tr><td>&quot;process2&quot;</td><td>&quot;aborted&quot;</td></tr>
<tr><td>&quot;process3&quot;</td><td>&quot;prepared&quot;</td></tr>
</tbody></table>
<p>In the above table, the first column is the value of the function argument,
while the second column is the function result. An important property of this
table is that no value appears in the first column more than once, so
<em>every argument value is assigned at most one result value</em>.</p>
<p>Importantly, every function is defined in terms of the set of arguments over which it is
defined. This set is called the function's <em>domain</em>.  There is even a special
operator <code>DOMAIN f</code>, which returns the domain of a function <code>f</code>.</p>
<p>In contrast to TLA+ operators, <em>TLA+ functions are proper values</em>, so they can be
used as values in more complex data structures.</p>
<p><strong>Construction.</strong> Typically, the predicate <code>Init</code> constructs a function that
maps all elements of its domain to a default value.
In the example below we map the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code>
to the value &quot;working&quot;:</p>
<pre><code class="language-tla">Init ==
  rmState = [ p \in { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } |-&gt; &quot;working&quot; ]
</code></pre>
<p>In general, we can construct a function by giving an expression that shows us
how to map every argument to the result:</p>
<pre><code class="language-tla">  [ fahrenheit \in Int |-&gt; (fahrenheit - 32) * 5 \div 9 ]
</code></pre>
<p>Note that this function effectively defines an infinite table, as the set <code>Int</code>
is infinite. Both TLC and Apalache would give up on a function with an infinite
domain. (Though in the above example, it is obvious that we could treat the
function symbolically, without enumerating all of its elements.)</p>
<p>Another way to construct a function is to <em>non-deterministically</em> pick one
from a set of functions by using the <a href="lang/functions.html#funSetCtor">function set constructor</a>, <code>-&gt;</code>. E.g.:</p>
<pre><code class="language-tla">Init ==
    \E f \in [ { &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; } -&gt;
                    { &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; } ]:
        rmState = f
</code></pre>
<p>In the above example we are not talking about one function that is somehow
initialized &quot;by default&quot;. Rather, we say that <code>rmState</code> can be set to an
arbitrary function that receives arguments from the set <code>{ &quot;process1&quot;, &quot;process2&quot;, &quot;process3&quot; }</code> and returns values that belong to the set <code>{ &quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot; }</code>. As a result, TLC has to
enumerate all possible functions that match this constraint. On the contrary,
Apalache introduces one instance of a function and restricts it with the
symbolic constraints. So it efficiently considers all possible functions
without enumerating them. However, this trick only works with existential
quantifiers. If you use a universal quantifier over a set of functions,
both TLC and Apalache unfold this set.</p>
<p><strong>Immutability</strong>. As you can see, TLA+ functions are similar to <a href="https://docs.python.org/3/library/stdtypes.html#dict">dictionaries
in Python</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">maps in
Java</a> rather than
to normal functions in programming languages. However, <em>TLA+ functions are
immutable</em>. Hence, they are even closer to immutable maps in Scala.  As in the
case of sets, you do not need to define hash or equality, in order to use
functions.</p>
<p>If you want to update a function, you have to produce another function and
describe how it is different from the original function. Luckily, TLA+ provides
you with operators for describing these updates in a compact way: By using the
function constructor (above) along with <code>EXCEPT</code>. For instance, to produce a
new function from <code>rmState</code>, we write the following:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process3&quot;] = &quot;committed&quot; ]
</code></pre>
<p>This new function is like <code>rmState</code>, except that it returns <code>&quot;committed&quot;</code>
on the argument <code>&quot;process3&quot;</code>:</p>
<pre><code class="language-tla">&quot;process1&quot;,  &quot;working&quot;
&quot;process2&quot;,  &quot;aborted&quot;
&quot;process3&quot;,  &quot;committed&quot;
</code></pre>
<p><em>Importantly, you cannot extend the function domain by using <code>EXCEPT</code>.</em>
For instance, the following expression produces the function that is
equivalent to <code>rmState</code>:</p>
<pre><code class="language-tla">  [ rmState EXCEPT ![&quot;process10&quot;] = &quot;working&quot; ]
</code></pre>
<p><strong>Types.</strong> In pure TLA+, functions are free to mix values of different types in their domains.
See the example below:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
        IF x \in { 1, &quot;TRUE&quot;, TRUE}
        THEN TRUE
        ELSE FALSE
  ]
</code></pre>
<p>TLA+ functions are also free to return any kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 0, &quot;FALSE&quot;, FALSE, 1, &quot;TRUE&quot;, TRUE } |-&gt;
    CASE x = 0 -&gt; 1
      [] x = 1 -&gt; 0
      [] x = &quot;FALSE&quot; -&gt; &quot;TRUE&quot;
      [] x = &quot;TRUE&quot; -&gt; &quot;FALSE&quot;
      [] x = FALSE -&gt; TRUE
      OTHER -&gt; FALSE
  ]
</code></pre>
<p>As in the case of <a href="lang/./sets.html">sets</a>, TLC restricts function domains to comparable
values. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>. So, TLC rejects the two
examples that are given above.</p>
<p>However, functions in TLC are free to return different kinds of values:</p>
<pre><code class="language-tla">  [ x \in { 1, 2 } |-&gt;
                        IF x = 1 THEN FALSE ELSE 3 ]
</code></pre>
<p>This is why, in pure TLA+ and TLC, records, tuples, and sequences are just
functions over particular domains (finite sets of strings and finite sets
of integers).</p>
<p>Apalache enforces stricter types. It has designated types for all four
data structures: general functions, records, tuples, and sequences.
Moreover, all elements of the function domain must have the same type.
The same is true for the codomain. That is, general functions have the
type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>. This is enforced
by the type checker.</p>
<p>In this sense, the type restrictions of Apalache are similar to those for the
generic collections of Java and Scala.  As a result, the type checker in
Apalache rejects the three above examples.</p>
<p><strong>TLA+ functions and Python dictionaries</strong>. As we mentioned before, TLA+
functions are similar to maps and dictionaries in programming languages. To
demonstrate this similarity, let us compare TLA+ functions with <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">Python
dictionaries</a>.  Consider a TLA+ function <code>price</code> that is defined as follows:</p>
<pre><code class="language-tla">  [ meal \in { &quot;Schnitzel&quot;, &quot;Gulash&quot;, &quot;Cordon bleu&quot; } |-&gt;
                CASE meal = &quot;Schnitzel&quot;     -&gt; 18
                  [] meal = &quot;Gulash&quot;        -&gt; 11
                  [] meal = &quot;Cordon bleu&quot;   -&gt; 12
  ]
</code></pre>
<p>If we had to define a similar dictionary in Python, we would normally introduce
a Python dictionary like follows:</p>
<pre><code class="language-python">py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
</code></pre>
<p>As long as we are using the variable <code>py_price</code> to access the dictionary, our
approach works. For instance, we can type the following in the python shell:</p>
<pre><code class="language-python"># similar to DOMAIN price in TLA+
py_price.keys()
</code></pre>
<p>In the above example, we used <code>py_price.keys()</code>, which produces a view of the
mutable dictionary's keys. In TLA+, <code>DOMAIN</code> returns a set. If we want to
faithfully model the effect of <code>DOMAIN</code>, then we have to produce an immutable
set. We use
<a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><code>frozenset</code></a>,
which is a less famous cousin of the python <code>set</code>. A frozen set can be
inserted into another set, in contrast to the standard (mutable) set.</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; frozenset(py_price.keys()) == frozenset({'Schnitzel', 'Gulash', 'Cordon bleu'})
True

</code></pre>
<p>We can also apply our python dictionary similar to the TLA+ function <code>price</code>:</p>
<pre><code class="language-tla">&gt;&gt;&gt; # similar to price[&quot;Schnitzel&quot;] in TLA+
&gt;&gt;&gt; py_price[&quot;Schnitzel&quot;]
18

</code></pre>
<p>However, there is a catch! What if you like to put the function <code>price</code> in a
set? In TLA+, this is easy: Simply construct the singleton set that contains
the function <code>price</code>.</p>
<pre><code class="language-tla"># TLA+: wrapping a function with a set
{ price }
</code></pre>
<p>Unfortunately, this does not work as easy in Python:</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; # python expects hashable and immutable data structures inside sets
&gt;&gt;&gt; frozenset({py_price})
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'

</code></pre>
<p>Of course, this is an implementation detail of Python and it has nothing to do
with TLA+. This example probably demonstrates that the built-in primitives of
TLA+ are more powerful than the standard primitives of many programming
languages (see <a href="https://github.com/informalsystems/apalache/discussions/551">this
discussion</a>).</p>
<p>Alternatively, we could represent a TLA+ function in Python as a set
of pairs <code>(key, value)</code> and implement TLA+ function operators over such a
set. Surely, this implementation would be inefficient, but this is not
an issue for a <em>specification language</em> such as TLA+. For instance:</p>
<pre><code class="language-python">&gt;&gt;&gt; py_price = { &quot;Schnitzel&quot;: 18, &quot;Gulash&quot;: 11, &quot;Cordon bleu&quot;: 12 }
&gt;&gt;&gt; { tuple(py_price.items()) }
{(('Schnitzel', 18), ('Gulash', 11), ('Cordon bleu', 12))}

</code></pre>
<p>If we try to implement TLA+-like operators over this data structure, things
will get complicated very quickly. For this reason, we are just using
mutable dictionaries in the Python examples in the rest of this text.</p>
<hr />
<h2><a class="header" href="#operators-3" id="operators-3">Operators</a></h2>
<hr />
<p><a name="funCtor"></a></p>
<h3><a class="header" href="#function-constructor" id="function-constructor">Function constructor</a></h3>
<p><strong>Notation:</strong> <code>[ x \in S |-&gt; e ]</code> or <code>[ x \in S, y \in T |-&gt; e ]</code>, or more
arguments</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/fun-ctor.png" alt="fun-ctor" /></p>
<p><strong>Arguments:</strong> At least three arguments: a variable name (or a tuple of names,
see <strong>Advanced syntax</strong>), a set, and a mapping expression. Instead of one
variable and one set, you can use multiple variables and multiple sets.</p>
<p><strong>Apalache type:</strong> The formal type of this operator is a bit complex.
Hence, we give an informal description:</p>
<ul>
<li><code>x</code> has the type <code>a</code>, for some type <code>a</code>,</li>
<li><code>S</code> has the type <code>Set(a)</code>,</li>
<li><code>e</code> has the type <code>b</code>, for some type <code>b</code>,</li>
<li>the expression <code>[ x \in S |-&gt; e ]</code> has the type <code>a -&gt; b</code>.</li>
</ul>
<p><strong>Effect:</strong> We give the semantics for one argument.  We write a sequence of
steps to ease the understanding.  This operator constructs a function <code>f</code> over
the domain <code>S</code> as follows.  For every element <code>elem</code> of <code>S</code>, do the following:</p>
<ol>
<li>Bind the element <code>elem</code> to variable <code>x</code>,</li>
<li>Compute the value of <code>e</code> under the binding <code>[x |-&gt; elem]</code> and store it
in a temporary variable called <code>result</code>.</li>
<li>Set <code>f[elem]</code> to <code>result</code>.</li>
</ol>
<p>Of course, the semantics of the function constructor in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>
does not require us to compute the function at all. We believe that
our description helps you to see that there is a way to compute this data
structure, though in a very straightforward and inefficient way.</p>
<p>If the function constructor introduces multiple variables, then the constructed
function maps a tuple to a value. See <strong>Example</strong>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> Pure TLA+ does not restrict the function domain and the mapping
expression. They can be any
combination of TLA+ values: Booleans, integers, strings, sets, functions, etc.</p>
<p>TLC accepts function domains of comparable values. For
instance, two integers are comparable, but an integer and a set are not
comparable. See Section 14.7.2 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p>Apalache goes further: It requires the function domain to be well-typed (as a
set), and it requires the mapping expression <code>e</code> to be well-typed. If this
is not the case, the type checker flags an error.</p>
<p><strong>Advanced syntax:</strong> Instead of a single variable <code>x</code>, one can use the tuple
syntax to unpack variables from a Cartesian product, see <a href="lang/./tuples.html">Tuples</a>.
For instance, one can write <code>[ &lt;&lt;x, y&gt;&gt; \in S |-&gt; x + y ]</code>. In this case, for
every element <code>e</code> of <code>S</code>, the variable <code>x</code> is bound to <code>e[1]</code> and <code>y</code> is bound
to <code>e[2]</code>. The function constructor maps the tuples from <code>S</code> to the values
that are computed under such a binding.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ x \in 1..3 |-&gt; 2 * x ]  \* a function that maps 1, 2, 3 to 2, 4, 6
  [ x, y \in 1..3 |-&gt; x * y ]
    \* a function that maps &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;, ..., &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
    \* to 1, 2, 3, ..., 6, 9
  [ &lt;&lt;x, y&gt;&gt; \in (1..3) \X (4..6) |-&gt; x + y ]
    \* a function that maps &lt;&lt;1, 4&gt;&gt;, &lt;&lt;1, 5&gt;&gt;, &lt;&lt;1, 6&gt;&gt;, ..., &lt;&lt;2, 6&gt;&gt;, &lt;&lt;3, 6&gt;&gt;
    \* to 5, 6, 7, ..., 8, 9
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]]
    \* a function that maps a number n from 1 to 3
    \* to a function from 1..n to n + i. Like an array of arrays.
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: [ x \in 1..3 |-&gt; 2 * x ]
&gt;&gt;&gt; {x: 2 * x for x in range(1, 4)}
{1: 2, 2: 4, 3: 6}
&gt;&gt;&gt; # TLA: [ x, y \in 1..3 |-&gt; x * y ]
&gt;&gt;&gt; {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}
{(1, 1): 1, (1, 2): 2, (1, 3): 3, (2, 1): 2, (2, 2): 4, (2, 3): 6, (3, 1): 3, (3, 2): 6, (3, 3): 9}
&gt;&gt;&gt; # TLA: [ &lt;&lt;x, y&gt;&gt; \in (1..3) \X (4..6) |-&gt; x + y ]
&gt;&gt;&gt; xy = {(x, y) for x in range(1, 4) for y in range(4, 7)}
&gt;&gt;&gt; {(x, y): x + y for (x, y) in xy}
{(2, 4): 6, (3, 4): 7, (1, 5): 6, (1, 4): 5, (2, 6): 8, (3, 6): 9, (1, 6): 7, (2, 5): 7, (3, 5): 8}
&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt;
&gt;&gt;&gt; #        [ i \in 1..n |-&gt; n + i ]]
&gt;&gt;&gt; {
...     n: {i: n + i for i in range(1, n + 1)}
...     for n in range(1, 4)
... }
{1: {1: 2}, 2: {1: 3, 2: 4}, 3: {1: 4, 2: 5, 3: 6}}

</code></pre>
<hr />
<p><a name="funSetCtor"></a></p>
<h3><a class="header" href="#function-set-constructor" id="function-set-constructor">Function set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ S -&gt; T ]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/funset.png" alt="funset" /></p>
<p><strong>Arguments:</strong> Two arguments. Both have to be sets. Otherwise, the result is
undefined.</p>
<p><strong>Apalache type:</strong> <code>(Set(a), Set(b)) =&gt; Set(a -&gt; b)</code>, for some types <code>a</code> and <code>b</code>.</p>
<p><strong>Effect:</strong> This operator constructs the set of all possible functions that
have <code>S</code> as their domain, and for each argument <code>x \in S</code> return a value <code>y \in T</code>.</p>
<p>Note that if one of the sets is infinite, then the set <code>[S -&gt; T]</code> is infinite
too. TLC flags an error, if <code>S</code> or <code>T</code> are infinite. Apalache flags an error,
if <code>S</code> is infinite, but when it does not have to explicitly construct <code>[S -&gt; T]</code>, it may accept infinite <code>T</code>. For instance:</p>
<pre><code class="language-tla">  \E f \in [ 1..3 -&gt; 4..6]:
    ...
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, if <code>S</code> and <code>T</code> are not sets, then <code>[S -&gt; T]</code>
is undefined. If either <code>S</code> or <code>T</code> is not a set, TLC flags a model checking error.
Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ 1..3 -&gt; 1..100 ]
    \* the set of functions that map 1, 2, 3 to values from 1 to 100
  [ Int -&gt; BOOLEAN ]
    \* The infinite set of functions that map every integer to a Boolean.
    \* Error in TLC.
</code></pre>
<p><strong>Example in Python:</strong> We do not give here the code that enumerates all
functions. It should be similar in spirit to <a href="lang/./examples/subset.py">subset.py</a>,
but it should enumerate strings over the alphabet of <code>0..(Cardinality(T) - 1)</code>
values, rather than over the alphabet of 2 values.</p>
<p><a name="funApp"></a></p>
<h3><a class="header" href="#function-application" id="function-application">Function application</a></h3>
<p><strong>Notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>f[e]</code> or <code>f[e_1, ..., e_n]</code></p>
<p><strong>Arguments:</strong> At least two arguments. The first one should be a function,
the other arguments are the arguments to the function. Several arguments
are treated as a tuple. For instance, <code>f[e_1, ..., e_n]</code> is shorthand for
<code>f[&lt;&lt;e_1, ..., e_n&gt;&gt;]</code>.</p>
<p><strong>Apalache type:</strong> In the single-index case, the type is
<code>((a -&gt; b), a) =&gt; b</code>, for some types <code>a</code> and <code>b</code>. In the multi-index case,
the type is <code>((&lt;&lt;a_1, ..., a_n&gt;&gt; -&gt; b), a_1, ..., a_n) =&gt; b</code>.</p>
<p><strong>Effect:</strong> This operator is evaluated as follows:</p>
<ul>
<li>If <code>e \in DOMAIN f</code>, then <code>f[e]</code> evaluates to the value that function
<code>f</code> associates with the value of <code>e</code>.</li>
<li>If <code>e \notin DOMAIN f</code>, then the value is undefined.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>e \notin DOMAIN f</code>, TLC flags a model checking error.</p>
<p>When <code>e</code> has a type incompatible with the type of <code>DOMAIN f</code>, Apalache flags
a type error. When <code>e \notin DOMAIN f</code>, Apalache assigns some type-compatible
value to <code>f[e]</code>, but does not report any error. This is not a bug in Apalache,
but a feature of the SMT encoding. Usually, an illegal access surfaces
somewhere, when checking a specification.  If you want to detect an access
outside of the function domain, instrument your code with an additional state
variable.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [x \in 1..10 |-&gt; x * x][5]                \* 25
  [x \in 1..3, y \in 1..3 |-&gt; x * y][2, 2]
    \* Result = 4. Accessing a two-dimensional matrix by a pair
  [ n \in 1..3 |-&gt;
      [ i \in 1..n |-&gt; n + i ]][3][2]
    \* The first access returns a function, the second access returns 5.
  [x \in 1..10 |-&gt; x * x][100]              \* model checking error in TLC,
                                            \* Apalache produces some value
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: [x \in 1..10 |-&gt; x * x][5]
&gt;&gt;&gt; {x: x * x for x in range(1, 11)}[5]
25
&gt;&gt;&gt; # TLA: [x, y \in 1..3 |-&gt; x * y][2, 2]
&gt;&gt;&gt; {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}[(2, 2)]
4
&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]][3][2]
&gt;&gt;&gt; {n: {i: n + i for i in range(1, n + 1)} for n in range(1, 4)}[3][2]
5

</code></pre>
<hr />
<p><a name="except"></a></p>
<h3><a class="header" href="#function-replacement" id="function-replacement">Function replacement</a></h3>
<p><strong>Notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>LaTeX notation:</strong> <code>[f EXCEPT ![a_1] = e_1, ..., ![a_n] = e_n]</code></p>
<p><strong>Arguments:</strong> At least three arguments. The first one should be a function,
the other arguments are interleaved pairs of argument expressions and value
expressions.</p>
<p><strong>Apalache type:</strong> In the case of a single-point update, the type is simple:
<code>(a -&gt; b, a, b) =&gt; (a -&gt; b)</code>, for some types <code>a</code> and <code>b</code>. In the general case,
the type is: <code>(a -&gt; b, a, b, ..., a, b) =&gt; (a -&gt; b)</code>.</p>
<p><strong>Effect:</strong> This operator evaluates to a new function <code>g</code> that is constructed
as follows:</p>
<ul>
<li>Set the domain of <code>g</code> to <code>DOMAIN f</code>.</li>
<li>For every element <code>b \in DOMAIN f</code>, do:
<ul>
<li>If <code>b = a_i</code> for some <code>i \in 1..n</code>, then set <code>g[b]</code> to <code>e_i</code>.</li>
<li>If <code>b \notin { a_1, ..., a_n }</code>, then set <code>g[b]</code> to <code>f[b]</code>.</li>
</ul>
</li>
</ul>
<p><em>Importantly, <code>g</code> is a new function: the function <code>f</code> is not modified!</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> When <code>a_i \notin DOMAIN f</code> for some <code>i \in 1..n</code>,
TLC flags a model checking error.</p>
<p>When <code>a_1, ..., a_n</code> are not type-compatible with the type of <code>DOMAIN f</code>,
Apalache flags a type error. When <code>a_i \notin DOMAIN f</code>, Apalache ignores this
argument. This is consistent with the semantics of TLA+ in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>.</p>
<p><strong>Advanced syntax:</strong> There are three extensions to the basic syntax.</p>
<p><em>Extension 1</em>. If the domain elements of a function <code>f</code> are tuples, then, similar to
function application, the expressions <code>a_1, ..., a_n</code> can be written without
the tuple braces <code>&lt;&lt;...&gt;&gt;</code>. For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1, 2] = e ]
</code></pre>
<p>In the above example, the element <code>f[&lt;&lt;1, 2&gt;&gt;]</code> is replaced with <code>e</code>.
As you can see, this is just syntax sugar.</p>
<p><em>Extension 2</em>. The operator <code>EXCEPT</code> introduces an implicit alias <code>@</code>
that refers to the element <code>f[a_i]</code> that is going to be replaced:</p>
<pre><code class="language-tla">  [ f EXCEPT ![1] = @ + 1, ![2] = @ + 3 ]
</code></pre>
<p>In the above example, the element <code>f[1]</code> is replaced with <code>f[1] + 1</code>, whereas
the element <code>f[2]</code> is replaced with <code>f[2] + 3</code>.
This is also syntax sugar.</p>
<p><em>Extension 3</em>. The advanced syntax of <code>EXCEPT</code> allows for chained replacements.
For example:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1][a_2]...[a_n] = e ]
</code></pre>
<p>This is syntax sugar for:</p>
<pre><code class="language-tla">  [ f EXCEPT ![a_1] =
    [ @ EXCEPT ![a_2] =
        ...
            [ @ EXCEPT ![a_n] = e ]]]
</code></pre>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET f1 == [ p \in 1..3 |-&gt; &quot;working&quot; ] IN
  [ f1 EXCEPT ![2] = &quot;aborted&quot; ]
    \* a new function that maps: 1 to &quot;working&quot;, 2 to &quot;aborted&quot;, 3 to &quot;working&quot;

  LET f2 == [x \in 1..3, y \in 1..3 |-&gt; x * y] IN
  [ f2 EXCEPT ![1, 1] = 0 ]
    \* a new function that maps:
    \*   &lt;&lt;1, 1&gt;&gt; to 0, and &lt;&lt;x, y&gt;&gt; to x * y when `x /= 0` or `y /= 0`
  LET f3 ==  [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]] IN
  [ f3 EXCEPT ![2][2] = 100 ]
    \* a new function that maps:
    \*   1 to the function that maps: 1 to 2
    \*   2 to the function that maps: 1 to 3, 2 to 100
    \*   3 to the function that maps: 1 to 4, 2 to 5, 3 to 6
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance. Additionally, given a Python
dictionary <code>f</code>, we write <code>f.items()</code> to quickly iterate over the pairs of keys
and values. Had we wanted to follow the TLA+ semantics more precisely, we would
have to enumerate over the keys in the function domain and apply the function to
each key, in order to obtain the value that is associated with the key.  This
code would be less efficient than the idiomatic Python code.</p>
<pre><code class="language-python">&gt;&gt;&gt; # TLA: LET f1 == [ p \in 1..3 |-&gt; &quot;working&quot; ] IN
&gt;&gt;&gt; f1 = {i: &quot;working&quot; for i in range(1, 4)}
&gt;&gt;&gt; f1
{1: 'working', 2: 'working', 3: 'working'}
&gt;&gt;&gt; # TLA: [ f1 EXCEPT ![2] = &quot;aborted&quot; ]
&gt;&gt;&gt; g1 = {i: status if i != 2 else &quot;aborted&quot; for i, status in f1.items()}
&gt;&gt;&gt; g1
{1: 'working', 2: 'aborted', 3: 'working'}

&gt;&gt;&gt; # TLA: LET f2 == [x, y \in 1..3 |-&gt; x * y] IN
&gt;&gt;&gt; f2 = {(x, y): x * y for x in range(1, 4) for y in range(1, 4)}
&gt;&gt;&gt; # TLA: [ f2 EXCEPT ![1, 1] = 0
&gt;&gt;&gt; g2 = {k: v if k != (1, 1) else 0 for k, v in f2.items()}
&gt;&gt;&gt; g2
{(1, 1): 0, (1, 2): 2, (1, 3): 3, (2, 1): 2, (2, 2): 4, (2, 3): 6, (3, 1): 3, (3, 2): 6, (3, 3): 9}

&gt;&gt;&gt; # TLA: [ n \in 1..3 |-&gt; [ i \in 1..n |-&gt; n + i ]]
&gt;&gt;&gt; f3 = {n: {i: n + i for i in range(1, n + 1)} for n in range(4)}
&gt;&gt;&gt; # TLA: [ f3 EXCEPT ![2][2] = 100 ]
&gt;&gt;&gt; g3 = f3.copy()
&gt;&gt;&gt; g3[2][2] = 100
&gt;&gt;&gt; g3
{0: {}, 1: {1: 2}, 2: {1: 3, 2: 100}, 3: {1: 4, 2: 5, 3: 6}}

</code></pre>
<hr />
<p><a name="domain"></a></p>
<h3><a class="header" href="#function-domain" id="function-domain">Function domain</a></h3>
<p><strong>Notation:</strong> <code>DOMAIN f</code></p>
<p><strong>LaTeX notation:</strong> <code>DOMAIN f</code></p>
<p><strong>Arguments:</strong> One argument, which should be a function
(respectively, a record, tuple, sequence).</p>
<p><strong>Apalache type:</strong> <code>(a -&gt; b) =&gt; Set(a)</code>.</p>
<p><strong>Effect:</strong> <code>DOMAIN f</code> returns the set of values, on which the function
has been defined, see: Function constructor and Function set constructor.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> In pure TLA+, the result is undefined, if <code>f</code> is not a function
(respectively, a record, tuple, or sequence). TLC flags a model checking error
if <code>f</code> is a value that does not have a domain. Apalache flags a type checking
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET f == [ x \in 1..3 |-&gt; 2 * x ] IN
  DOMAIN f \* { 1, 2, 3 }
</code></pre>
<p><strong>Example in Python:</strong></p>
<p>In the following code, we write <code>range(m, n)</code> instead of <code>frozenset(range(m, n))</code> to simplify the presentation and produce idiomatic Python code. In the
general case, we have to iterate over a set, as the type and structure of the
function domain is not known in advance.</p>
<pre><code class="language-python">&gt;&gt;&gt; f = {x: 2 * x for x in range(1, 4)}
&gt;&gt;&gt; f.keys()
dict_keys([1, 2, 3])

</code></pre>
<p>In the above code, we write <code>f.keys()</code> to obtain an iterable over the
dictionary keys, which can be used in a further python code. In a more
principled approach that follows the semantics of TLA+, we would have to
produce a set, that is to write:</p>
<pre><code class="language-python">frozenset(f.keys())
</code></pre>
<h1><a class="header" href="#records-1" id="records-1">Records</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Records in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that have the
following properties:</p>
<ul>
<li>The domain of a record contains only strings.</li>
<li>The domain of a record is finite.</li>
</ul>
<p>That is it in pure TLA+. Essentially, TLA+ is following the duck-typing principle for
records: Any function over strings can be also treated as a record, and vice
versa, a record is also a function. So you can use all function operators on
records too.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
records.  For instance, the following example shows how to construct a record
that has two fields: Field <code>&quot;a&quot;</code> is assigned value <code>2</code>, and field <code>&quot;b&quot;</code> is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  [ a |-&gt; 2, b |-&gt; TRUE ]
</code></pre>
<p>Similar to the function set <code>[S -&gt; T]</code>, there is a record set constructor:</p>
<pre><code class="language-tla">  [ name: { &quot;Alice&quot;, &quot;Bob&quot; }, year_of_birth: 1900..2000 ]
</code></pre>
<p>The expression in the above example constructs a set of records that have: the
<code>name</code> field set to either &quot;Alice&quot; or &quot;Bob&quot;, and the <code>year_of_birth</code> field set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> TLA+ provides you with a shorthand operator for accessing
a record field by following C-style struct-member notation. For example:</p>
<pre><code class="language-tla">  r.myField
</code></pre>
<p>This is essentially syntax sugar for <code>r[&quot;myField&quot;]</code>.</p>
<p><strong>Immutability</strong>. As records are special kinds of <a href="lang/./functions.html">functions</a>,
records are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions and records. When Apalache processes a
record constructor, it assigns the record type to the result. This record type
carries the information about the names of the record fields and their types.
Similarly, Apalache assigns the type of a set of records, when it processes a
record set constructor.  See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types.</p>
<p><em>Owing to the type information, records are translated into SMT more efficiently
by Apalache than the general functions.</em></p>
<p>It is quite common to mix records of different shapes into sets. For instance,
see how the variable <code>msgs</code> is updated in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>. To address this pattern,
Apalache treats records that do not disagree on field types to be
type-compatible. For instance, the records <code>[type |-&gt; &quot;A&quot;, a |-&gt; 3]</code>
and <code>[type |-&gt; &quot;B&quot;, b |-&gt; TRUE]</code> have the joint type:</p>
<pre><code>  [type: Str, a: Int, b: Bool]
</code></pre>
<hr />
<h2><a class="header" href="#operators-4" id="operators-4">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="recCtor"></a></p>
<h3><a class="header" href="#record-constructor" id="record-constructor">Record constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/rec-ctor.png" alt="rec-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Apalache type:</strong> <code>(a_1, ..., a_n) =&gt; [field_1: a_1, ..., field_n: a_n]</code>, for
some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The record constructor returns a function <code>r</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN r</code> to <code>{ field_1, ..., field_n }</code>,</li>
<li>set <code>r[field_i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ]
    \* A record that has two fields:
    \* field &quot;name&quot; that is equal to &quot;Printer&quot;, and field &quot;port&quot; that is equal to 631.
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; { &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 }
{'name': 'Printer', 'port': 631}

</code></pre>
<hr />
<p><a name="recSetCtor"></a></p>
<h3><a class="header" href="#record-set-constructor" id="record-set-constructor">Record set constructor</a></h3>
<p><strong>Notation:</strong> <code>[ field_1: S_1, ..., field_n: S_n]</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/recset-ctor.png" alt="recset-ctor" /></p>
<p><strong>Arguments:</strong> An even number of arguments: field names and field values,
interleaved. At least one field is expected. Note that field names are TLA+
identifiers, not strings.</p>
<p><strong>Apalache type:</strong> <code>(Set(a_1), ..., Set(a_n)) =&gt; Set([field_1: a_1, ..., field_n: a_n])</code>, for some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The record set constructor <code>[ field_1: S_1, ..., field_n: S_n]</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ [ field_1 |-&gt; e_1, ..., field_n |-&gt; e_n]: e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite records sets in some cases, when one record
is picked with <code>\E r \in [ field_1: S_1, ..., field_n: S_n]</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  [ name: { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, port: 1..65535 ]
    \* A set of records. Each has two fields:
    \* field &quot;name&quot; that has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \* field &quot;port&quot; that has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  frozenset({ frozendict({ &quot;name&quot;: n, &quot;port&quot;: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="recApp"></a></p>
<h3><a class="header" href="#access-by-field-name" id="access-by-field-name">Access by field name</a></h3>
<p><strong>Notation:</strong> <code>r.field_i</code></p>
<p><strong>LaTeX notation:</strong> <code>r.field_i</code></p>
<p><strong>Arguments:</strong> Two arguments: a record and a field name (as an identifier).</p>
<p><strong>Apalache type:</strong> <code>[field_1: a_1, ..., field_i: a_i, ..., field_n: a_n]) =&gt; a_i</code>, for some types <code>a_1, ..., a_n</code>. Due to the record unification rule, we
usually write this type simply as: <code>[field_i: a_i] =&gt; a_i</code>.</p>
<p>Note that <code>r.field_i</code> is just a syntax sugar for <code>r[&quot;field_i&quot;]</code> in TLA+.
Hence, if the type of <code>r</code> cannot be inferred, you can see an error message
about Apalache not knowing, whether <code>r</code> is a record, or a function.</p>
<p><strong>Effect:</strong> As records are also functions, this operator works as <code>r[&quot;field_i&quot;]</code>.</p>
<p>Apalache treats records as values of a record type. In comparison to the
general function application <code>r[&quot;field&quot;]</code>, the operator <code>r.field</code> is handled
much more efficiently in Apalache. Due to the use of types, Apalache can
extract the respective field when translating the access expression into SMT.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET r == [ name |-&gt; &quot;Printer&quot;, port |-&gt; 631 ] IN
  r.name    \* &quot;Printer&quot;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; r = { &quot;name&quot;: &quot;Printer&quot;, &quot;port&quot;: 631 }
&gt;&gt;&gt; r[&quot;name&quot;]
'Printer'

</code></pre>
<hr />
<h1><a class="header" href="#tuples-1" id="tuples-1">Tuples</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>Tuples in TLA+ are special kinds of <a href="lang/./functions.html">functions</a> that satisfy one
of the following properties:</p>
<ul>
<li>The domain is either empty, that is, <code>{}</code>, or</li>
<li>The domain is <code>1..n</code> for some <code>n &gt; 0</code>.</li>
</ul>
<p>That is right. You can construct the empty tuple <code>&lt;&lt;&gt;&gt;</code> in TLA+ as well as a
single-element tuple, e.g., <code>&lt;&lt;1&gt;&gt;</code>. You can also construct pairs, triples, an
so on, e.g., <code>&lt;&lt;1, TRUE&gt;&gt;</code>, <code>&lt;&lt;&quot;Hello&quot;, &quot;world&quot;, 2020&gt;&gt;</code>. If you think that
empty tuples do not make sense: In TLA+, there is no difference between tuples
and <a href="lang/./sequences.html">sequences</a>.  Again, it is duck typing: Any function with
the domain <code>1..n</code> can be also treated as a tuple (or a sequence!), and vice
versa, tuples and sequences are also functions. So you can use all function
operators on tuples.</p>
<p>Importantly, the domain of a nonempty tuple is <code>1..n</code> for some <code>n &gt; 0</code>. So tuples never
have a 0th element. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us 1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p><strong>Construction.</strong> TLA+ provides you with a convenient syntax for constructing
tuples. For instance, the following example shows how to construct a tuple
that has two fields: Field 1 is assigned value <code>2</code>, and field 2 is
assigned value <code>TRUE</code>.</p>
<pre><code class="language-tla">  &lt;&lt;2, TRUE&gt;&gt;
</code></pre>
<p>There is a tuple set constructor, which is well-known as <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>:</p>
<pre><code class="language-tla">  { &quot;Alice&quot;, &quot;Bob&quot; } \X (1900..2000)
</code></pre>
<p>The expression in the above example constructs a set of tuples <code>&lt;&lt;n, y&gt;&gt;</code>: the
first field <code>n</code> is set to either &quot;Alice&quot; or &quot;Bob&quot;, and the second field <code>y</code> is set
to an integer from 1900 to 2000.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>t[2]</code>.</p>
<p><strong>Immutability</strong>. As tuples are special kinds of <a href="lang/./functions.html">functions</a>,
tuples are immutable.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>A -&gt; B</code> that
restricts the arguments and results as follows: the arguments have the type
<code>A</code> and the results have the type <code>B</code>. A sequence has the type
<code>Seq(C)</code>, which restricts the sequence elements to have the same type <code>C</code>. In
contrast, tuples have more fine-grained types in Apalache: <code>&lt;&lt;T_1&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2&gt;&gt;</code>, <code>&lt;&lt;T_1, T_2, T_3&gt;&gt;</code> and so on. As a result, different tuple fields are
allowed to carry elements of different types, whereas functions and sequences
are not allowed to do that. See the <a href="lang/../adr/002adr-types.html">Apalache ADR002</a> on types for details.</p>
<p>As tuples are also sequences in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence. Usually, this problem is resolved by annotating the
type of a variable or the type of a user operator. See <a href="lang/../../HOWTOs/howto-write-type-annotations.html">HOWTO write type
annotations</a>.</p>
<p><em>Owing to the type information, tuples are translated into SMT much more efficiently
by Apalache than the general functions and sequences!</em></p>
<hr />
<h2><a class="header" href="#operators-5" id="operators-5">Operators</a></h2>
<p>In the Python examples, we are using the package <a href="https://pypi.org/project/frozendict/">frozendict</a>, to produce an
immutable dictionary.</p>
<hr />
<p><a name="tuple"></a></p>
<h3><a class="header" href="#tuplesequence-constructor" id="tuplesequence-constructor">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Apalache type:</strong> This operator is overloaded. There are two potential types:</p>
<ol>
<li>A tuple constructor: <code>(a_1, ..., a_n) =&gt; &lt;&lt;a_1, ..., a_n&gt;&gt;</code>,
for some types <code>a_1, ..., a_n</code>.</li>
<li>A sequence constructor: <code>(a, ..., a) =&gt; Seq(a)</code>, for some type <code>a</code>.</li>
</ol>
<p>That is why the Apalache type checker is sometimes asking you to add annotations,
in order to resolve this ambiguity.</p>
<p><strong>Effect:</strong> The tuple constructor returns a function <code>t</code> that is constructed
as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a [type
annotation].</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
tuples, which are indexed with 0!. If we want to stick to the
principle &quot;tuples are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">&gt;&gt;&gt; (&quot;Printer&quot;, 631)          # the pythonic way, introducing fields 0 and 1
('Printer', 631)
&gt;&gt;&gt; { 1: &quot;Printer&quot;, 2: 631 }  # the &quot;tuples-are-functions&quot; way
{1: 'Printer', 2: 631}

</code></pre>
<hr />
<p><a name="times"></a></p>
<h3><a class="header" href="#cartesian-product" id="cartesian-product">Cartesian product</a></h3>
<p><strong>Notation:</strong> <code>S_1 \X ... \X S_n</code> (or <code>S_1 \times ... \times S_n</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/set-prod.png" alt="set-prod" /></p>
<p><strong>Arguments:</strong> At least two arguments. All of them should be sets.</p>
<p><strong>Apalache type:</strong> <code>(Set(a_1), ..., Set(a_n)) =&gt; Set(&lt;&lt;a_1, ..., a_n&gt;&gt;)</code>,
for some types <code>a_1, ..., a_n</code>.</p>
<p><strong>Effect:</strong> The Cartesian product <code>S_1 \X ... \X S_n</code>
is syntax sugar for the set comprehension:</p>
<pre><code class="language-tla">{ &lt;&lt; e_1, ..., e_n &gt;&gt; : e_1 \in S_1, ..., e_n \in S_n }
</code></pre>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>S_1, ..., S_n</code> must be sets. If they are not sets,
the result is undefined in pure TLA+. TLC raises a model checking error. Apalache
flags a static type error.</p>
<p>TLC raises a model checking error, whenever one of the sets <code>S_1, ..., S_n</code> is
infinite. Apalache can handle infinite sets in some cases, e.g., when one tuple
is picked with <code>\E t \in S_1 \X S_2</code>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } \X (1..65535)
    \* A set of tuples. Each tuple has two fields:
    \*   - field 1 has the value from the set { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }, and
    \*   - field 2 has the value from the set 1..65535.
</code></pre>
<p><strong>Example in Python:</strong> TLA+ functions are immutable, so we are using <a href="https://pypi.org/project/frozendict/">frozendict</a>:</p>
<pre><code class="language-python">  # the pythonic way: a set of python tuples (indexed with 0, 1, ...)
  frozenset({ (n, p)
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
  # the TLA+ way
  frozenset({ frozendict({ 1: n, 2: p })
                for n in { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; } for p in range(1, 65535 + 1) })
</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-1" id="function-application-1">Function application</a></h3>
<p>As tuples are functions, you can access tuple elements by <a href="lang/./functions.html#funApp">function
application</a>, e.g., <code>tup[2]</code>. However, in the case of a
tuple, the type of the function application will be: <code>(&lt;&lt;a_1, ..., a_i, ..., a_n&gt;&gt;, Int) =&gt; a_i</code>, for some types <code>a_1, ..., a_n</code>.</p>
<h1><a class="header" href="#sequences-1" id="sequences-1">Sequences</a></h1>
<p><a href="lang/./standard-operators.html">[Back to all operators]</a></p>
<p>On the surface, TLA+ sequences are very much like lists in your programming
language of choice.  If you are writing code in Java, Python, Lisp, C++, Scala,
you will be tempted to use sequences in TLA+ too. This is simply due to the
fact that arrays, vectors, and lists are the most efficient collections in
programming languages (for many tasks, but not all of them). But TLA+ is not
about efficient compilation of your data structures!  Many algorithms can be
expressed in a much nicer way with <a href="lang/./sets.html">sets</a> and
<a href="lang/./functions.html">functions</a>. In general, use sequences when you really need
them.</p>
<p>In pure TLA+, sequences are just <a href="lang/./tuples">tuples</a>. As a tuple, a sequence is
a function of the domain <code>1..n</code> for some <code>n &gt;= 0</code> (the domain may be empty).
The duck-typing principle applies to sequences too: Any function with the domain <code>1..n</code> can also be
treated as a sequence (or a tuple), and vice versa, tuples and sequences are
also functions. So you can use all function and tuple operators on sequences.</p>
<p>Importantly, the domain of a sequence is <code>1..n</code> for some <code>n &gt;= 0</code>. So the
indices in a sequence start with 1, not 0. For instance, <code>&lt;&lt;1, 2&gt;&gt;[1]</code> gives us
1, whereas <code>&lt;&lt;1, 2&gt;&gt;[2]</code> gives us 2.</p>
<p>The operators on sequences are defined in the standard module <code>Sequences</code>. To
use it, write the <code>EXTENDS</code> clause in the first lines of your module. Like
this:</p>
<pre><code class="language-tla">------ MODULE MyLists ----====
EXTENDS Sequences
...
==============================
</code></pre>
<p><strong>Construction.</strong> Sequences are constructed exactly as tuples in TLA+:</p>
<pre><code class="language-tla">  &lt;&lt;2, 4, 8&gt;&gt;
</code></pre>
<p>Sometimes, you have to talk about all possible sequences. The operator
<code>Seq(S)</code> constructs the set of all (finite) sequences that draw elements
from the set <code>S</code>. For instance, <code>&lt;&lt;1, 2, 2, 1&gt;&gt; \in Seq({1, 2, 3})</code>.
Note that <code>Seq(S)</code> is an infinite set. To use it with TLC, you often have
to override this operator, see <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=learning.html">Specifying Systems</a>, page 237.</p>
<p><strong>Application.</strong> Simply use function application, e.g., <code>s[2]</code>.</p>
<p><strong>Immutability.</strong> As sequences are special kinds of
<a href="lang/./functions.html">functions</a>, sequences are immutable.</p>
<p><strong>Sequence operators.</strong> The module <code>Sequences</code> provides you with convenient
operators on sequences:</p>
<ul>
<li>Add to end: <code>Append(s, e)</code></li>
<li>First and rest: <code>Head(s)</code> and <code>Tail(s)</code></li>
<li>Length: <code>Len(s)</code></li>
<li>Concatenation: <code>s \o t</code></li>
<li>Subsequence: <code>SubSeq(s, i, k)</code></li>
<li>Sequence filter: <code>SelectSeq(s, Test)</code></li>
</ul>
<p>See the detailed description in <strong>Operators</strong>.</p>
<p><strong>Types.</strong> In contrast to pure TLA+ and TLC, the Apalache model checker
distinguishes between general functions, tuples, and sequences. They all have
different types. Essentially, a function has the type <code>T_1 -&gt; T_2</code> that
restricts the arguments and results as follows: the arguments have the type
<code>T_1</code> and the results have the type <code>T_2</code>. A sequence has the type <code>Seq(T_3)</code>,
which restricts the sequence elements to have the same type <code>T_3</code>.</p>
<p>As sequences are also tuples in TLA+, this poses a challenge for the Apalache
type checker. For instance, it can immediately figure out that <code>&lt;&lt;1, &quot;Foo&quot;&gt;&gt;</code>
is a tuple, as Apalache does not allow sequences to carry elements of different
types. However, there is no way to say, whether <code>&lt;&lt;1, 2, 3&gt;&gt;</code> should be treated
as a tuple or a sequence.  Usually, this problem is resolved by annotating the
type of a variable or the type of a user operator. See <a href="lang/../../HOWTOs/howto-write-type-annotations.html">HOWTO write type
annotations</a>.</p>
<p><em>The current SMT encoding of sequences in Apalache is not optimized,
so operations on sequences are often significantly slower than operations
on sets.</em></p>
<hr />
<h2><a class="header" href="#operators-6" id="operators-6">Operators</a></h2>
<p><a name="seqCtor"></a></p>
<h3><a class="header" href="#tuplesequence-constructor-1" id="tuplesequence-constructor-1">Tuple/Sequence constructor</a></h3>
<p><strong>Notation:</strong> <code>&lt;&lt;e_1, ..., e_n&gt;&gt;</code></p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/tuple.png" alt="tuple" /></p>
<p><strong>Arguments:</strong> An arbitrary number of arguments.</p>
<p><strong>Apalache type:</strong> This operator is overloaded. There are two potential types:</p>
<ol>
<li>A tuple constructor: <code>(a_1, ..., a_n) =&gt; &lt;&lt;a_1, ..., a_n&gt;&gt;</code>,
for some types <code>a_1, ..., a_n</code>.</li>
<li>A sequence constructor: <code>(a, ..., a) =&gt; Seq(a)</code>, for some type <code>a</code>.</li>
</ol>
<p>That is why the Apalache type checker is sometimes asking you to add annotations,
in order to resolve this ambiguity.</p>
<p><strong>Effect:</strong> The tuple/sequence constructor returns a function <code>t</code> that is
constructed as follows:</p>
<ul>
<li>set <code>DOMAIN t</code> to <code>1..n</code>,</li>
<li>set <code>r[i]</code> to the value of <code>e_i</code> for <code>i \in 1..n</code>.</li>
</ul>
<p>In Apalache, this constructor may be used to construct either a tuple, or a
sequence. To distinguish between them, you will sometimes need a [type
annotation].</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;&quot;Printer&quot;, 631&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong> Python provides us with the syntax for constructing
lists, which are indexed with 0!. If we want to stick to the
principle &quot;sequences are functions&quot;, we have to use a dictionary.</p>
<pre><code class="language-python">&gt;&gt;&gt; [&quot;Printer&quot;, 631]          # the pythonic way, a two-element list
['Printer', 631]
&gt;&gt;&gt; { 1: &quot;Printer&quot;, 2: 631 }  # the &quot;sequences-are-functions&quot; way
{1: 'Printer', 2: 631}

</code></pre>
<hr />
<p><a name="append"></a></p>
<h3><a class="header" href="#sequence-append" id="sequence-append">Sequence append</a></h3>
<p><strong>Notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>LaTeX notation:</strong> <code>Append(seq, e)</code></p>
<p><strong>Arguments:</strong> Two arguments. The first argument should be a sequence, the
second one is an arbitrary expression.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), a) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Append(seq, e)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \union { Len(seq) + 1 }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i]</code> for <code>i \in 1..Len(seq)</code>.</li>
<li>set <code>newSeq[Len(seq) + 1]</code> to <code>e</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined in pure TLA+.
TLC raises a model checking error. Apalache flags a static type error.</p>
<p>Apalache flags a static type error, when the type of <code>e</code> is not compatible with
the type of the sequence elements.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Append(&lt;&lt;1, 2&gt;&gt;, 5)
    \* The sequence &lt;&lt;1, 2, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l = [ 1, 2 ]
&gt;&gt;&gt; l.append(5)
&gt;&gt;&gt; l
[1, 2, 5]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 1, 2: 2 }
&gt;&gt;&gt; { i: l[i] if i &lt;= len(l) else 5
...   for i in range(1, len(l) + 2) }
{1: 1, 2: 2, 3: 5}

</code></pre>
<hr />
<p><a name="app"></a></p>
<h3><a class="header" href="#function-application-2" id="function-application-2">Function application</a></h3>
<p>As sequences are functions, you can access sequence elements with <a href="lang/./functions.html#funApp">function
application</a>, e.g., <code>seq[2]</code>.  However, in the case of a
sequence, the type of the function application is: <code>(Seq(a), Int) =&gt; a</code>, for
some type <code>a</code>.</p>
<hr />
<p><a name="head"></a></p>
<h3><a class="header" href="#sequence-head" id="sequence-head">Sequence head</a></h3>
<p><strong>Notation:</strong> <code>Head(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Head(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; a</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Head(seq)</code> evaluates to <code>seq[1]</code>.
If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Head(&lt;&lt;3, 4&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4 ]
&gt;&gt;&gt; l[0]
3
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4 }
&gt;&gt;&gt; l[1]
3

</code></pre>
<hr />
<p><a name="tail"></a></p>
<h3><a class="header" href="#sequence-tail" id="sequence-tail">Sequence tail</a></h3>
<p><strong>Notation:</strong> <code>Tail(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Tail(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Tail(seq)</code> constructs a new sequence <code>newSeq</code> as
follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>(DOMAIN seq) \ { Len(seq) }</code>.</li>
<li>set <code>newSeq[i]</code> to <code>seq[i + 1]</code> for <code>i \in 1..(Len(seq) - 1)</code>.</li>
</ul>
<p>If <code>seq</code> is an empty sequence, the result is undefined.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Tail</code> is a very simple operation that just increments <code>start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Tail(&lt;&lt;3, 4, 5&gt;&gt;)
    \* &lt;&lt;4, 5&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4, 5 ]
&gt;&gt;&gt; l[1:]
[4, 5]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 5 }
&gt;&gt;&gt; { i: l[i + 1] for i in range(1, len(l)) }
{1: 4, 2: 5}

</code></pre>
<hr />
<p><a name="len"></a></p>
<h3><a class="header" href="#sequence-length" id="sequence-length">Sequence length</a></h3>
<p><strong>Notation:</strong> <code>Len(seq)</code></p>
<p><strong>LaTeX notation:</strong> <code>Len(seq)</code></p>
<p><strong>Arguments:</strong> One argument. The argument should be a sequence (or a tuple).</p>
<p><strong>Apalache type:</strong> <code>Seq(a) =&gt; Int</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Len(seq)</code> is semantically equivalent to
<code>Cardinality(DOMAIN seq)</code>.</p>
<p>Apalache encodes a sequences as a triple <code>&lt;&lt;fun, start, end&gt;&gt;</code>, where
<code>start</code> and <code>end</code> define a slice of the function <code>fun</code>. As a result,
<code>Len</code> is simply computed as <code>end - start</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence (or a tuple), that is, a
function over integers <code>1..n</code> for some <code>n</code>. Otherwise, the result is undefined
in pure TLA+. TLC raises a model checking error. Apalache flags a static type
error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Len(&lt;&lt;3, 4, 5&gt;&gt;)
    \* 3
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: using the list
&gt;&gt;&gt; l = [ 3, 4, 5 ]
&gt;&gt;&gt; len(l)
3
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 5 }
&gt;&gt;&gt; len(l.keys())
3

</code></pre>
<hr />
<p><a name="concat"></a></p>
<h3><a class="header" href="#sequence-concatenation" id="sequence-concatenation">Sequence concatenation</a></h3>
<p><strong>Notation:</strong> <code>s \o t</code> (or <code>s \circ t</code>)</p>
<p><strong>LaTeX notation:</strong> <img src="lang/./img/seq-concat.png" alt="seq-concat" /></p>
<p><strong>Arguments:</strong> Two arguments: both should be sequences (or tuples).</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), Seq(a)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>s \o t</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(Len(s) + Len(t))</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[i]</code> for <code>i \in 1..Len(s)</code>.</li>
<li>set <code>newSeq[Len(s) + i]</code> to <code>t[i]</code> for <code>i \in 1..Len(t)</code>.</li>
</ul>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The arguments <code>s</code> and <code>t</code> must be sequences, that is, functions
over integers <code>1..n</code> and <code>1..k</code> for some <code>n</code> and <code>k</code>. Otherwise, the result is
undefined in pure TLA+. TLC raises a model checking error. Apalache flags a
static type error.</p>
<p>Apalache flags a static type error, when the types of <code>s</code> and <code>t</code> are
incompatible.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  &lt;&lt;3, 5&gt;&gt; \o &lt;&lt;7, 9&gt;&gt;
    \* The sequence &lt;&lt;3, 5, 7, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l1 = [ 3, 5 ]
&gt;&gt;&gt; l2 = [ 7, 9 ]
&gt;&gt;&gt; l1 + l2
[3, 5, 7, 9]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l1 = { 1: 3, 2: 5 }
&gt;&gt;&gt; l2 = { 1: 7, 2: 9 }
&gt;&gt;&gt; { i: l1[i] if i &lt;= len(l1) else l2[i - len(l1)]
...    for i in range(1, len(l1) + len(l2) + 1) }
{1: 3, 2: 5, 3: 7, 4: 9}

</code></pre>
<hr />
<p><a name="subseq"></a></p>
<h3><a class="header" href="#subsequence" id="subsequence">Subsequence</a></h3>
<p><strong>Notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>LaTeX notation:</strong> <code>SubSeq(seq, m, n)</code></p>
<p><strong>Arguments:</strong> Three arguments: a sequence (tuple), and two integers.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), Int, Int) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>SubSeq(seq, m, n)</code>
constructs a new sequence <code>newSeq</code> as follows:</p>
<ul>
<li>set <code>DOMAIN newSeq</code> to be <code>1..(n - m)</code>.</li>
<li>set <code>newSeq[i]</code> to <code>s[m + i - 1]</code> for <code>i \in 1..(n - m + 1)</code>.</li>
</ul>
<p>If <code>m &gt; n</code>, then <code>newSeq</code> is equal to the empty sequence <code>&lt;&lt; &gt;&gt;</code>.
If <code>m &lt; 1</code> or <code>n &gt; Len(seq)</code>, then the result is undefined.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>seq</code> must be a sequence, that is, a function over
integers <code>1..k</code> for some <code>k</code>. The arguments <code>m</code> and <code>n</code> must be integers.
Otherwise, the result is undefined in pure TLA+. TLC raises a model checking
error. Apalache flags a static type error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  SubSeq(&lt;&lt;3, 5, 9, 10&gt;&gt;, 2, 3)
    \* The sequence &lt;&lt;5, 9&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; l = [ 3, 5, 9, 10 ]
&gt;&gt;&gt; l[1:3]
[5, 9]
&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 5, 3: 9, 4: 10 }
&gt;&gt;&gt; m = 2
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; { i: l[i + m - 1]
...   for i in range(1, n - m + 2) }
{1: 5, 2: 9}

</code></pre>
<hr />
<p><a name="filter"></a></p>
<h3><a class="header" href="#sequence-filter" id="sequence-filter">Sequence filter</a></h3>
<p><strong>Notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>LaTeX notation:</strong> <code>SelectSeq(seq, Test)</code></p>
<p><strong>Arguments:</strong> Two arguments: a sequence (a tuple) and a one-argument
operator that evaluates to <code>TRUE</code> or <code>FALSE</code> when called with
an element of <code>seq</code> as its argument.</p>
<p><strong>Apalache type:</strong> <code>(Seq(a), (a =&gt; Bool)) =&gt; Seq(a)</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>SelectSeq(seq, Test)</code> constructs a new sequence
<code>newSeq</code> that contains every element <code>e</code> of <code>seq</code> on which <code>Test(e)</code> evaluates
to <code>TRUE</code>.</p>
<p>It is much easier to describe the effect of <code>SelectSeq</code> in words than to
give a precise sequence of steps. See <strong>Examples</strong>.</p>
<p><em>This operator is not supported by Apalache, as it inlines all operators,
before translating the specification in SMT. Hence, it cannot pass <code>Test</code>
into a built-in operator. To work around it, write a user-defined
recursive operator that is equivalent to <code>SelectSeq</code>.</em></p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> If the arguments are not as described in <strong>Arguments</strong>, then the
result is undefined in pure TLA+. TLC raises a model checking error.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  LET Test(x) ==
    x % 2 = 0
  IN
  SelectSeq(&lt;&lt;3, 4, 9, 10, 11&gt;&gt;, Test)
    \* The sequence &lt;&lt;4, 10&gt;&gt;
</code></pre>
<p><strong>Example in Python:</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; # the pythonic way: a list (indexed with 0, 1, ...)
&gt;&gt;&gt; def test(x):
...   return x % 2 == 0
&gt;&gt;&gt;
&gt;&gt;&gt; l = [ 3, 4, 9, 10, 11 ]
&gt;&gt;&gt; [ x for x in l if test(x) ]
[4, 10]

&gt;&gt;&gt; # the TLA+ way
&gt;&gt;&gt; l = { 1: 3, 2: 4, 3: 9, 4: 10, 5: 11 }
&gt;&gt;&gt; as_list = sorted(list(l.items()))
&gt;&gt;&gt; filtered = [ x for (_, x) in as_list if test(x) ]
&gt;&gt;&gt; { i: x
...   for (i, x) in zip(range(1, len(filtered) + 1), filtered)
... }
{1: 4, 2: 10}

</code></pre>
<hr />
<p><a name="seq"></a></p>
<h3><a class="header" href="#all-sequences" id="all-sequences">All sequences</a></h3>
<p><strong>Notation:</strong> <code>Seq(S)</code></p>
<p><strong>LaTeX notation:</strong> <code>Seq(S)</code></p>
<p><strong>Arguments:</strong> One argument that should be a set.</p>
<p><strong>Apalache type:</strong> <code>Set(a) =&gt; Set(Seq(a))</code>, for some type <code>a</code>.</p>
<p><strong>Effect:</strong> The operator <code>Seq(S)</code> constructs the set of all (finite) sequences
that contain elements from <code>S</code>. This set is infinite.</p>
<p>It is easy to give a recursive definition of all sequences whose length
is bounded by some <code>n &gt;= 0</code>:</p>
<pre><code class="language-tla">RECURSIVE BSeq(_, _)
BSeq(S, n) ==
  IF n = 0
  THEN {&lt;&lt; &gt;&gt;}  \* the set that contains the empty sequence
  ELSE LET Shorter == BSeq(S, n - 1) IN
        Shorter \union { Append(seq, x): seq \in Shorter, x \in S }
</code></pre>
<p>Then we can define <code>Seq(S)</code> to be <code>UNION { BSeq(S, n): n \in Nat }</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> The argument <code>S</code> must be a set.
Apalache flags a static type error, if <code>S</code> is not a set.</p>
<p>TLC raises a model checking error, when it meets <code>Seq(S)</code>, as <code>Seq(S)</code> is
infinite. You can override <code>Seq(S)</code> with its bounded version <code>BSeq(S, n)</code>
for some <code>n</code>. See: <a href="https://groups.google.com/g/tlaplus/c/sYx_6e3YyWk/m/4CnwPqIVAgAJ">Overriding Seq in TLC</a>.</p>
<p>Apalache does not support <code>Seq(S)</code> yet. As a workaround, you can manually
replace <code>Seq(S)</code> with <code>BSeq(S, n)</code> for some constant <code>n</code>.  See the progress in
<a href="https://github.com/informalsystems/apalache/issues/314">Issue 314</a>.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">  Seq({1, 2, 3})
    \* The infinite set
      { &lt;&lt;&gt;&gt;,
        &lt;&lt;1&gt;&gt;, &lt;&lt;2&gt;&gt;, &lt;&lt;3&gt;&gt;,
        &lt;&lt;1, 1&gt;&gt;, &lt;&lt;1, 2&gt;&gt;, &lt;&lt;1, 3&gt;&gt;,
            &lt;&lt;2, 1&gt;&gt;, &lt;&lt;2, 2&gt;&gt;, &lt;&lt;2, 3&gt;&gt;, &lt;&lt;3, 1&gt;&gt;, &lt;&lt;3, 2&gt;&gt;, &lt;&lt;3, 3&gt;&gt;
        ...
      }
</code></pre>
<p><strong>Example in Python:</strong> We cannot construct an infinite set in Python. However,
we could write an iterator that enumerates the sequences in <code>Seq(S)</code>
till the end of the universe.</p>
<h1><a class="header" href="#user-defined-operators-and-recursive-functions" id="user-defined-operators-and-recursive-functions">User-defined operators and recursive functions</a></h1>
<p><em>Like macros, to do a lot of things in one system step...</em></p>
<p>User-defined operators in TLA+ may be confusing. At first, they look like
functions in programming languages. (Recall that <a href="lang/./functions.html">TLA+
functions</a> are more like dictionaries or hash maps, not
functions in PL.) Then you realize that operators such as <code>Init</code> and <code>Next</code> are
used as logic predicates. However, large specifications often contain operators
that are not predicates, but in fact are similar to pure functions in
programming languages: They are computing values over the system state but pose
no constraints over the system states. On top of that, there are <a href="lang/./user/recursive-functions.html">Recursive
functions</a> that syntactically looks very similar to
operators.</p>
<p>Recently, Leslie Lamport has extended the syntax of TLA+ operators in <a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf">TLA+
version 2</a>, which supports recursive operators and lambda operators.  The
operator syntax that is described in <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying Systems</a> describes TLA+
version 1. This page summarizes the syntax of user-defined operators in
versions 1 and 2.</p>
<p><strong>Short digression</strong>. The most important thing to understand about user-defined
operators is that they are normally used inside <code>Init</code> and <code>Next</code>. While the
operator <code>Init</code> describes the initial states, the operator <code>Next</code> describes a
single step of the system.  That is, these two operators are describing the
initial states and the possible transitions of the system, respectively. They
do not describe the whole system computation.  Most of the time, we are writing
<em>canonical specifications</em>, which are written in temporal logic as <code>Init /\ [][Next]_vars</code>. Actually, you do not have to understand temporal logic, in
order to write canonical specifications. A canonical specification is saying:
(1) Initialize the system as <code>Init</code> prescribes, and (2) compute system
transitions as <code>Next</code> prescribes. It also allows for stuttering, but this
belongs to <a href="http://lamport.azurewebsites.net/tla/advanced.html?back-link=user-operators.html">Advanced topics</a>.</p>
<p>After the digression, you should now see that user-defined operators in TLA+
are (normally) describing a single step of the system. Hence, they should be
terminating. That is why user operators are often understood as macros.  The
same applies to <a href="lang/./user/recursive-operators.html">Recursive operator definitions</a>. They have to
terminate within a single system step.</p>
<p><strong>Quirks of TLA+ operators.</strong> Below we summarize features of
user-defined operators that you would probably find unexpected:</p>
<ol>
<li>
<p>Some operators are used as predicates and some are used to compute
values (<em>√† la pure</em>).</p>
</li>
<li>
<p>Operators may accept other operators as parameters. Such operators are
called <a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a>.</p>
</li>
<li>
<p>Although operators may be passed as parameters, they are not first-class
citizens in TLA+. For instance, an operator cannot be returned as a result of
another operator. Nor can an operator be assigned to a variable (only the result
of its application may be assigned to a variable).</p>
</li>
<li>
<p>Operators do not support <a href="https://en.wikipedia.org/wiki/Currying">Currying</a>. That is, you can only apply an operator
by providing values for all of its expected arguments.</p>
</li>
<li>
<p>Operators can be nested. However, nested operators require a slightly
different syntax. They are defined with LET-IN definitions.</p>
</li>
</ol>
<p><strong>Details about operators.</strong> We go in detail about different kinds of operators
and recursive functions below:</p>
<ul>
<li>
<p><a href="lang/./user/top-level-operators.html">Top-level operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/let-in.html">LET-IN definitions</a></p>
</li>
<li>
<p><a href="lang/./user/higher-order-operators.html">Higher-order operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/lambdas.html">Anonymous operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/recursive-operators.html">Recursive operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/local-operators.html">Local operator definitions</a></p>
</li>
<li>
<p><a href="lang/./user/recursive-functions.html">Recursive functions</a></p>
</li>
</ul>
<h1><a class="header" href="#top-level-operator-definitions" id="top-level-operator-definitions">Top-level operator definitions</a></h1>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h2><a class="header" href="#quick-example" id="quick-example">Quick example</a></h2>
<p>Here is a quick example of a top-level user operator (which has to be defined
in a module) and of its application:</p>
<pre><code class="language-tla">----------------------- MODULE QuickTopOperator -------------------------------
...
Abs(i) == IF i &gt;= 0 THEN i ELSE -i
...
B(k) == Abs(k)
===============================================================================
</code></pre>
<p>As you most probably guessed, the operator <code>Abs</code> expects one argument <code>i</code>.
Given an integer <code>j</code>, then the result of computing <code>Abs(j)</code> is the absolute
value of <code>j</code>. The same applies, when <code>j</code> is a natural number or a real number.</p>
<h2><a class="header" href="#syntax-of-operator-definitions" id="syntax-of-operator-definitions">Syntax of operator definitions</a></h2>
<p>In general, operators of <code>n</code> arguments are
defined as follows:</p>
<pre><code class="language-tla">\* an operator without arguments (nullary)
Opa0 == body_0

\* an operator of one argument (unary)
Opa1(param1) == body_1

\* an operator of two arguments (binary)
Opa2(param1, param2) == body_2
...
</code></pre>
<p>In this form, the operator arguments are not allowed to be operators. If you want
to receive an operator as an argument, see the syntax of <a href="lang/user/./higher-order-operators.html">Higher-order operators</a>.</p>
<p>Here are concrete examples of operator definitions:</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
...

ABSOLUTE_ZERO_IN_CELCIUS ==
    -273

Fahrenheit2Celcius(t) ==
    (t - 32) * 10 / 18

Max(s, t) ==
    IF s &gt;= t THEN s ELSE t
...
===============================================================================
</code></pre>
<p><em>What is their arity (number of arguments)?</em></p>
<p>If you are used to imperative languages such as Python or Java, then you are
probably surprised that operator definitions do not have any <code>return</code>
statement. The reason for that is simple: TLA+ is not executed on any hardware.
To understand how operators are evaluated, see the semantics below.</p>
<h2><a class="header" href="#syntax-of-operator-applications" id="syntax-of-operator-applications">Syntax of operator applications</a></h2>
<p>Having defined an operator, you can apply it inside another operator as follows
(in a module):</p>
<pre><code class="language-tla">----------------------------- MODULE FandC ------------------------------------
EXTENDS Integers
VARIABLE fahrenheit, celcius
\* skipping the definitions of
\* ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius, and Max
...

UpdateCelcius(t) ==
    celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(t))

Next ==
    /\ fahrenheit' \in -1000..1000
    /\ UpdateCelcius(fahrenheit')
...
===============================================================================
</code></pre>
<p>In the above example, you see examples of four operator applications:</p>
<ol>
<li>
<p>The nullary operator <code>ABSOLUTE_ZERO_IN_CELCIUS</code> is applied without any
arguments, just by its name. Note how a nullary operator does not require
parentheses <code>()</code>. Yet another quirk of TLA+.</p>
</li>
<li>
<p>The one-argument operator Fahrenheit2Celcius is applied to <code>t</code>,
which is a parameter of the operator <code>UpdateCelcius</code>.</p>
</li>
<li>
<p>The two-argument operator <code>Max</code> is applied to <code>ABSOLUTE_ZERO_IN_CELCIUS</code>
and <code>Fahrenheit2Celcius(t)</code>.</p>
</li>
<li>
<p>The one-argument operator <code>UpdateCelcius</code> is applied to <code>fahrenheit'</code>,
which is the value of state variable <code>fahrenheit</code> in the next state of the
state machine. TLA+ has no problem applying the operator to <code>fahrenheit'</code> or
to <code>fahrenheit</code>.</p>
</li>
</ol>
<p>Technically, there are more than four operator applications in our example.
However, all other operators are the <a href="lang/user/./standard-operators.html">standard
operators</a>. We do not focus on them here.</p>
<p><strong>Note on the operator order.</strong> As you can see, we are applying operators after
they have been defined in a module. This is a general rule in TLA+: A name can
be only referred to, if it has been defined in the code before. TLA+ is not
the first language to impose that rule. For instance, <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal</a> had it too.</p>
<p><strong>Note on shadowing.</strong> TLA+ does not allow you to use the same name as an
operator parameter, if it has been defined in the context of the operator
definition. For instance, the following is not allowed:</p>
<pre><code class="language-tla">-------------------------- MODULE NoShadowing ---------------------------------
VARIABLE x

\* the following operator definition produces a semantic error:
\* the parameter x is shadowing the state variable x
IsZero(x) == x = 0
===============================================================================
</code></pre>
<p>There are a few tricky cases, where shadowing can actually happen, e.g., see
the operator <code>dir</code> in <a href="https://github.com/tlaplus/Examples/blob/master/specifications/SlidingPuzzles/SlidingPuzzles.tla">SlidingPuzzles</a>. However, we recommend to keep things
simple and avoid shadowing at all.</p>
<h2><a class="header" href="#semantics-of-operator-application" id="semantics-of-operator-application">Semantics of operator application</a></h2>
<p>Precise treatment of operator application is given on page 320 of <a href="http://lamport.azurewebsites.net/tla/book.html?back-link=user-operators.html">Specifying
Systems</a>. In a nutshell, operator application in TLA+ is a <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_macro_expansion">Call by macro
expansion</a>, though it is a bit smarter: It does not blindly mix names from the
operator's body and its application context. For example, the following
semantics by substitution is implemented in the <a href="https://apalache.informal.systems">Apalache</a> model checker.</p>
<p>Here we give a simple explanation for non-recursive operators. Consider the
definition of an <code>n</code>-ary operator <code>A</code> and its application in the definition
of another operator <code>B</code>:</p>
<pre><code class="language-tla">A(p_1, ..., p_n) == body_of_A
...
B(p_1, ..., p_k) ==
    ...
    A(e_1, ..., e_n)
    ...
</code></pre>
<p>The following three steps allow us to replace application of the operator <code>A</code>
in <code>B</code>:</p>
<ol>
<li>Change the names in the definition of <code>A</code> in such a way such they do not
clash with the names in <code>B</code> (as well as with other names that may be used in
<code>B</code>). This is the well-known technique of <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> in programming
languages. This may also require renaming of the parameters <code>p_1, ..., p_n</code>.
Let the result of alpha conversion be the following operator:</li>
</ol>
<pre><code class="language-tla">uniq_A(uniq_p_1, ..., uniq_p_n) == body_of_uniq_A
</code></pre>
<ol>
<li>
<p>Substitute the expression <code>A(e_1, ..., e_n)</code> in the definition of <code>B</code> with
<code>body_of_uniq_A</code>.</p>
</li>
<li>
<p>Substitute the names <code>uniq_p_1, ..., uniq_p_n</code> with the expressions <code>e_1, ..., e_n</code>, respectively.</p>
</li>
</ol>
<p>The above transformation is usually called <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a>.</p>
<p><strong>Example.</strong> Let's go back to the module <code>FandC</code>, which we considered above. By
applying the substitution approach several times, we transform <code>Next</code> in
several steps as follows:</p>
<p>First, by substituting the body of <code>UpdateCelsius</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' = Max(ABSOLUTE_ZERO_IN_CELCIUS, Fahrenheit2Celcius(fahrenheit'))
</code></pre>
<p>Second, by substituting the body of <code>Max</code>:</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= Fahrenheit2Celcius(fahrenheit')
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE Fahrenheit2Celcius(fahrenheit')
</code></pre>
<p>Third, by substituting the body of <code>Fahrenheit2Celcius</code> (twice):</p>
<pre><code class="language-tla">  Next ==
      /\ fahrenheit' \in -1000..1000
      /\ celcius' =
          IF ABSOLUTE_ZERO_IN_CELCIUS &gt;= (fahrenheit' - 32) * 10 / 18
          THEN ABSOLUTE_ZERO_IN_CELCIUS
          ELSE (fahrenheit' - 32) * 10 / 18
</code></pre>
<p>You could notice that we applied beta reduction syntactically from top to
bottom, like peeling an onion. We could do it in another direction: First
starting with the application of <code>Fahrenheit2Celcius</code>. This actually does not
matter, as long as our goal is to produce a TLA+ expression that is free of
user-defined operators. For instance, <a href="https://apalache.informal.systems">Apalache</a> applies <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion">Alpha conversion</a> and
<a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction">Beta reduction</a> to remove user-defined operator and then translates the TLA+
expression to SMT.</p>
<h1><a class="header" href="#let-in-operator-definitions" id="let-in-operator-definitions">LET-IN operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#higher-order-operator-definitions" id="higher-order-operator-definitions">Higher-order operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#anonymous-operator-definitions" id="anonymous-operator-definitions">Anonymous operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#recursive-operator-definitions" id="recursive-operator-definitions">Recursive operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#local-operator-definitions" id="local-operator-definitions">Local operator definitions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#recursive-functions-1" id="recursive-functions-1">Recursive functions</a></h1>
<p>work in progress...</p>
<p><a href="lang/user/./user-operators.html">[Back to user operators]</a></p>
<h1><a class="header" href="#idiomatic-tla" id="idiomatic-tla">Idiomatic TLA+</a></h1>
<p><strong>Authors:</strong> Shon Feder, Igor Konnov + (who likes to contribute?)</p>
<p><em>This document is under construction.
If you like to contribute, open a pull request.</em></p>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>In this document, we collect specification idioms that aid us in writing TLA+
specifications that are:</p>
<ol>
<li>understood by distributed system engineers,</li>
<li>understood by verification engineers, and</li>
<li>understood by automatic analysis tools such as the Apalache model checker.</li>
</ol>
<p>If you believe, that the above points are contradictory when put together, it is
to some extent true. TLA+ is an extremely general specification language. As a
result, it is easy to write a short specification that leaves a human reader
puzzled . It is even easier to write a (syntactically correct) specification that
turns any program trying to reason about TLA+ to dust.</p>
<p>Nevertheless, we find TLA+ quite useful when writing concise specifications of
distributed protocols at <a href="https://informal.systems">Informal Systems</a>. Other specification languages --
especially, those designed for software verification -- would require us to
introduce unnecessary book-keeping details that would both obfuscate the
protocols and make their verification harder. However, we do not always need
<em>&quot;all the power of mathematics&quot;</em>, so we find it useful to introduce additional
structure in TLA+ specifications.</p>
<p>Below, we summarize the idioms that help us in maintaining that structure.  As
a bonus, these idioms usually aid the Apalache model checker in analyzing the
specifications. Our idioms are quite likely different from the original ideas
of <a href="https://lamport.azurewebsites.net/">Leslie Lamport</a> (the author of TLA+).
So it is useful to read Lamport's <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>. Importantly, these are
<em>idioms</em>, not rules set in stone. If you believe that one of those idioms
does not work for you in your specific setting, don't follow it.</p>
<p>If this is the first page where you encounter the word &quot;TLA+&quot;, we do not
recommend that you continue to read the material. It is better to start with <a href="http://lamport.azurewebsites.net/video/videos.html">The TLA+
Video Course</a> by Leslie
Lamport.  Once you have understood the basics and tried the language, it makes
sense to ask the question: &quot;How do I write a specification that other people
understand?&quot;.  We believe that many TLA+ users reinvent rules that are
similar to our idioms.  By providing you with a bit of guidance, we hope to
reduce your discomfort when learning more advanced TLA+.</p>
<h2><a class="header" href="#the-idioms" id="the-idioms">The idioms</a></h2>
<p><strong>Idiom 0:</strong>
<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the minimum</a> üîã</p>
<p><strong>Idiom 1:</strong> <a href="idiomatic/001assignments.html">Update state variables with assignments</a> üìÖ</p>
<p><strong>Idiom 2:</strong> <a href="idiomatic/002primes.html">Apply primes only to state variables</a> üìå</p>
<p><strong>Idiom 3:</strong> Isolate updates to VARIABLES üëª</p>
<p><strong>Idiom 4:</strong> Isolate non-determinism in actions üîÆ</p>
<p><strong>Idiom 5:</strong> Introduce pure operators üôà</p>
<p><strong>Idiom 6:</strong> Introduce a naming convention for operator parameters üõÇ</p>
<p><strong>Idiom 7:</strong> Use Boolean operators in actions, not <code>IF-THEN-ELSE</code> üôÖ</p>
<p><strong>Idiom 8:</strong> <code>CHOOSE</code> smart, prefer <code>\E</code> üíÇ‚Äç‚ôÇ</p>
<p><strong>Idiom 9:</strong> Do not over-structure üî¨</p>
<p><strong>Idiom 10:</strong> Do not over-modularize ü¶Ü</p>
<p><strong>Idiom 11:</strong> Separate normal paths from error paths. ‚ö°</p>
<p><strong>Idiom 12:</strong> Do you really need those nice recursive operators? üåÄ</p>
<p><strong>Idiom 13:</strong> Do you really need set cardinalities? üçï</p>
<p><strong>Idiom 14:</strong> Do you really need integers? üî¢</p>
<h1><a class="header" href="#idiom-0-keep-state-variables-to-the-minimum" id="idiom-0-keep-state-variables-to-the-minimum">Idiom 0: Keep state variables to the minimum</a></h1>
<p>In imperative programming, it is common to use mutable variable assignments liberally, but to exercise caution whenever mutable variables have a global scope. In TLA+, mutable variables are always global, so it is important to use them carefully and in a way that accurately reflects the global state of the system you are specifying.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p><em>A good TLA+ specification minimizes the computation state and makes it visible</em>.</p>
<p>TLA+ does not have special syntax for variable assignment.  For a good
reason. The power of TLA+ is in writing constraints on variables rather than in
writing detailed commands. If you have been writing in languages such as C, C++,
Java, Python, your first reflex would be to define a variable to store the
intermediate result of a complex computation.</p>
<p>In programming languages, we introduce temporary variables for several reasons:</p>
<ol>
<li>To avoid repetitive computations of the same expression,</li>
<li>To break down a large expression into a series of smaller expressions,</li>
<li>To make the code concise.</li>
</ol>
<p>Point 1 is a non-issue in TLA+, as it is mostly executed in the reader's brain,
and people are probably less efficient in caching expressions than computers.
Points 2 and 3 can be nicely addressed with LET-definitions in TLA+. Hence,
there is no need for auxiliary variables.</p>
<p>Usually, we should minimize the specification state, that is, the scope of the data
structures that are declared with <code>VARIABLES</code>. It does not mean that one variable
is always better than two. It means that what is stored in <code>VARIABLES</code> should be
absolutely necessary to describe the computations or the observed properties.</p>
<h2><a class="header" href="#advantages" id="advantages">Advantages</a></h2>
<p>By avoiding auxiliary state variables, we localize the updates to the state.
This improves specification readability. It also helps the tools, as large parts
of the specification become deterministic.</p>
<h2><a class="header" href="#disadvantages" id="disadvantages">Disadvantages</a></h2>
<p>Sometimes, we have to expose the internals of the computation. For instance,
if we want to closely monitor the values of the computed expressions, when using
the specification for model-based testing.</p>
<p>Sometimes, we have to break this idiom to make the specification more readable. Here is an example by Markus Kuppe. The specification of <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueueSplit.tla#L16-L51">BlockingQueue</a> that has one more variable is easier to read than <a href="https://github.com/lemmy/BlockingQueue/blob/3a66f46f6f5703f2863f71baaf0aedaaee58836f/BlockingQueue.tla">the original specification</a> with a minimal number of variables.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Consider the following implementation of <a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble sort</a> in Python:</p>
<pre><code class="language-python">    my_list = [5, 4, 3, 8, 1]
    finished = False
    my_list_len = len(my_list)  # cache the length
    while not finished:
        finished = True
        if my_list_len &gt; 0:
            prev = my_list[0]       # save the first element to use in the loop
        for i in range(1, my_list_len):
            current = my_list[i]
            if prev &lt;= current:
                # save current for the next iteration
                prev = current
            else:
                # swap the elements
                my_list[i - 1] = current
                my_list[i] = prev
                finished = False
</code></pre>
<p>Notice that we have introduced three local variables to optimize the code:</p>
<ul>
<li><code>my_list_len</code> to cache the length of the list,</li>
<li><code>prev</code> to cache the previously accessed element of the list,
in order to minimize the number of list accesses,</li>
<li><code>current</code> to cache the iterated element of the list.</li>
</ul>
<p>In TLA+, one usually does not introduce local variables for the intermediate
results of the computation, but rather introduces variables to represent the
essential part of the algorithm state. (While we have spent some time on code
optimization, we might have missed the fact that our sorting algorithm is not
as good as <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a>.) In the above example, the essential variables are
<code>finished</code> and <code>my_list</code>.</p>
<p>Compare the above code to (a slightly more abstract) <a href="idiomatic/./example/bubble.tla">bubble sort in
TLA+</a>:</p>
<pre><code class="language-tla">EXTENDS Integers, Sequences

in_list == &lt;&lt;5, 4, 3, 8, 1&gt;&gt;
VARIABLES my_list, finished

Init ==
    /\ my_list = in_list
    /\ finished = FALSE

IsSorted(lst) ==
    \A i \in DOMAIN lst \ {1}:
        lst[i - 1] &lt;= lst[i]

WhenSorted ==
    /\ IsSorted(my_list)
    /\ finished' = TRUE
    /\ UNCHANGED my_list

WhenUnsorted ==
    /\ \E i \in DOMAIN my_list \ {1}:
        /\ my_list[i - 1] &gt; my_list[i]
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
    /\ finished' = FALSE

Next ==
    IF finished
    THEN UNCHANGED &lt;&lt;my_list, finished&gt;&gt;
    ELSE WhenSorted \/ WhenUnsorted

</code></pre>
<p>Our TLA+ code contains only two state variables: <code>my_list</code> and <code>finished</code>.
Other variables are introduced by quantifiers (e.g., <code>\E i \in ...</code>).
The state variables are not updated in the sense of programming languages.
Rather, one writes constraints over unprimed and primed versions, e.g.:</p>
<pre><code class="language-tla">        ...
        /\ my_list' = [my_list EXCEPT ![i - 1] = my_list[i],
                                      ![i] = my_list[i - 1]]
</code></pre>
<p>Of course, one can introduce aliases for intermediate expressions, for instance,
by using let-definitions:</p>
<pre><code class="language-tla">        ...
        LET prev == my_list[i - 1]
            current == my_list[i]
        IN
        /\ prev &gt; current
        /\ my_list' = [my_list EXCEPT ![i - 1] = current, ![i] = prev]
</code></pre>
<p>However, the let-definitions are not variables, they are just aliases for more
complex expressions. Importantly, one cannot update the value of an expression
that is defined with a let-definition. In this sense, TLA+ is similar to
functional languages, where side effects are carefully avoided and minimized.</p>
<p>In contrast to functional languages, the value of TLA+ is not in computing
the result of a function application, but in producing sequences of states
(called behaviors). Hence, some parts of a useful TLA+ specification should have side effects to record the states.</p>
<h1><a class="header" href="#idiom-1-update-state-variables-with-assignments" id="idiom-1-update-state-variables-with-assignments">Idiom 1: Update state variables with assignments</a></h1>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The idiom &quot;<a href="idiomatic/000keep-minimum-state-variables.html">Keep state variables to the
minimum</a>&quot; tells us to store the minimum
necessary state variables. By following this idiom, we develop
the specification by writing constraints over the primed variables.</p>
<p>TLA+ comes with a great freedom of expressing constraints over variables.
While we love TLA+ for that freedom, we believe that constraints over primed
variables are sometimes confusing.
TLA+ uses the same glyph, <code>=</code> for three separate purposes: assignment, asserting equality, and binding variables. But these are very different operations and have different semantics.</p>
<h3><a class="header" href="#issue-1" id="issue-1">Issue 1</a></h3>
<p><strong>tl;dr:</strong> Use <code>:=</code> (supplied by the <code>Apalache.tla</code> module) instead of <code>=</code> for assignment.</p>
<p>Consider the expression:</p>
<pre><code class="language-tla">  x' = x + 1
</code></pre>
<p>It is all clear here. The value of <code>x</code> in the next states (there may be many)
is equal to <code>val(x)+1</code>, where <code>val(x)</code> is the value of <code>x</code> in the current
state.</p>
<p>Wait. Is it clear? What if that expression was just the first line of the following
expression:</p>
<pre><code class="language-tla">  x' = x + 1
    =&gt; x' = 3
</code></pre>
<p>This says, &quot;if <code>x'</code> is equal to <code>x + 1</code>, then assign the value of <code>3</code> to <code>x'</code> in the next state&quot;, which
implies that <code>x'</code> may receive a value from the set:</p>
<pre><code class="language-tla">  { 3 } \union { y \in Int: y /= val(x) + 1 }
</code></pre>
<p>But maybe the author of that specification just made a typo and never
meant to put the implication <code>=&gt;</code> in the first place. Actually, the intended
specification looks like follows:</p>
<pre><code class="language-tla">  x' = x + 1
    \/ x' = 3
</code></pre>
<p>We believe that it is helpful to label the expressions that intend to denote the
values of the state variables in the next state. Apalache introduces the infix
operator <code>:=</code> in the module <code>Apalache.tla</code> for that purpose:</p>
<pre><code class="language-tla">  x' := x + 1
    \/ x' := 3
</code></pre>
<p>Hence, it would be obvious in our motivating example that the author made a typo:</p>
<pre><code class="language-tla">  x' := x + 1
    =&gt; x' := 3
</code></pre>
<p>because the assignment <code>x' := x + 1</code> does not express a boolean value
and so cannot be the antecedent of the conditional.</p>
<h3><a class="header" href="#issue-2" id="issue-2">Issue 2</a></h3>
<p><strong>tl;dr:</strong> Use existential variables with the <code>:=</code> operator for non-deterministic assignment.</p>
<p>Another common use of primed variables is to select the next value of a variable
from a set:</p>
<pre><code class="language-tla">  x' \in { 1, 2, 3 }
</code></pre>
<p>This expression can be rewritten as an equivalent one:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' = y
</code></pre>
<p>Which one to choose? The first one is more concise. The second one highlights
the important effect, namely, non-deterministic choice of the next value of <code>x</code>.
When combined with the operator <code>:=</code>, the effect of non-deterministic choice is
clearly visible:</p>
<pre><code class="language-tla">  \E y \in { 1, 2, 3 }:
    x' := y
</code></pre>
<p>In fact, every constraint over primes can be translated into the existential form.
For instance, consider the expression:</p>
<pre><code class="language-tla">  x' * x' = 4
</code></pre>
<p>It can be written as:</p>
<pre><code class="language-tla">  \E y \in Int:
    /\ y * y = 4
    /\ x' := y
</code></pre>
<h2><a class="header" href="#advantages-1" id="advantages-1">Advantages</a></h2>
<ul>
<li>
<p>The reader clearly sees the writer's intention about the updates
to the primed variables.</p>
</li>
<li>
<p>Non-determinism is clearly isolated in existential choice: <code>\E y \in S: x' := y</code>.
If there is no existential choice, the assignment is deterministic.</p>
</li>
<li>
<p>When the existential form is used, the range of the values is clearly indicated.
This is in contrast to the negated form such as: <code>~(x' = 10)</code>.</p>
</li>
<li>
<p>TLC treats the expressions of the form <code>x' = e</code> and <code>x' \in S</code> as assignments,
as long as <code>x'</code> is not bound to a value.</p>
</li>
<li>
<p>Apalache uses assignments to decompose the specification into smaller pieces.
Although Apalache tries to find assignments automatically, it often has to choose
from several expressions, some of them may be more complex than the others. By using
the <code>:=</code> operator, Apalache gets unambiguous instructions about when assignment is taking
place</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-1" id="disadvantages-1">Disadvantages</a></h2>
<ul>
<li>Replacing <code>x' \in S</code> with <code>\E y \in S: x' := y</code> makes the specification a bit larger.</li>
</ul>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>The following example <a href="idiomatic/./example/deliver.tla">deliver.tla</a> demonstrates how
one can clearly mark assignments using the <code>:=</code> operator.</p>
<pre><code class="language-tla">------------------------------ MODULE deliver ----------------------------------
(*
 * A simple specification of two processes in the network: sender and receiver.
 * The sender sends messages in sequence. The receiver may receive the sent
 * messages out of order, but delivers them to the client in order.
 *
 * Igor Konnov, 2020
 *)
EXTENDS Integers, Apalache

VARIABLES
    sentSeqNo,      \* the sequence number of the next message to be sent
    sent,           \* the messages that are sent by the sender
    received,       \* the messages that are received by the receiver
    deliveredSeqNo  \* the sequence number of the last delivered message
(* We assign to the unprimed state variables to set their initial values. *)
Init ==
    /\ sentSeqNo := 0
    /\ sent := {}
    /\ received := {}
    /\ deliveredSeqNo := -1

(* Subsequent assignments are all to primed variables, designating changed values
   after state transition. *)
Send ==
    /\ sent' := sent \union {sentSeqNo}
    /\ sentSeqNo' := sentSeqNo + 1
    /\ UNCHANGED &lt;&lt;received, deliveredSeqNo&gt;&gt;

Receive ==
    (* We make the nonderministic assignment explicit, by use of existential quantification *)
    /\ \E msgs \in SUBSET (sent \ received):
        received' := received \union msgs
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, deliveredSeqNo&gt;&gt;

Deliver ==
    /\ (deliveredSeqNo + 1) \in received
    /\ deliveredSeqNo' := deliveredSeqNo + 1
        \* deliver the message with the sequence number deliveredSeqNo'
    /\ UNCHANGED &lt;&lt;sentSeqNo, sent, received&gt;&gt;

Next ==
    \/ Send
    \/ Receive
    \/ Deliver

Inv ==
    (deliveredSeqNo &gt;= 0) =&gt; deliveredSeqNo \in sent
================================================================================
</code></pre>
<h1><a class="header" href="#idiom-2-apply-primes-only-to-state-variables" id="idiom-2-apply-primes-only-to-state-variables">Idiom 2: Apply primes only to state variables</a></h1>
<p>(<em>Until you learn how prime actually works!</em>)</p>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>In many formal languages, the notation <code>x'</code> denotes the value that a variable
<code>x</code> has after the system has fired a transition. The reason for having both <code>x</code>
and <code>x'</code> is that the transitions are often described as relations over unprimed
and primed variables, e.g., <code>x' = x+1</code>. It is easy to extend this idea to
vectors of variables, but for simplicity we will use only one variable.</p>
<p>TLA+ goes further and declares prime (<code>'</code>) as an operator! This operator distributes over
any state variables in the scope of its application. For example, assume that we
evaluate a TLA+ expression <code>A</code> over <code>x</code> and <code>x'</code>, and <code>v[i]</code> and <code>v[i+1]</code> are
meant to be the values of <code>x</code> in the ith state and i+1-th state, respectively.
Then <code>x</code> is evaluated to <code>v[i]</code> and <code>x'</code> is evaluated to <code>v[i+1]</code>.  Naturally,
<code>x + 3</code> is evaluated to <code>v[i] + 3</code>, whereas <code>x' + 4</code> is evaluated to <code>v[i+1] + 4</code>. We can go further and evaluate <code>(x + 4)'</code>, which can be rewritten as <code>x' + 4</code>.</p>
<p>Intuitively, there is nothing wrong with the operator &quot;prime&quot;. However, you
have to understand this operator well, in order to use it right. For starters, check
the warning by Leslie Lamport in <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a> on page 82. The following
example illustrates the warning:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3 ------------------------------------
(* Model a system of three processes, each one equipped with a logical clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

\* a shortcut to refer to the clock of the process that is taking the step
MyClock == clocks[turn]
\* a shortcut to refer to the processes that are not taking the step
Others == DOMAIN clocks \ {turn}

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes (the section Example shows a better way)
    /\ \E f \in [1..3 -&gt; Int]:
        clocks' := f
    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<p>Did you spot a problem in the above example? If not, check these lines again:</p>
<pre><code class="language-tla">    \* increment the clock of the process that is taking the step
    /\ MyClock' = MyClock + 1
</code></pre>
<p>The code does not match the comment. By writing <code>MyClock'</code>, we get
<code>(clocks[turn])'</code> that is equivalent to <code>clocks'[turn']</code>. So our constraint
says: Increment the clock of the process that is taking the next step.  By
looking at the next constraint, we can see that <code>Next</code> can never be evaluated
to true (a logician would say that <code>Next</code> is &quot;unsatisfiable&quot;):</p>
<pre><code class="language-tla">    \* all clocks of the other processes keep their clock values
    /\ \A i \in Others:
        clocks'[i] = clocks[i]
</code></pre>
<p>Our intention was to make the specification easier to read, but instead we have
introduced a deadlock in the system. In a larger specification, this bug would be
much harder to find.</p>
<p>We recommend to follow this simple rule: <em>Apply primes only to state variables</em></p>
<p>Can we remove the &quot;prime&quot; operator altogether and agree to use <code>x</code> and <code>x'</code> as
names of the variables? Not really. More advanced features of TLA+ require this
operator.  In a nutshell, TLA+ is built around the idea of refinement, that is,
replacing an abstract specification with a more detailed one. Concretely, this
idea is implemented by module instances in TLA+. It often happens that
refinement requires us to replace a state variable of the abstract
specification with an operator of the detailed specification.  Voil√†. You have
to apply prime to an expression. For the details,
see Chapter 5 and pages 312-313 of <a href="http://lamport.azurewebsites.net/tla/book.html">Specifying Systems</a>.</p>
<h2><a class="header" href="#advantages-2" id="advantages-2">Advantages</a></h2>
<ul>
<li>
<p>It is easy to see, whether the specification author intended to talk about
the variables in the next state or about the variable in the current state.</p>
</li>
<li>
<p>It is harder to make an unexpected substitution mistake, as in the above
example.</p>
</li>
</ul>
<h2><a class="header" href="#disadvantages-2" id="disadvantages-2">Disadvantages</a></h2>
<ul>
<li>Sometimes, the operator &quot;prime&quot; helps us in avoiding code duplication.
For instance, you can write a state invariant <code>Inv</code> and later evaluate it
against a next state by simply writing <code>Inv'</code>. However, you have to be
careful about propagation of primes in <code>Inv</code>.</li>
</ul>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<p>A better version of the <code>clocks</code> example applies prime only to state variables.
By doing so, we notice that the specification can be further simplified:</p>
<pre><code class="language-tla">--------------------------- MODULE clocks3_2 ----------------------------------
(* Model a system of three processes, each one equipped with a digital clock *)
EXTENDS Integers, Apalache
VARIABLES clocks, turn

Init ==
    /\ clocks := [p \in 1..3 |-&gt; 0]  \* initialize the clocks with 0
    /\ turn := 1                     \* process 1 makes the first step

Next ==
    \* update the clocks of the processes
    /\ clocks' :=
        [p \in 1..3 |-&gt;
            IF p = turn THEN clocks[turn] + 1 ELSE clocks[p]]
    \* use round-robin to decide who makes the next step
    /\ turn' := 1 + (turn + 1) % 3
===============================================================================
</code></pre>
<h1><a class="header" href="#adr-002-types-and-type-annotations" id="adr-002-types-and-type-annotations">ADR-002: types and type annotations</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Shon Feder, Igor Konnov, Jure Kukovec</td><td align="right">4</td></tr>
</tbody></table>
<p>This is a follow up of
<a href="https://github.com/informalsystems/apalache/blob/unstable/docs/internal/rfc/001rfc-types.md">RFC-001</a>, which discusses
plenty of alternative solutions. In this <strong>ADR-002</strong>, we fix one solution that seems to be most suitable. The
interchange format for the type inference tools will be discussed in a separate ADR.</p>
<ol>
<li>How to write types in TLA+ (Type System 1).</li>
<li>How to write type annotations (as a user).</li>
</ol>
<p>This document assumes that one can write a simple type checker that computes
the types of all expressions based on the annotations provided by the user.
Such an implementation is provided by the type checker Snowcat.
See the <a href="adr/../apalache/typechecker-snowcat.html">manual chapter</a> on Snowcat.</p>
<p>In contrast, the <a href="https://github.com/informalsystems/apalache/tree/types">type inference
algorithm</a> by @Kukovec
is fully automatic and thus it eliminates the need for type annotations.
Jure's algorithm is using Type System 1 too. The type inference algorithm
is still in the prototype phase.</p>
<p>System engineers often want to write type annotations and quickly check types
when writing TLA+ specifications. This document is filling this gap.</p>
<h2><a class="header" href="#1-how-to-write-types-in-tla" id="1-how-to-write-types-in-tla">1. How to write types in TLA+</a></h2>
<h3><a class="header" href="#11-type-grammar-type-system-1-or-ts1" id="11-type-grammar-type-system-1-or-ts1">1.1. Type grammar (Type System 1, or TS1)</a></h3>
<p>We simply write types as strings that follow the type grammar:</p>
<pre><code>T ::=   Bool | Int | Str
      | T -&gt; T
      | Set(T)
      | Seq(T)
      | &lt;&lt;T, ..., T&gt;&gt;
      | [field: T, ..., field: T]
      | (T, ..., T) =&gt; T
      | typeConst
      | typeVar
      | (T)

field     ::= &lt;an identifier that matches [a-zA-Z_][a-zA-Z0-9_]*&gt;

typeConst ::= &lt;an identifier that matches [A-Z_][A-Z0-9_]*&gt;

typeVar   ::= &lt;a single letter from [a-z]&gt;
</code></pre>
<p>The type rules have the following meaning:</p>
<ul>
<li>The rules <code>Bool</code>, <code>Int</code>, <code>Str</code> produce primitive types:
the Boolean type, the integer type, and the string type, respectively.</li>
<li>The rule <code>T -&gt; T</code> produces a function.</li>
<li>The rule <code>Set(T)</code> produces a set type over elements of type <code>T</code>.</li>
<li>The rule <code>Seq(T)</code> produces a sequence type over elements of type <code>T</code>.</li>
<li>The rule <code>&lt;&lt;T, ..., T&gt;&gt;</code> produces a tuple type over types that
are produced by <code>T</code>. <em>Types at different positions may differ</em>.</li>
<li>The rule <code>[field: T, ..., field: T]</code> produces a record type over types that
are produced by <code>T</code>. <em>Types at different positions may differ</em>.</li>
<li>The rule <code>(T, ..., T) =&gt; T</code> defines an operator whose result type and parameter types are produced by <code>T</code>.</li>
<li>The rule <code>typeConst</code> defines an uninterpreted type (or a reference to a type alias), look for an explanation below.</li>
<li>The rule <code>typeVar</code> defines a type variable, look for an explanation below.</li>
</ul>
<p>Importantly, a multi-argument function always receives a tuple, e.g., <code>&lt;&lt;Int, Bool&gt;&gt; -&gt; Int</code>, whereas a single-argument function receives the type of its
argument, e.g., <code>Int -&gt; Int</code>.  The arrow <code>-&gt;</code> is right-associative, e.g., <code>A -&gt; B -&gt; C</code> is understood as <code>A -&gt; (B -&gt; C)</code>, which is consistent with programming
languages. If you like to change the priority of <code>-&gt;</code>, use parentheses, as
usual.  For example, you may write <code>(A -&gt; B) -&gt; C</code>.</p>
<p>An operator always has the types of its arguments inside <code>(...)</code>, e.g., <code>(Int, Bool) =&gt; Int</code> and <code>() =&gt; Bool</code>. If a
type <code>T</code> contains a type variable, e.g.,
<code>a</code>, then <code>T</code> is a polymorphic type, in which <code>a</code> can be instantiated with a monotype (a variable-free term). Type
variables are useful for describing the types of polymorphic operators. Although the grammar accepts an operator type
that returns an operator, e.g., <code>Int =&gt; (Int =&gt; Int)</code>, such a type does not have a meaningful interpretation in TLA+.
Indeed, TLA+ does not allow operators to return other operators.</p>
<p>A type constant should be understood as a type we don't know and we don't want to know, that is, an uninterpreted type.
Type constants are useful for fixing the types of CONSTANTS and using them later in a specification. Two different type
constants correspond to two different -- yet uninterpreted -- types. If you
know <a href="https://github.com/Z3Prover/z3">Microsoft Z3</a>, a type constant can be understood as an uninterpreted sort in SMT.
Essentially, values of an uninterpreted type can be only checked for equality.</p>
<p>Another use for a type constant is referring to a type alias, see <a href="adr/002adr-types.html#defTypeAlias">Section 1.2</a>. This is purely a
convenience feature to make type annotations more concise and easier to maintain. We expect that only users will write
type aliases: tools should always exchange data with types in the alias-free form.</p>
<p><strong>Examples.</strong></p>
<ul>
<li><code>x</code> is an integer. Its type is <code>Int</code>.</li>
<li><code>f</code> is a function from an integer to an integer. Its type is <code>Int -&gt; Int</code>.</li>
<li><code>f</code> is a function from a set of integers to a set of integers.
Its type is <code>Set(Int) -&gt; Set(Int)</code>.</li>
<li><code>r</code> is a record that has the fields <code>a</code> and <code>b</code>, where <code>a</code> is an integer
and <code>b</code> is a string. Its type is <code>[a: Int, b: Str]</code>.</li>
<li><code>F</code> is a set of functions from a pair of integers to an integer.
Its type is <code>Set(&lt;&lt;Int, Int&gt;&gt; -&gt; Int)</code>.</li>
<li><code>Foo</code> is an operator of an integer and of a string that returns an integer.
Its type is  <code>(Int, Str) =&gt; Int</code>.</li>
<li><code>Bar</code> is a higher-order operator that takes an operator that takes
an integer and a string and returns an integer, and returns a Boolean.
Its type is  <code>((Int, Str) =&gt; Int) =&gt; Bool</code>.</li>
<li><code>Baz</code> is a polymorphic operator that takes two arguments of the same type
and returns a value of the type equal to the types of its arguments.
Its type is <code>(a, a) =&gt; a</code>.</li>
<li><code>Proc</code> and <code>Faulty</code> are sets of the same type.
Their type is <code>Set(PID)</code>.</li>
</ul>
<p><a id="defTypeAlias"></a></p>
<h3><a class="header" href="#12-type-aliases" id="12-type-aliases">1.2. Type aliases</a></h3>
<p>The grammar of <code>T</code> includes one more rule for defining a type alias:</p>
<pre><code>A ::= typeConst &quot;=&quot; T
</code></pre>
<p>This rule binds a type (produced by <code>T</code>) to a name (produced by <code>typeConst</code>). As you can see from the definition
of <code>typeConst</code>, the name should be an identifier in the upper case. The type checker should use the bound type instead
of the constant type. For examples, see <a href="adr/002adr-types.html#useTypeAlias">Section 2.4</a>.</p>
<p><a id="comments"></a></p>
<h3><a class="header" href="#13-comments-inside-types" id="13-comments-inside-types">1.3. Comments inside types</a></h3>
<p>When you introduce records that have dozens of fields, it is useful to explain
those fields right in the type annotations. For that reason, the type lexer
supports one-line comments right in the type definitions. The following
text presents a type definition that contains comments:</p>
<pre><code>// packets are stored in a set
Set([
  // unique sequence number
  seqno: Int,
  // payload hash
  payloadHash: Str
])
</code></pre>
<p>The parser only supports one-line comments that starts with <code>//</code>. Since type
annotations are currently written inside TLA+ comments, we feel that more
complex comments would complicate the matters.</p>
<h3><a class="header" href="#14-discussion" id="14-discussion">1.4. Discussion</a></h3>
<p>Our type grammar presents a minimal type system that, in our understanding,
captures all interesting cases that occur in practice. Obviously, this type
system considers ill-typed some perfectly legal TLA+ values. For instance, we
cannot assign a reasonable type to <code>{1, TRUE}</code>. However, we can assign a
reasonable type to <code>{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1], [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}</code>, a pattern that often occurs in practice, e.g., see
<a href="https://github.com/tlaplus/Examples/blob/master/specifications/Paxos/Paxos.tla">Paxos</a>.
The type of that set will be <code>Set([type: Str, bal: Int, val: Int])</code>, which is
probably not what you expected, but it is the best type we can actually compute
without having algebraic datatypes in TLA+. It also reminds the user that one
better tests the field <code>type</code> carefully.</p>
<p>Type System 1 is also very much in line with the <a href="https://dblp.org/search?q=Automatic+Verification+of+%7BTLA%7D+%2B+Proof+Obligations+with+%7BSMT%7D+Solvers">type system by Stephan Merz and Hernan Vanzetto</a>
, which is used internally by
<a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">TLAPS</a> when translating proof obligations in SMT. We introduce
types for user-defined operators, on top of their types for TLA+ expressions that do not contain user-defined operators.</p>
<p>We expect that this type system will evolve in the future. That is why we call it <strong>Type System 1</strong>. Feel free to
suggest <strong>Type System 2</strong> :-)</p>
<p><strong>Note:</strong> For the above example of a set of records, we are considering to introduce union types. So the type of the set</p>
<pre><code class="language-tla">{[type |-&gt; &quot;1a&quot;, bal |-&gt; 1],
 [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3]}
</code></pre>
<p>would be something like:</p>
<pre><code class="language-tla">Set([type |-&gt; &quot;1a&quot;], bal |-&gt; 1]
  + [type |-&gt; &quot;2a&quot;, bal |-&gt; 2, val |-&gt; 3])
</code></pre>
<p>The value of the field <code>type</code> would serve as a type tag. However, we would have to fix a set of patterns that turn a
union type into a precise record type. One such pattern is a set comprehension, e.g., <code>{ r \in S: r.type = &quot;1a&quot; }</code>. If
you have suggestions on this line of thought, please let us know.</p>
<h2><a class="header" href="#2-how-to-write-type-annotations-as-a-user" id="2-how-to-write-type-annotations-as-a-user">2. How to write type annotations (as a user)</a></h2>
<p>In the following, we discuss how to annotate different TLA+ declarations.</p>
<p><em>In the previous version of this document, we defined two operators:
<code>AssumeType(_, _)</code> and <code>_ ## _</code>. They are no longer needed as we have introduced <a href="adr/./004adr-annotations.html">Code annotations</a>.</em></p>
<h3><a class="header" href="#21-annotating-constants-and-variables" id="21-annotating-constants-and-variables">2.1. Annotating CONSTANTS and VARIABLES</a></h3>
<p>Simply write an annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the declaration of a constant declaration or
a variable. See the following example:</p>
<pre><code class="language-tla">CONSTANT
  \* @type: Int;
  N,
  \* @type: Set(ID);
  Base

VARIABLE
  \* @type: ID;
  x,
  \* @type: Set(ID);
  S
</code></pre>
<p><strong>Why don't we use THEOREMs?</strong> It is tempting to declare the types of variables
as theorems. For example:</p>
<pre><code class="language-tla">THEOREM N &lt;: &quot;Int&quot;
</code></pre>
<p>However, this theorem must be proven. A <em>type inference engine</em> would be able
to infer the type of <code>N</code> and thus state such a theorem. However, with type
assumptions, the user merely states the variable types and the <em>type checker</em>
has a simple job of checking type consistency and finding the types of the
expressions.</p>
<h2><a class="header" href="#22-annotating-operators" id="22-annotating-operators">2.2. Annotating operators</a></h2>
<p>Again, write a type annotation <code>@type: &lt;your type&gt;;</code> in a comment that precedes the operator declaration. For example:</p>
<pre><code class="language-tla">\* @type: (a, Seq(a)) =&gt; Bool;
Mem(e, es) ==
    (e \in {es[i]: i \in DOMAIN es})
</code></pre>
<p>Higher-order operators are also easy to annotate:</p>
<pre><code class="language-tla">\* @type: ((a) =&gt; Bool, Seq(a)) =&gt; Int;
Find(Pred(_), es) ==
    IF \E i \in DOMAIN es: Pred(es[i])
    THEN CHOOSE i \in DOMAIN es: Pred(es[i])
    ELSE -1
</code></pre>
<p>The following definition declares a (global) recursive function, not an
operator. However, the annotation syntax is quite similar to that of the
operators (note though that we are using <code>-&gt;</code> instead of <code>=&gt;</code>):</p>
<pre><code class="language-tla">\* @type: Set(a) -&gt; Int;
Card[S \in T] ==
    IF S = {}
    THEN 0
    ELSE LET \* @type: a;
             \* we could also write: &quot;() =&gt; a&quot; instead of just &quot;a&quot;
             one_elem == (CHOOSE x \in S: TRUE)
         IN
         1 + Card[S \ {one_elem}]
</code></pre>
<p>In the definition of <code>Card</code>, we annotated the let-definition <code>one_elem</code> with its type, though any type checker should be
able to compute the type of
<code>one_elem</code> from its context. So the type of <code>one_elem</code> is there for clarification. According to our type grammar, the
type of <code>one_elem</code> should be
<code>() =&gt; a</code>, as <code>one_elem</code> is an operator. It is not obvious from the syntax:
TLA+ blends in nullary operators with other names. We have found that LET-definitions without arguments are so common,
so it is more convenient to write the shorter type annotation, that is, just <code>a</code>.</p>
<h3><a class="header" href="#23-dealing-with-bound-variables" id="23-dealing-with-bound-variables">2.3. Dealing with bound variables</a></h3>
<p>A number of TLA+ operators are defining bound variables. Following <a href="https://lamport.azurewebsites.net/tla/summary.pdf">TLA+
Summary</a>, we list these
operators here (we omit the unbounded quantifiers and temporal quantifiers):</p>
<ul>
<li><code>\A x \in S: P</code></li>
<li><code>\E x \in S: P</code></li>
<li><code>CHOOSE x: P</code></li>
<li><code>{x \in S: P}</code></li>
<li><code>{e: x \in S}</code></li>
<li><code>[x \in S |-&gt; e}</code></li>
</ul>
<p>We do not introduce any special annotation to support these operators. Indeed, they are all introducing bound variables
that range over sets. In most cases, the type checker should be able to extract the element type from a set expression.</p>
<p>However, there are a few pathological cases arising from empty collections. For example:</p>
<pre><code class="language-tla">/\ \E x \in {}: x &gt; 1
/\ f = [x \in {} |-&gt; 2]
/\ z \in DOMAIN &lt;&lt; &gt;&gt;
</code></pre>
<p>Similar typing issues occur in programming languages, e.g., Scala and Java. In these rare cases, you can write an
auxiliary LET-definition to specify the type of the empty collection:</p>
<pre><code class="language-tla">/\ LET \* @type: Set(Int);
       EmptyInts == {}
   IN
   \E x \in EmptyInts: x &gt; 1
/\ LET \* @type: Set(Str);
       EmptyStrings == {}
   IN
   f = [x \in EmptyStrings |-&gt; 2]
/\ LET \* @type: Seq(Int);
       EmptyIntSeq == {}
   IN
   z \in DOMAIN EmptyIntSeq
</code></pre>
<p>The type checker uses the type annotation to refine the type of an empty set
(or, of an empty sequence).</p>
<p><a id="useTypeAlias"></a></p>
<h3><a class="header" href="#24-introducing-and-using-type-aliases" id="24-introducing-and-using-type-aliases">2.4. Introducing and using type aliases</a></h3>
<p>A type alias is introduced with the annotation <code>@typeAlias: ...;</code>. See the example below:</p>
<pre><code class="language-tla">VARIABLE
    \* @typeAlias ENTRY = [a: Int, b: Bool];
    \* @type Set(ENTRY);
    msgs

\* @type: (Set(ENTRY), ENTRY) =&gt; ENTRY;
Foo(ms, m) ==
    msgs' = ms \union {m}
</code></pre>
<p>You have to follow three rules:</p>
<ol>
<li>
<p>You can define a type alias with <code>@typeAlias</code> anywhere you can define a <code>@type</code>.</p>
</li>
<li>
<p>The names of type aliases must be unique in a module.</p>
</li>
<li>
<p>There is no scoping for aliases within a module. Even if an alias is defined deep in a tree of LET-IN definitions, it
can be references at any level in the module.</p>
</li>
</ol>
<h2><a class="header" href="#3-example" id="3-example">3. Example</a></h2>
<p>As an example that contains non-trivial type information, we chose the specification
of <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">Cigarette Smokers</a>
by @mryndzionek from <a href="https://github.com/tlaplus/Examples/tree/master/specifications">TLA+ Examples</a>. In this document,
we focus on the type information and give a shorter version of the specification. For detailed comments,
check <a href="https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla">the original
specification</a>.</p>
<pre><code class="language-tla">---------------------- MODULE CigaretteSmokersTyped --------------------------
(***************************************************************************)
(* A specification of the cigarette smokers problem, originally            *)
(* described in 1971 by Suhas Patil.                                       *)
(* https://en.wikipedia.org/wiki/Cigarette_smokers_problem                 *)
(*                                                                         *)
(* This specification has been extended with type annotations for the      *)
(* demonstration purposes. Some parts of the original specification are    *)
(* omitted for brevity.                                                    *)
(*                                                                         *)
(* The original specification by @mryndzionek can be found here:           *)
(* https://github.com/tlaplus/Examples/blob/master/specifications/CigaretteSmokers/CigaretteSmokers.tla *)
(***************************************************************************)

EXTENDS Integers, FiniteSets

CONSTANT
  \* @type: Set(INGREDIENT);
  Ingredients,
  \* @type: Set(Set(INGREDIENT));
  Offers

VARIABLE
  \* @type: INGREDIENT -&gt; [smoking: Bool];
  smokers,
  \* @type: Set(INGREDIENT);
  dealer

(* try to guess the types in the code below *)
ASSUME /\ Offers \subseteq (SUBSET Ingredients)
       /\ \A n \in Offers : Cardinality(n) = Cardinality(Ingredients) - 1

vars == &lt;&lt;smokers, dealer&gt;&gt;

(***************************************************************************)
(* 'smokers' is a function from the ingredient the smoker has              *)
(* infinite supply of, to a BOOLEAN flag signifying smoker's state         *)
(* (smoking/not smoking)                                                   *)
(* 'dealer' is an element of 'Offers', or an empty set                     *)
(***************************************************************************)
TypeOK == /\ smokers \in [Ingredients -&gt; [smoking: BOOLEAN]]
          /\ dealer  \in Offers \/ dealer = {}

\* @type: (Set(INGREDIENT), (INGREDIENT) =&gt; Bool) =&gt; INGREDIENT;
ChooseOne(S, P(_)) ==
    (CHOOSE x \in S : P(x) /\ \A y \in S : P(y) =&gt; y = x)

Init ==
    /\ smokers = [r \in Ingredients |-&gt; [smoking |-&gt; FALSE]]
    /\ dealer \in Offers

startSmoking ==
    /\ dealer /= {}
    /\ smokers' = [r \in Ingredients |-&gt;
                    [smoking |-&gt; {r} \cup dealer = Ingredients]]
    /\ dealer' = {}

stopSmoking ==
    /\ dealer = {}
        (* the type of LAMBDA should be inferred from the types
           of ChooseOne and Ingredients *)
    /\ LET r == ChooseOne(Ingredients, LAMBDA x : smokers[x].smoking)
       IN smokers' = [smokers EXCEPT ![r].smoking = FALSE]
    /\ dealer' \in Offers

Next ==
    startSmoking \/ stopSmoking

Spec ==
    Init /\ [][Next]_vars

FairSpec ==
    Spec /\ WF_vars(Next)

AtMostOne ==
    Cardinality({r \in Ingredients : smokers[r].smoking}) &lt;= 1
=============================================================================```
</code></pre>
<h1><a class="header" href="#adr-004-syntax-for-java-like-annotations-in-tla-comments" id="adr-004-syntax-for-java-like-annotations-in-tla-comments">ADR-004: Syntax for Java-like annotations in TLA+ comments</a></h1>
<table><thead><tr><th>author</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov</td><td align="right">2</td></tr>
</tbody></table>
<p>This ADR documents our decision on using Java-like annotations in comments.
Our main motivation to have annotations is to simplify type annotations, as
presented in <a href="https://apalache.informal.systems/docs/adr/002adr-types.html">ADR-002</a>. Hence, in the following text, we are using
examples for type annotations. However, the annotations framework is not
restricted to types. Similar to Java and Scala, we can use annotations
to decorate operators with hints, which may aid the model checker.</p>
<h2><a class="header" href="#1-what-can-be-annotated" id="1-what-can-be-annotated">1. What can be annotated</a></h2>
<p>Annotations should be written in comments that are written in front of a
declaration. The following declarations are supported:</p>
<ol>
<li>Constant declarations, e.g., <code>CONSTANT N</code>.</li>
<li>Variable declarations, e.g., <code>VARIABLE x</code>.</li>
<li>Operator declarations, including:</li>
<li>Top-level operator declarations, e.g., <code>Foo(x) == e</code>.</li>
<li>Operators defined via LET-IN, e.g., <code>Foo(x) == LET Inner(y) == e IN f</code>.</li>
<li>Recursive operators, e.g., <code>RECURSIVE Fact(_) Fact(n) == ...</code></li>
<li>Recursive and non-recursive functions including:</li>
<li>Top-level functions, e.g., <code>foo[i \in Int] == e</code>.</li>
<li>Functions defined via LET-IN, e.g.,<code>Foo == LET foo[i \in Int] == e IN f</code></li>
</ol>
<p>For an example, see Section 3.</p>
<h2><a class="header" href="#2-annotations-syntax" id="2-annotations-syntax">2. Annotations syntax</a></h2>
<p>An annotation is a string that follows the grammar (question mark denotes
optional rules):</p>
<pre><code>Annotation  ::= '@' tlaIdentifier ( '(' ArgList? ')' | ':' inlineArg ';' )?
ArgList     ::= (Arg) ( ',' Arg )*
Arg         ::= (string | integer | boolean | tlaIdentifier)
string      ::= '&quot;' &lt;char sequence&gt; '&quot;'
integer     ::= '-'? [0-9]+
boolean     ::= ('false' | 'true')
inlineArg   ::= &lt;char sequence excluding ';' and '@'&gt;
</code></pre>
<p>The sequence <code>&lt;char sequence&gt;</code> is a sequence of characters admitted by the TLA+ parser:</p>
<ul>
<li>Any ASCII character except double quotes, control characters or backslash <code>\</code></li>
<li>A backslash followed by another backslash, a single or double quote,
or one of the letters <code>f</code>, <code>n</code>, <code>r</code> or <code>t</code>.</li>
</ul>
<p><strong>Examples.</strong> The following strings are examples of syntactically correct
annotations:</p>
<ol>
<li><code>@tailrec</code></li>
<li><code>@type(&quot;(Int, Int) =&gt; Int&quot;)</code></li>
<li><code>@require(Init)</code></li>
<li><code>@type: (Int, Int) =&gt; Int ;</code></li>
<li><code>@random(true)</code></li>
<li><code>@deprecated(&quot;Use operator Foo instead&quot;)</code></li>
<li><code>@range(0, 100)</code></li>
</ol>
<p>The above examples are just syntactically correct. Their meaning, if there is
any, is defined by the tool that is reading these annotations. Note that the
example 3 is not following the syntax of Java annotations. We have introduced
this format for one-argument annotations, especially, for type annotations.
Its purpose is to reduce the visual clutter in annotations that accept a string
as their only argument.</p>
<p>Currently, annotations are written in comments that precede a definition (see
the explanation below). String arguments can span over multiple lines. For instance,
the following examples demonstrate valid annotations inside TLA+ comments:</p>
<pre><code class="language-tla">(*
  @type: Int
            =&gt; Int
  ;
 *)

\* @type: Int
\*           =&gt; Int
\* ;

\* @hal_msg(&quot;Sorry,
\*           I
\*           CAN
\*           do that,
\*           Dave&quot;)
</code></pre>
<h2><a class="header" href="#3-an-annotated-specification" id="3-an-annotated-specification">3. An annotated specification</a></h2>
<p>The following specification shows how to write annotations, so they can be
correctly parsed by the SANY parser and Apalache. Note the location of comments
in front of: local operators, LET-definitions, and recursive operators.
Although these locations may seem to be suboptimal, this is how the SANY
parser locates comments that precede declarations.</p>
<pre><code class="language-tla">-------------------------- MODULE Annotations ---------------------------------
EXTENDS Integers

CONSTANT
  \* @type: Int;
  N

VARIABLE
  \* the single-argument annotation
  \* @type: Set(Int);
  set

\* @pure
\* using the Java annotations, a bit verbose:
\* @type(&quot; Int =&gt; Int &quot;)
Inc(n) == n + 1

\* @type: Int =&gt; Int;
LOCAL LocalInc(x) == x + 1

A(n) ==
  LET \* @pure
      \* @type: Int =&gt; Int;
      Dec(x) == x + 1
  IN
  Dec(n)

RECURSIVE Fact(_)
\* @tailrec
\* @type: Int =&gt; Int;
Fact(n) ==
  IF n &lt;= 1 THEN 1 ELSE n * Fact(n - 1)

\* @tailrec
\* @type: Int -&gt; Int;
FactFun[n \in Int] ==
  IF n &lt;= 1 THEN 1 ELSE n * FactFun[n - 1]

===============================================================================
</code></pre>
<h2><a class="header" href="#4-implementation" id="4-implementation">4. Implementation</a></h2>
<p>The implementation of the annotation parser can be found in the class
<code>at.forsyte.apalache.io.annotations.AnnotationParser</code> of the module
<code>tla-import</code>, see <a href="https://github.com/informalsystems/apalache/blob/unstable/tla-import/src/main/scala/at/forsyte/apalache/io/annotations/AnnotationParser.scala">AnnotationParser</a>.</p>
<h2><a class="header" href="#5-discussion" id="5-discussion">5. Discussion</a></h2>
<p>Most likely, this topic does not deserve much discussion, as we are using
the pretty standard syntax of Java annotations. So we are following the
principle of the least surprise.</p>
<p>We also support the concise syntax for the annotations that accept a string as
a simple argument. For these annotations, we had to add the end marker ';'.
This is done because the SANY parser is pruning the linefeed character <code>\n</code>,
so it would be otherwise impossible to find the end of an annotation.</p>
<h1><a class="header" href="#rfc-006-unit-testing-and-property-based-testing-of-tla-specifications" id="rfc-006-unit-testing-and-property-based-testing-of-tla-specifications">RFC-006: Unit testing and property-based testing of TLA+ specifications</a></h1>
<table><thead><tr><th>authors</th><th align="right">revision</th></tr></thead><tbody>
<tr><td>Igor Konnov, Vitor Enes, Shon Feder, ...</td><td align="right">1</td></tr>
</tbody></table>
<!-- toc -->
<p><strong>Abstract.</strong> This document discusses a framework for testing TLA+
specifications. Our first goal is to give the writers of TLA+ specifications an
interactive approach to quickly test their specifications in the design
phase, similar to unit-testing in programming languages. Our second goal is to
give the readers of TLA+ specifications a clear framework for dissecting TLA+
specifications, in order to understand them in smaller pieces. These ideas
have not been implemented yet. We believe that the testing framework will
enable the users of Apalache and TLC to write and read TLA+ specifications in a
much more efficient manner than they do it today.</p>
<h2><a class="header" href="#1-long-rationale" id="1-long-rationale">1. Long rationale</a></h2>
<p>TLA+ is a specification language that was designed to be executable inside a
human brain. Moreover, it was intended to run in the brains that underwent a
specific software upgrade, called mathematical training. Many years have passed
since then. We now have automatic tools that can run TLA+ in a computer (to
some extent). Even more, these tools can prove or disprove certain properties
of TLA+ specs.</p>
<p>Nowadays, we have two tools that aid us in writing a TLA+ spec: our brain and a
model checker. Both these tools have the same problem. They are slow. Software
engineers are facing a similar problem when they are trying to test their
system against different inputs. Interestingly, software engineers have found a
way around this problem. They first test the individual parts of the system and
then they test the system as a whole. The former is done with unit tests,
whereas the latter is done with integration tests. (Software engineers probably
borrowed this approach from industrial engineers.) Unit tests are used almost
interactively, to debug a small part of the system, while integration tests are
run in a continuous integration environment, which is not interactive at all.</p>
<p>Actually, our brains also have a built-in ability of abstracting away from one
part of a problem while thinking about the other part. That is why some of us
can still win against automatic tools. Model checkers do not have this built-in
ability. So it looks like when we are using TLC or Apalache, we are doing
integration testing all the time. Unfortunately, when we are checking a
specification as a whole, we rarely get a quick response, except for very small
specs. This is hardly surprising, as we are interested in specifying complex
systems, not the trivial ones.</p>
<p>Surprisingly, when we are writing large TLA+ specs, our interaction with the
model checker looks more like an interaction with a <a href="https://en.wikipedia.org/wiki/Mainframe_computer">Mainframe computer</a> from
the early days of computing than a modern interactive development cycle. We
feed the model checker our specification and wait for hours in the hope that it
gives us a useful response. If it does not, we have to make the specification
parameters small enough for the model checker to do anything useful. If our
parameters are already ridiculously small, we have to throw more computing
power at the problem and wait for days. In contrast, verification tools for
programs are meant to be much more interactive, e.g., see <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a> and
<a href="https://github.com/kenmcmil/ivy">Ivy</a>.</p>
<p>Why cannot we do something like <a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> in Apalache? We believe that
we actually can do that. We can probably do it even better by implementing
<a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, that is, test parts of our specifications against a
large set of inputs instead of testing it against a few carefully crafted
inputs.</p>
<h2><a class="header" href="#2-a-motivating-example" id="2-a-motivating-example">2. A motivating example</a></h2>
<p>Let's consider a relatively simple distributed algorithm as an example.  The
repository of <a href="https://github.com/tlaplus/Examples/">TLA+ examples</a> contains the well-known leader election
algorithm called <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> (specified in TLA+ by Stephan Merz). The algorithm is
over 40 years old, but it is tricky enough to be still interesting. To
understand the algorithm, check <a href="https://dl.acm.org/doi/book/10.5555/2821576">Distributed Algorithms</a> by Nancy Lynch.</p>
<p>As the description suggests, when we fix <code>N</code> to <code>6</code> and <code>Id</code> to
<code>&lt;&lt;27, 4, 42, 15, 63, 9&gt;&gt;</code>, TLC checks that the spec satisfies the invariant
<code>Correctness</code> in just 11 seconds, after having explored 40K states.
Of course, had we wanted to check the property for all possible combinations
of six unique identifiers in the range of <code>1..6</code>, we would had to run TLC
<code>6! = 720</code> times, which would take over 2 hours.</p>
<p>In Apalache, we can setup a TLA+ module instance, to check all instances of
the algorithm that have from 2 to 6 processes:</p>
<pre><code class="language-tla">--------------------- MODULE ChangRobertsTyped_Test -------------------------
(*
 * A test setup for ChangRobertsTyped.
 *)
EXTENDS Integers, Apalache

\* a copy of constants from ChangRobertsTyped
CONSTANTS
    \* @type: Int;
    N,
    \* @type: Int -&gt; Int;
    Id

\* a copy of state variables from ChangRobertsTyped
VARIABLES
    \* @type: Int -&gt; Set(Int);
    msgs,
    \* @type: Int -&gt; Str;
    pc,
    \* @type: Int -&gt; Bool;
    initiator,
    \* @type: Int -&gt; Str;
    state

INSTANCE ChangRobertsTyped

\* We bound N in the test
MAX_N == 6

\* we override Node, as N is not known in advance
OVERRIDE_Node == { i \in 1..MAX_N: i &lt;= N }

\* initialize constants
ConstInit ==
    /\ N \in 2..MAX_N
    /\ Id \in [ 1..MAX_N -&gt; Int ]

\* The below constraints are copied from ASSUME.
\* They are not enforced automatically, see issue #69.
Assumptions ==    
    /\ Node = DOMAIN Id
    /\ \A n \in Node: Id[n] &gt;= 0
    /\ \A m,n \in Node : m # n =&gt; Id[m] # Id[n]  \* IDs are unique

InitAndAssumptions ==
    Init /\ Assumptions

</code></pre>
<p>By running Apalache as follows, we can check <code>Correctness</code> for all
configurations of 2 to 6 processes and all combinations of <code>Id</code>:</p>
<pre><code class="language-sh">apalache check --cinit=ConstInit \
  --init=InitAndAssumptions --inv=Correctness ChangRobertsTyped_Test.tla
</code></pre>
<p>Actually, we do not restrict <code>Id</code> to be a function from <code>1..N</code> to <code>1..N</code>, but
rather allow <code>Id</code> to be a function from <code>1..N</code> to <code>Int</code>. So Apalache should
be able to check an infinite number of configurations!</p>
<p>Unfortunately, Apalache starts to dramatically slow down after having explored
6 steps of the algorithm. Indeed, it does symbolic execution for a
non-deterministic algorithm and infinitely many inputs. We could try to improve
the SMT encoding, but that would only win us several steps more. A more
realistic approach would be to find an inductive invariant and let Apalache
check it.</p>
<p>It looks like we are trapped: Either we have to invest some time in
verification, or we can check the algorithm for a few data points. In case
of LCR, the choice of process identifiers is important, so it is not clear at
all, whether a few data points are giving us a good confidence.</p>
<p>This situation can be frustrating, especially when you are designing a large
protocol. For instance, both Apalache and TLC can run for hours on <a href="https://github.com/tlaplus/Examples/tree/master/specifications/raft">Raft</a>
without finishing. We should be able to quickly debug our specs like software
engineers do!</p>
<h2><a class="header" href="#3-an-approach-to-writing-tests" id="3-an-approach-to-writing-tests">3. An approach to writing tests</a></h2>
<p><em>What we describe below has not been implemented yet. Apalache has all the
necessary ingredients for implementing this approach. We are asking for your
input to find an ergonomic approach to testing TLA+ specifications.  Many of
the following ideas apply to TLC as well. We are gradually introducing
Apalache-specific features.</em></p>
<p>A complete specification can be found in <a href="https://github.com/informalsystems/apalache/blob/unstable/test/tla/ChangRobertsTyped_Test.tla">ChangRobertsTyped_Test.tla</a>.</p>
<p>Our idea is to quickly check operators in isolation, without analyzing the
whole specification and without analyzing temporal behavior of the
specification. There are three principally different kinds of operators in TLA+:</p>
<ul>
<li>
<p>Stateless operators that take input parameters and return the result.
These operators are similar to functions in functional languages.</p>
</li>
<li>
<p>Action operators that act on a specification state.
These operators are similar to procedures in imperative languages.</p>
</li>
<li>
<p>Temporal operators that act on executions, which are called behaviors
in TLA+. These operators are somewhat similar to regular expressions,
but they are more powerful, as they reason about infinite executions.</p>
</li>
</ul>
<h3><a class="header" href="#31-testing-stateless-operators" id="31-testing-stateless-operators">3.1. Testing stateless operators</a></h3>
<p>Consider the following auxiliary operator in the specification:</p>
<pre><code class="language-tla">succ(n) == IF n=N THEN 1 ELSE n+1  \* successor along the ring
</code></pre>
<p>While this operator is defined in the specification, it is clear that it is
well isolated from the rest of the specification: We only have to know the
value of the constant <code>N</code> and the value of the operator parameter <code>n</code>.</p>
<pre><code class="language-tla">\* Note that succ(n) is not referring to state variables,
\* so we can test it in isolation.
\*
\* @require(ConstInit)
\* @testStateless
Test_succ ==
    \* This is like a property-based test.
    \* Note that it is exhaustive (for the range of N).
    \A n \in Node:
        succ(n) \in Node
</code></pre>
<p>This test is very simple. It requires <code>succ(n)</code> to be in the set <code>Node</code>, for
all values <code>n \in Node</code>. The body of the operator <code>Test_succ</code> is pure TLA+.
We annotate the operator with <code>@testStateless</code>, to indicate that it should
be checked in a stateless context.</p>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla Test_succ
</code></pre>
<p>We pass the test name <code>Test_succ</code>, as we expect the <code>test</code> command to run all
tests by default, if no test name is specified. Also, we have to initialize the
constants with <code>ConstInit</code>, which we specify with the annotation
<code>@require(ConstInit)</code>.</p>
<p><a id="testAction"></a></p>
<h3><a class="header" href="#32-testing-actions" id="32-testing-actions">3.2. Testing actions</a></h3>
<p>Testing stateless operators is nice. However, TLA+ is built around the concept
of a state machine. Hence, we believe that most of the testing activity will be
centered around TLA+ actions. For instance, the <a href="https://github.com/tlaplus/Examples/tree/master/specifications/chang_roberts">LCR</a> specification has two
actions: <code>n0</code> and <code>n1</code>. Let's have a look at <code>n0</code>:</p>
<pre><code class="language-tla">n0(self) == /\ pc[self] = &quot;n0&quot;
            /\ IF initiator[self]
                  THEN /\ msgs' = [msgs EXCEPT ![succ(self)] = @ \cup {Id[self]}]
                  ELSE /\ TRUE
                       /\ msgs' = msgs
            /\ pc' = [pc EXCEPT ![self] = &quot;n1&quot;]
            /\ UNCHANGED &lt;&lt; initiator, state &gt;&gt;
</code></pre>
<p>Assume we like to test it without looking at the rest of the system, namely,
the predicates <code>Init</code> and <code>n1</code>. First of all, we have to describe the states
that could be passed to the action <code>n0</code>. In this section, we will just use
TypeOK (see <a href="adr/006rfc-unit-testing.html#generators">Section 5</a> for a more fine-grained control over the
inputs):</p>
<pre><code class="language-tla">TypeOK ==
  /\ pc \in [Node -&gt; {&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;Done&quot;}]
  /\ msgs \in [Node -&gt; SUBSET {Id[n] : n \in Node}]
  /\ initiator \in [Node -&gt; BOOLEAN]
  /\ state \in [Node -&gt; {&quot;cand&quot;, &quot;lost&quot;, &quot;won&quot;}]

</code></pre>
<p>Further, we specify what kind of outcome we expect:</p>
<pre><code class="language-tla">\* Assertion that we expect to hold true after firing Action_n0.
Assert_n0 ==
    \E n, m \in Node:
        msgs'[n] = msgs[n] \union {m}
</code></pre>
<p>(Do you think this condition actually holds true after firing <code>n0</code>?)</p>
<p>Finally, we have to specify, how to run the action <code>n0</code>. In fact, if you look
at <code>Next</code>, this requires us to write a bit of code, instead of just calling
<code>n0</code>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>The operator <code>TestAction_n0</code> carries several annotations:</p>
<ul>
<li>The annotation <code>@require(TypeOK)</code> tells the framework that
<code>TypeOK</code> should act as an initialization predicate for testing
<code>TestAction_n0</code>.</li>
<li>The annotation <code>@testAction</code> indicates that <code>TestAction_n0</code> should be tested
as an action that is an operator over unprimed and primed variable.</li>
<li>The annotation <code>@ensure(Assert_n0)</code> tells the framework that
<code>Assert_n0</code> should hold after <code>TestAction_n0</code> has been fired.</li>
</ul>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>Importantly, we decompose the test in three parts:</p>
<ul>
<li>preparing the states by evaluating predicates <code>ConstInit</code> and <code>TypeOK</code>
(similar to <code>Init</code>),</li>
<li>executing the action by evaluating the action predicate <code>TestAction_n0</code>
(like a single instance of <code>Next</code>),</li>
<li>testing the next states against the previous states by evaluating
the predicate <code>Assert_n0</code>
(like an action invariant).</li>
</ul>
<h3><a class="header" href="#33-testing-executions" id="33-testing-executions">3.3. Testing executions</a></h3>
<p>Engineers often like to test a particular set of executions to support their
intuition, or to communicate an example to their peers. Sometimes, it is useful
to isolate a set of executions to make continuous integration break, until the
protocol is fixed. Needless to say, TLA+ tools have no support for this
standard technique, though they have all capabilities to produce such tests.</p>
<p>Similar to testing an action in isolation, we propose an interface for testing
a restricted set of executions as follows:</p>
<pre><code class="language-tla">\* Execute a sequence of 5 actions, similar to TestAction_n0.
\* We test a final state with Assert_n0.
\*
\* @require(ConstInit) \* in  the future, we will allow the user to omit quotes
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
TestExec_n0_n1 ==
    \* in this test, we only execute actions by processes 1 and 2
    \E self \in { 1, 2 }:
        n0(self) \/ n1(self)

</code></pre>
<p>In this case, we are using a different assertion in the <code>@ensure</code> annotation:</p>
<pre><code class="language-tla">Assert_noWinner ==
    \A n \in Node:
        state'[n] /= &quot;won&quot;

</code></pre>
<p>The test <code>TestExec_n0_n1</code> is similar to <code>TestAction_n0</code> in many aspects.  It
starts by initializing the state with the predicate <code>Prepare_n0</code> and it expects
a final state to satisfy the predicate <code>Assert_noWinner</code>. There is an important
difference between the variables in <code>Assert_n0</code> and <code>Assert_noWinner</code>:</p>
<ul>
<li>
<p>Unprimed variables in <code>Assert_n0</code> refer to a state before firing an action,
whereas primed variables in <code>Assert_n0</code> refer to a state after firing
the action.</p>
</li>
<li>
<p>Unprimed variables in <code>Assert_noWinner</code> refer to a state before firing
an <em>execution</em>, whereas primed variables in <code>Assert_noWinner</code> refer to
a final state of the execution.</p>
</li>
</ul>
<p><em>(If you find the above behavior of <code>Assert_noWinner</code> confusing, please let us
know.)</em></p>
<p>We should be able to run this test via:</p>
<pre><code class="language-sh">apalache test ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<p>If the test is violated, a counterexample should be produced in the file
<code>counterexample_TestExec_n0_n1.tla</code>.</p>
<h3><a class="header" href="#34-test-executions-with-temporal-properties" id="34-test-executions-with-temporal-properties">3.4. Test executions with temporal properties</a></h3>
<p>When we wrote the test <code>TestExec_n0_n1</code>, we did not think about the
intermediate states of an execution. This test was a functional test: It is
matching the output against the input. When reasoning about state machines,
we often like to restrict the executions and check the properties of those
executions.</p>
<p>Fortunately, we have all necessary ingredients in TLA+ to do
exactly this. Test <code>TestExec_correctness_under_liveness</code>.</p>
<pre><code class="language-tla">\* Execute a sequence of 5 actions, while using temporal properties.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @require(Liveness)
\* @ensure(GlobalCorrectness)
\* @testExecution(5)
TestExec_correctness_under_liveness ==
    \E self \in Node:
        n0(self) \/ n1(self)

</code></pre>
<p>Predicates <code>Correctness</code> and <code>Liveness</code> are defined in the spec as follows:</p>
<pre><code class="language-tla">(***************************************************************************)
(* Safety property: when node n wins the election, it is the initiator     *)
(* with the smallest ID, and all other nodes know that they lost.          *)
(***************************************************************************)
Correctness ==
  \A n \in Node : state[n] = &quot;won&quot; =&gt;
     /\ initiator[n]
     /\ \A m \in Node \ {n} : 
           /\ state[m] = &quot;lost&quot;
           /\ initiator[m] =&gt; Id[m] &gt; Id[n]

Liveness == (\E n \in Node : state[n] = &quot;cand&quot;) =&gt; &lt;&gt;(\E n \in Node : state[n] = &quot;won&quot;)
</code></pre>
<p>Since <code>Correctness</code> is a state predicate, we wrap it with a temporal operator
to check it against all states of an execution:</p>
<pre><code class="language-tla">GlobalCorrectness == []Correctness

</code></pre>
<h3><a class="header" href="#35-discussion" id="35-discussion">3.5. Discussion</a></h3>
<p>As you can see, we clearly decompose a test in three parts:</p>
<ul>
<li>preparing the states (like a small version of <code>Init</code>),</li>
<li>executing the action (like a small version of <code>Next</code>),</li>
<li>testing the next states against the previous states (like an action invariant).</li>
</ul>
<p>In the rest of this section, we comment on the alternative approaches.</p>
<h4><a class="header" href="#351-but-i-can-do-all-of-that-in-tla" id="351-but-i-can-do-all-of-that-in-tla">3.5.1. But I can do all of that in TLA+</a></h4>
<p>True. TLA+ is an extremely expressive language.</p>
<p>Let's go back to the test <code>TestAction_n0</code> that was explained in <a href="adr/006rfc-unit-testing.html#testAction">Section
3.2</a>:</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Can we rewrite this test in pure TLA+? Yes, but it is an error-prone approach.
Let's do it step-by-step.</p>
<p>First of all, there is no simple way to initialize constants in TLA+, as we did
with <code>ConstInit</code> (this is an Apalache-specific feature). Of course, one can
restrict constants with <code>ASSUME(...)</code>.  However, assumptions about constants
are global, so we cannot easily isolate constant initialization in one test.
The canonical way of initializing constants is to define them in a TLC
configuration file. If we forget about all these idiosyncrasies of TLC, we
could just use implication (<code>=&gt;</code>), as we normally do in logic. So our test
<code>TestAction_n0_TLA</code> in pure TLA+ would look like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt; (* ... *)
</code></pre>
<p>Second, we want to restrict the states with <code>TypeOK</code>. That should be easy:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK (* ... *)
</code></pre>
<p>Third, we want to execute the action <code>n0</code>, as we did in <code>TestAction_n0</code>.
The intuitive way is to write it like follows:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    /\ TypeOK
    /\ \E self \in Node:
         n0(self)
    (* ... *)     
</code></pre>
<p>Although the above code looks reasonable, we cheated. It combines two steps in
one: It initializes states with <code>TypeOK</code> and it simultaneously executes the
action <code>n0</code>. If we tried that in TLC (forgetting about <code>ConstInit</code>), that would
not work. Though there is nothing wrong about this constraint from the
perspective of logic, it just restricts the unprimed variables and primed
variables.  There is probably a way to split this code in two steps by applying
the operator <code>\cdot</code>, which is implemented neither in TLC, nor in Apalache:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      \E self \in Node:
         n0(self)
      (* ... *)
    )
</code></pre>
<p>In these circumstances, a more reasonable way would be to introduce a new file
like <code>MCTestAction_n0.tla</code> and clearly specify <code>TypeOK</code> as the initial
predicate and the action as the next predicate. But we do not want
state-of-the-art dictate us our behavior.</p>
<p>Finally, we have to place the assertion <code>Assert_n0</code>. Let's try it this way:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert_n0
    )
</code></pre>
<p>Unfortunately, this is not the right solution. Instead of executing <code>n0</code>
and checking that the result satisfies <code>Assert_n0</code>, we have restricted
the next states to always satisfy <code>Assert_n0</code>!</p>
<p>Again, we would like to write something like the implication <code>Action =&gt; Assertion</code>, but we are not allowed do that with the model checkers for TLA+.
We can use the operator <code>Assert</code> that is supported by TLC:</p>
<pre><code class="language-tla">TestAction_n0_TLA ==
  ConstInit =&gt;
    TypeOK
      \cdot
    (
      /\ \E self \in Node:
         n0(self)
      /\ Assert(Assert_n0, &quot;assertion violation&quot;)
    )
</code></pre>
<p>This time it should conceptually work. Once <code>n0</code> has been executed, TLC could
start evaluating <code>Assert(...)</code> and find a violation of <code>Assert_n0</code>.  There is
another problem. The operator <code>Assert</code> is a purely imperative operator, which
relies on the order in which the formula is evaluated. Hence, Apalache does not
support this operator and, most likely, it never will. The imperative semantics
of the operator <code>Assert</code> is simply incompatible with logical constraints.
Period.</p>
<p>Phew. It was not easy to write <code>TestAction_n0_TLA</code>. In principle, we could
fix this pattern and extract the test in a dedicated file <code>MC.tla</code> to run
it with TLC or Apalache.</p>
<p>Let's compare it with <code>TestAction_n0</code>. Which one would you choose?</p>
<pre><code class="language-tla">\* Execute the action under test.
\* Note that we decouple Assert_n0 from TestAction_n0.
\* The reason is that we always assume that TestAction_n0 always holds,
\* whereas we may want to see Assert_n0 violated.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_n0)
\* @testAction
TestAction_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<p>Another problem of <code>TestAction_n0_TLA</code> is that it has a very brittle structure.
What happens if one writes <code>~ConstInit \/ TypeOK ...</code> instead of <code>ConstInit =&gt; TypeOK ...</code>? In our experience, when one sees a logical formula, they expect
that an equivalent logical formula should be also allowed.</p>
<p><em>In the defense of TLA+, the issues that we have seen above are not the issues
of TLA+ as a language, but these are the problems of the TLA+ tooling. There
is a very simple and aesthetically pleasing way of writing <code>TestAction_n0</code> in
the logic of TLA+:</em></p>
<pre><code class="language-tla">TestAction_n0_pure_TLA ==
  (ConstInit /\ TypeOK) =&gt;
    (\E self \in Node: n0(self)) =&gt; Assert_n0
</code></pre>
<p>The operator <code>TestAction_n0_pure_TLA</code> could be probably reasoned about in <a href="adr/">TLA+
Proof System</a>.  From the automation perspective, it would require a
completely automatic constraint-based solver for TLA+, which we do not have.
In practice, this would mean either rewriting TLC and Apalache from scratch, or
hacking them to enforce the right semantics of the above formula.</p>
<h4><a class="header" href="#352-why-annotations-instead-of-special-operators" id="352-why-annotations-instead-of-special-operators">3.5.2. Why annotations instead of special operators</a></h4>
<p>The annotations <code>@require</code> and <code>@ensure</code> are not our invention. You can find
them in <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design-by-contract</a> languages. In particular, they are used as pre-
and post-conditions in code verification tools, e.g., <a href="https://www.thestrangeloop.com/2018/contracts-for-getting-more-programs-less-wrong.html">JML</a>, <a href="https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/">Dafny</a>, <a href="http://mcmil.net/pubs/SIGCOMM19.pdf">QUIC
testing</a> with <a href="https://github.com/kenmcmil/ivy">Ivy</a>. </p>
<p>You could ask a reasonable question: Why cannot we introduce operators such
as <code>Require</code> and <code>Ensure</code> instead of writing annotations? For instance,
we could rewrite <code>TestAction_n0</code> as follows:</p>
<pre><code class="language-tla">TestAction_n0_no_annotations ==
  /\ Require(ConstInit)
  /\ Require(TypeOK)
  /\ \E self \in Node:
        n0(self)
  /\ Ensure(Assert_n0)
</code></pre>
<p>The above test looks self-contained, no annotations. Moreover, we have probably
given more power to the users: They could pass expressions to <code>Require</code> and
<code>Ensure</code>, or they could combine <code>Require</code> and <code>Ensure</code> in other ways and do
something great... Well, we have actually introduced more problems to the users
than solutions. Since logical formulas can be composed in a lot of ways, we
could start writing interesting things:</p>
<pre><code class="language-tla">Can_I_do_that ==
  /\ ~Require(ConstInit)
  /\ Require(TypeOK) =&gt; Ensure(ConstInit)
  /\ \E self \in Node:
        n0(self) /\ Require(self \in { 1, 2 })
  /\ Ensure(Assert_n0) \/ Ensure(Assert_noWinner)
</code></pre>
<p>It is not clear to us how the test <code>Can_I_do_that</code> should be understood.
But what is written is kind of legal, so it should work, right?</p>
<p><em>The annotations gives us a clear structure instead of obfuscating the
requirements in logical formulas.</em></p>
<p>For the moment, we are using Apalache annotations in code comments.  However,
TLA+ could be extended with ensure/require one day, if they prove to be useful.</p>
<h2><a class="header" href="#4-using-tests-for-producing-quick-examples" id="4-using-tests-for-producing-quick-examples">4. Using tests for producing quick examples</a></h2>
<p>It is often nice to see examples of test inputs that pass the
test. Apalache has all the ingredients to do that that. We should be able
to run a command like that:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestAction_n0
</code></pre>
<p>The above call would produce <code>example_TestAction_n0.tla</code>, a TLA+ description of
two states that satisfy the test. This is similar to <code>counterexample.tla</code>,
which is produced when an error is found.</p>
<p>In a similar way we should be able to produce an example of an execution:</p>
<pre><code class="language-sh">apalache example ChangRobertsTyped_Test.tla TestExec_n0_n1
</code></pre>
<h2><a class="header" href="#5-bounding-the-inputs" id="5-bounding-the-inputs">5. Bounding the inputs</a></h2>
<p>The following ideas clearly stem from <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>, e.g., we use
generators similar to <a href="https://www.scalacheck.org/">Scalacheck</a>. In contrast to property-based testing, we
want to run the test not only on some random inputs, but to run it exhaustively
on all inputs within a predefined bounded scope.</p>
<p><a id="generators"></a></p>
<h3><a class="header" href="#51-using-apalache-generators" id="51-using-apalache-generators">5.1. Using Apalache generators</a></h3>
<p>Let's go back to the example in <a href="adr/006rfc-unit-testing.html#testAction">Section 3.2</a>.</p>
<p>In <code>TestAction_n0</code> we used <code>TypeOK</code> to describe the states that can be used as
the input to the test. While this conceptually works, it often happens that
<code>TypeOK</code> describes a large set of states. Sometimes, this set is even infinite,
e.g., when <code>TypeOK</code> refers to the infinite set of sequences <code>Seq(S)</code>.
In Apalache, we can use the operator <code>Gen</code> that produces bounded data structures,
similar to <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. Here is how we could describe the set
of input states, by bounding the size of the data structures:</p>
<pre><code class="language-tla">\* Preparing the inputs for the second test. Note that this is a step of its own.
\* This is similar to an initialization predicate.
Prepare_n0 ==
    \* the following constraint should be added automatically in the future
    /\ Assumptions
    \* let the solver pick some data structures within the bounds
    \* up to 15 messages
    /\ msgs = Gen(3 * MAX_N)
    /\ pc = Gen(MAX_N)
    /\ initiator = Gen(MAX_N)
    /\ state = Gen(MAX_N)
    \* restrict the contents with TypeOK,
    \* so we don't generate useless data structures
    /\ TypeOK
</code></pre>
<p>In <code>Prepare_n0</code>, we let the solver to produce bounded data structures with
<code>Gen</code>, by providing bounds on the size of every set, function, sequence, etc.
Since we don't want to have completely arbitrary values for the data
structures, we further restrict them with <code>TypeOK</code>, which we conveniently have
in the specification.</p>
<p>The more scoped version of <code>TestAction_n0</code> looks like following:</p>
<pre><code class="language-tla">\* Another version of the test where we further restrict the inputs.
\* 
\* @require(ConstInit)
\* @require(Prepare_n0)
\* @ensure(Assert_n0)
\* @testAction
TestAction2_n0 ==
    \E self \in Node:
        n0(self)

</code></pre>
<h3><a class="header" href="#52-using-tlc-random" id="52-using-tlc-random">5.2. Using TLC Random</a></h3>
<p>Leslie Lamport has recently introduced a solution that allows one to run TLC
in the spirit of <a href="https://en.wikipedia.org/wiki/QuickCheck">Property-based testing</a>. This is done by initializing
states with the operators that are defined in the module <code>Randomization</code>. For
details, see Leslie's paper on <a href="http://lamport.azurewebsites.net/tla/inductive-invariant.pdf">Inductive invariants with TLC</a>.</p>
<h2><a class="header" href="#6-test-options" id="6-test-options">6. Test options</a></h2>
<p>To integrate unit tests in the standard TLA+ development cycle, the tools
should remember how every individual test was run. To avoid additional
scripting on top of the command-line interface, we can simply pass the tool
options with the annotation <code>@testOption</code>. The following example demonstrates
how it could be done:</p>
<pre><code class="language-tla">\* A copy of TestExec_n0_n1 that passes additional flags to the model checker.
\*
\* @require(ConstInit)
\* @require(TypeOK)
\* @ensure(Assert_noWinner)
\* @testExecution(5)
\* @testOption(&quot;tool&quot;, &quot;apalache&quot;)
\* @testOption(&quot;search.smt.timeout&quot;, 10)
\* @testOption(&quot;checker.algo&quot;, &quot;offline&quot;)
\* @testOption(&quot;checker.nworkers&quot;, 2)
TestExec_n0_n1_with_options ==
    TestExec_n0_n1

</code></pre>
<p>The test options in the above example have the following meaning:</p>
<ul>
<li>
<p>The annotation <code>testOption(&quot;tool&quot;, &quot;apalache&quot;)</code> runs the test only if it is
executed in Apalache. For example, if we run this test in TLC, it should be
ignored.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;search.smt.timeout&quot;, 10)</code> sets the tool-specific
option <code>search.smt.timeout</code> to 10, meaning that the SMT solver should time
out if it cannot solve a problem in 10 seconds.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.algo&quot;, &quot;offline&quot;)</code> sets the tool-specific
option <code>checker.algo</code> to <code>offline</code>, meaning that the model checker should
use the offline solver instead of the incremental one.</p>
</li>
<li>
<p>The annotation <code>testOption(&quot;checker.nworkers&quot;, 2)</code> sets the tool-specific
option <code>checker.nworkers</code> to <code>2</code>, meaning that the model checker should
use two cores.</p>
</li>
</ul>
<p>By having all test options specified directly in tests, we reach two goals:</p>
<ul>
<li>We let the users to save their experimental setup, to enable reproducibility
of the experiments and later re-design of specifications.</li>
<li>We let the engineers integrate TLA+ tests in continuous integration, to
make sure that updates in a specification do not break the tests.
This would allow us to integrate TLA+ model checkers in a CI/CD loop,
e.g., at GitHub.</li>
</ul>
<h2><a class="header" href="#7-what-do-you-think" id="7-what-do-you-think">7. What do you think?</a></h2>
<p>Let us know:</p>
<ul>
<li>
<p>At <a href="https://informal-systems.zulipchat.com/#narrow/stream/265309-apalache">Apalache Zulip stream</a>,</p>
</li>
<li>
<p>On <a href="https://twitter.com/ApalacheTLA">ApalacheTLA Twitter</a>,</p>
</li>
<li>
<p>email: igor at informal.systems.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
