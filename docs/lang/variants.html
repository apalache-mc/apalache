<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variants - Apalache Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorials/entry-tutorial.html"><strong aria-hidden="true">2.</strong> Entry-level Model Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">3.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/pluscal-tutorial.html"><strong aria-hidden="true">4.</strong> Checking Pluscal specifications</a></li><li class="chapter-item expanded "><a href="../tutorials/trail-tips.html"><strong aria-hidden="true">5.</strong> Apalache trail tips: how to check your specs faster</a></li><li class="chapter-item expanded "><a href="../tutorials/symbmc.html"><strong aria-hidden="true">6.</strong> Symbolic Model Checking</a></li><li class="chapter-item expanded "><a href="../tutorials/temporal-properties.html"><strong aria-hidden="true">7.</strong> Specifying temporal properties and understanding counterexamples</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="../HOWTOs/index.html"><strong aria-hidden="true">8.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">9.</strong> How to write type annotations</a></li><li class="chapter-item expanded "><a href="../HOWTOs/uninterpretedTypes.html"><strong aria-hidden="true">10.</strong> How to use uninterpreted types</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="../apalache/index.html"><strong aria-hidden="true">11.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/index.html"><strong aria-hidden="true">11.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/jvm.html"><strong aria-hidden="true">11.1.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="../apalache/installation/docker.html"><strong aria-hidden="true">11.1.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../apalache/installation/source.html"><strong aria-hidden="true">11.1.3.</strong> Build from Source</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/running.html"><strong aria-hidden="true">11.2.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="../apalache/example.html"><strong aria-hidden="true">11.3.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="../apalache/parameters.html"><strong aria-hidden="true">11.4.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="../apalache/principles/index.html"><strong aria-hidden="true">11.5.</strong> Symbolic Model Checking with Apalache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/principles/assignments.html"><strong aria-hidden="true">11.5.1.</strong> Assignments and symbolic transitions</a></li><li class="chapter-item expanded "><a href="../apalache/principles/folds.html"><strong aria-hidden="true">11.5.2.</strong> Folding sets and sequences</a></li><li class="chapter-item expanded "><a href="../apalache/principles/invariants.html"><strong aria-hidden="true">11.5.3.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="../apalache/principles/enumeration.html"><strong aria-hidden="true">11.5.4.</strong> Enumeration of counterexamples</a></li><li class="chapter-item expanded "><a href="../apalache/principles/apalache-mod.html"><strong aria-hidden="true">11.5.5.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="../apalache/principles/naturals.html"><strong aria-hidden="true">11.5.6.</strong> Naturals</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/config.html"><strong aria-hidden="true">11.6.</strong> Apalache global configuration file</a></li><li class="chapter-item expanded "><a href="../apalache/statistics.html"><strong aria-hidden="true">11.7.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="../apalache/profiling.html"><strong aria-hidden="true">11.8.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="../apalache/theory.html"><strong aria-hidden="true">11.9.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/tuning.html"><strong aria-hidden="true">12.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="../apalache/tlc-config.html"><strong aria-hidden="true">13.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="../apalache/typechecker-snowcat.html"><strong aria-hidden="true">14.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="../apalache/features.html"><strong aria-hidden="true">15.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../apalache/principles/recursive.html"><strong aria-hidden="true">16.</strong> Obsolete: Recursive operators and functions</a></li><li class="chapter-item expanded "><a href="../apalache/known-issues.html"><strong aria-hidden="true">17.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="../apalache/antipatterns.html"><strong aria-hidden="true">18.</strong> Antipatterns</a></li><li class="chapter-item expanded "><a href="../apalache/preprocessing.html"><strong aria-hidden="true">19.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="../apalache/assignments-in-depth.html"><strong aria-hidden="true">20.</strong> Assignments and Symbolic Transitions in Depth</a></li><li class="chapter-item expanded "><a href="../apalache/kera.html"><strong aria-hidden="true">21.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="../lang/index.html"><strong aria-hidden="true">22.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../lang/standard-operators.html"><strong aria-hidden="true">23.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/booleans.html"><strong aria-hidden="true">23.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../lang/control-and-nondeterminism.html"><strong aria-hidden="true">23.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="../lang/conditionals.html"><strong aria-hidden="true">23.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../lang/integers.html"><strong aria-hidden="true">23.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../lang/sets.html"><strong aria-hidden="true">23.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="../lang/logic.html"><strong aria-hidden="true">23.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="../lang/functions.html"><strong aria-hidden="true">23.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../lang/records.html"><strong aria-hidden="true">23.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="../lang/tuples.html"><strong aria-hidden="true">23.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../lang/sequences.html"><strong aria-hidden="true">23.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="../lang/apalache-extensions.html"><strong aria-hidden="true">24.</strong> Apalache extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/apalache-operators.html"><strong aria-hidden="true">24.1.</strong> Apalache module</a></li><li class="chapter-item expanded "><a href="../lang/variants.html" class="active"><strong aria-hidden="true">24.2.</strong> Variants</a></li><li class="chapter-item expanded "><a href="../lang/option-types.html"><strong aria-hidden="true">24.3.</strong> Option types</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/user-operators.html"><strong aria-hidden="true">25.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/user/top-level-operators.html"><strong aria-hidden="true">25.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/let-in.html"><strong aria-hidden="true">25.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/higher-order-operators.html"><strong aria-hidden="true">25.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/lambdas.html"><strong aria-hidden="true">25.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/local-operators.html"><strong aria-hidden="true">25.5.</strong> Local operator definitions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="../idiomatic/index.html"><strong aria-hidden="true">27.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">28.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="../idiomatic/001assignments.html"><strong aria-hidden="true">29.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="../idiomatic/002primes.html"><strong aria-hidden="true">30.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded "><a href="../idiomatic/007if-then-else.html"><strong aria-hidden="true">31.</strong> Use Boolean operators in actions, not IF-THEN-ELSE</a></li><li class="chapter-item expanded "><a href="../idiomatic/003record-sets.html"><strong aria-hidden="true">32.</strong> Avoid sets of mixed records</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="../adr/001rfc-types.html"><strong aria-hidden="true">33.</strong> RFC 001: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/002adr-types.html"><strong aria-hidden="true">34.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/003adr-trex.html"><strong aria-hidden="true">35.</strong> ADR-003: transition executor (TRex)</a></li><li class="chapter-item expanded "><a href="../adr/004adr-annotations.html"><strong aria-hidden="true">36.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="../adr/005adr-json.html"><strong aria-hidden="true">37.</strong> ADR-005: JSON Serialization Format</a></li><li class="chapter-item expanded "><a href="../adr/006rfc-unit-testing.html"><strong aria-hidden="true">38.</strong> RFC-006: unit tests and property-based tests</a></li><li class="chapter-item expanded "><a href="../adr/007adr-restructuring.html"><strong aria-hidden="true">39.</strong> ADR-007: restructuring</a></li><li class="chapter-item expanded "><a href="../adr/008adr-exceptions.html"><strong aria-hidden="true">40.</strong> ADR-008: exceptions</a></li><li class="chapter-item expanded "><a href="../adr/009adr-outputs.html"><strong aria-hidden="true">41.</strong> ADR-009: outputs</a></li><li class="chapter-item expanded "><a href="../adr/010rfc-transition-explorer.html"><strong aria-hidden="true">42.</strong> RFC-010: Implementation of Transition Exploration Server</a></li><li class="chapter-item expanded "><a href="../adr/011adr-smt-arrays.html"><strong aria-hidden="true">43.</strong> ADR-011: alternative SMT encoding using arrays</a></li><li class="chapter-item expanded "><a href="../adr/012adr-adopt-adr-template.html"><strong aria-hidden="true">44.</strong> ADR-012: Adopt an ADR Template</a></li><li class="chapter-item expanded "><a href="../adr/013adr-configuration.html"><strong aria-hidden="true">45.</strong> ADR-013: Configuration Management Component</a></li><li class="chapter-item expanded "><a href="../adr/014adr-precise-records.html"><strong aria-hidden="true">46.</strong> ADR-014: Precise type inference for records and variants</a></li><li class="chapter-item expanded "><a href="../adr/015adr-trace.html"><strong aria-hidden="true">47.</strong> ADR-015: ITF: informal trace format</a></li><li class="chapter-item expanded "><a href="../adr/016adr-retla.html"><strong aria-hidden="true">48.</strong> ADR-016: ReTLA: Relational TLA</a></li><li class="chapter-item expanded "><a href="../adr/017pdr-temporal.html"><strong aria-hidden="true">49.</strong> PDR-017: Checking temporal properties</a></li><li class="chapter-item expanded "><a href="../adr/018adr-inlining.html"><strong aria-hidden="true">50.</strong> ADR-018: Inlining in Apalache</a></li><li class="chapter-item expanded "><a href="../adr/019adr-harmonize-changelog.html"><strong aria-hidden="true">51.</strong> ADR-019: Harmonize changelog management</a></li><li class="chapter-item expanded "><a href="../adr/020adr-arenas.html"><strong aria-hidden="true">52.</strong> ADR-020: Improving membership in arenas</a></li><li class="chapter-item expanded "><a href="../adr/021rfc-prioritization.html"><strong aria-hidden="true">53.</strong> RFC-021: Prioritization of Work</a></li><li class="chapter-item expanded "><a href="../adr/022adr-unification-of-configs-and-options.html"><strong aria-hidden="true">54.</strong> ADR-022: Unify Configuration Management and &quot;Pass Options&quot;</a></li><li class="chapter-item expanded "><a href="../adr/023adr-trace-evaluation.html"><strong aria-hidden="true">55.</strong> ADR-023: Trace evaluation</a></li><li class="chapter-item expanded "><a href="../adr/024adr-arena-pass.html"><strong aria-hidden="true">56.</strong> ADR-024: Arena computation isolation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#variants" id="variants">Variants</a></h1>
<p><a href="./apalache-extensions.html">[Back to Apalache extensions]</a></p>
<p><a href="https://en.wikipedia.org/wiki/Tagged_union">Variants</a> (also called <em>tagged unions</em> or <em>sum types</em>) are useful, when you want to combine
values of different shapes in a single set or a sequence.</p>
<p><strong>Idiomatic tagged unions in untyped TLA+.</strong>
In untyped TLA+, one can construct sets, which contain records with different fields,
where one filed is typically used as a disambiguation tag. 
For instance, we could create a set that contains two records of different shapes:</p>
<pre><code class="language-tla">ApplesAndOranges == {
    [ tag |-&gt; &quot;Apple&quot;, color |-&gt; &quot;red&quot; ],
    [ tag |-&gt; &quot;Orange&quot;, seedless |-&gt; TRUE ]
  }
</code></pre>
<p>We can dynamically reason about the elements of <code>ApplesAndOranges</code> based on their tag:</p>
<pre><code class="language-tla">  \E e \in ApplesAndOranges:
    /\ e.tag = &quot;Apple&quot;
    /\ e.color /= &quot;green&quot;
</code></pre>
<p>This idiom is quite common in untyped TLA+. <a href="https://github.com/tlaplus/Examples/blob/779852ba9951621f062fc4074b8e81fd12db21dc/specifications/Paxos/Paxos.tla#L85-L106">Tagged unions in Paxos</a> is
probably the most illuminating example of this idiom. Unfortunately, it is way
too easy to make a typo in the tag name, since it is a string, or simply access
a field, which records marked with the given tag do not have. For example:</p>
<pre><code class="language-tla">  \E e \in ApplesAndOranges:
    /\ e.tag = &quot;Apple&quot;
    /\ e.seedless
</code></pre>
<p><strong>Variants module.</strong> Apalache formalizes the above idiom in the module
<a href="https://github.com/informalsystems/apalache/blob/main/src/tla/Variants.tla">Variants.tla</a>. Apalache's type checker alerts users with a type error when
they access a wrong value. Additionally, the default implementation raises an
error in TLC when a variant is used incorrectly.</p>
<p><strong>Immutability</strong>. All variants are immutable.</p>
<p><strong>Construction.</strong> An instance of a variant can be constructed via the operator
<code>Variant</code>:</p>
<pre><code class="language-tla">Variant(&quot;Apple&quot;, &quot;red&quot;)
</code></pre>
<p>If we just construct a variant like in the example above, it will be assigned
a parametric variant type:</p>
<pre><code>Apple(Str) | a
</code></pre>
<p>In this type, we know that whenever a value is tagged with &quot;Apple&quot; it should be
of the string type. However, we know nothing about other options. Most of the
time, we want to define variants that are sealed, that is, we know all
available options. Suppose we wanted to reason about different kinds of fruit, 
but wanted to limit our model to only comparing apples and oranges.
In Apalache, the type for a value that could be either an apple or an orange, but nothing else, 
would be as follows:</p>
<pre><code>Apple(Str) | Orange(Bool)
</code></pre>
<p>To make it easier to represent the fruits, we can introduce variants together with 
user-defined constructors for each option::</p>
<pre><code class="language-tla">\* @typeAlias: FRUIT = Apple(Str) | Orange(Bool);

\* @type: Str =&gt; FRUIT;
Apple(color) == Variant(&quot;Apple&quot;, color)

\* @type: Bool =&gt; FRUIT;
Orange(seedless) == Variant(&quot;Orange&quot;, seedless)
</code></pre>
<p>Now we can naturally construct apples and orange as follows:</p>
<pre><code class="language-tla">Apple(&quot;red&quot;)
Orange(TRUE)
</code></pre>
<p>Variants can wrap records, for when we want to represent compound data with named fields:</p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])
</code></pre>
<p>Once a variant is constructed, it becomes opaque to the type checker, that is,
the type checker only knows that <code>Water(TRUE)</code> and <code>Beer(&quot;Dark&quot;, 5)</code> are both
of type <code>DRINK</code>. This is exactly what we want, in order to combine these values
in a single set. However, we have lost the ability to access the fields of
these values. To deconstruct values of a variant type, we have to use other
operators, presented below.</p>
<p><strong>Filtering by tag name.</strong> Following the idiomatic use of tagged unions in
untyped TLA+, we can filter a set of variants:</p>
<pre><code class="language-tla">LET Drinks == { Water(TRUE), Water(FALSE), Beer(&quot;Radler&quot;, 2) } IN
\E d \in VariantFilter(&quot;Beer&quot;, Drink):
    d.strength &lt; 3
</code></pre>
<p>We believe that <code>VariantFilter</code> is the most commonly used way to partition a
set of variants. Note that <code>VariantFilter</code> transforms a set of variants into a
set of values (that correspond to the associated tag name).</p>
<p><strong>Type-safe get.</strong> Sometimes, we do have just a value that does not belong to a
set, so we cannot use <code>VariantFilter</code> directly. In this case, we can use
<code>VariantGetOrElse</code>:</p>
<pre><code class="language-tla">LET water == Water(TRUE) IN
VariantGetOrElse(&quot;Beer&quot;, water,
                 [ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0])).strength
</code></pre>
<p>In the above example, we unpack <code>water</code> by using the tag name <code>&quot;Beer&quot;</code>.  Since
<code>water</code> is actually tagged with <code>&quot;Water&quot;</code>, the operator falls back to the
default case and returns the record <code>[ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0]</code>.</p>
<p><strong>Type-unsafe get.</strong> Sometimes, using <code>VariantFilter</code> and <code>VariantGetOrElse</code>
is a nuisance, when we know the exact value type. In this case, we can bypass
the type checker and get the value notwithstanding the tag:</p>
<pre><code class="language-tla">LET drink == ... IN
LET nonFree ==
    IF VariantTag(drink) = &quot;Water&quot;
    THEN VariantGetUnsafe(&quot;Water&quot;, drink).sparkling
    ELSE VariantGetUnsafe(&quot;Beer&quot;, drink).strength &gt; 0
IN
...
</code></pre>
<p>In general, you should avoid using <code>VariantGetUnsafe</code>, as it is type unsafe.
Consider the following example:</p>
<pre><code class="language-tla">  VariantGetUnsafe(&quot;Beer&quot;, Water(TRUE)).strength
</code></pre>
<p>In the above example, we treat water as beer. If you try this example with TLC,
it would complain about the missing field <code>strength</code>, as it computes some form
of types dynamically. If you try this example with Apalache, it would compute
types statically and in the case of <code>VariantGetUnsafe</code> it would simply produce
an arbitrary integer. Most likely, this arbitrary integer would propagate into
an invariant violation and will lead to a spurious counterexample.</p>
<hr />
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<hr />
<p><a name="variantCtor"></a></p>
<h3><a class="header" href="#variant-constructor" id="variant-constructor">Variant constructor</a></h3>
<p><strong>Notation:</strong> <code>Variant(tagName, associatedValue)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a value
(a TLA+ expression).</p>
<p><strong>Apalache type:</strong> <code>(Str, a) =&gt; tagName(a) | b </code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The variant constructor returns a new value of the variant type.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])
</code></pre>
<hr />
<p><a name="variantTag"></a></p>
<h3><a class="header" href="#variant-tag" id="variant-tag">Variant tag</a></h3>
<p><strong>Notation:</strong> <code>VariantTag(variant)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> One argument: a variant constructed via <code>Variant</code>.</p>
<p><strong>Apalache type:</strong> <code>(tagName(a) | b) =&gt; Str</code>, for some types <code>a</code> and <code>b</code>. Note
that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a type
variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> This operator simply returns the tag attached to the variant.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">VariantTag(Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])) = &quot;Water&quot;
</code></pre>
<hr />
<p><a name="variantFilter"></a></p>
<h3><a class="header" href="#variant-filter" id="variant-filter">Variant filter</a></h3>
<p><strong>Notation:</strong> <code>VariantFilter(tagName, set)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a set of
variants (a TLA+ expression).</p>
<p><strong>Apalache type:</strong> <code>(Str, Set(tagName(a) | b)) =&gt; Set(a)</code>, for some types <code>a</code>
and <code>b</code>. Note that <code>tagName</code> is an identifier in this notation. In this type,
<code>b</code> is a type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The variant filter keeps the set elements that are tagged with
<code>tagName</code>. It removes the tags from these elements and produces the set of
values that were packed with <code>Variant</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET Drinks == { Water(TRUE), Water(FALSE), Beer(&quot;Radler&quot;, 2) } IN
\E d \in VariantFilter(&quot;Beer&quot;, Drinks):
    d.strength &lt; 3
</code></pre>
<hr />
<p><a name="variantGetOrElse"></a></p>
<h3><a class="header" href="#unpacking-a-variant-safely" id="unpacking-a-variant-safely">Unpacking a variant safely</a></h3>
<p><strong>Notation:</strong> <code>VariantGetOrElse(tagName, variant, defaultValue)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Three arguments: the tag name (a string literal), a variant
constructed via <code>Variant</code>, a default value compatible with the value carried by
the variant.</p>
<p><strong>Apalache type:</strong> <code>(Str, tagName(a) | b, a) =&gt; a</code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The operator <code>VariantGetOrElse</code> returns the value that was wrapped
via the <code>Variant</code> constructor, if the variant is tagged with <code>tagName</code>.
Otherwise, the operator returns <code>defaultValue</code>.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET water == Water(TRUE) IN
VariantGetOrElse(&quot;Beer&quot;, water,
                 [ malt |-&gt; &quot;Non-alcoholic&quot;, strength |-&gt; 0])).strength
</code></pre>
<hr />
<p><a name="variantGetUnsafe"></a></p>
<h3><a class="header" href="#unpacking-a-variant-unsafely" id="unpacking-a-variant-unsafely">Unpacking a variant unsafely</a></h3>
<p><strong>Notation:</strong> <code>VariantGetUnsafe(tagName, variant)</code></p>
<p><strong>LaTeX notation:</strong> same</p>
<p><strong>Arguments:</strong> Two arguments: the tag name (a string literal) and a variant
constructed via <code>Variant</code>.</p>
<p><strong>Apalache type:</strong> <code>(Str, tagName(a) | b) =&gt; a</code>, for some types <code>a</code> and <code>b</code>.
Note that <code>tagName</code> is an identifier in this notation. In this type, <code>b</code> is a
type variable that captures other options in the variant type.</p>
<p><strong>Effect:</strong> The operator <code>VariantGetUnsafe</code> unconditionally returns some value
that is compatible with the type of values tagged with <code>tagName</code>. If <code>variant</code>
is tagged with <code>tagName</code>, the returned value is the value that was wrapped via
the <code>Variant</code> constructor. Otherwise, it is some arbitrary value of a proper type.
As such, this operator does not guarantee that the retrieved value
is always constructed via <code>Variant</code>, unless the operator is used with the right tag.</p>
<p><strong>Determinism:</strong> Deterministic.</p>
<p><strong>Errors:</strong> No errors.</p>
<p><strong>Example in TLA+:</strong></p>
<pre><code class="language-tla">\* @typeAlias: DRINK =
\*     Water({ sparkling: Bool })
\*   | Beer({ malt: Str, strength: Int });
\*
\* @type: Bool =&gt; DRINK;
Water(sparkling) == Variant(&quot;Water&quot;, [ sparkling |-&gt; sparkling ])

\* @type: (Str, Int) =&gt; DRINK;
Beer(malt, strength) == Variant(&quot;Beer&quot;, [ malt |-&gt; malt, strength |-&gt; strength ])

LET drink == Beer(&quot;Dunkles&quot;, 4) IN
LET nonFree ==
    IF VariantTag(drink) = &quot;Water&quot;
    THEN VariantGetUnsafe(&quot;Water&quot;, drink).sparkling
    ELSE VariantGetUnsafe(&quot;Beer&quot;, drink).strength &gt; 0
IN
...
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../lang/apalache-operators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../lang/option-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../lang/apalache-operators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../lang/option-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".././highlightjs-tlaplus/dist/tlaplus.min.js"></script>
        
        <script type="text/javascript" src=".././theme/highlightTla.js"></script>
        

        

    </body>
</html>
