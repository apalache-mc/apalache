<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Symbolic Model Checking - Apalache Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../tutorials/entry-tutorial.html"><strong aria-hidden="true">2.</strong> Entry-level Model Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/snowcat-tutorial.html"><strong aria-hidden="true">3.</strong> Type Checker Tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/pluscal-tutorial.html"><strong aria-hidden="true">4.</strong> Checking Pluscal specifications</a></li><li class="chapter-item expanded "><a href="../tutorials/trail-tips.html"><strong aria-hidden="true">5.</strong> Apalache trail tips: how to check your specs faster</a></li><li class="chapter-item expanded "><a href="../tutorials/symbmc.html" class="active"><strong aria-hidden="true">6.</strong> Symbolic Model Checking</a></li><li class="chapter-item expanded "><a href="../tutorials/temporal-properties.html"><strong aria-hidden="true">7.</strong> Specifying temporal properties and understanding counterexamples</a></li><li class="chapter-item expanded affix "><li class="part-title">HOWTOs</li><li class="chapter-item expanded "><a href="../HOWTOs/index.html"><strong aria-hidden="true">8.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../HOWTOs/howto-write-type-annotations.html"><strong aria-hidden="true">9.</strong> How to write type annotations</a></li><li class="chapter-item expanded "><a href="../HOWTOs/uninterpretedTypes.html"><strong aria-hidden="true">10.</strong> How to use uninterpreted types</a></li><li class="chapter-item expanded affix "><li class="part-title">Apalache User Manual</li><li class="chapter-item expanded "><a href="../apalache/index.html"><strong aria-hidden="true">11.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/index.html"><strong aria-hidden="true">11.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/installation/jvm.html"><strong aria-hidden="true">11.1.1.</strong> Prebuilt Packages</a></li><li class="chapter-item expanded "><a href="../apalache/installation/docker.html"><strong aria-hidden="true">11.1.2.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../apalache/installation/source.html"><strong aria-hidden="true">11.1.3.</strong> Build from Source</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/running.html"><strong aria-hidden="true">11.2.</strong> Running the Tool</a></li><li class="chapter-item expanded "><a href="../apalache/example.html"><strong aria-hidden="true">11.3.</strong> An Example TLA+ Specification</a></li><li class="chapter-item expanded "><a href="../apalache/parameters.html"><strong aria-hidden="true">11.4.</strong> Specification Parameters</a></li><li class="chapter-item expanded "><a href="../apalache/principles/index.html"><strong aria-hidden="true">11.5.</strong> Symbolic Model Checking with Apalache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apalache/principles/assignments.html"><strong aria-hidden="true">11.5.1.</strong> Assignments and symbolic transitions</a></li><li class="chapter-item expanded "><a href="../apalache/principles/folds.html"><strong aria-hidden="true">11.5.2.</strong> Folding sets and sequences</a></li><li class="chapter-item expanded "><a href="../apalache/principles/invariants.html"><strong aria-hidden="true">11.5.3.</strong> Invariants: State, Action, Trace</a></li><li class="chapter-item expanded "><a href="../apalache/principles/enumeration.html"><strong aria-hidden="true">11.5.4.</strong> Enumeration of counterexamples</a></li><li class="chapter-item expanded "><a href="../apalache/principles/apalache-mod.html"><strong aria-hidden="true">11.5.5.</strong> The Apalache Module</a></li><li class="chapter-item expanded "><a href="../apalache/principles/naturals.html"><strong aria-hidden="true">11.5.6.</strong> Naturals</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/config.html"><strong aria-hidden="true">11.6.</strong> Apalache global configuration file</a></li><li class="chapter-item expanded "><a href="../apalache/statistics.html"><strong aria-hidden="true">11.7.</strong> TLA+ Execution Statistics</a></li><li class="chapter-item expanded "><a href="../apalache/profiling.html"><strong aria-hidden="true">11.8.</strong> Profiling Your Specification</a></li><li class="chapter-item expanded "><a href="../apalache/theory.html"><strong aria-hidden="true">11.9.</strong> Five minutes of theory</a></li></ol></li><li class="chapter-item expanded "><a href="../apalache/tuning.html"><strong aria-hidden="true">12.</strong> Fine Tuning</a></li><li class="chapter-item expanded "><a href="../apalache/tlc-config.html"><strong aria-hidden="true">13.</strong> TLC Configuration Files</a></li><li class="chapter-item expanded "><a href="../apalache/typechecker-snowcat.html"><strong aria-hidden="true">14.</strong> The Snowcat Type Checker</a></li><li class="chapter-item expanded "><a href="../apalache/features.html"><strong aria-hidden="true">15.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../apalache/principles/recursive.html"><strong aria-hidden="true">16.</strong> Obsolete: Recursive operators and functions</a></li><li class="chapter-item expanded "><a href="../apalache/known-issues.html"><strong aria-hidden="true">17.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="../apalache/antipatterns.html"><strong aria-hidden="true">18.</strong> Antipatterns</a></li><li class="chapter-item expanded "><a href="../apalache/preprocessing.html"><strong aria-hidden="true">19.</strong> TLA+ Preprocessing</a></li><li class="chapter-item expanded "><a href="../apalache/assignments-in-depth.html"><strong aria-hidden="true">20.</strong> Assignments and Symbolic Transitions in Depth</a></li><li class="chapter-item expanded "><a href="../apalache/kera.html"><strong aria-hidden="true">21.</strong> KerA: kernel logic of actions</a></li><li class="chapter-item expanded affix "><li class="part-title">TLA+ Language Manual for Engineers</li><li class="chapter-item expanded "><a href="../lang/index.html"><strong aria-hidden="true">22.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../lang/standard-operators.html"><strong aria-hidden="true">23.</strong> The standard operators of TLA+</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/booleans.html"><strong aria-hidden="true">23.1.</strong> Booleans</a></li><li class="chapter-item expanded "><a href="../lang/control-and-nondeterminism.html"><strong aria-hidden="true">23.2.</strong> Control And Nondeterminism</a></li><li class="chapter-item expanded "><a href="../lang/conditionals.html"><strong aria-hidden="true">23.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../lang/integers.html"><strong aria-hidden="true">23.4.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../lang/sets.html"><strong aria-hidden="true">23.5.</strong> Sets</a></li><li class="chapter-item expanded "><a href="../lang/logic.html"><strong aria-hidden="true">23.6.</strong> Logic</a></li><li class="chapter-item expanded "><a href="../lang/functions.html"><strong aria-hidden="true">23.7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../lang/records.html"><strong aria-hidden="true">23.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="../lang/tuples.html"><strong aria-hidden="true">23.9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../lang/sequences.html"><strong aria-hidden="true">23.10.</strong> Sequences</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.11.</strong> Bags</div></li></ol></li><li class="chapter-item expanded "><a href="../lang/apalache-extensions.html"><strong aria-hidden="true">24.</strong> Apalache extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/apalache-operators.html"><strong aria-hidden="true">24.1.</strong> Apalache module</a></li><li class="chapter-item expanded "><a href="../lang/variants.html"><strong aria-hidden="true">24.2.</strong> Variants</a></li><li class="chapter-item expanded "><a href="../lang/option-types.html"><strong aria-hidden="true">24.3.</strong> Option types</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/user-operators.html"><strong aria-hidden="true">25.</strong> User-defined operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/user/top-level-operators.html"><strong aria-hidden="true">25.1.</strong> Top-level operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/let-in.html"><strong aria-hidden="true">25.2.</strong> LET-IN definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/higher-order-operators.html"><strong aria-hidden="true">25.3.</strong> Higher-order operators definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/lambdas.html"><strong aria-hidden="true">25.4.</strong> Anonymous operator definitions</a></li><li class="chapter-item expanded "><a href="../lang/user/local-operators.html"><strong aria-hidden="true">25.5.</strong> Local operator definitions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Modules, Extends, and Instances</div></li><li class="chapter-item expanded affix "><li class="part-title">Idiomatic TLA+</li><li class="chapter-item expanded "><a href="../idiomatic/index.html"><strong aria-hidden="true">27.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../idiomatic/000keep-minimum-state-variables.html"><strong aria-hidden="true">28.</strong> Keep state variables to the minimum</a></li><li class="chapter-item expanded "><a href="../idiomatic/001assignments.html"><strong aria-hidden="true">29.</strong> Update state variables with assignments</a></li><li class="chapter-item expanded "><a href="../idiomatic/002primes.html"><strong aria-hidden="true">30.</strong> Apply primes only to state variables</a></li><li class="chapter-item expanded "><a href="../idiomatic/007if-then-else.html"><strong aria-hidden="true">31.</strong> Use Boolean operators in actions, not IF-THEN-ELSE</a></li><li class="chapter-item expanded "><a href="../idiomatic/003record-sets.html"><strong aria-hidden="true">32.</strong> Avoid sets of mixed records</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Documents</li><li class="chapter-item expanded "><a href="../adr/001rfc-types.html"><strong aria-hidden="true">33.</strong> RFC 001: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/002adr-types.html"><strong aria-hidden="true">34.</strong> ADR-002: types and type annotations</a></li><li class="chapter-item expanded "><a href="../adr/003adr-trex.html"><strong aria-hidden="true">35.</strong> ADR-003: transition executor (TRex)</a></li><li class="chapter-item expanded "><a href="../adr/004adr-annotations.html"><strong aria-hidden="true">36.</strong> ADR-004: code annotations</a></li><li class="chapter-item expanded "><a href="../adr/005adr-json.html"><strong aria-hidden="true">37.</strong> ADR-005: JSON Serialization Format</a></li><li class="chapter-item expanded "><a href="../adr/006rfc-unit-testing.html"><strong aria-hidden="true">38.</strong> RFC-006: unit tests and property-based tests</a></li><li class="chapter-item expanded "><a href="../adr/007adr-restructuring.html"><strong aria-hidden="true">39.</strong> ADR-007: restructuring</a></li><li class="chapter-item expanded "><a href="../adr/008adr-exceptions.html"><strong aria-hidden="true">40.</strong> ADR-008: exceptions</a></li><li class="chapter-item expanded "><a href="../adr/009adr-outputs.html"><strong aria-hidden="true">41.</strong> ADR-009: outputs</a></li><li class="chapter-item expanded "><a href="../adr/010rfc-transition-explorer.html"><strong aria-hidden="true">42.</strong> RFC-010: Implementation of Transition Exploration Server</a></li><li class="chapter-item expanded "><a href="../adr/011adr-smt-arrays.html"><strong aria-hidden="true">43.</strong> ADR-011: alternative SMT encoding using arrays</a></li><li class="chapter-item expanded "><a href="../adr/012adr-adopt-adr-template.html"><strong aria-hidden="true">44.</strong> ADR-012: Adopt an ADR Template</a></li><li class="chapter-item expanded "><a href="../adr/013adr-configuration.html"><strong aria-hidden="true">45.</strong> ADR-013: Configuration Management Component</a></li><li class="chapter-item expanded "><a href="../adr/014adr-precise-records.html"><strong aria-hidden="true">46.</strong> ADR-014: Precise type inference for records and variants</a></li><li class="chapter-item expanded "><a href="../adr/015adr-trace.html"><strong aria-hidden="true">47.</strong> ADR-015: ITF: informal trace format</a></li><li class="chapter-item expanded "><a href="../adr/016adr-retla.html"><strong aria-hidden="true">48.</strong> ADR-016: ReTLA: Relational TLA</a></li><li class="chapter-item expanded "><a href="../adr/017pdr-temporal.html"><strong aria-hidden="true">49.</strong> PDR-017: Checking temporal properties</a></li><li class="chapter-item expanded "><a href="../adr/018adr-inlining.html"><strong aria-hidden="true">50.</strong> ADR-018: Inlining in Apalache</a></li><li class="chapter-item expanded "><a href="../adr/019adr-harmonize-changelog.html"><strong aria-hidden="true">51.</strong> ADR-019: Harmonize changelog management</a></li><li class="chapter-item expanded "><a href="../adr/020adr-arenas.html"><strong aria-hidden="true">52.</strong> ADR-020: Improving membership in arenas</a></li><li class="chapter-item expanded "><a href="../adr/021rfc-prioritization.html"><strong aria-hidden="true">53.</strong> RFC-021: Prioritization of Work</a></li><li class="chapter-item expanded "><a href="../adr/022adr-unification-of-configs-and-options.html"><strong aria-hidden="true">54.</strong> ADR-022: Unify Configuration Management and &quot;Pass Options&quot;</a></li><li class="chapter-item expanded "><a href="../adr/023adr-trace-evaluation.html"><strong aria-hidden="true">55.</strong> ADR-023: Trace evaluation</a></li><li class="chapter-item expanded "><a href="../adr/024adr-arena-pass.html"><strong aria-hidden="true">56.</strong> ADR-024: Arena computation isolation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Apalache Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/informalsystems/apalache" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#symbolic-model-checking" id="symbolic-model-checking">Symbolic Model Checking</a></h1>
<p>This brief introduction to symbolic model checking discusses the following:</p>
<ol>
<li>State-spaces and transition systems</li>
<li>What is a symbolic state?</li>
<li>What are symbolic traces?</li>
<li>How do I interpret Apalache counterexamples?</li>
</ol>
<p>A glossary of notations and definitions can be found <a href="#notation-and-definitions">below</a></p>
<h2><a class="header" href="#on-state-spaces-and-transition-systems" id="on-state-spaces-and-transition-systems">On state-spaces and transition systems</a></h2>
<p>A TLA+ specification defines a triple \((S,S_0,\to)\), called a <em>transition system</em>.
\(S\) is the <em>state space</em>, \(S_0\) is the set of initial states \(\left(S_0 \subseteq S\right)\),
and \(\to\) is the transition relation, a subset of \(S^2\).</p>
<h3><a class="header" href="#state-spaces" id="state-spaces">State spaces</a></h3>
<p>The structure of a single state depends on the number of variables a specification declares.
For example, if a specification declares </p>
<pre><code class="language-tla">VARIABLE A1, A2, A3, ..., Ak
</code></pre>
<p>then a <em>state</em> is a mapping \([A_1 \mapsto a_1, \dots, A_k \mapsto a_k]\),
where \(a_i\) represents the value of the variable <code>Ai</code>, for each \(i = 1,\dots,k\).
Here, we represent TLA+ variable names as unique formal symbols,
where, for example the TLA+ variable <code>A1</code> is represented by the formal symbol \(A_1\).
By convention, we will use markdown-syntax to refer to objects in TLA+ specifications, and latex notation otherwise.
The state space \(S\) is then the set of all such mappings,
i.e. the set of all possible combinations of values that variables may hold.
For brevity, whenever the specification defines exactly one variable,
we will treat a state as a single value \(a_1\) instead of the mapping \([A_1 \mapsto a_1]\).</p>
<p>In untyped TLA+, one can think of \(S\) as \(U^{\{A_1,\dots, A_k\}}\), that is,
the set of all mappings, which assign a value in \(U\), the universe of all TLA+ values, to each symbol.
This set is naturally isomorphic to \(U^k\).
In typed TLA+, such as in Apalache, where variable declarations look like:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: T1;
  A1, 
  ..., 
  \* @type: Tk;
  Ak
</code></pre>
<p>\(S\) is additionally restricted, such that for all \(s \in S\)
each symbol \(A_i\) maps to a value \(s(A_i) \in V_i\), where \(Vi \subset U\)
is the set of all values, which hold the type \(T_i\), for each \(i = 1,\dots,k\).
For example, in the specification with</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Bool;
  A1, 
  \* @type: Bool;
  A2
</code></pre>
<p>The state space is \(\mathbb{B}^{\{x,y\}}\) when considering types,
since each variable can hold one of two boolean values.
In the untyped setting, the state space is infinite, and contains states where,
for example, \(A1\) maps to <code>[z \in 1..5 |-&gt; &quot;a&quot;]</code> and \(A2\) maps to  <code>CHOOSE p \in {}: TRUE</code>.</p>
<p>As Apalache enforces a type system, the remainder of this document will assume the typed setting.
This assumption does not change any of the definitions. 
We will also assume that every specification declares an initial-state predicate <code>Init</code>,
a transition-predicate <code>Next</code> and an invariant <code>Inv</code> (if not specified, assumed to be <code>TRUE</code>).
For simplicity, we will also assume that the specification if free of constants,
resp. that all of the constants have been initialized.</p>
<h3><a class="header" href="#initial-states" id="initial-states">Initial states</a></h3>
<p>The second component, \(S_0\), the set of all initial states, is derived from \(S\) and <code>Init</code>. 
The initial state predicate is a Boolean formula, in which specification-variables appear as free logic variables. 
The operator <code>Init</code> characterizes a predicate \(P_{S_0} \in \mathbb{B}^S\) in the following way:
given a state \(s \in S\), the formula obtained by replacing all occurrences of variable names <code>Ai</code> in <code>Init</code>
with the values \(s(A_i)\) is a Boolean formula with no free variables (in a well-typed, parseable specification),
which evaluates to either <code>TRUE</code> or <code>FALSE</code>. We say \(P_{S_0}(s)\) is the evaluation of this formula.
By the subset-predicate equivalence, we identify the predicate \(P_{S_0}\)
with a subset \(S_0\) of \(S\): \(S_0 = \{ s \in S\mid P_{S_0}(s) = TRUE \}\). </p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 3..5 /\ y = 2 
</code></pre>
<p>we see that \(S = \mathbb{Z}^{\{x,y\}}\) and \(S_0 = \{ [x \mapsto 3, y \mapsto 2], [x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2] \}\).</p>
<h3><a class="header" href="#transitions" id="transitions">Transitions</a></h3>
<p>Similar to \(S_0\), \(\to\) is derived from \(S\) and <code>Next</code>.
If \(S_0\) is a single-argument predicate \(S_0 \in \mathbb{B}^S\),
then \(\to\) is a relation \(\to \in \mathbb{B}^{S^2}\). 
\(\to(s_1,s_2)\) is the evaluation of the formula obtained by replacing all occurrences
of variable names <code>Ai</code> in <code>Next</code> with the values \(s_1(A_i)\),
and all occurrences of <code>Ai'</code> with \(s_2(A_i)\).
By the same principle of subset-predicate equivalence, we can treat \(\to\) as a subset of \(S^2\).
As mentioned in the notation section, it is generally more convenient to use the infix notation
\(s_1 \to s_2\) over \(\to(s_1, s_2)\). We say that a state \(s_2\)
is a <em>successor</em> of the state \(s_1\) if \(s_1 \to s_2\). </p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 3..5 /\ y = 2 

Next == x' \in { x, x + 1 } /\ UNCHANGED y
</code></pre>
<p>One can deduce, for any state \([x \mapsto a, y \mapsto b] \in S\), that it has two successors:
\([x \mapsto a + 1, y \mapsto b]\) and \([x \mapsto a, y \mapsto b]\)
because the following relations hold \([x \mapsto a, y \mapsto b] \to [x \mapsto a + 1, y \mapsto b]\)
and \( [x \mapsto a, y \mapsto b] \to [x \mapsto a, y \mapsto b] \).</p>
<p>Lastly, we define traces in the following way:
A <em>trace</em> of length \(k\) is simply a sequence of states \(s_0,\dots, s_k \in S\),
such that \(s_0 \in S_0\) and \(s_i \to s_{i+1}\) for all \(i\in \{0,\dots,k-1\}\). 
This definition naturally extends to <em>inifinite traces</em>.</p>
<p>For example, the above specification admits the following traces of length 2 (among others):
\[
[x \mapsto 3, y \mapsto 2], [x \mapsto 3, y \mapsto 2], [x \mapsto 3, y \mapsto 2]
\]
\[
[x \mapsto 3, y \mapsto 2], [x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2]
\]
\[
[x \mapsto 4, y \mapsto 2], [x \mapsto 5, y \mapsto 2], [x \mapsto 5, y \mapsto 2]
\]</p>
<h3><a class="header" href="#reachable-states" id="reachable-states">Reachable states</a></h3>
<p>Using the above definitions, we can define the set of states reachable in exactly \(k\)-steps,
for \(k \in \mathbb{N}\), denoted by \(R(k)\). We define \(R(0) = S_0\) and for each \(k \in \mathbb{N}\),
\[
R(k+1) := \{ t \in S \mid \exists s \in R(k) \ .\ s \to t \}
\]</p>
<p>Similarly, we can define the set of states reachable in <em>at most</em> \(k\)-steps,
denoted \(r(k)\), for \(k \in \mathbb{N}\) by
\[
r(k) := \bigcup_{i=0}^k R(i)
\]</p>
<p>Finally, we define the set of all <em>reachable</em> states, \(R\),
as the (infinite) union of all \(R(k)\), over \(k \in \mathbb{N}\):
\[
R := \bigcup_{k \in \mathbb{N}} R(k)
\]</p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y

Init == x \in 1..3 /\ y = 2

Next == x' = x + 1 /\ UNCHANGED y
</code></pre>
<p>we can deduce: </p>
<p>\begin{align}
R(0) &amp;= r(0) = S_0 = \{[x\mapsto 1, y\mapsto 2],[x\mapsto 2, y\mapsto 2],[x\mapsto 3, y\mapsto 2]\} \\
\\
R(1) &amp;= \{[x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2]\} \\
r(1) &amp;= \{[x\mapsto 1, y\mapsto 2], [x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2]\} \\
\\
R(2) &amp;= \{[x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2], [x\mapsto 5, y\mapsto 2]\} \\
r(2) &amp;= \{[x\mapsto 1, y\mapsto 2], [x\mapsto 2, y\mapsto 2], [x\mapsto 3, y\mapsto 2], [x\mapsto 4, y\mapsto 2], [x\mapsto 5, y\mapsto 2]\}
\end{align}</p>
<p>and so on. We can express this compactly as:
\begin{align}
[x\mapsto a, y \mapsto b] \in R(i) &amp;\iff i+1 \le a \le i + 3 \land b = 2 \\
[x\mapsto a, y \mapsto b] \in r(i) &amp;\iff 1 \le a \le i + 3 \land b = 2 \\
[x\mapsto a, y \mapsto b] \in R &amp;\iff 1 \le a \land b = 2
\end{align}</p>
<h3><a class="header" href="#finite-diameters" id="finite-diameters">Finite diameters</a></h3>
<p>We say that a transition system has a <em>finite diameter</em>, if there exists a \(k \in N\), such that \(R = r(k)\).</p>
<p>If such an integer exists then the smallest integer \(k\), for which this holds true,
is the <em>diameter</em> of the transition system.
In other words, if the transition system \((S,S_0,\to)\) has a finite diameter of \(k\),
any state that is reachable from a state in \(S_0\) is reachable in at most \(k\) transitions.
The example above clearly does not have a finite diameter, since \(R\) is infinite,
but \(r(k)\) is finite for each \(k\).</p>
<p>However, the spec</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 0 

Next == x' = (x + 1) % 7
</code></pre>
<p>has a finite diameter (more specifically, a diameter of 6), because:</p>
<ol>
<li>\(R = \{0,1,\dots,6\}\) (the set of remainders modulo 7), since those are the only values <code>x'</code>,
which is defined as a <code>% 7</code> expression, can take. </li>
<li>for any \(k = 0,\dots,5\), it is the case that \(r(k) = \{0,\dots,k\} \ne R\),
so the diameter is not in \(\{1,\dots,5\}\)</li>
<li>for any \(k \ge 6\), \(r(k) = r(6) = R\)</li>
</ol>
<h3><a class="header" href="#invariants" id="invariants">Invariants</a></h3>
<p>Much like <code>Init</code>, an invariant operator <code>Inv</code> defines a predicate.
However, it is not, in general, the case that <code>Inv</code> defines a predicate over <code>S</code>.
There are different cases we can consider, discussed in more detail <a href="../apalache/principles/invariants.html">here</a>.
For the purposes of this document, we focus on <em>state invariants</em>,
i.e. operators which use only unprimed variables and no temporal- or trace- operators.
A state invariant operator <code>Inv</code> defines a predicate \(I\) over \(S\).
We say that the \(I\) is an <em>invariant</em> in the transition system, if \(R \subseteq I\), that is,
for every reachable state \(s_r \in R\), \(I(s_r)\) holds true.
If \(R \setminus I\) is nonempty (i.e., there exists a state \(s_r \in R\),
such that \(\neg I(s_r)\)), we refer to elements of \(R \setminus I\) as <em>witnesses</em> to invariant violation.</p>
<h3><a class="header" href="#goals-of-model-checking" id="goals-of-model-checking">Goals of model checking</a></h3>
<p>The goal of model checking is to determine whether or not \(R \setminus I\) contains a witness. 
The goal of bounded model checking is to determine, given a bound \(k\), whether or not \(r(k) \setminus I\) contains a witness.</p>
<p>In a transition system with a bounded diameter, one can use bounded model checking
to solve the general model checking problem, since \(R \setminus I\) is equivalent to \(r(k) \setminus I\) for a sufficiently large \(k\). In general, if the system does not have a bounded diameter, failing to find a witness in \(r(k) \setminus I\) cannot be used to reason about the absence of witnesses in \(R \setminus I\)! </p>
<h2><a class="header" href="#explicit-state-model-checking" id="explicit-state-model-checking">Explicit-state model checking</a></h2>
<p>The idea behind explicit-state model checking is to simply perform the following algorithm
(in pseudocode, \(\leftarrow\) represents assignment):</p>
<p>Compute \(S_0\) and set \(Visited \leftarrow \emptyset, ToVisit \leftarrow S_0\)</p>
<ol>
<li>
<p>While \(ToVisit \ne \emptyset\), pick some \(s \in ToVisit\): 
1. If \(\neg I(s)\) then terminate, since a witness is found.
1. If \(I(s)\) then compute \(Successors(s) = \{ t \in S\mid s \to t \}\). Set
\begin{align}
Visited &amp;\leftarrow Visited \cup \{s\}\\
ToVisit &amp;\leftarrow (ToVisit \cup Successors(s)) \setminus Visited
\end{align}</p>
</li>
<li>
<p>If \(ToVisit = \emptyset\) terminate. \(R = Visited\) and \(I\) is an invariant.</p>
</li>
</ol>
<p>While simple to describe, there are several limitations of this approach in practice.
The first limitation is the absence of a termination guarantee.
More specifically, this algorithm terminates if and only if \(R\) is finite.
For example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 0
Next == x' = x + 1
</code></pre>
<p>defines a state space, for which \(R = \mathbb{N}\), so the above algorithm never terminates.
Further, in the general case, it is difficult or impossible to compute \(S_0\)
or the set \(Successors(s)\) defined in the algorithm. 
As an example, consider the following specification:</p>
<pre><code class="language-tla">VARIABLE x

Successor(n) == IF n % 2 = 0 THEN n \div 2 ELSE 3*n + 1 

RECURSIVE kIter(_,_)
kIter(a,k) == IF k &lt;= 0 THEN a ELSE Successor(kIter(a, k-1))

ReachesOne(a) == \E n \in Nat: kIter(a,n) = 1

Init == x \in { n \in Nat: ~ReachesOne(n) }
</code></pre>
<p>The specification encodes the <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz conjecture</a>,
so computing \(S_0\) is equivalent to proving or disproving the conjecture,
which remains an open problem at present. 
It is therefore unreasonable to expect any model checker to be able to accept such an input,
despite the fact that the condition is easily describable in first-order logic.</p>
<p>A similar problem can occur in computing \(Successors(s)\);
the relation between variables <code>Ai</code> (\(s(A_i)\)) and <code>Ai'</code> (\(s_2(A_i)\))
may be given by means of an implicit function or uncomputable expression.
Therefore, most tools impose the following constraints,
which make computing \(S_0\) and \(Successors(s)\) possible without any sort of specialized solver:
The specification must have the shape</p>
<pre><code class="language-tla">VARIABLE A1,...,Ak

Init == /\ A1 \in F1()
        /\ A2 \in F2(A1)
        ...
        /\ Ak \in Fk(A1,...,A{k-1})

Next == /\ CondN(A1,...,Ak)
        /\ A1' \in G1(A1,...,Ak)
        /\ A2' \in G2(A1,...,Ak, A1')
        ...
        /\ Ak' \in Gk(A1,...,Ak, A1',...,A{k-1}')
</code></pre>
<p>or some equivalent form, in which variable values in a state can be iteratively computed,
one at a time, by means of an explicit formula, which uses only variables computed so far.
For instance,</p>
<pre><code class="language-tla">VARIABLE x,y

Init == /\ x \in 1..0
        /\ y \in { k \in 1..10, k &gt; x }

Next == \/ /\ x &gt; 5
           /\ x' = x - 1
           /\ y' = x' + 1
        \/ /\ x &lt;= 5
           /\ y' = 5 - x
           /\ x' = x + y'
</code></pre>
<p>allows one to compute both \(S_0\) as well as \(Successors(s)\), for any \(s\),
by traversing the conjunctions in the syntax-imposed order. </p>
<p>However, even in a situation where states are computable, and \(R\) is finite,
the size of \(R\) itself might be an issue in practice.
We can create very compact specifications with large state-space sizes:</p>
<pre><code class="language-tla">VARIABLE A1,...,Ak

Init == /\ A1 = 0
        ...
        /\ Ak = 0
Next == \/ /\ A1' = (A1 + 1) % C
           /\ UNCHANGED &lt;&lt;A2,...,Ak&gt;&gt;
        \/ /\ A2' = (A2 + 1) % C
           /\ UNCHANGED &lt;&lt;A1,A3,...,Ak&gt;&gt;
        ...
        \/ /\ Ak' = (Ak + 1) % C
           /\ UNCHANGED &lt;&lt;A1,...,A{k-1}&gt;&gt;

</code></pre>
<p>This specification will have \(C^k\) distinct states, despite its rather simplistic behavior.</p>
<h2><a class="header" href="#explicit-state-bounded-model-checking" id="explicit-state-bounded-model-checking">Explicit-state bounded model checking</a></h2>
<p>Adapting the general explicit-state approach to bounded model checking is trivial,
and therefore not particularly interesting.
Assume a bound \(k \in \mathbb{N}\) on the length of the traces considered. </p>
<p>Compute \(S_0\) and set \(Visited \leftarrow \emptyset, ToVisit \leftarrow \{ (s,0)\mid s \in S_0 \}\)</p>
<ol>
<li>
<p>While \(ToVisit \ne \emptyset\), pick some \((s,j) \in ToVisit\): </p>
<ol>
<li>If \(\neg I(s)\) then terminate, since a witness is found.</li>
<li>If \(I(s)\) then:
\begin{align}
Visited &amp;\leftarrow Visited \cup \{(s,j)\} \\
ToVisit &amp;\leftarrow (ToVisit \cup T) \setminus Visited
\end{align}
where \( T \) equals \(\{(t,j+1)\mid t \in Successors(s)\}\) if \(j &lt; k\) and \(\emptyset\) otherwise</li>
</ol>
</li>
<li>
<p>If \(ToVisit = \emptyset\) terminate. \(r(k) = \{v \mid \exists j \in \mathbb{N} \ .\ (v,j) \in Visited\}\)
and \(I\) holds in all states reachable in at most \(k\) steps.</p>
</li>
</ol>
<p>A real implementation would, for efficiency reasons, avoid entering the same state via traces of different length,
but the basic idea would remain unchanged.
Bounding the execution length guarantees termination of the algorithm
if \(S_0\) is finite and each state has finitely many successors w.r.t. \(\to\),
even if the state space is unbounded in general.
However, this comes at a cost of guarantees: while bounded model checking might still find an invariant violation
if it can occur within the bound \(k\), it will fail if the shortest possible trace,
on which the invariant is violated has a length greater than \(k\).</p>
<p>If the system has a finite diameter, bounded model checking is equivalent to model checking,
as long as \(k\) exceeds the diameter.</p>
<h2><a class="header" href="#symbolic-bounded-model-checking" id="symbolic-bounded-model-checking">Symbolic bounded model checking</a></h2>
<p>For a given \(k \in \mathbb{N}\), we want to find a way to determine if \(r(k) \setminus I\) is empty,
without testing every single state in \(r(k)\) like in the explicit-state approach.</p>
<p>The key insight behind symbolic model checking is the following:
it is often the case that the size of the reachable state space is large,
not because of the properties of the specification, but simply because of the constants or sets involved.</p>
<p>Consider the example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x = 1
Next1 == x' \in 1..9
Next2 == x' \in 1..999999999999

Inv == x &lt; 5
</code></pre>
<p>The sets of reachable states defined by each <code>Next</code> have sizes proportional to the upper bounds of the ranges used.
However, to find a violation of the invariant, one merely needs to identify a state \(s\)
in which, for example, \(s(x) = 7\), which belongs to both sets. 
It is not necessary, or efficient, to loop over elements in the range and test each one against <code>Inv</code> to find a violation.
Depending on the logic fragment <code>Inv</code> belongs to, there usually exist strategies for finding such violations much faster.</p>
<p>From this perspective, if, for some \(k\), we succeeded in finding a predicate \(P\) over \(S\), such that:</p>
<ul>
<li>\(P\) belongs to a logic fragment, for which optimizations exist</li>
<li>\(P\) has a witness iff a state reachable in at most \(k\) steps violates \(I\): \(\left(\exists s \in S \ .\ P(s)\right) \iff r(k) \setminus I \ne \emptyset\)</li>
</ul>
<p>we can use specialized techniques within the logical fragment to evaluate \(P\)
and find a witness to the violation of \(I\), or else conclude that \(r(k) \subseteq I\).</p>
<p>To do this, it is sufficient to find a predicate \(P_R^l\) encoding \(R(l)\),
for each \(l \in \{0,\dots,k\}\), since:
\begin{align}
s \in r(l) \iff&amp; \lor s \in R(0) \\
&amp;\lor s \in R(1) \\
&amp;\dots \\
&amp;\lor s \in R(l)
\end{align}</p>
<p>How does one encode \(P_R^0\)?
\[
s \in R(0) \iff s \in S_0 \iff P_{S_0}(s)
\]</p>
<p>so \(P_R^0(s) = P_{S_0}(s)\). What about \(P_R^1\)?
\begin{align}
s \in R(1) &amp;\iff s \in \{ t \in S \mid \exists s_0 \in R(0) \ .\ s_0 \to t \} \\
&amp;\iff \exists s_0 \in R(0) \ .\ s_0 \to s \\
&amp;\iff \exists s_0 \in S \ .\ P_R^0(s_0) \land s_0 \to s
\end{align}
so \(P_R^1(s) := \exists s_0 \in S \ .\ P_R^0(s_0) \land s_0 \to s\)</p>
<p>continuing this way, we can determine
\[
P_R^k(s) := \exists s_{k-1} \in S \ .\ P_R^{k-1}(s_{k-1}) \land s_{k-1} \to s
\]
Which can be expanded to
\[
Pk(s) = \exists s_0,\dots,s_{k-1} \in S \ .\ P_{S_0}(s_0) \land s_0 \to s_1 \land s_1 \to s_2 \land \dots \land s_{k-1} \to s
\]</p>
<p>Then, the formula describing invariant violation in exactly \(k\) steps, \(\exists s_k \in R(k) \setminus I\), becomes
\[
\exists s_0,\dots,s_k \in S \ .\ P_{S_0}(s_0) \land \neg I(s_k) \land \bigwedge_{i=0}^{k-1} s_i \to s_{i+1}
\]</p>
<p>The challenge in designing a symbolic model checker is determining, given TLA+ operators <code>Init</code>, <code>Next</code> and <code>Inv</code>,
the encodings of \(P_{S_0}, \to, I\) as formulas in logics supported by external solvers, for example SMT.</p>
<h3><a class="header" href="#symbolic-states" id="symbolic-states">Symbolic states</a></h3>
<p>In an explicit approach, the basic unit of computation is a single state \(s \in S\).
However, as demonstrated above, symbolic approaches deal with logical formulas.
Recall that a state formula, such as <code>Init</code> is actually a predicate over \(S\),
and a predicate is equivalent to a subset of \(S\).</p>
<p>Predicates tend to not distinguish between certain concrete states. For instance, the formula
\(x &lt; 3\) is equally false for both \(x = 7\) and \(x = 70000000\).
It is useful to characterize all of the states, in which a predicate evaluates to the same value.
This is because we will define symbolic states in terms of equivalence relations:
A predicate \(P\) over \(S\) naturally defines an equivalence relation \(\circledcirc_P\):
For \(a,b \in S\), we say that \(a \circledcirc_P b\) holds if \(P(a) = P(b)\).
Proving that this relation satisfies the criteria for an equivalence relation is left as an exercise to the reader.
This equivalence relation has only two distinct equivalence classes, since \(P(s)\) can only be <code>TRUE</code> or <code>FALSE</code>.
We can therefore think of predicates in the following way: Each predicate \(P\) slices the 
set \(S\) into two disjoint subsets, i.e. the equivalence classes of \(\circledcirc_P\).
An equivalent formulation of the above is saying that each predicate \(P\)
defines a quotient space \(S / \circledcirc_P\), of size \(2\).</p>
<p>Recall that we have expressed the set of states \(R(l)\) with the predicate \(P_R^l\),
for each \(l \in \{0,\dots,k\}\). By the above, \(P_R^l\) defines an equivalence relation
\(\circledcirc_{P_R^l}\) on \(S\), and consequently, two equivalence classes. 
For notational clarity, we use \(\circledcirc^l\) instead of \(\circledcirc_{P_R^l}\). 
Each concrete state \(s \in S\) belongs to exactly one equivalence class \(\lbrack s \rbrack_{ \circledcirc^l} \in S / \circledcirc^l\).</p>
<p>The states in \(R(l)\) correspond to the equivalence class in which \(P_R^l\)
holds true (i.e. \(s \in R(l) \iff \lbrack s \rbrack_{\circledcirc^l} = \{t \in S \mid P_R^l(t) = TRUE\}\)),
and the ones in \(S \setminus R(l)\) correspond to the equivalence class in which \(P_R^l\) is false
(i.e. \(s \notin R(l) \iff \lbrack s \rbrack_{\circledcirc^l} = \{t \in S \mid P_R^l(t) = FALSE\}\)).</p>
<p>We define symbolic states in the following way: Given a predicate \(P\) over \(S\),
a <em>symbolic state</em> with respect to \(P\) is an element of \(S / \circledcirc_P\),
where \(\circledcirc_P\) is the equivalence relation derived from \(P\) (i.e. \(a \circledcirc_P b \iff P(a) = P(b)\)). 
Recall the subset-predicate equivalence: in this context, a symbolic state, w.r.t. \(P\)
is equivalent to a predicate, specifically, either \(P\) or \(\neg P\).</p>
<p>For example, given</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x,
  \* @type: Int;
  y


Init == x = 1 /\ y = 1 
Next == x' \in 1..5 /\ y \in {0,1}
</code></pre>
<p>and the predicate \(P(s) = s(x) &lt; 3\), the symbolic states are 
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land a &lt; 3 \}
\]
and
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land a \ge 3 \}
\]</p>
<p>while the symbolic states w.r.t. \(R(0)\) are 
\[
\{ [x \mapsto 1, y \mapsto 1] \}
\]
and
\[
\{ [x \mapsto a, y \mapsto b] \mid a,b\in \mathbb{Z} \land ( a \ne 1 \lor b \ne 1 )\}
\]</p>
<p>If we only care about characterizing invariant violations, the above techniques are sufficient.
However, specification invariants are often composed of multiple smaller, independent invariants. 
For feedback purposes, it can be beneficial to identify, whenever an invariant violation occurs,
the precise sub-invariant that is the cause. 
Suppose we are given an invariant \(s(x) &gt; 0 \land s(y) &gt; 0\). 
The information whether a reachable state has just \(s(x) \le 0\), just \(s(y) \le 0\),
or both can help determine problems at the design level. </p>
<p>More generally: often, a predicate \(P\) is constructed as a conjunction of other predicates,
e.g. \(P(s) \iff p_1(s) \land \dots \land p_m(s)\). A violation of \(P\) means a violation of (at least) one of
\(p_1,\dots,p_m\), but knowing which one enables additional analysis.</p>
<p>A collection of predicates \(p_1,\dots,p_m\) over \(S\) define an equivalence relation
\(\circledcirc\lbrack p_1,\dots,p_m\rbrack\)in the following way:
For \(a,b \in S\), we say that \( a \circledcirc\lbrack p_1,\dots,p_m\rbrack\ b\) holds if
\(p_1(a) = p_1(b) \land \dots \land p_m(a) = p_m(b)\).
Clearly, \(\circledcirc\lbrack p_1\rbrack = \circledcirc_{p_1}\).</p>
<p>Since a predicate can only evaluate to one of two values, there exist only two equivalence classes for
\(\circledcirc_P\), i.e. only two symbolic states w.r.t. \(P\): one is the set of all states for which
\(P\) is <code>TRUE</code>, and the other is the set of all values for which \(P\) is <code>FALSE</code>. 
In this sense, \(S / \circledcirc_P\) is isomorphic to the set \(\mathbb{B}\).
In the case of \(\circledcirc\lbrack p_1,\dots,p_m\rbrack\), there are \(2^m\) different \(m\)-tuples with values from
\(\mathbb{B}\), so \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\) is isomorphic to \(\mathbb{B}^m\) . </p>
<p>What is the relation between \(\circledcirc\lbrack p_1,\dots,p_m\rbrack\) and \(\circledcirc_P\),
where \(P(s) = p_1(s) \land \dots \land p_m(s)\)?
Clearly, \(P(s) = TRUE \iff p_1(s) = \dots = p_m(s) = TRUE\). 
Consequently, there is one equivalence class in \(S / \circledcirc_P\), that is equal to
\[
C_1 = \{ s \in S \mid P(s) = TRUE \}
\]
and one equivalence class in \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\) that is equal to
\[
C_2 = \{ s \in S \mid p_1(s) = TRUE \land \dots \land p_m(s) = TRUE \}
\]</p>
<p>They are one and the same, i.e. \(C_1 = C_2\). The difference is, that splitting \(P\) into \(m\) components
\(p_1,\dots,p_m\) splits the other (unique) equivalence class \(C \in \{ c \in S / \circledcirc_P \mid c \ne C_1 \}\)
into \(2^m - 1\) parts, which are the equivalence classes in \(\{ c \in S/\circledcirc\lbrack p_1,\dots,p_m\rbrack \mid c \ne C_2 \}\).</p>
<p>Consequently, we can also define symbolic states with respect to a set of predicates \(p_1,\dots,p_m\),
implicitly conjoined, as elements of \(S / \circledcirc\lbrack p_1,\dots,p_m\rbrack\).
Similarly, by the subset-predicate equivalence, a symbolic state, w.r.t. \(p_1,\dots,p_m\) can be viewed as one of
\begin{align}
p_1(s) \land p_2(s) \land \dots \land p_m(s)                  \qquad&amp;= P(s) \\
\neg p_1(s) \land p_2(s) \land \dots \land p_m(s)                 \qquad&amp; | \\
p_1(s) \land \neg p_2(s) \land \dots \land p_m(s)                 \qquad&amp;  | \\
\dots                                             \qquad&amp;   |&gt; \text{(as a disjunction)} = \neg P(s) \\
\neg p_1(s) \land \neg p_2(s) \land \dots \land \neg p_{m-1}(s) \land p_m(s)  \qquad&amp; | \\
\neg p_1(s) \land \neg p_2(s) \land \dots \land \neg p_{m-1}(s) \land \neg p_m(s) \qquad&amp; | \\
\end{align}</p>
<p>For example, take \(p_1(s) = s \in R(k)\) and \(p_2(s) = \neg I(s)\). With respect to \(p_1(s) \land p_2(s)\),
there are two symbolic states: one corresponds to the set of all states which are both reachable and in which the invariant is violated,
while the other corresponds to the set of all states, which are either not reachable, or in which the invariant holds.
Conversely, with respect to \(p_1,p_2\), there are four symbolic states: one corresponds to states
which are both reachable and violate the invariant, one corresponds to states which are reachable,
but which do not violate the invariant, one corresponds to states which are not reachable,
but violate the invariant and the last one corresponds to states which are neither reachable, nor violate the invariant.</p>
<h3><a class="header" href="#symbolic-traces" id="symbolic-traces">Symbolic traces</a></h3>
<p>Having defined symbolic states, what is then the meaning of a symbolic trace?
Recall, a trace of length \(k\) is simply a sequence of reachable states 
\(s_0,\dots, s_k \in S\), such that \(s_0 \in S_0\) and \(s_i \to s_{i+1}\). 
In the symbolic setting, a <em>symbolic trace</em> is a sequence of symbolic states \(C_0,\dots,C_k \subseteq S\), such that 
\[
C_0 \in S / \circledcirc^0 \land \dots \land  C_k \in S / \circledcirc^k
\]</p>
<p>and, for each \(i = 0,\dots,k\), it is the case that \(C_i = \{ s \in S \mid P_R^i(s) = TRUE\}\).
In other words, a symbolic trace is the unique sequence of symbolic states, which correspond to the set
of explicit states evaluating to <code>TRUE</code> under each of \(P_R^0,\dots,P_R^k\) respectively.</p>
<p>Recall that \(P_R^{i+1}(s_{i+1})\) was defined as \(\exists s_i \in S \ .\ P_R^i(s_i) \land s_i \to s_{i+1}\).
While, in the explicit case, we needed to enforce the condition \(s_i \to s_{i+1}\),
in the symbolic case this is already a part of the predicate definition.</p>
<p>For example, consider:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

Init == x \in {0,1}
Next == x' = x + 1
</code></pre>
<p>a trace of length 2 would be one of \(0,1,2\) or \(1,2,3\). A symbolic trace would be the sequence
\[
\{0,1\}, \{1,2\}, \{2,3\}
\]</p>
<p>In the case of symbolic states, we were particularly interested in symbolic states with respect to predicates that encoded reachability. </p>
<p>Unlike the case of invariants, where we considered conjunctions of sub-invariants,
the most interesting scenario w.r.t. traces is when a transition relation is presented as a disjunction of transitions,
i.e. when 
\begin{align}
s_1 \to s_2 \iff&amp; \lor t_1(s_1,s_2)\\
&amp; \lor t_2(s_1,s_2)\\
&amp; \dots \\
&amp; \lor t_m(s_1,s_2)
\end{align}</p>
<p>At the specification level, this is usually the case when one can nondeterministically choose to perform one of \(m\) actions,
and each \(t_1,\dots,t_m\) is an encoding of one such action, which, like \(\to\), translates to a binary predicate over \(S\). </p>
<p>Instead of a single trace \(C_1, \dots, C_k\), where states in \(C_{i+1}\) are reachable from states in
\(C_i\) via \(\to\), we want to separate sets of states reachable by each \(t_i\) individually.</p>
<p>Recall that symbolic traces are sequences of symbolic states, implicitly related by \(\to\),
since \(R\) is defined in terms of \(\to\). 
We define a symbolic trace decomposition by \(t_1,\dots,t_m\), in the following way: 
If \(t_1,\dots,t_m\) are relations, such that \(s_1 \to s_2 \iff \bigvee_{i=1}^m t_i(s_1,s_2)\),
the decomposition of a symbolic trace \(X_0,\dots,X_k\) of length \(k\) w.r.t. \(t_1,\dots,t_m\) is a set \(
D = \{
Y(\tau) \mid \tau \in \{1,\dots,m\}^{\{1,\dots, k\}}
\}
\) , such that: </p>
<ul>
<li>\(Y(\tau)\) is a <em>partial symbolic trace</em> of length k: \(Y_0(\tau) = X_0, Y_1(\tau),\dots, Y_k(\tau)\)</li>
<li>For each \(i = 0,\dots,k-1\), \(Y_{i+1}\) is the set of all states reachable from \(Y_i\) by the transition fragment \(t_j\), where \(j = \tau(i+1)\):
\[
Y_{i+1}(\tau) = \{ s_{i+1} \in X_{i+1} \mid \exists s_i \in Y_i(\tau) \ .\ t_{\tau(i+1)}(s_i,s_{i+1}) \}
\]</li>
</ul>
<p>An interesting property to observe is that, for each \(i=1,\dots,k\), the sets
\(Y_i(\tau)\), over all possible \(\tau\), form a decomposition of \(X_i\). Concretely:
\[
X_i = \bigcup \left\{ Y_i(\tau)\mid \tau \in \{1,\dots,m\}^{\{1,\dots, k\}} \right\}
\]</p>
<p>Less obvious is the fact that, the larger the index \(i\), the finer this decomposition becomes.
Consider \(i=1\). Since \(Y_0\) is fixed, there are as many different \(Y_1(\tau)\) components as there are possible values of
\(\tau(1)\), i.e. \(m\). As \(Y_2\) depends on \(Y_1\), there are as many different components as there are pairs
\((\tau(1),\tau(2))\), i.e. \(m^2\), and so on until \(k\), where there are \(m^k\) possible \(Y_k(\tau)\) sets. 
In practice, however, many of these sets are empty.</p>
<p>Let us look at an example:</p>
<pre><code class="language-tla">VARIABLE 
  \* @type: Int;
  x

A1 == /\ x &gt; 4
      /\ x' = x - 1

A2 == /\ x &lt; 7
      /\ x' = x + 1

A3 == x' = x

A4 == /\ x = 1
      /\ x' = 10

Init == x \in 1..10
Next == \/ A1
        \/ A2
        \/ A3
        \/ A4
</code></pre>
<p>The \(\to\) predicate can be decomposed into:
\begin{align}
t_1(s_1,s_2) &amp;= s_1(x) &gt; 4 \land s_2(x) = s_1(x) - 1 \\
t_2(s_1,s_2) &amp;= s_1(x) &lt; 7 \land s_2(x) = s_1(x) + 1 \\
t_3(s_1,s_2) &amp;= s_2(x) = s_1(x) \\
t_4(s_1,s_2) &amp;= s_1(x) = 1 \land s_2(x) = 10 \\
\end{align}</p>
<p>Suppose we fix the length of the trace \(k = 2\).
Without considering the decomposition, the symbolic trace is equal to 
\[
X_0 = \{1,\dots,10\}, X_1 = \{1,\dots,10\}, X_2 = \{1,\dots,10\}
\]</p>
<p>Under the decomposition, we have \(m^k = 4^2 = 16\) candidates for \(\tau\).
Let us look at \(\tau_1\), for which \(\tau_1(1) = 1, \tau_1(2) = 2\), representing an execution
where the action <code>A1</code> is followed by the action <code>A2</code>.
If \(Y_0(\tau_1),Y_1(\tau_1),Y_2(\tau_1)\) is a partial trace (i.e. one of the elements in the decomposition \(D\)),
then:</p>
<ul>
<li>
<p>\(Y_1(\tau_1) = \{ b \in X_1 \mid \exists a \in Y_0(\tau_1) \ .\ t_{\tau_1(1)}(a,b)\}\) which means
\[
Y_1(\tau_1) = \{ b \in \{1,\dots,10\} \mid \exists a \in \{1,\dots,10\} \ .\ a &gt; 4 \land b = a - 1 \}
= \{4,\dots,9\}
\]</p>
</li>
<li>
<p>\(Y_2(\tau_1) = \{ b \in X_2 \mid \exists a \in Y_1(\tau_1)\ .\ t_{\tau_1(2)}(a,b)\}\) which means
\[
Y_2(\tau_1) = \{ b \in \{1,\dots,10\} \mid \exists a \in \{4,\dots,9\} \ .\ a &lt; 7 \land b = a + 1 \}
= \{5,\dots,7\}
\]</p>
</li>
</ul>
<p>so the partial trace, corresponding to the sequence of actions <code>Init,A1,A2</code> is 
\[
\{1,\dots,10\}, \{4,\dots,9\}, \{5,\dots,7\}
\]</p>
<p>In fact, we can draw a table, representing partial traces corresponding to sequences of actions:</p>
<table><thead><tr><th>Sequence of actions (after <code>Init</code>)</th><th>Partial trace (without \(Y_0\))</th></tr></thead><tbody>
<tr><td>A1, A1</td><td>\(\{4, \dots, 9\}, \{4, \dots, 8\}\)</td></tr>
<tr><td>A1, A2</td><td>\(\{4, \dots, 9\}, \{5, \dots, 7\}\)</td></tr>
<tr><td>A1, A3</td><td>\(\{4, \dots, 9\}, \{4, \dots, 9\}\)</td></tr>
<tr><td>A1, A4</td><td>\(\{4, \dots, 9\}, \emptyset\)</td></tr>
<tr><td>A2, A1</td><td>\(\{2, \dots, 7\}, \{4, \dots, 6\}\)</td></tr>
<tr><td>A2, A2</td><td>\(\{2, \dots, 7\}, \{3, \dots, 7\}\)</td></tr>
<tr><td>A2, A3</td><td>\(\{2, \dots, 7\}, \{2, \dots, 7\}\)</td></tr>
<tr><td>A2, A4</td><td>\(\{2, \dots, 7\}, \emptyset\)</td></tr>
<tr><td>A3, A1</td><td>\(\{1, \dots, 10\}, \{4, \dots, 9\}\)</td></tr>
<tr><td>A3, A2</td><td>\(\{1, \dots, 10\}, \{2, \dots, 7\}\)</td></tr>
<tr><td>A3, A3</td><td>\(\{1, \dots, 10\}, \{1, \dots, 10\}\)</td></tr>
<tr><td>A3, A4</td><td>\(\{1, \dots, 10\}, \{10\}\)</td></tr>
<tr><td>A4, A1</td><td>\(\{10\}, \{9\}\)</td></tr>
<tr><td>A4, A2</td><td>\(\{10\}, \emptyset\)</td></tr>
<tr><td>A4, A3</td><td>\(\{10\}, \{10\}\)</td></tr>
<tr><td>A4, A4</td><td>\(\{10\}, \emptyset\)</td></tr>
</tbody></table>
<p>Clearly, the elements in every column (representing the various \(Y_i(\tau)\)), add up to \(X_i = \{1,\dots,10\}\).
Also noticeable is the fact that some actions disable others, represented by the fact that some \(Y_2(\tau)\) sets are empty.
For example, the action <code>A2</code> disables <code>A4</code>, because after <code>A2</code>, <code>x</code> cannot hold the value \(1\), which is a precondition for <code>A4</code>.</p>
<h3><a class="header" href="#counterexamples-in-apalache" id="counterexamples-in-apalache">Counterexamples in Apalache</a></h3>
<p>Finally, we can interpret Apalache counterexamples in the context of the above definitions.
Given an invariant \(I\), a transition system \((S, S_0, \to)\) and an upper bound on executions \(k\),
Apalache first finds predicates \(t_1,\dots,t_m\) partitioning \(\to\).
Then, it encodes a symbolic trace \(X_0,\dots,X_k\) and its decomposition \(D\).
A counterexample in Apalache defines an explicit trace \(s_0,s_1,\dots,s_l \in S\) for some \(l \le k\),
as well as a sequence \(t_{\tau(1)}, \dots, t_{\tau(l)}\) (in the comments).
The predicate sequence defines a partial trace (of length \(l\))
\(Y_0(\tau),\dots,Y_l(\tau)\) and \(s_0,\dots,s_l\) are chosen such that \(s_i \in Y_i(\tau)\).</p>
<p>Take the following specification and counterexample, for \(k = 10\):</p>
<pre><code class="language-tla">---------- MODULE example ----------

EXTENDS Integers

VARIABLE
  \* @type: Int;
  x

A == /\ x = 1
     /\ x' = x + 1
B == /\ x &gt; 1
     /\ x' = x + 1

Init == x = 1
Next == \/ A
        \/ B
Inv == x &lt; 3 

====================

---------------------------- MODULE counterexample ----------------------------

EXTENDS test

(* Constant initialization state *)
ConstInit == TRUE

(* Initial state *)
State0 == x = 1

(* Transition 0 to State1 *)
State1 == x = 2

(* Transition 1 to State2 *)
State2 == x = 3

(* The following formula holds true in the last state and violates the invariant *)
InvariantViolation == x &gt;= 3

================================================================================
</code></pre>
<p>We can see that, even though \(k=10\), we found a violation in \(l=2\) steps.
Each <code>State{i}</code> represents one of \(s_0,\dots,s_l\), by explicitly defining variable values in that state (e.g. <code>x = 1 /\ y = 2 /\ z = &quot;A&quot;</code>). 
The comment <code>(* Transition X to StateY *)</code> outlines which \(t_1,\dots,t_m\) was used to reach \(s_{i+1}\) from \(s_i\) (0-indexed). 
The shape of \(t_i\) can be found by looking at the file <code>XX_OutTransitionFinderPass.tla</code>, and will be named <code>Next_si_i</code>.
In the above case, <code>Transition 0</code> refers to the one representing <code>A</code> and <code>Transition 1</code> refers to the one representing <code>B</code>. 
<code>InvariantViolation</code> is the negation of the invariant <code>Inv</code>, and it will hold in <code>State{l}</code> (in this case, <code>x &lt; 3</code> does not hold in <code>State2</code>, where <code>x = 3</code>).</p>
<h2><a class="header" href="#notation-and-definitions" id="notation-and-definitions">Notation and definitions</a></h2>
<p>We use the following definitions and conventions:</p>
<ul>
<li>Common sets: We use the notation \(\mathbb{Z}\) to refer to the set of all integers, \(\mathbb{B}\)
to refer to the set of Booleans \(\{TRUE,FALSE\}\), and \(\mathbb{N}\) to refer to the set of all naturals,
i.e. \(\mathbb{N} = \{z \in \mathbb{Z}\mid z \ge 0\}\).</li>
<li>Function sets: We denote by \(B^A\) the set of all functions from \(A\) to \(B\), i.e. \(f \in B^A \iff f\colon A \to B\).</li>
<li>Powersets: We denote by \(2^A\) the set of all subsets of a set \(A\), i.e. 
\(B \subseteq A \iff B \in 2^A\)</li>
<li>Isomorphisms: Sets \( A \) and \(B\) are called isomorphic, if there exists a bijective function
\(b\in B^A\).</li>
<li>Predicates: Given a set \(T\), a <em>predicate</em> over \(T\) is a function \(P \in \mathbb{B}^T\), that is,
a function \(P\), such that \(P(t) \in \mathbb{B}\) for each \(t \in T\).</li>
<li>Relations: Predicates over \(A \times B\) are called <em>relations</em>. A relation \(R\) over \(T \times T\) is an <em>equivalence relation</em>,
if the following holds:
<ul>
<li>For all \(t \in T\), it is the case that \(R(t,t)\) (reflexivity).</li>
<li>For all \(s,t \in T\), \(R(s,t)\) holds if and only if \(R(t,s)\) holds (symmetry).</li>
<li>For all \(r,s,t \in T\), \(R(r,s) \land R(s,t)\) implies \(R(r,t)\) (transititvity).</li>
</ul>
</li>
<li>Equivalence classes: An equivalence relation \(R\) over \(T \times T\) defines a function \(E \in (2^T)^T\),
such that, for each \(t \in T\), \(E(t) = \{ s \in T\mid R(t,s) \}\). \(E(t)\)
is called the <em>equivalence class</em> of \(t\) for \(R\), denoted as \(\lbrack t\rbrack_R\).</li>
<li>Quotient space: An equivalence relation \(R\) over \(T \times T\) defines a <em>quotient space</em>, denoted \(T / R\),
such that \(T / R = \{ \lbrack t\rbrack_R \mid t \in T \} \subseteq 2^T\).</li>
<li>Subset-predicate equivalence: For any set \(T\), there exists a natural isomorphism between
\(\mathbb{B}^T\) and \(2^T\) (implied by the similarity in notation): Each predicate \(P \in \mathbb{B}^T\)
corresponds to the set \(\{ t \in T \mid P(t) = TRUE\} \in 2^T\).
For this reason, predicates are often directly identified with the subset they are equivalent to, and we write \(P \subseteq T\) for brevity.</li>
<li>Infix notation: Given a relation \(R \in \mathbb{B}^{A\times B}\), we commonly write \(a\  R\  b\)
instead of \(R(a,b)\) (e.g. \(a &gt; b\) instead of \(&gt;(a,b)\)).</li>
<li>Cartesian product: Given a set \(T\), we use \(T^2\) to refer to \(T \times T\).
\(T^k\), for \(k &gt; 2\) is defined similarly.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../tutorials/trail-tips.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tutorials/temporal-properties.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../tutorials/trail-tips.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tutorials/temporal-properties.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".././highlightjs-tlaplus/dist/tlaplus.min.js"></script>
        
        <script type="text/javascript" src=".././theme/highlightTla.js"></script>
        

        

    </body>
</html>
