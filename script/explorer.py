#!/usr/bin/env python3
"""
Apalache Explorer Script

This script starts an Apalache server in explorer mode, loads a TLA+ specification,
explores transitions, and checks invariants. It terminates when an invariant is
violated or after exploring 100 transitions.

Usage:
    python explorer_script.py <spec_file> <invariant1> [invariant2] ...

Example:
    python explorer_script.py MySpec.tla TypeOK Safety

 - The initial version: Generated by Claude Sonnet 4 (Sep 29, 2025).
 - Further versions: Igor Konnov, 2025
"""

import argparse
import base64
import json
import os
import random
import subprocess
import sys
import time
import hashlib, pickle
from pathlib import Path
from typing import List, Optional, Dict, Any

# Check for requests module and provide helpful error message
try:
    import requests
except ImportError:
    print("Error: The 'requests' module is required but not installed.")
    print("Please install it using one of the following commands:")
    print("  pip install requests")
    print("  pip3 install requests")
    print("  python -m pip install requests")
    print("  python3 -m pip install requests")
    print("")
    print("Or install all dependencies from the project root:")
    print("  pip install -r requirements.txt")
    print("")
    print("In Nix environments, you may need to:")
    print("  - Add python3Packages.requests to your shell.nix or flake.nix")
    print("  - Or run: nix-shell -p python3Packages.requests python3Packages.pip")
    sys.exit(1)

class ApalacheExplorer:
    def __init__(self, port: int = 8822):
        self.port = port
        self.base_url = f"http://localhost:{port}/rpc"
        self.server_process = None
        self.session_id = None
        self.current_snapshot_id = None
        self.nruns = 0
        self.nsteps = 0
        self.request_id_counter = 0

    def start_server(self) -> bool:
        """Start the Apalache server in explorer mode."""
        print("Starting Apalache server in explorer mode...")

        # Find the apalache-mc executable
        apalache_cmd = self._find_apalache_executable()
        if not apalache_cmd:
            print("Error: Could not find apalache-mc executable")
            return False

        # Start the server
        cmd = [apalache_cmd, "server", "--server-type=explorer", f"--port={self.port}"]
        print(f"Running command: {' '.join(cmd)}")

        try:
            self.server_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Wait for server to start
            max_retries = 30
            for i in range(max_retries):
                try:
                    response = requests.get(f"http://localhost:{self.port}/rpc", timeout=1)
                    if response.status_code in [200, 405]:  # 405 is expected for GET on JSON-RPC endpoint
                        print(f"Server started successfully on port {self.port}")
                        return True
                except requests.exceptions.RequestException:
                    pass

                # Check if process is still running
                if self.server_process.poll() is not None:
                    # Process has terminated
                    stdout, stderr = self.server_process.communicate()
                    print(f"Server process terminated unexpectedly!")
                    print(f"Exit code: {self.server_process.returncode}")
                    print(f"STDOUT:\n{stdout}")
                    print(f"STDERR:\n{stderr}")
                    return False

                time.sleep(1)
                if i % 5 == 0:  # Print progress every 5 seconds
                    print(f"Waiting for server to start... ({i+1}/{max_retries})")

            # Check process output before giving up
            if self.server_process.poll() is not None:
                stdout, stderr = self.server_process.communicate()
                print(f"Server process terminated during startup!")
                print(f"Exit code: {self.server_process.returncode}")
                print(f"STDOUT:\n{stdout}")
                print(f"STDERR:\n{stderr}")
            else:
                print("Server process is still running but not responding to HTTP requests")
                # Get some output to see what's happening
                try:
                    stdout, stderr = self.server_process.communicate(timeout=1)
                    print(f"STDOUT:\n{stdout}")
                    print(f"STDERR:\n{stderr}")
                except subprocess.TimeoutExpired:
                    print("Server process is still running but not producing output")

            print("Error: Server failed to start within timeout")
            return False

        except Exception as e:
            print(f"Error starting server: {e}")
            return False

    def _find_apalache_executable(self) -> Optional[str]:
        """Find the apalache-mc executable."""
        # Check if it's in the bin directory of the project root (not script/bin)
        script_dir = Path(__file__).parent
        project_root = script_dir.parent  # Go up one level from script/ to project root
        project_bin = project_root / "bin" / "apalache-mc"
        if project_bin.exists() and os.access(project_bin, os.X_OK):
            return str(project_bin)

        # Check PATH
        import shutil
        apalache_cmd = shutil.which("apalache-mc")
        if apalache_cmd:
            return apalache_cmd

        return None

    def stop_server(self):
        """Stop the Apalache server."""
        if self.server_process:
            print("Stopping Apalache server...")
            self.server_process.terminate()
            try:
                self.server_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.server_process.kill()
                self.server_process.wait()
            self.server_process = None

    def _make_rpc_call(self, method: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Make a JSON-RPC call to the server."""
        self.request_id_counter += 1
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": self.request_id_counter
        }

        try:
            response = requests.post(
                self.base_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                stream=True,
                timeout=(10, None)
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error making RPC call to {method}: {e}")
            raise

    def load_spec(self, sources: List[str], invariants: List[str], exports: List[str]) -> bool:
        """Load a TLA+ specification."""
        print(f"Loading specification from: {', '. join(sources)}")

        sources_base64 = []
        # Read the specification file
        for filename in sources:
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    text = f.read()
                    encoded = base64.b64encode(text.encode('utf-8')).decode('ascii')
                    sources_base64.append(encoded)
            except Exception as e:
                print(f"Error reading specification file: {e}")
                return False

        # Make the loadSpec RPC call
        params = {
            "sources": sources_base64,
            "init": "Init",
            "next": "Next",
            "invariants": invariants,
            "exports": exports,
        }

        try:
            response = self._make_rpc_call("loadSpec", params)

            if "error" in response:
                print(f"Error loading specification: {response['error']}")
                return False

            result = response["result"]
            self.session_id = result["sessionId"]
            self.current_snapshot_id = result["snapshotId"]
            spec_params = result["specParameters"]

            print(f"Specification loaded successfully!")
            print(f"Session ID: {self.session_id}")
            initTransitions = spec_params['initTransitions']
            nextTransitions = spec_params['nextTransitions']
            stateInvariants = spec_params['stateInvariants']
            actionInvariants = spec_params['actionInvariants']
            print(f"Initial transitions: {len(initTransitions)}")
            print(f"Next transitions: {len(nextTransitions)}")
            print(f"State invariants: {len(stateInvariants)}")
            print(f"Action invariants: {len(actionInvariants)}")

            return {
                'ninit': len(initTransitions),
                'nnext': len(nextTransitions),
                'nstate': len(stateInvariants),
                'naction': len(actionInvariants),
                'snapshot_id': self.current_snapshot_id
            }

        except Exception as e:
            print(f"Error loading specification: {e}")
            return None

    def check_invariants(self, nstate: int, naction: int, timeout: int) -> Optional[str]:
        """Check all invariants. Returns violated invariant name or None."""
        for (kind, inv_id) in [('STATE', i) for i in range(nstate)] + \
                      [('ACTION', i) for i in range(naction)]:
            params = {
                "sessionId": self.session_id,
                "invariantId": inv_id,
                "kind": kind,
                "timeoutSec": timeout
            }

            try:
                response = self._make_rpc_call("checkInvariant", params)

                if "error" in response:
                    print(f"Error checking invariant {inv_id}: {response['error']}")
                    continue

                result = response["result"]
                status = result["invariantStatus"]

                if status == "VIOLATED":
                    print(f"\n*** INVARIANT VIOLATION DETECTED ***")
                    print(f"Invariant ID {inv_id} is violated!")
                    print(f"Counterexample:")
                    if result["trace"]:
                        print(json.dumps(result["trace"], indent=2))
                    return f"invariant_{inv_id}"
                elif status == "UNKNOWN":
                    print(f"Invariant {inv_id}: UNKNOWN (timeout or solver issue)")

            except Exception as e:
                print(f"Error checking invariant {inv_id}: {e}")

        return None

    def rollback(self, snapshot_id: int) -> bool:
        """Roll back to an earlier snapshot."""
        params = {
            "sessionId": self.session_id,
            "snapshotId": snapshot_id,
        }

        response = self._make_rpc_call("rollback", params)

        if "error" in response:
            print(f"Error rolling back to {snapshot_id}: {response['error']}")
            return False

        return True

    def assume_transition(self, transition_id: int, timeout: int) -> bool:
        """Assume a transition and check if it's enabled."""
        params = {
            "sessionId": self.session_id,
            "transitionId": transition_id,
            "checkEnabled": True,
            "timeoutSec": timeout
        }

        response = self._make_rpc_call("assumeTransition", params)

        if "error" in response:
            print(f"Error assuming transition {transition_id}: {response['error']}")
            return False

        result = response["result"]
        status = result["status"]
        self.current_snapshot_id = result["snapshotId"]

        if status == "ENABLED":
            print(f"Transition {transition_id}: ENABLED")
            return True
        elif status == "DISABLED":
            print(f"Transition {transition_id}: DISABLED")
            return False
        else:  # UNKNOWN
            print(f"Transition {transition_id}: UNKNOWN")
            return True  # Assume it's enabled for exploration

    def next_step(self) -> bool:
        """Move to the next step."""
        params = {"sessionId": self.session_id}

        response = self._make_rpc_call("nextStep", params)

        if "error" in response:
            print(f"Error moving to next step: {response['error']}")
            return False

        result = response["result"]
        self.current_snapshot_id = result["snapshotId"]
        new_step = result["newStepNo"]

        print(f"Moved to step {new_step}")
        return True

    def dispose_spec(self):
        """Dispose of the current specification session."""
        if self.session_id:
            params = {"sessionId": self.session_id}
            try:
                self._make_rpc_call("disposeSpec", params)
                print("Specification session disposed")
            except Exception as e:
                print(f"Error disposing specification: {e}")

    def query(self, operator: str, timeout: int) -> bool:
        """Query against the current context"""
        params = {
            "sessionId": self.session_id, "timeoutSec": timeout,
            "kinds": ["OPERATOR"], "operator": operator,
        }

        response = self._make_rpc_call("query", params)

        if "error" in response:
            print(f"Error in query: {response['error']}")
            return False

        result = response["result"]

        return result["operatorValue"]

    def explore(self, sources: List[str], invariants: List[str], view: Optional[str],
                max_steps: int = 20, max_runs: int = 100, timeout: int = 60):
        """Main exploration loop."""
        try:
            # Start server
            if not self.start_server():
                return False

            # Load specification
            spec_params = self.load_spec(sources, invariants, [view] if view else [])
            if not spec_params:
                return False

            print(f"\nStarting exploration (<= {max_runs} runs, <= {max_steps} steps each)...")

            # Get initial spec parameters for transition counts
            # We'll assume we get this from the loadSpec response

            while self.nruns < max_runs:
                print(f"\n--- Run {self.nruns} ---")
                self.nsteps = 0
                self.nruns += 1

                while self.nsteps < max_steps:
                    print(f"\n--- Step {self.nsteps} ---")

                    # Determine available transitions based on current step
                    if self.nsteps == 0:
                        # Use Init transitions
                        max_transitions_to_try = spec_params['ninit']
                    else:
                        # Use Next transitions
                        max_transitions_to_try = spec_params['nnext']

                    # Try to find an enabled transition by picking transitions at random
                    ids = list(range(max_transitions_to_try))
                    transition_found = False
                    while len(ids) > 0 and not transition_found:
                        trans_id = ids[random.randint(0, len(ids) - 1)]
                        ids.remove(trans_id)
                        if self.nsteps == 0:
                            self.rollback(spec_params['snapshot_id'])
                        if self.assume_transition(trans_id, timeout):
                            transition_found = True

                    if not transition_found:
                        print("Cannot extend symbolic run")
                        break

                    # Move to next step
                    if not self.next_step():
                        print("Failed to move to next step")
                        break

                    self.nsteps += 1

                    # Check invariants after each transition
                    violated_invariant = \
                        self.check_invariants(spec_params['nstate'], spec_params['naction'], timeout)
                    if violated_invariant:
                        print(f"\nExploration stopped due to invariant violation: {violated_invariant}")
                        return False

                    if view:
                        view_val = self.query(view, timeout)
                        view_hash = hashlib.sha256(pickle.dumps(view_val, protocol=5)).hexdigest()
                        print(f"View hash: {view_hash}")

                    print(f"All invariants satisfied at step {self.nsteps}")

            return True

        except KeyboardInterrupt:
            print("\nExploration interrupted by user")
            return False
        except Exception as e:
            print(f"Error during exploration: {e}")
            return False
        finally:
            # Clean up
            self.dispose_spec()
            self.stop_server()


def main():
    parser = argparse.ArgumentParser(
        description="Explore TLA+ specifications using Apalache",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python explorer_script.py MySpec.tla TypeOK
  python explorer_script.py MySpec.tla TypeOK Safety Liveness
        """
    )

    parser.add_argument("sources", nargs="+", help="TLA+ specification files")
    parser.add_argument("--inv", type=str, default="Inv", help="Invariant to check (default: Inv)")
    parser.add_argument("--view", type=str, default=None, help="View to report")
    parser.add_argument("--port", type=int, default=8822, help="Server port (default: 8822)")
    parser.add_argument("--max-steps", type=int, default=20,
                       help="Maximum steps to explore per run (default: 20)")
    parser.add_argument("--max-runs", type=int, default=100,
                       help="Maximum steps to explore per run (default: 100)")
    parser.add_argument("--timeout", type=int, default=60,
                       help="Timeout in seconds per single SMT call (default: 60)")
    parser.add_argument("--seed", type=int, default=None,
                       help="Random seed for reproducible exploration (default: random)")

    args = parser.parse_args()

    # Set random seed if provided
    if args.seed is not None:
        random.seed(args.seed)
        print(f"Using random seed: {args.seed}")

    # Validate spec file exists
    for s in args.sources:
        if not os.path.exists(s):
            print(f"Error: Specification file '{s}' not found")
            return 1

    # Create explorer and run
    explorer = ApalacheExplorer(port=args.port)
    success = explorer.explore(args.sources, [args.inv], args.view,
                               args.max_steps, args.max_runs, args.timeout)

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
