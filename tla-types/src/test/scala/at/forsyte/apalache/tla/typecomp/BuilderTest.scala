package at.forsyte.apalache.tla.typecomp

import at.forsyte.apalache.tla.lir._
import at.forsyte.apalache.tla.lir.oper.TlaOper
import org.junit.runner.RunWith
import org.scalacheck.Gen
import org.scalacheck.Prop.forAll
import org.scalatest.{AppendedClues, BeforeAndAfter}
import org.scalatest.funsuite.AnyFunSuite
import org.scalatest.matchers.should.Matchers
import org.scalatestplus.junit.JUnitRunner
import org.scalatestplus.scalacheck.Checkers

import shapeless._

/**
 * BuilderTest implements a framework for PB testing various Builder methods.
 *
 * Since builder methods have many different arities no useful Scala-native supertype to represent the type of a builder
 * method in full generality. To this end, we use shapeless' HList (H for heterogeneous) as a representation of any
 * builder method's argument types. For example:
 *   - plus has the signature (TBuilderInstruction,TBuilderInstruction) => TBuilderInstruction, represented by
 *     TBuilderInstruction :: TBuilderInstruction :: HNil <: HList
 *   - union has the signature (TBuilderInstruction) => TBuilderInstruction, and is represented by the type
 *     TBuilderInstruction :: HNil <: HList
 *   - map has the signature (TBuilderInstruction, TBuilderInstruction*) => TBuilderInstruction, represented by
 *     TBuilderInstruction :: Seq[TBuilderInstruction] :: HNil <: HList
 *
 * The central method, with various convenience extensions, is runPBT, which performs the following testing tasks:
 *   - Tests whether a TBuilderInstruction, which is supposed to construct a well-typed operator expression actually
 *     does
 *   - Tests whether all of the inputs which would have produced an ill-typed expression actually cause `build` to fail
 */
@RunWith(classOf[JUnitRunner])
trait BuilderTest extends AnyFunSuite with BeforeAndAfter with Checkers with AppendedClues with Matchers {
  var builder = new ScopedBuilder
  var cmpFactory = new TypeComputationFactory

  before {
    builder = new ScopedBuilder
    cmpFactory = new TypeComputationFactory
  }

  protected val tt1gen: TlaType1Gen = new TlaType1Gen {}

  implicit val singleTypeGen: Gen[TlaType1] = tt1gen.genType1
  implicit val doubleTypeGen: Gen[(TlaType1, TlaType1)] = for {
    t1 <- singleTypeGen
    t2 <- singleTypeGen
  } yield (t1, t2)

  // Useful methods for defining mkIllTypedArgs
  object InvalidTypeMethods {
    def notSet: TlaType1 = IntT1
    def notSeq: TlaType1 = IntT1
    def notBool: TlaType1 = differentFrom(BoolT1)
    def notInt: TlaType1 = differentFrom(IntT1)
    def notApplicative: TlaType1 = IntT1
    def differentFrom(tt: TlaType1): TlaType1 = if (tt == IntT1) StrT1 else IntT1
  }

  /** Convenience method, for constructing resultIsExpected as an test of eqTyped */
  def expectEqTyped[TypeParameterization, T](
      op: TlaOper,
      mkWellTyped: TypeParameterization => T,
      toSeq: T => Seq[TBuilderResult],
      resType: TypeParameterization => TlaType1): TypeParameterization => TBuilderResult => Boolean = {
    tparam =>
      { resEx =>
        resEx.eqTyped(
            OperEx(
                op,
                toSeq(mkWellTyped(tparam)): _*
            )(Typed(resType(tparam)))
        )
      }
  }

  /**
   * Central testing method. Recommended to use the convenience methods testUnary, testBinary, etc. whenever possible.
   *
   * @param methodH
   *   A builder method lifted to HList. For example, builder.binaryMethod(_,_) can be tested as { case a :: b :: HNil
   *   \=> builder.binaryMethod(_,_) }
   * @param mkWellTypedArgs
   *   A method that, given a TypeParameterization, produces list of arguments to methodH, which are expected to
   *   generate a TBuilderInstruction which successfully builds
   * @param mkIllTypedArgs
   *   A method that, given a TypeParameterization, produces collection of lists of arguments to methodH, which are all
   *   expected to generate TBuilderInstructions which fail to build
   * @param resultIsExpected
   *   Judgement method, which asserts whether the expression produced by building the instruction generated by
   *   methodH(mkWellTypedArgs(_)) satisfies expectations
   * @param tparam
   *   Concrete instance of type parameter(s) under test
   * @tparam H
   *   Particular variant of HList, based on the method being tested. For example, testing a binary method will have H
   *   equal to TBuilderInstruction :: TBuilderInstruction :: HNil, while testing a variadic method will have H equal to
   *   Seq[TBuilderInstruction] :: HNil
   * @tparam TypeParameterization
   *   Degree of polymorphism. Unit if testing non-polymorphic methods, TlaType1, if testing a method with one type
   *   parameter, Seq[TlaType1] if testing a method with many type parameters, etc.
   */
  def runPBT[H <: HList, TypeParameterization](
      methodH: PartialFunction[H, TBuilderInstruction],
      mkWellTypedArgs: TypeParameterization => H,
      mkIllTypedArgs: TypeParameterization => Seq[H], // some operators cannot be passed an invalid arg
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {
    val wellTypedH = mkWellTypedArgs(tparam)
    val illTypedIs = mkIllTypedArgs(tparam).map(methodH)
    val resEx = build(methodH(wellTypedH))

    val isAsExpected = resultIsExpected(tparam)(resEx)

    isAsExpected shouldBe true

    illTypedIs.foreach { bi =>
      assertThrows[TBuilderTypeException] {
        build(bi)
      }
    }

    true
  }

  /** test `run` against a generator of TypeParameterization values */
  def checkRun[TypeParameterization](
      run: TypeParameterization => Boolean
    )(implicit typegen: Gen[TypeParameterization]): Unit = {
    val prop = forAll(typegen) { run }
    check(prop, minSuccessful(1000), sizeRange(8))
  }

  /** Invokes tests for a unary builder method. Performs lifting to HList logic for the user. */
  def runUnary[TypeParameterization](
      method: TBuilderInstruction => TBuilderInstruction,
      mkWellTypedArg: TypeParameterization => TBuilderInstruction,
      mkIllTypedArg: TypeParameterization => Seq[TBuilderInstruction],
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {

    type H = TBuilderInstruction :: HNil
    def mkWellTypedArgH(tparam: TypeParameterization): H = mkWellTypedArg(tparam) :: HNil
    def mkIllTypedArgH(tparam: TypeParameterization): Seq[H] = mkIllTypedArg(tparam).map { _ :: HNil }
    def methodH: PartialFunction[H, TBuilderInstruction] = { case a :: HNil =>
      method(a)
    }

    runPBT(
        methodH,
        mkWellTypedArgH,
        mkIllTypedArgH,
        resultIsExpected,
    )(tparam)
  }

  /** Invokes tests for a binary builder method. Performs lifting to HList logic for the user. */
  def runBinary[TypeParameterization](
      method: (TBuilderInstruction, TBuilderInstruction) => TBuilderInstruction,
      mkWellTypedArg: TypeParameterization => (TBuilderInstruction, TBuilderInstruction),
      mkIllTypedArg: TypeParameterization => Seq[(TBuilderInstruction, TBuilderInstruction)],
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {

    type H = TBuilderInstruction :: TBuilderInstruction :: HNil
    def mkWellTypedArgH(tparam: TypeParameterization): H = {
      val (a, b) = mkWellTypedArg(tparam)
      a :: b :: HNil
    }
    def mkIllTypedArgH(tparam: TypeParameterization): Seq[H] = mkIllTypedArg(tparam).map { case (a, b) =>
      a :: b :: HNil
    }
    def methodH: PartialFunction[H, TBuilderInstruction] = { case a :: b :: HNil =>
      method(a, b)
    }

    runPBT(
        methodH,
        mkWellTypedArgH,
        mkIllTypedArgH,
        resultIsExpected,
    )(tparam)
  }

  /** Invokes tests for a ternary builder method. Performs lifting to HList logic for the user. */
  def runTernary[TypeParameterization](
      method: (TBuilderInstruction, TBuilderInstruction, TBuilderInstruction) => TBuilderInstruction,
      mkWellTypedArg: TypeParameterization => (TBuilderInstruction, TBuilderInstruction, TBuilderInstruction),
      mkIllTypedArg: TypeParameterization => Seq[(TBuilderInstruction, TBuilderInstruction, TBuilderInstruction)],
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {

    type H = TBuilderInstruction :: TBuilderInstruction :: TBuilderInstruction :: HNil
    def mkWellTypedArgH(tparam: TypeParameterization): H = {
      val (a, b, c) = mkWellTypedArg(tparam)
      a :: b :: c :: HNil
    }
    def mkIllTypedArgH(tparam: TypeParameterization): Seq[H] = mkIllTypedArg(tparam).map { case (a, b, c) =>
      a :: b :: c :: HNil
    }
    def methodH: PartialFunction[H, TBuilderInstruction] = { case a :: b :: c :: HNil =>
      method(a, b, c)
    }

    runPBT(
        methodH,
        mkWellTypedArgH,
        mkIllTypedArgH,
        resultIsExpected,
    )(tparam)
  }

  /** Invokes tests for a variadic builder method. Performs lifting to HList logic for the user. */
  def runVariadic[TypeParameterization, T](
      method: Seq[T] => TBuilderInstruction,
      mkWellTypedArg: TypeParameterization => Seq[T],
      mkIllTypedArg: TypeParameterization => Seq[Seq[T]],
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {

    type H = Seq[T] :: HNil
    def mkWellTypedArgH(tparam: TypeParameterization): H =
      mkWellTypedArg(tparam) :: HNil

    def mkIllTypedArgH(tparam: TypeParameterization): Seq[H] = mkIllTypedArg(tparam).map { _ :: HNil }

    def methodH: PartialFunction[H, TBuilderInstruction] = { case seq :: HNil =>
      method(seq)
    }

    runPBT(
        methodH,
        mkWellTypedArgH,
        mkIllTypedArgH,
        resultIsExpected,
    )(tparam)
  }

  /**
   * Invokes tests for a variadic builder method with a distinguished first argument. Performs lifting to HList logic
   * for the user.
   */
  def runVariadicWithDistinguishedFirst[TypeParameterization, T](
      method: (TBuilderInstruction, Seq[T]) => TBuilderInstruction,
      mkWellTypedArg: TypeParameterization => (TBuilderInstruction, Seq[T]),
      mkIllTypedArg: TypeParameterization => Seq[(TBuilderInstruction, Seq[T])],
      resultIsExpected: TypeParameterization => TBuilderResult => Boolean,
    )(tparam: TypeParameterization): Boolean = {

    type H = TBuilderInstruction :: Seq[T] :: HNil
    def mkWellTypedArgH(tparam: TypeParameterization): H = {
      val (a, seq) = mkWellTypedArg(tparam)
      a :: seq :: HNil
    }

    def mkIllTypedArgH(tparam: TypeParameterization): Seq[H] =
      mkIllTypedArg(tparam).map { case (a, seq) => a :: seq :: HNil }

    def methodH: PartialFunction[H, TBuilderInstruction] = { case a :: seq :: HNil =>
      method(a, seq)
    }

    runPBT(
        methodH,
        mkWellTypedArgH,
        mkIllTypedArgH,
        resultIsExpected,
    )(tparam)
  }

}
